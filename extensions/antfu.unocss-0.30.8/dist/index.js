var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = __spreadProps(__spreadValues({}, POSIX_CHARS), {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path = require("path");
    var win322 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win322 === true || path.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants2 = require_constants();
    var utils = require_utils();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants2;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils.isWindows(options);
      const PLATFORM_CHARS = constants2.globChars(win322);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = __spreadProps(__spreadValues({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, __spreadProps(__spreadValues({}, options), { fastpaths: false })).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants2.globChars(win322);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  }
});

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse2 = require_parse();
    var utils = require_utils();
    var constants2 = require_constants();
    var isObject3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix2 = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps(__spreadValues({}, options), { ignore: null, onMatch: null, onResult: null });
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
        const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix2);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix2 = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, __spreadProps(__spreadValues({}, options), { fastpaths: false }));
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants2;
    module2.exports = picomatch;
  }
});

// ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/dist/jiti.js
var require_jiti = __commonJS({
  "../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/dist/jiti.js"(exports, module2) {
    (() => {
      var __webpack_modules__ = { "./node_modules/create-require/create-require.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const nativeModule = __webpack_require__2("module"), path = __webpack_require__2("path"), fs3 = __webpack_require__2("fs");
        module3.exports = function(filename) {
          return filename || (filename = process.cwd()), function(path2) {
            try {
              return fs3.lstatSync(path2).isDirectory();
            } catch (e2) {
              return false;
            }
          }(filename) && (filename = path.join(filename, "index.js")), nativeModule.createRequire ? nativeModule.createRequire(filename) : nativeModule.createRequireFromPath ? nativeModule.createRequireFromPath(filename) : function(filename2) {
            const mod = new nativeModule.Module(filename2, null);
            return mod.filename = filename2, mod.paths = nativeModule.Module._nodeModulePaths(path.dirname(filename2)), mod._compile("module.exports = require;", filename2), mod.exports;
          }(filename);
        };
      }, "./node_modules/lru-cache/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        const Yallist = __webpack_require__2("./node_modules/yallist/yallist.js"), MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
        const get = (self2, key, doUse) => {
          const node = self2[CACHE].get(key);
          if (node) {
            const hit = node.value;
            if (isStale(self2, hit)) {
              if (del(self2, node), !self2[ALLOW_STALE])
                return;
            } else
              doUse && (self2[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self2[LRU_LIST].unshiftNode(node));
            return hit.value;
          }
        }, isStale = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE])
            return false;
          const diff = Date.now() - hit.now;
          return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
        }, trim = (self2) => {
          if (self2[LENGTH] > self2[MAX])
            for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
              const prev = walker.prev;
              del(self2, walker), walker = prev;
            }
        }, del = (self2, node) => {
          if (node) {
            const hit = node.value;
            self2[DISPOSE] && self2[DISPOSE](hit.key, hit.value), self2[LENGTH] -= hit.length, self2[CACHE].delete(hit.key), self2[LRU_LIST].removeNode(node);
          }
        };
        class Entry {
          constructor(key, value, length, now, maxAge) {
            this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
          }
        }
        const forEachStep = (self2, fn, node, thisp) => {
          let hit = node.value;
          isStale(self2, hit) && (del(self2, node), self2[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
        };
        module3.exports = class {
          constructor(options) {
            if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX] = options.max || 1 / 0;
            const lc = options.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || false, options.maxAge && typeof options.maxAge != "number")
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false, this.reset();
          }
          set max(mL) {
            if (typeof mL != "number" || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX] = mL || 1 / 0, trim(this);
          }
          get max() {
            return this[MAX];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE];
          }
          set maxAge(mA) {
            if (typeof mA != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA, trim(this);
          }
          get maxAge() {
            return this[MAX_AGE];
          }
          set lengthCalculator(lC) {
            typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
            })), trim(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR];
          }
          get length() {
            return this[LENGTH];
          }
          get itemCount() {
            return this[LRU_LIST].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].tail; walker !== null; ) {
              const prev = walker.prev;
              forEachStep(this, fn, walker, thisp), walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].head; walker !== null; ) {
              const next = walker.next;
              forEachStep(this, fn, walker, thisp), walker = next;
            }
          }
          keys() {
            return this[LRU_LIST].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST].toArray().map((k) => k.value);
          }
          reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
          }
          dump() {
            return this[LRU_LIST].map((hit) => !isStale(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST];
          }
          set(key, value, maxAge) {
            if ((maxAge = maxAge || this[MAX_AGE]) && typeof maxAge != "number")
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX])
                return del(this, this[CACHE].get(key)), false;
              const item = this[CACHE].get(key).value;
              return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), true;
            }
            const hit = new Entry(key, value, len, now, maxAge);
            return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), false) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), true);
          }
          has(key) {
            if (!this[CACHE].has(key))
              return false;
            const hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
          get(key) {
            return get(this, key, true);
          }
          peek(key) {
            return get(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST].tail;
            return node ? (del(this, node), node.value) : null;
          }
          del(key) {
            del(this, this[CACHE].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l], expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
          prune() {
            this[CACHE].forEach((value, key) => get(this, key, false));
          }
        };
      }, "./node_modules/mkdirp/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const optsArg = __webpack_require__2("./node_modules/mkdirp/lib/opts-arg.js"), pathArg = __webpack_require__2("./node_modules/mkdirp/lib/path-arg.js"), { mkdirpNative, mkdirpNativeSync } = __webpack_require__2("./node_modules/mkdirp/lib/mkdirp-native.js"), { mkdirpManual, mkdirpManualSync } = __webpack_require__2("./node_modules/mkdirp/lib/mkdirp-manual.js"), { useNative, useNativeSync } = __webpack_require__2("./node_modules/mkdirp/lib/use-native.js"), mkdirp = (path, opts) => (path = pathArg(path), opts = optsArg(opts), useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts));
        mkdirp.sync = (path, opts) => (path = pathArg(path), opts = optsArg(opts), useNativeSync(opts) ? mkdirpNativeSync(path, opts) : mkdirpManualSync(path, opts)), mkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts)), mkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts)), mkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts)), mkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts)), module3.exports = mkdirp;
      }, "./node_modules/mkdirp/lib/find-made.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const { dirname: dirname3 } = __webpack_require__2("path"), findMade = (opts, parent, path) => path === parent ? Promise.resolve() : opts.statAsync(parent).then((st) => st.isDirectory() ? path : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : void 0), findMadeSync = (opts, parent, path) => {
          if (path !== parent)
            try {
              return opts.statSync(parent).isDirectory() ? path : void 0;
            } catch (er) {
              return er.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : void 0;
            }
        };
        module3.exports = { findMade, findMadeSync };
      }, "./node_modules/mkdirp/lib/mkdirp-manual.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const { dirname: dirname3 } = __webpack_require__2("path"), mkdirpManual = (path, opts, made) => {
          opts.recursive = false;
          const parent = dirname3(path);
          return parent === path ? opts.mkdirAsync(path, opts).catch((er) => {
            if (er.code !== "EISDIR")
              throw er;
          }) : opts.mkdirAsync(path, opts).then(() => made || path, (er) => {
            if (er.code === "ENOENT")
              return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path, opts, made2));
            if (er.code !== "EEXIST" && er.code !== "EROFS")
              throw er;
            return opts.statAsync(path).then((st) => {
              if (st.isDirectory())
                return made;
              throw er;
            }, () => {
              throw er;
            });
          });
        }, mkdirpManualSync = (path, opts, made) => {
          const parent = dirname3(path);
          if (opts.recursive = false, parent === path)
            try {
              return opts.mkdirSync(path, opts);
            } catch (er) {
              if (er.code !== "EISDIR")
                throw er;
              return;
            }
          try {
            return opts.mkdirSync(path, opts), made || path;
          } catch (er) {
            if (er.code === "ENOENT")
              return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));
            if (er.code !== "EEXIST" && er.code !== "EROFS")
              throw er;
            try {
              if (!opts.statSync(path).isDirectory())
                throw er;
            } catch (_) {
              throw er;
            }
          }
        };
        module3.exports = { mkdirpManual, mkdirpManualSync };
      }, "./node_modules/mkdirp/lib/mkdirp-native.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const { dirname: dirname3 } = __webpack_require__2("path"), { findMade, findMadeSync } = __webpack_require__2("./node_modules/mkdirp/lib/find-made.js"), { mkdirpManual, mkdirpManualSync } = __webpack_require__2("./node_modules/mkdirp/lib/mkdirp-manual.js");
        module3.exports = { mkdirpNative: (path, opts) => {
          opts.recursive = true;
          return dirname3(path) === path ? opts.mkdirAsync(path, opts) : findMade(opts, path).then((made) => opts.mkdirAsync(path, opts).then(() => made).catch((er) => {
            if (er.code === "ENOENT")
              return mkdirpManual(path, opts);
            throw er;
          }));
        }, mkdirpNativeSync: (path, opts) => {
          opts.recursive = true;
          if (dirname3(path) === path)
            return opts.mkdirSync(path, opts);
          const made = findMadeSync(opts, path);
          try {
            return opts.mkdirSync(path, opts), made;
          } catch (er) {
            if (er.code === "ENOENT")
              return mkdirpManualSync(path, opts);
            throw er;
          }
        } };
      }, "./node_modules/mkdirp/lib/opts-arg.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const { promisify } = __webpack_require__2("util"), fs3 = __webpack_require__2("fs");
        module3.exports = (opts) => {
          if (opts)
            if (typeof opts == "object")
              opts = __spreadValues({ mode: 511, fs: fs3 }, opts);
            else if (typeof opts == "number")
              opts = { mode: opts, fs: fs3 };
            else {
              if (typeof opts != "string")
                throw new TypeError("invalid options argument");
              opts = { mode: parseInt(opts, 8), fs: fs3 };
            }
          else
            opts = { mode: 511, fs: fs3 };
          return opts.mkdir = opts.mkdir || opts.fs.mkdir || fs3.mkdir, opts.mkdirAsync = promisify(opts.mkdir), opts.stat = opts.stat || opts.fs.stat || fs3.stat, opts.statAsync = promisify(opts.stat), opts.statSync = opts.statSync || opts.fs.statSync || fs3.statSync, opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs3.mkdirSync, opts;
        };
      }, "./node_modules/mkdirp/lib/path-arg.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform, { resolve: resolve5, parse: parse2 } = __webpack_require__2("path");
        module3.exports = (path) => {
          if (/\0/.test(path))
            throw Object.assign(new TypeError("path must be a string without null bytes"), { path, code: "ERR_INVALID_ARG_VALUE" });
          if (path = resolve5(path), platform === "win32") {
            const badWinChars = /[*|"<>?:]/, { root } = parse2(path);
            if (badWinChars.test(path.substr(root.length)))
              throw Object.assign(new Error("Illegal characters in path."), { path, code: "EINVAL" });
          }
          return path;
        };
      }, "./node_modules/mkdirp/lib/use-native.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const fs3 = __webpack_require__2("fs"), versArr = (process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version).replace(/^v/, "").split("."), hasNative = +versArr[0] > 10 || +versArr[0] == 10 && +versArr[1] >= 12, useNative = hasNative ? (opts) => opts.mkdir === fs3.mkdir : () => false, useNativeSync = hasNative ? (opts) => opts.mkdirSync === fs3.mkdirSync : () => false;
        module3.exports = { useNative, useNativeSync };
      }, "./node_modules/mlly/dist lazy recursive": (module3) => {
        function webpackEmptyAsyncContext(req) {
          return Promise.resolve().then(() => {
            var e2 = new Error("Cannot find module '" + req + "'");
            throw e2.code = "MODULE_NOT_FOUND", e2;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/mlly/dist lazy recursive", module3.exports = webpackEmptyAsyncContext;
      }, "./node_modules/object-hash/index.js": (module3, exports2, __webpack_require__2) => {
        "use strict";
        var crypto = __webpack_require__2("crypto");
        function objectHash(object, options) {
          return function(object2, options2) {
            var hashingStream;
            hashingStream = options2.algorithm !== "passthrough" ? crypto.createHash(options2.algorithm) : new PassThrough();
            hashingStream.write === void 0 && (hashingStream.write = hashingStream.update, hashingStream.end = hashingStream.update);
            typeHasher(options2, hashingStream).dispatch(object2), hashingStream.update || hashingStream.end("");
            if (hashingStream.digest)
              return hashingStream.digest(options2.encoding === "buffer" ? void 0 : options2.encoding);
            var buf = hashingStream.read();
            if (options2.encoding === "buffer")
              return buf;
            return buf.toString(options2.encoding);
          }(object, options = applyDefaults(object, options));
        }
        (exports2 = module3.exports = objectHash).sha1 = function(object) {
          return objectHash(object);
        }, exports2.keys = function(object) {
          return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, exports2.MD5 = function(object) {
          return objectHash(object, { algorithm: "md5", encoding: "hex" });
        }, exports2.keysMD5 = function(object) {
          return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var hashes = crypto.getHashes ? crypto.getHashes().slice() : ["sha1", "md5"];
        hashes.push("passthrough");
        var encodings = ["buffer", "hex", "binary", "base64"];
        function applyDefaults(object, sourceOptions) {
          sourceOptions = sourceOptions || {};
          var options = {};
          if (options.algorithm = sourceOptions.algorithm || "sha1", options.encoding = sourceOptions.encoding || "hex", options.excludeValues = !!sourceOptions.excludeValues, options.algorithm = options.algorithm.toLowerCase(), options.encoding = options.encoding.toLowerCase(), options.ignoreUnknown = sourceOptions.ignoreUnknown === true, options.respectType = sourceOptions.respectType !== false, options.respectFunctionNames = sourceOptions.respectFunctionNames !== false, options.respectFunctionProperties = sourceOptions.respectFunctionProperties !== false, options.unorderedArrays = sourceOptions.unorderedArrays === true, options.unorderedSets = sourceOptions.unorderedSets !== false, options.unorderedObjects = sourceOptions.unorderedObjects !== false, options.replacer = sourceOptions.replacer || void 0, options.excludeKeys = sourceOptions.excludeKeys || void 0, object === void 0)
            throw new Error("Object argument required.");
          for (var i = 0; i < hashes.length; ++i)
            hashes[i].toLowerCase() === options.algorithm.toLowerCase() && (options.algorithm = hashes[i]);
          if (hashes.indexOf(options.algorithm) === -1)
            throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
          if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough")
            throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
          return options;
        }
        function isNativeFunction(f) {
          if (typeof f != "function")
            return false;
          return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(f)) != null;
        }
        function typeHasher(options, writeTo, context) {
          context = context || [];
          var write = function(str) {
            return writeTo.update ? writeTo.update(str, "utf8") : writeTo.write(str, "utf8");
          };
          return { dispatch: function(value) {
            options.replacer && (value = options.replacer(value));
            var type = typeof value;
            return value === null && (type = "null"), this["_" + type](value);
          }, _object: function(object) {
            var objString = Object.prototype.toString.call(object), objType = /\[object (.*)\]/i.exec(objString);
            objType = (objType = objType ? objType[1] : "unknown:[" + objString + "]").toLowerCase();
            var objectNumber;
            if ((objectNumber = context.indexOf(object)) >= 0)
              return this.dispatch("[CIRCULAR:" + objectNumber + "]");
            if (context.push(object), typeof Buffer != "undefined" && Buffer.isBuffer && Buffer.isBuffer(object))
              return write("buffer:"), write(object);
            if (objType === "object" || objType === "function" || objType === "asyncfunction") {
              var keys = Object.keys(object);
              options.unorderedObjects && (keys = keys.sort()), options.respectType === false || isNativeFunction(object) || keys.splice(0, 0, "prototype", "__proto__", "constructor"), options.excludeKeys && (keys = keys.filter(function(key) {
                return !options.excludeKeys(key);
              })), write("object:" + keys.length + ":");
              var self2 = this;
              return keys.forEach(function(key) {
                self2.dispatch(key), write(":"), options.excludeValues || self2.dispatch(object[key]), write(",");
              });
            }
            if (!this["_" + objType]) {
              if (options.ignoreUnknown)
                return write("[" + objType + "]");
              throw new Error('Unknown object type "' + objType + '"');
            }
            this["_" + objType](object);
          }, _array: function(arr, unordered) {
            unordered = unordered !== void 0 ? unordered : options.unorderedArrays !== false;
            var self2 = this;
            if (write("array:" + arr.length + ":"), !unordered || arr.length <= 1)
              return arr.forEach(function(entry) {
                return self2.dispatch(entry);
              });
            var contextAdditions = [], entries = arr.map(function(entry) {
              var strm = new PassThrough(), localContext = context.slice();
              return typeHasher(options, strm, localContext).dispatch(entry), contextAdditions = contextAdditions.concat(localContext.slice(context.length)), strm.read().toString();
            });
            return context = context.concat(contextAdditions), entries.sort(), this._array(entries, false);
          }, _date: function(date) {
            return write("date:" + date.toJSON());
          }, _symbol: function(sym) {
            return write("symbol:" + sym.toString());
          }, _error: function(err) {
            return write("error:" + err.toString());
          }, _boolean: function(bool) {
            return write("bool:" + bool.toString());
          }, _string: function(string) {
            write("string:" + string.length + ":"), write(string.toString());
          }, _function: function(fn) {
            write("fn:"), isNativeFunction(fn) ? this.dispatch("[native]") : this.dispatch(fn.toString()), options.respectFunctionNames !== false && this.dispatch("function-name:" + String(fn.name)), options.respectFunctionProperties && this._object(fn);
          }, _number: function(number) {
            return write("number:" + number.toString());
          }, _xml: function(xml) {
            return write("xml:" + xml.toString());
          }, _null: function() {
            return write("Null");
          }, _undefined: function() {
            return write("Undefined");
          }, _regexp: function(regex) {
            return write("regex:" + regex.toString());
          }, _uint8array: function(arr) {
            return write("uint8array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint8clampedarray: function(arr) {
            return write("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int8array: function(arr) {
            return write("uint8array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint16array: function(arr) {
            return write("uint16array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int16array: function(arr) {
            return write("uint16array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _uint32array: function(arr) {
            return write("uint32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _int32array: function(arr) {
            return write("uint32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _float32array: function(arr) {
            return write("float32array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _float64array: function(arr) {
            return write("float64array:"), this.dispatch(Array.prototype.slice.call(arr));
          }, _arraybuffer: function(arr) {
            return write("arraybuffer:"), this.dispatch(new Uint8Array(arr));
          }, _url: function(url) {
            return write("url:" + url.toString());
          }, _map: function(map) {
            write("map:");
            var arr = Array.from(map);
            return this._array(arr, options.unorderedSets !== false);
          }, _set: function(set) {
            write("set:");
            var arr = Array.from(set);
            return this._array(arr, options.unorderedSets !== false);
          }, _file: function(file) {
            return write("file:"), this.dispatch([file.name, file.size, file.type, file.lastModfied]);
          }, _blob: function() {
            if (options.ignoreUnknown)
              return write("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return write("domwindow");
          }, _bigint: function(number) {
            return write("bigint:" + number.toString());
          }, _process: function() {
            return write("process");
          }, _timer: function() {
            return write("timer");
          }, _pipe: function() {
            return write("pipe");
          }, _tcp: function() {
            return write("tcp");
          }, _udp: function() {
            return write("udp");
          }, _tty: function() {
            return write("tty");
          }, _statwatcher: function() {
            return write("statwatcher");
          }, _securecontext: function() {
            return write("securecontext");
          }, _connection: function() {
            return write("connection");
          }, _zlib: function() {
            return write("zlib");
          }, _context: function() {
            return write("context");
          }, _nodescript: function() {
            return write("nodescript");
          }, _httpparser: function() {
            return write("httpparser");
          }, _dataview: function() {
            return write("dataview");
          }, _signal: function() {
            return write("signal");
          }, _fsevent: function() {
            return write("fsevent");
          }, _tlswrap: function() {
            return write("tlswrap");
          } };
        }
        function PassThrough() {
          return { buf: "", write: function(b) {
            this.buf += b;
          }, end: function(b) {
            this.buf += b;
          }, read: function() {
            return this.buf;
          } };
        }
        exports2.writeToStream = function(object, options, stream) {
          return stream === void 0 && (stream = options, options = {}), typeHasher(options = applyDefaults(object, options), stream).dispatch(object);
        };
      }, "./node_modules/pirates/lib/index.js": (module3, exports2, __webpack_require__2) => {
        "use strict";
        module3 = __webpack_require__2.nmd(module3), Object.defineProperty(exports2, "__esModule", { value: true }), exports2.addHook = function(hook, opts = {}) {
          let reverted = false;
          const loaders = [], oldLoaders = [];
          let exts;
          const originalJSLoader = Module._extensions[".js"], matcher = opts.matcher || null, ignoreNodeModules = opts.ignoreNodeModules !== false;
          exts = opts.extensions || opts.exts || opts.extension || opts.ext || [".js"], Array.isArray(exts) || (exts = [exts]);
          return exts.forEach((ext) => {
            if (typeof ext != "string")
              throw new TypeError(`Invalid Extension: ${ext}`);
            const oldLoader = Module._extensions[ext] || originalJSLoader;
            oldLoaders[ext] = Module._extensions[ext], loaders[ext] = Module._extensions[ext] = function(mod, filename) {
              let compile;
              reverted || function(filename2, exts2, matcher2, ignoreNodeModules2) {
                if (typeof filename2 != "string")
                  return false;
                if (exts2.indexOf(_path.default.extname(filename2)) === -1)
                  return false;
                const resolvedFilename = _path.default.resolve(filename2);
                if (ignoreNodeModules2 && nodeModulesRegex.test(resolvedFilename))
                  return false;
                if (matcher2 && typeof matcher2 == "function")
                  return !!matcher2(resolvedFilename);
                return true;
              }(filename, exts, matcher, ignoreNodeModules) && (compile = mod._compile, mod._compile = function(code) {
                mod._compile = compile;
                const newCode = hook(code, filename);
                if (typeof newCode != "string")
                  throw new Error("[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.");
                return mod._compile(newCode, filename);
              }), oldLoader(mod, filename);
            };
          }), function() {
            reverted || (reverted = true, exts.forEach((ext) => {
              Module._extensions[ext] === loaders[ext] && (oldLoaders[ext] ? Module._extensions[ext] = oldLoaders[ext] : delete Module._extensions[ext]);
            }));
          };
        };
        var _module = _interopRequireDefault(__webpack_require__2("module")), _path = _interopRequireDefault(__webpack_require__2("path"));
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }
        const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/, Module = module3.constructor.length > 1 ? module3.constructor : _module.default;
      }, "./node_modules/semver/classes/comparator.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const ANY = Symbol("SemVer ANY");
        class Comparator {
          static get ANY() {
            return ANY;
          }
          constructor(comp, options) {
            if (options = parseOptions(options), comp instanceof Comparator) {
              if (comp.loose === !!options.loose)
                return comp;
              comp = comp.value;
            }
            debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
          }
          parse(comp) {
            const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
            if (!m)
              throw new TypeError(`Invalid comparator: ${comp}`);
            this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
          }
          toString() {
            return this.value;
          }
          test(version3) {
            if (debug("Comparator.test", version3, this.options.loose), this.semver === ANY || version3 === ANY)
              return true;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer(version3, this.options);
              } catch (er) {
                return false;
              }
            return cmp(version3, this.operator, this.semver, this.options);
          }
          intersects(comp, options) {
            if (!(comp instanceof Comparator))
              throw new TypeError("a Comparator is required");
            if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), this.operator === "")
              return this.value === "" || new Range3(comp.value, options).test(this.value);
            if (comp.operator === "")
              return comp.value === "" || new Range3(this.value, options).test(comp.semver);
            const sameDirectionIncreasing = !(this.operator !== ">=" && this.operator !== ">" || comp.operator !== ">=" && comp.operator !== ">"), sameDirectionDecreasing = !(this.operator !== "<=" && this.operator !== "<" || comp.operator !== "<=" && comp.operator !== "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(this.operator !== ">=" && this.operator !== "<=" || comp.operator !== ">=" && comp.operator !== "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
          }
        }
        module3.exports = Comparator;
        const parseOptions = __webpack_require__2("./node_modules/semver/internal/parse-options.js"), { re, t } = __webpack_require__2("./node_modules/semver/internal/re.js"), cmp = __webpack_require__2("./node_modules/semver/functions/cmp.js"), debug = __webpack_require__2("./node_modules/semver/internal/debug.js"), SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
      }, "./node_modules/semver/classes/range.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        class Range3 {
          constructor(range, options) {
            if (options = parseOptions(options), range instanceof Range3)
              return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range3(range.raw, options);
            if (range instanceof Comparator)
              return this.raw = range.value, this.set = [[range]], this.format(), this;
            if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${range}`);
            if (this.set.length > 1) {
              const first = this.set[0];
              if (this.set = this.set.filter((c) => !isNullSet(c[0])), this.set.length === 0)
                this.set = [first];
              else if (this.set.length > 1) {
                for (const c of this.set)
                  if (c.length === 1 && isAny(c[0])) {
                    this.set = [c];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(range) {
            range = range.trim();
            const memoKey = `parseRange:${Object.keys(this.options).join(",")}:${range}`, cached = cache.get(memoKey);
            if (cached)
              return cached;
            const loose = this.options.loose, hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
            range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, re[t.COMPARATORTRIM]), range = (range = (range = range.replace(re[t.TILDETRIM], tildeTrimReplace)).replace(re[t.CARETTRIM], caretTrimReplace)).split(/\s+/).join(" ");
            const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options)), rangeMap = (rangeList.length, /* @__PURE__ */ new Map());
            for (const comp of rangeList) {
              if (isNullSet(comp))
                return [comp];
              rangeMap.set(comp.value, comp);
            }
            rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
            const result = [...rangeMap.values()];
            return cache.set(memoKey, result), result;
          }
          intersects(range, options) {
            if (!(range instanceof Range3))
              throw new TypeError("a Range is required");
            return this.set.some((thisComparators) => isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => rangeComparators.every((rangeComparator) => thisComparator.intersects(rangeComparator, options)))));
          }
          test(version3) {
            if (!version3)
              return false;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer(version3, this.options);
              } catch (er) {
                return false;
              }
            for (let i = 0; i < this.set.length; i++)
              if (testSet(this.set[i], version3, this.options))
                return true;
            return false;
          }
        }
        module3.exports = Range3;
        const cache = new (__webpack_require__2("./node_modules/lru-cache/index.js"))({ max: 1e3 }), parseOptions = __webpack_require__2("./node_modules/semver/internal/parse-options.js"), Comparator = __webpack_require__2("./node_modules/semver/classes/comparator.js"), debug = __webpack_require__2("./node_modules/semver/internal/debug.js"), SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), { re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __webpack_require__2("./node_modules/semver/internal/re.js"), isNullSet = (c) => c.value === "<0.0.0-0", isAny = (c) => c.value === "", isSatisfiable = (comparators, options) => {
          let result = true;
          const remainingComparators = comparators.slice();
          let testComparator = remainingComparators.pop();
          for (; result && remainingComparators.length; )
            result = remainingComparators.every((otherComparator) => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
          return result;
        }, parseComparator = (comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp), isX = (id) => !id || id.toLowerCase() === "x" || id === "*", replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceTilde(comp2, options)).join(" "), replaceTilde = (comp, options) => {
          const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug("tilde return", ret), ret;
          });
        }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceCaret(comp2, options)).join(" "), replaceCaret = (comp, options) => {
          debug("caret", comp, options);
          const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET], z = options.includePrerelease ? "-0" : "";
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = M === "0" ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug("caret return", ret), ret;
          });
        }, replaceXRanges = (comp, options) => (debug("replaceXRanges", comp, options), comp.split(/\s+/).map((comp2) => replaceXRange(comp2, options)).join(" ")), replaceXRange = (comp, options) => {
          comp = comp.trim();
          const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
          return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
            debug("xRange", comp, ret, gtlt, M, m, p, pr);
            const xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
            return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? ret = gtlt === ">" || gtlt === "<" ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug("xRange return", ret), ret;
          });
        }, replaceStars = (comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), replaceGTE0 = (comp, options) => (debug("replaceGTE0", comp, options), comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version3, options) => {
          for (let i = 0; i < set.length; i++)
            if (!set[i].test(version3))
              return false;
          if (version3.prerelease.length && !options.includePrerelease) {
            for (let i = 0; i < set.length; i++)
              if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch)
                  return true;
              }
            return false;
          }
          return true;
        };
      }, "./node_modules/semver/classes/semver.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const debug = __webpack_require__2("./node_modules/semver/internal/debug.js"), { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__2("./node_modules/semver/internal/constants.js"), { re, t } = __webpack_require__2("./node_modules/semver/internal/re.js"), parseOptions = __webpack_require__2("./node_modules/semver/internal/parse-options.js"), { compareIdentifiers } = __webpack_require__2("./node_modules/semver/internal/identifiers.js");
        class SemVer {
          constructor(version3, options) {
            if (options = parseOptions(options), version3 instanceof SemVer) {
              if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease)
                return version3;
              version3 = version3.version;
            } else if (typeof version3 != "string")
              throw new TypeError(`Invalid Version: ${version3}`);
            if (version3.length > MAX_LENGTH)
              throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
            debug("SemVer", version3, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
            const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
            if (!m)
              throw new TypeError(`Invalid Version: ${version3}`);
            if (this.raw = version3, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m[4] ? this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
              if (typeof other == "string" && other === this.version)
                return 0;
              other = new SemVer(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
          }
          comparePre(other) {
            if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              const a = this.prerelease[i], b = other.prerelease[i];
              if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof SemVer || (other = new SemVer(other, this.options));
            let i = 0;
            do {
              const a = this.build[i], b = other.build[i];
              if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          inc(release, identifier) {
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                  i === -1 && this.prerelease.push(0);
                }
                identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        module3.exports = SemVer;
      }, "./node_modules/semver/functions/clean.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const parse2 = __webpack_require__2("./node_modules/semver/functions/parse.js");
        module3.exports = (version3, options) => {
          const s = parse2(version3.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        };
      }, "./node_modules/semver/functions/cmp.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const eq = __webpack_require__2("./node_modules/semver/functions/eq.js"), neq = __webpack_require__2("./node_modules/semver/functions/neq.js"), gt = __webpack_require__2("./node_modules/semver/functions/gt.js"), gte = __webpack_require__2("./node_modules/semver/functions/gte.js"), lt = __webpack_require__2("./node_modules/semver/functions/lt.js"), lte = __webpack_require__2("./node_modules/semver/functions/lte.js");
        module3.exports = (a, op, b, loose) => {
          switch (op) {
            case "===":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
            case "!==":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError(`Invalid operator: ${op}`);
          }
        };
      }, "./node_modules/semver/functions/coerce.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), parse2 = __webpack_require__2("./node_modules/semver/functions/parse.js"), { re, t } = __webpack_require__2("./node_modules/semver/internal/re.js");
        module3.exports = (version3, options) => {
          if (version3 instanceof SemVer)
            return version3;
          if (typeof version3 == "number" && (version3 = String(version3)), typeof version3 != "string")
            return null;
          let match = null;
          if ((options = options || {}).rtl) {
            let next;
            for (; (next = re[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re[t.COERCERTL].lastIndex = -1;
          } else
            match = version3.match(re[t.COERCE]);
          return match === null ? null : parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
        };
      }, "./node_modules/semver/functions/compare-build.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (a, b, loose) => {
          const versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
      }, "./node_modules/semver/functions/compare-loose.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b) => compare(a, b, true);
      }, "./node_modules/semver/functions/compare.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      }, "./node_modules/semver/functions/diff.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const parse2 = __webpack_require__2("./node_modules/semver/functions/parse.js"), eq = __webpack_require__2("./node_modules/semver/functions/eq.js");
        module3.exports = (version1, version22) => {
          if (eq(version1, version22))
            return null;
          {
            const v1 = parse2(version1), v2 = parse2(version22), hasPre = v1.prerelease.length || v2.prerelease.length, prefix = hasPre ? "pre" : "", defaultResult = hasPre ? "prerelease" : "";
            for (const key in v1)
              if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
                return prefix + key;
            return defaultResult;
          }
        };
      }, "./node_modules/semver/functions/eq.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) === 0;
      }, "./node_modules/semver/functions/gt.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) > 0;
      }, "./node_modules/semver/functions/gte.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) >= 0;
      }, "./node_modules/semver/functions/inc.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (version3, release, options, identifier) => {
          typeof options == "string" && (identifier = options, options = void 0);
          try {
            return new SemVer(version3, options).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        };
      }, "./node_modules/semver/functions/lt.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) < 0;
      }, "./node_modules/semver/functions/lte.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) <= 0;
      }, "./node_modules/semver/functions/major.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (a, loose) => new SemVer(a, loose).major;
      }, "./node_modules/semver/functions/minor.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (a, loose) => new SemVer(a, loose).minor;
      }, "./node_modules/semver/functions/neq.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(a, b, loose) !== 0;
      }, "./node_modules/semver/functions/parse.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const { MAX_LENGTH } = __webpack_require__2("./node_modules/semver/internal/constants.js"), { re, t } = __webpack_require__2("./node_modules/semver/internal/re.js"), SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), parseOptions = __webpack_require__2("./node_modules/semver/internal/parse-options.js");
        module3.exports = (version3, options) => {
          if (options = parseOptions(options), version3 instanceof SemVer)
            return version3;
          if (typeof version3 != "string")
            return null;
          if (version3.length > MAX_LENGTH)
            return null;
          if (!(options.loose ? re[t.LOOSE] : re[t.FULL]).test(version3))
            return null;
          try {
            return new SemVer(version3, options);
          } catch (er) {
            return null;
          }
        };
      }, "./node_modules/semver/functions/patch.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js");
        module3.exports = (a, loose) => new SemVer(a, loose).patch;
      }, "./node_modules/semver/functions/prerelease.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const parse2 = __webpack_require__2("./node_modules/semver/functions/parse.js");
        module3.exports = (version3, options) => {
          const parsed = parse2(version3, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
      }, "./node_modules/semver/functions/rcompare.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (a, b, loose) => compare(b, a, loose);
      }, "./node_modules/semver/functions/rsort.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compareBuild = __webpack_require__2("./node_modules/semver/functions/compare-build.js");
        module3.exports = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      }, "./node_modules/semver/functions/satisfies.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (version3, range, options) => {
          try {
            range = new Range3(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version3);
        };
      }, "./node_modules/semver/functions/sort.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const compareBuild = __webpack_require__2("./node_modules/semver/functions/compare-build.js");
        module3.exports = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      }, "./node_modules/semver/functions/valid.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const parse2 = __webpack_require__2("./node_modules/semver/functions/parse.js");
        module3.exports = (version3, options) => {
          const v = parse2(version3, options);
          return v ? v.version : null;
        };
      }, "./node_modules/semver/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const internalRe = __webpack_require__2("./node_modules/semver/internal/re.js");
        module3.exports = { re: internalRe.re, src: internalRe.src, tokens: internalRe.t, SEMVER_SPEC_VERSION: __webpack_require__2("./node_modules/semver/internal/constants.js").SEMVER_SPEC_VERSION, SemVer: __webpack_require__2("./node_modules/semver/classes/semver.js"), compareIdentifiers: __webpack_require__2("./node_modules/semver/internal/identifiers.js").compareIdentifiers, rcompareIdentifiers: __webpack_require__2("./node_modules/semver/internal/identifiers.js").rcompareIdentifiers, parse: __webpack_require__2("./node_modules/semver/functions/parse.js"), valid: __webpack_require__2("./node_modules/semver/functions/valid.js"), clean: __webpack_require__2("./node_modules/semver/functions/clean.js"), inc: __webpack_require__2("./node_modules/semver/functions/inc.js"), diff: __webpack_require__2("./node_modules/semver/functions/diff.js"), major: __webpack_require__2("./node_modules/semver/functions/major.js"), minor: __webpack_require__2("./node_modules/semver/functions/minor.js"), patch: __webpack_require__2("./node_modules/semver/functions/patch.js"), prerelease: __webpack_require__2("./node_modules/semver/functions/prerelease.js"), compare: __webpack_require__2("./node_modules/semver/functions/compare.js"), rcompare: __webpack_require__2("./node_modules/semver/functions/rcompare.js"), compareLoose: __webpack_require__2("./node_modules/semver/functions/compare-loose.js"), compareBuild: __webpack_require__2("./node_modules/semver/functions/compare-build.js"), sort: __webpack_require__2("./node_modules/semver/functions/sort.js"), rsort: __webpack_require__2("./node_modules/semver/functions/rsort.js"), gt: __webpack_require__2("./node_modules/semver/functions/gt.js"), lt: __webpack_require__2("./node_modules/semver/functions/lt.js"), eq: __webpack_require__2("./node_modules/semver/functions/eq.js"), neq: __webpack_require__2("./node_modules/semver/functions/neq.js"), gte: __webpack_require__2("./node_modules/semver/functions/gte.js"), lte: __webpack_require__2("./node_modules/semver/functions/lte.js"), cmp: __webpack_require__2("./node_modules/semver/functions/cmp.js"), coerce: __webpack_require__2("./node_modules/semver/functions/coerce.js"), Comparator: __webpack_require__2("./node_modules/semver/classes/comparator.js"), Range: __webpack_require__2("./node_modules/semver/classes/range.js"), satisfies: __webpack_require__2("./node_modules/semver/functions/satisfies.js"), toComparators: __webpack_require__2("./node_modules/semver/ranges/to-comparators.js"), maxSatisfying: __webpack_require__2("./node_modules/semver/ranges/max-satisfying.js"), minSatisfying: __webpack_require__2("./node_modules/semver/ranges/min-satisfying.js"), minVersion: __webpack_require__2("./node_modules/semver/ranges/min-version.js"), validRange: __webpack_require__2("./node_modules/semver/ranges/valid.js"), outside: __webpack_require__2("./node_modules/semver/ranges/outside.js"), gtr: __webpack_require__2("./node_modules/semver/ranges/gtr.js"), ltr: __webpack_require__2("./node_modules/semver/ranges/ltr.js"), intersects: __webpack_require__2("./node_modules/semver/ranges/intersects.js"), simplifyRange: __webpack_require__2("./node_modules/semver/ranges/simplify.js"), subset: __webpack_require__2("./node_modules/semver/ranges/subset.js") };
      }, "./node_modules/semver/internal/constants.js": (module3) => {
        const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        module3.exports = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER, MAX_SAFE_COMPONENT_LENGTH: 16 };
      }, "./node_modules/semver/internal/debug.js": (module3) => {
        const debug = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        };
        module3.exports = debug;
      }, "./node_modules/semver/internal/identifiers.js": (module3) => {
        const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
          const anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        module3.exports = { compareIdentifiers, rcompareIdentifiers: (a, b) => compareIdentifiers(b, a) };
      }, "./node_modules/semver/internal/parse-options.js": (module3) => {
        const opts = ["includePrerelease", "loose", "rtl"];
        module3.exports = (options) => options ? typeof options != "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => (options2[k] = true, options2), {}) : {};
      }, "./node_modules/semver/internal/re.js": (module3, exports2, __webpack_require__2) => {
        const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__2("./node_modules/semver/internal/constants.js"), debug = __webpack_require__2("./node_modules/semver/internal/debug.js"), re = (exports2 = module3.exports = {}).re = [], src = exports2.src = [], t = exports2.t = {};
        let R = 0;
        const createToken = (name, value, isGlobal) => {
          const index = R++;
          debug(index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0);
        };
        createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t.COERCE], true), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true), exports2.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true), exports2.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true), exports2.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      }, "./node_modules/semver/ranges/gtr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const outside = __webpack_require__2("./node_modules/semver/ranges/outside.js");
        module3.exports = (version3, range, options) => outside(version3, range, ">", options);
      }, "./node_modules/semver/ranges/intersects.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (r1, r2, options) => (r1 = new Range3(r1, options), r2 = new Range3(r2, options), r1.intersects(r2));
      }, "./node_modules/semver/ranges/ltr.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const outside = __webpack_require__2("./node_modules/semver/ranges/outside.js");
        module3.exports = (version3, range, options) => outside(version3, range, "<", options);
      }, "./node_modules/semver/ranges/max-satisfying.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (versions, range, options) => {
          let max = null, maxSV = null, rangeObj = null;
          try {
            rangeObj = new Range3(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (max = v, maxSV = new SemVer(max, options)));
          }), max;
        };
      }, "./node_modules/semver/ranges/min-satisfying.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (versions, range, options) => {
          let min = null, minSV = null, rangeObj = null;
          try {
            rangeObj = new Range3(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (min && minSV.compare(v) !== 1 || (min = v, minSV = new SemVer(min, options)));
          }), min;
        };
      }, "./node_modules/semver/ranges/min-version.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), Range3 = __webpack_require__2("./node_modules/semver/classes/range.js"), gt = __webpack_require__2("./node_modules/semver/functions/gt.js");
        module3.exports = (range, loose) => {
          range = new Range3(range, loose);
          let minver = new SemVer("0.0.0");
          if (range.test(minver))
            return minver;
          if (minver = new SemVer("0.0.0-0"), range.test(minver))
            return minver;
          minver = null;
          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i];
            let setMin = null;
            comparators.forEach((comparator) => {
              const compver = new SemVer(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  setMin && !gt(compver, setMin) || (setMin = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${comparator.operator}`);
              }
            }), !setMin || minver && !gt(minver, setMin) || (minver = setMin);
          }
          return minver && range.test(minver) ? minver : null;
        };
      }, "./node_modules/semver/ranges/outside.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const SemVer = __webpack_require__2("./node_modules/semver/classes/semver.js"), Comparator = __webpack_require__2("./node_modules/semver/classes/comparator.js"), { ANY } = Comparator, Range3 = __webpack_require__2("./node_modules/semver/classes/range.js"), satisfies = __webpack_require__2("./node_modules/semver/functions/satisfies.js"), gt = __webpack_require__2("./node_modules/semver/functions/gt.js"), lt = __webpack_require__2("./node_modules/semver/functions/lt.js"), lte = __webpack_require__2("./node_modules/semver/functions/lte.js"), gte = __webpack_require__2("./node_modules/semver/functions/gte.js");
        module3.exports = (version3, range, hilo, options) => {
          let gtfn, ltefn, ltfn, comp, ecomp;
          switch (version3 = new SemVer(version3, options), range = new Range3(range, options), hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies(version3, range, options))
            return false;
          for (let i = 0; i < range.set.length; ++i) {
            const comparators = range.set[i];
            let high = null, low = null;
            if (comparators.forEach((comparator) => {
              comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version3, low.semver))
              return false;
          }
          return true;
        };
      }, "./node_modules/semver/ranges/simplify.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const satisfies = __webpack_require__2("./node_modules/semver/functions/satisfies.js"), compare = __webpack_require__2("./node_modules/semver/functions/compare.js");
        module3.exports = (versions, range, options) => {
          const set = [];
          let min = null, prev = null;
          const v = versions.sort((a, b) => compare(a, b, options));
          for (const version3 of v) {
            satisfies(version3, range, options) ? (prev = version3, min || (min = version3)) : (prev && set.push([min, prev]), prev = null, min = null);
          }
          min && set.push([min, null]);
          const ranges = [];
          for (const [min2, max] of set)
            min2 === max ? ranges.push(min2) : max || min2 !== v[0] ? max ? min2 === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min2} - ${max}`) : ranges.push(`>=${min2}`) : ranges.push("*");
          const simplified = ranges.join(" || "), original = typeof range.raw == "string" ? range.raw : String(range);
          return simplified.length < original.length ? simplified : range;
        };
      }, "./node_modules/semver/ranges/subset.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const Range3 = __webpack_require__2("./node_modules/semver/classes/range.js"), Comparator = __webpack_require__2("./node_modules/semver/classes/comparator.js"), { ANY } = Comparator, satisfies = __webpack_require__2("./node_modules/semver/functions/satisfies.js"), compare = __webpack_require__2("./node_modules/semver/functions/compare.js"), simpleSubset = (sub, dom, options) => {
          if (sub === dom)
            return true;
          if (sub.length === 1 && sub[0].semver === ANY) {
            if (dom.length === 1 && dom[0].semver === ANY)
              return true;
            sub = options.includePrerelease ? [new Comparator(">=0.0.0-0")] : [new Comparator(">=0.0.0")];
          }
          if (dom.length === 1 && dom[0].semver === ANY) {
            if (options.includePrerelease)
              return true;
            dom = [new Comparator(">=0.0.0")];
          }
          const eqSet = /* @__PURE__ */ new Set();
          let gt, lt, gtltComp, higher, lower, hasDomLT, hasDomGT;
          for (const c of sub)
            c.operator === ">" || c.operator === ">=" ? gt = higherGT(gt, c, options) : c.operator === "<" || c.operator === "<=" ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
          if (eqSet.size > 1)
            return null;
          if (gt && lt) {
            if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0)
              return null;
            if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
              return null;
          }
          for (const eq of eqSet) {
            if (gt && !satisfies(eq, String(gt), options))
              return null;
            if (lt && !satisfies(eq, String(lt), options))
              return null;
            for (const c of dom)
              if (!satisfies(eq, String(c), options))
                return false;
            return true;
          }
          let needDomLTPre = !(!lt || options.includePrerelease || !lt.semver.prerelease.length) && lt.semver, needDomGTPre = !(!gt || options.includePrerelease || !gt.semver.prerelease.length) && gt.semver;
          needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = false);
          for (const c of dom) {
            if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt) {
              if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = false), c.operator === ">" || c.operator === ">=") {
                if (higher = higherGT(gt, c, options), higher === c && higher !== gt)
                  return false;
              } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
                return false;
            }
            if (lt) {
              if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = false), c.operator === "<" || c.operator === "<=") {
                if (lower = lowerLT(lt, c, options), lower === c && lower !== lt)
                  return false;
              } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
                return false;
            }
            if (!c.operator && (lt || gt) && gtltComp !== 0)
              return false;
          }
          return !(gt && hasDomLT && !lt && gtltComp !== 0) && (!(lt && hasDomGT && !gt && gtltComp !== 0) && (!needDomGTPre && !needDomLTPre));
        }, higherGT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
        }, lowerLT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
        };
        module3.exports = (sub, dom, options = {}) => {
          if (sub === dom)
            return true;
          sub = new Range3(sub, options), dom = new Range3(dom, options);
          let sawNonNull = false;
          OUTER:
            for (const simpleSub of sub.set) {
              for (const simpleDom of dom.set) {
                const isSub = simpleSubset(simpleSub, simpleDom, options);
                if (sawNonNull = sawNonNull || isSub !== null, isSub)
                  continue OUTER;
              }
              if (sawNonNull)
                return false;
            }
          return true;
        };
      }, "./node_modules/semver/ranges/to-comparators.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (range, options) => new Range3(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      }, "./node_modules/semver/ranges/valid.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        const Range3 = __webpack_require__2("./node_modules/semver/classes/range.js");
        module3.exports = (range, options) => {
          try {
            return new Range3(range, options).range || "*";
          } catch (er) {
            return null;
          }
        };
      }, "./node_modules/yallist/iterator.js": (module3) => {
        "use strict";
        module3.exports = function(Yallist) {
          Yallist.prototype[Symbol.iterator] = function* () {
            for (let walker = this.head; walker; walker = walker.next)
              yield walker.value;
          };
        };
      }, "./node_modules/yallist/yallist.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        function Yallist(list) {
          var self2 = this;
          if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list && typeof list.forEach == "function")
            list.forEach(function(item) {
              self2.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self2.push(arguments[i]);
          return self2;
        }
        function insert(self2, node, value) {
          var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
          return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
        }
        function push(self2, item) {
          self2.tail = new Node2(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
        }
        function unshift(self2, item) {
          self2.head = new Node2(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
        }
        function Node2(value, prev, next, list) {
          if (!(this instanceof Node2))
            return new Node2(value, prev, next, list);
          this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
        module3.exports = Yallist, Yallist.Node = Node2, Yallist.create = Yallist, Yallist.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
        }, Yallist.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++)
            walker = walker.next;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
            walker = walker.prev;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.head; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.tail; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.head.next, acc = this.head.value;
          }
          for (var i = 0; walker !== null; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.tail.prev, acc = this.tail.value;
          }
          for (var i = this.length - 1; walker !== null; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist.prototype.slice = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; walker !== null && i < from; i++)
            walker = walker.next;
          for (; walker !== null && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.sliceReverse = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
            walker = walker.prev;
          for (; walker !== null && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
          start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
          for (var i = 0, walker = this.head; walker !== null && i < start; i++)
            walker = walker.next;
          var ret = [];
          for (i = 0; walker && i < deleteCount; i++)
            ret.push(walker.value), walker = this.removeNode(walker);
          walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
          for (i = 0; i < nodes.length; i++)
            walker = insert(this, walker, nodes[i]);
          return ret;
        }, Yallist.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        try {
          __webpack_require__2("./node_modules/yallist/iterator.js")(Yallist);
        } catch (er) {
        }
      }, crypto: (module3) => {
        "use strict";
        module3.exports = require("crypto");
      }, fs: (module3) => {
        "use strict";
        module3.exports = require("fs");
      }, module: (module3) => {
        "use strict";
        module3.exports = require("module");
      }, path: (module3) => {
        "use strict";
        module3.exports = require("path");
      }, util: (module3) => {
        "use strict";
        module3.exports = require("util");
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0)
          return cachedModule.exports;
        var module3 = __webpack_module_cache__[moduleId] = { id: moduleId, loaded: false, exports: {} };
        return __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__), module3.loaded = true, module3.exports;
      }
      __webpack_require__.n = (module3) => {
        var getter = module3 && module3.__esModule ? () => module3.default : () => module3;
        return __webpack_require__.d(getter, { a: getter }), getter;
      }, __webpack_require__.d = (exports2, definition) => {
        for (var key in definition)
          __webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key) && Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
      }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.nmd = (module3) => (module3.paths = [], module3.children || (module3.children = []), module3);
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, { default: () => createJITI });
        var external_fs_ = __webpack_require__("fs"), external_module_ = __webpack_require__("module"), external_path_ = __webpack_require__("path");
        const external_os_namespaceObject = require("os"), external_vm_namespaceObject = require("vm");
        var external_vm_default = __webpack_require__.n(external_vm_namespaceObject);
        const external_url_namespaceObject = require("url");
        var mkdirp = __webpack_require__("./node_modules/mkdirp/index.js");
        const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, JsonSigRx = /^["{[]|^-?[0-9][0-9.]{0,14}$/;
        function jsonParseTransform(key, value) {
          if (key !== "__proto__" && key !== "constructor")
            return value;
        }
        const dist = function(val) {
          if (typeof val != "string")
            return val;
          const _lval = val.toLowerCase();
          if (_lval === "true")
            return true;
          if (_lval === "false")
            return false;
          if (_lval === "null")
            return null;
          if (_lval === "nan")
            return NaN;
          if (_lval === "infinity")
            return 1 / 0;
          if (_lval !== "undefined") {
            if (!JsonSigRx.test(val))
              return val;
            try {
              return suspectProtoRx.test(val) || suspectConstructorRx.test(val) ? JSON.parse(val, jsonParseTransform) : JSON.parse(val);
            } catch (_e) {
              return val;
            }
          }
        };
        var create_require = __webpack_require__("./node_modules/create-require/create-require.js"), create_require_default = __webpack_require__.n(create_require), semver = __webpack_require__("./node_modules/semver/index.js"), lib = __webpack_require__("./node_modules/pirates/lib/index.js"), object_hash = __webpack_require__("./node_modules/object-hash/index.js"), object_hash_default = __webpack_require__.n(object_hash);
        const external_assert_namespaceObject = require("assert");
        var external_util_ = __webpack_require__("util");
        const BUILTIN_MODULES$1 = new Set(external_module_.builtinModules);
        function normalizeSlash$1(str) {
          return str.replace(/\\/g, "/");
        }
        function fileURLToPath$1(id) {
          return typeof id != "string" || id.startsWith("file://") ? normalizeSlash$1((0, external_url_namespaceObject.fileURLToPath)(id)) : normalizeSlash$1(id);
        }
        const _IS_ABSOLUTE_RE$1 = /^\/|^\\|^[a-zA-Z]:[/\\]/;
        const isAbsolute$1 = function(p) {
          return _IS_ABSOLUTE_RE$1.test(p);
        };
        var re$b = { exports: {} };
        var constants$1 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 };
        var debug_1$1 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        };
        !function(module3, exports2) {
          const { MAX_SAFE_COMPONENT_LENGTH } = constants$1, debug2 = debug_1$1, re2 = (exports2 = module3.exports = {}).re = [], src = exports2.src = [], t2 = exports2.t = {};
          let R = 0;
          const createToken = (name, value, isGlobal) => {
            const index = R++;
            debug2(index, value), t2[name] = index, src[index] = value, re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
          };
          createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`), createToken("FULL", `^${src[t2.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`), createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t2.COERCE], true), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true), exports2.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true), exports2.caretTrimReplace = "$1^", createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true), exports2.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        }(re$b, re$b.exports);
        const opts$1 = ["includePrerelease", "loose", "rtl"];
        var parseOptions_1$1 = (options) => options ? typeof options != "object" ? { loose: true } : opts$1.filter((k) => options[k]).reduce((options2, k) => (options2[k] = true, options2), {}) : {};
        const numeric$1 = /^[0-9]+$/, compareIdentifiers$3 = (a, b) => {
          const anum = numeric$1.test(a), bnum = numeric$1.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        var identifiers$1 = { compareIdentifiers: compareIdentifiers$3, rcompareIdentifiers: (a, b) => compareIdentifiers$3(b, a) };
        const debug$6 = debug_1$1, { MAX_LENGTH: MAX_LENGTH$4, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = constants$1, { re: re$a, t: t$9 } = re$b.exports, parseOptions$8 = parseOptions_1$1, { compareIdentifiers: compareIdentifiers$2 } = identifiers$1;
        class SemVer$t {
          constructor(version3, options) {
            if (options = parseOptions$8(options), version3 instanceof SemVer$t) {
              if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease)
                return version3;
              version3 = version3.version;
            } else if (typeof version3 != "string")
              throw new TypeError(`Invalid Version: ${version3}`);
            if (version3.length > MAX_LENGTH$4)
              throw new TypeError(`version is longer than ${MAX_LENGTH$4} characters`);
            debug$6("SemVer", version3, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
            const m = version3.trim().match(options.loose ? re$a[t$9.LOOSE] : re$a[t$9.FULL]);
            if (!m)
              throw new TypeError(`Invalid Version: ${version3}`);
            if (this.raw = version3, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER$2 || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m[4] ? this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER$2)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug$6("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer$t)) {
              if (typeof other == "string" && other === this.version)
                return 0;
              other = new SemVer$t(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof SemVer$t || (other = new SemVer$t(other, this.options)), compareIdentifiers$2(this.major, other.major) || compareIdentifiers$2(this.minor, other.minor) || compareIdentifiers$2(this.patch, other.patch);
          }
          comparePre(other) {
            if (other instanceof SemVer$t || (other = new SemVer$t(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              const a = this.prerelease[i], b = other.prerelease[i];
              if (debug$6("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers$2(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof SemVer$t || (other = new SemVer$t(other, this.options));
            let i = 0;
            do {
              const a = this.build[i], b = other.build[i];
              if (debug$6("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers$2(a, b);
            } while (++i);
          }
          inc(release, identifier) {
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                  i === -1 && this.prerelease.push(0);
                }
                identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        var semver$5 = SemVer$t;
        const { MAX_LENGTH: MAX_LENGTH$3 } = constants$1, { re: re$9, t: t$8 } = re$b.exports, SemVer$s = semver$5, parseOptions$7 = parseOptions_1$1;
        var parse_1$1 = (version3, options) => {
          if (options = parseOptions$7(options), version3 instanceof SemVer$s)
            return version3;
          if (typeof version3 != "string")
            return null;
          if (version3.length > MAX_LENGTH$3)
            return null;
          if (!(options.loose ? re$9[t$8.LOOSE] : re$9[t$8.FULL]).test(version3))
            return null;
          try {
            return new SemVer$s(version3, options);
          } catch (er) {
            return null;
          }
        };
        const parse$b = parse_1$1;
        var valid_1$1 = (version3, options) => {
          const v = parse$b(version3, options);
          return v ? v.version : null;
        };
        const parse$a = parse_1$1;
        var clean_1$1 = (version3, options) => {
          const s = parse$a(version3.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        };
        const SemVer$r = semver$5;
        var inc_1$1 = (version3, release, options, identifier) => {
          typeof options == "string" && (identifier = options, options = void 0);
          try {
            return new SemVer$r(version3, options).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        };
        const SemVer$q = semver$5;
        var compare_1$1 = (a, b, loose) => new SemVer$q(a, loose).compare(new SemVer$q(b, loose));
        const compare$k = compare_1$1;
        var eq_1$1 = (a, b, loose) => compare$k(a, b, loose) === 0;
        const parse$9 = parse_1$1, eq$4 = eq_1$1;
        var diff_1$1 = (version1, version22) => {
          if (eq$4(version1, version22))
            return null;
          {
            const v1 = parse$9(version1), v2 = parse$9(version22), hasPre = v1.prerelease.length || v2.prerelease.length, prefix = hasPre ? "pre" : "", defaultResult = hasPre ? "prerelease" : "";
            for (const key in v1)
              if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
                return prefix + key;
            return defaultResult;
          }
        };
        const SemVer$p = semver$5;
        var major_1$1 = (a, loose) => new SemVer$p(a, loose).major;
        const SemVer$o = semver$5;
        var minor_1$1 = (a, loose) => new SemVer$o(a, loose).minor;
        const SemVer$n = semver$5;
        var patch_1$1 = (a, loose) => new SemVer$n(a, loose).patch;
        const parse$8 = parse_1$1;
        var prerelease_1$1 = (version3, options) => {
          const parsed = parse$8(version3, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
        const compare$j = compare_1$1;
        var rcompare_1$1 = (a, b, loose) => compare$j(b, a, loose);
        const compare$i = compare_1$1;
        var compareLoose_1$1 = (a, b) => compare$i(a, b, true);
        const SemVer$m = semver$5;
        var compareBuild_1$1 = (a, b, loose) => {
          const versionA = new SemVer$m(a, loose), versionB = new SemVer$m(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
        const compareBuild$4 = compareBuild_1$1;
        var sort_1$1 = (list, loose) => list.sort((a, b) => compareBuild$4(a, b, loose));
        const compareBuild$3 = compareBuild_1$1;
        var rsort_1$1 = (list, loose) => list.sort((a, b) => compareBuild$3(b, a, loose));
        const compare$h = compare_1$1;
        var gt_1$1 = (a, b, loose) => compare$h(a, b, loose) > 0;
        const compare$g = compare_1$1;
        var lt_1$1 = (a, b, loose) => compare$g(a, b, loose) < 0;
        const compare$f = compare_1$1;
        var neq_1$1 = (a, b, loose) => compare$f(a, b, loose) !== 0;
        const compare$e = compare_1$1;
        var gte_1$1 = (a, b, loose) => compare$e(a, b, loose) >= 0;
        const compare$d = compare_1$1;
        var lte_1$1 = (a, b, loose) => compare$d(a, b, loose) <= 0;
        const eq$3 = eq_1$1, neq$2 = neq_1$1, gt$6 = gt_1$1, gte$4 = gte_1$1, lt$4 = lt_1$1, lte$4 = lte_1$1;
        var cmp_1$1 = (a, op, b, loose) => {
          switch (op) {
            case "===":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
            case "!==":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq$3(a, b, loose);
            case "!=":
              return neq$2(a, b, loose);
            case ">":
              return gt$6(a, b, loose);
            case ">=":
              return gte$4(a, b, loose);
            case "<":
              return lt$4(a, b, loose);
            case "<=":
              return lte$4(a, b, loose);
            default:
              throw new TypeError(`Invalid operator: ${op}`);
          }
        };
        const SemVer$l = semver$5, parse$7 = parse_1$1, { re: re$8, t: t$7 } = re$b.exports;
        var coerce_1$1 = (version3, options) => {
          if (version3 instanceof SemVer$l)
            return version3;
          if (typeof version3 == "number" && (version3 = String(version3)), typeof version3 != "string")
            return null;
          let match = null;
          if ((options = options || {}).rtl) {
            let next;
            for (; (next = re$8[t$7.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re$8[t$7.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re$8[t$7.COERCERTL].lastIndex = -1;
          } else
            match = version3.match(re$8[t$7.COERCE]);
          return match === null ? null : parse$7(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
        }, yallist$1 = Yallist$3;
        function Yallist$3(list) {
          var self2 = this;
          if (self2 instanceof Yallist$3 || (self2 = new Yallist$3()), self2.tail = null, self2.head = null, self2.length = 0, list && typeof list.forEach == "function")
            list.forEach(function(item) {
              self2.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self2.push(arguments[i]);
          return self2;
        }
        function insert$1(self2, node, value) {
          var inserted = node === self2.head ? new Node$1(value, null, node, self2) : new Node$1(value, node, node.next, self2);
          return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
        }
        function push$1(self2, item) {
          self2.tail = new Node$1(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
        }
        function unshift$1(self2, item) {
          self2.head = new Node$1(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
        }
        function Node$1(value, prev, next, list) {
          if (!(this instanceof Node$1))
            return new Node$1(value, prev, next, list);
          this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
        Yallist$3.Node = Node$1, Yallist$3.create = Yallist$3, Yallist$3.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
        }, Yallist$3.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist$3.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist$3.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push$1(this, arguments[i]);
          return this.length;
        }, Yallist$3.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift$1(this, arguments[i]);
          return this.length;
        }, Yallist$3.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist$3.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist$3.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist$3.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist$3.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++)
            walker = walker.next;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist$3.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
            walker = walker.prev;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist$3.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist$3(), walker = this.head; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist$3.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist$3(), walker = this.tail; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist$3.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.head.next, acc = this.head.value;
          }
          for (var i = 0; walker !== null; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist$3.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.tail.prev, acc = this.tail.value;
          }
          for (var i = this.length - 1; walker !== null; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist$3.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist$3.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist$3.prototype.slice = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist$3();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; walker !== null && i < from; i++)
            walker = walker.next;
          for (; walker !== null && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist$3.prototype.sliceReverse = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist$3();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
            walker = walker.prev;
          for (; walker !== null && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist$3.prototype.splice = function(start, deleteCount, ...nodes) {
          start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
          for (var i = 0, walker = this.head; walker !== null && i < start; i++)
            walker = walker.next;
          var ret = [];
          for (i = 0; walker && i < deleteCount; i++)
            ret.push(walker.value), walker = this.removeNode(walker);
          walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
          for (i = 0; i < nodes.length; i++)
            walker = insert$1(this, walker, nodes[i]);
          return ret;
        }, Yallist$3.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        try {
          require("./iterator.js")(Yallist$3);
        } catch (er) {
        }
        const Yallist$2 = yallist$1, MAX$1 = Symbol("max"), LENGTH$1 = Symbol("length"), LENGTH_CALCULATOR$1 = Symbol("lengthCalculator"), ALLOW_STALE$1 = Symbol("allowStale"), MAX_AGE$1 = Symbol("maxAge"), DISPOSE$1 = Symbol("dispose"), NO_DISPOSE_ON_SET$1 = Symbol("noDisposeOnSet"), LRU_LIST$1 = Symbol("lruList"), CACHE$1 = Symbol("cache"), UPDATE_AGE_ON_GET$1 = Symbol("updateAgeOnGet"), naiveLength$1 = () => 1;
        const get$1 = (self2, key, doUse) => {
          const node = self2[CACHE$1].get(key);
          if (node) {
            const hit = node.value;
            if (isStale$1(self2, hit)) {
              if (del$1(self2, node), !self2[ALLOW_STALE$1])
                return;
            } else
              doUse && (self2[UPDATE_AGE_ON_GET$1] && (node.value.now = Date.now()), self2[LRU_LIST$1].unshiftNode(node));
            return hit.value;
          }
        }, isStale$1 = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE$1])
            return false;
          const diff = Date.now() - hit.now;
          return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE$1] && diff > self2[MAX_AGE$1];
        }, trim$1 = (self2) => {
          if (self2[LENGTH$1] > self2[MAX$1])
            for (let walker = self2[LRU_LIST$1].tail; self2[LENGTH$1] > self2[MAX$1] && walker !== null; ) {
              const prev = walker.prev;
              del$1(self2, walker), walker = prev;
            }
        }, del$1 = (self2, node) => {
          if (node) {
            const hit = node.value;
            self2[DISPOSE$1] && self2[DISPOSE$1](hit.key, hit.value), self2[LENGTH$1] -= hit.length, self2[CACHE$1].delete(hit.key), self2[LRU_LIST$1].removeNode(node);
          }
        };
        class Entry$1 {
          constructor(key, value, length, now, maxAge) {
            this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
          }
        }
        const forEachStep$1 = (self2, fn, node, thisp) => {
          let hit = node.value;
          isStale$1(self2, hit) && (del$1(self2, node), self2[ALLOW_STALE$1] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
        };
        var lruCache$1 = class {
          constructor(options) {
            if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX$1] = options.max || 1 / 0;
            const lc = options.length || naiveLength$1;
            if (this[LENGTH_CALCULATOR$1] = typeof lc != "function" ? naiveLength$1 : lc, this[ALLOW_STALE$1] = options.stale || false, options.maxAge && typeof options.maxAge != "number")
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE$1] = options.maxAge || 0, this[DISPOSE$1] = options.dispose, this[NO_DISPOSE_ON_SET$1] = options.noDisposeOnSet || false, this[UPDATE_AGE_ON_GET$1] = options.updateAgeOnGet || false, this.reset();
          }
          set max(mL) {
            if (typeof mL != "number" || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX$1] = mL || 1 / 0, trim$1(this);
          }
          get max() {
            return this[MAX$1];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE$1] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE$1];
          }
          set maxAge(mA) {
            if (typeof mA != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE$1] = mA, trim$1(this);
          }
          get maxAge() {
            return this[MAX_AGE$1];
          }
          set lengthCalculator(lC) {
            typeof lC != "function" && (lC = naiveLength$1), lC !== this[LENGTH_CALCULATOR$1] && (this[LENGTH_CALCULATOR$1] = lC, this[LENGTH$1] = 0, this[LRU_LIST$1].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR$1](hit.value, hit.key), this[LENGTH$1] += hit.length;
            })), trim$1(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR$1];
          }
          get length() {
            return this[LENGTH$1];
          }
          get itemCount() {
            return this[LRU_LIST$1].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST$1].tail; walker !== null; ) {
              const prev = walker.prev;
              forEachStep$1(this, fn, walker, thisp), walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST$1].head; walker !== null; ) {
              const next = walker.next;
              forEachStep$1(this, fn, walker, thisp), walker = next;
            }
          }
          keys() {
            return this[LRU_LIST$1].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST$1].toArray().map((k) => k.value);
          }
          reset() {
            this[DISPOSE$1] && this[LRU_LIST$1] && this[LRU_LIST$1].length && this[LRU_LIST$1].forEach((hit) => this[DISPOSE$1](hit.key, hit.value)), this[CACHE$1] = /* @__PURE__ */ new Map(), this[LRU_LIST$1] = new Yallist$2(), this[LENGTH$1] = 0;
          }
          dump() {
            return this[LRU_LIST$1].map((hit) => !isStale$1(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST$1];
          }
          set(key, value, maxAge) {
            if ((maxAge = maxAge || this[MAX_AGE$1]) && typeof maxAge != "number")
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR$1](value, key);
            if (this[CACHE$1].has(key)) {
              if (len > this[MAX$1])
                return del$1(this, this[CACHE$1].get(key)), false;
              const item = this[CACHE$1].get(key).value;
              return this[DISPOSE$1] && (this[NO_DISPOSE_ON_SET$1] || this[DISPOSE$1](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH$1] += len - item.length, item.length = len, this.get(key), trim$1(this), true;
            }
            const hit = new Entry$1(key, value, len, now, maxAge);
            return hit.length > this[MAX$1] ? (this[DISPOSE$1] && this[DISPOSE$1](key, value), false) : (this[LENGTH$1] += hit.length, this[LRU_LIST$1].unshift(hit), this[CACHE$1].set(key, this[LRU_LIST$1].head), trim$1(this), true);
          }
          has(key) {
            if (!this[CACHE$1].has(key))
              return false;
            const hit = this[CACHE$1].get(key).value;
            return !isStale$1(this, hit);
          }
          get(key) {
            return get$1(this, key, true);
          }
          peek(key) {
            return get$1(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST$1].tail;
            return node ? (del$1(this, node), node.value) : null;
          }
          del(key) {
            del$1(this, this[CACHE$1].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l], expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
          prune() {
            this[CACHE$1].forEach((value, key) => get$1(this, key, false));
          }
        };
        class Range$l {
          constructor(range2, options) {
            if (options = parseOptions$6(options), range2 instanceof Range$l)
              return range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease ? range2 : new Range$l(range2.raw, options);
            if (range2 instanceof Comparator$7)
              return this.raw = range2.value, this.set = [[range2]], this.format(), this;
            if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range2, this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${range2}`);
            if (this.set.length > 1) {
              const first = this.set[0];
              if (this.set = this.set.filter((c) => !isNullSet$1(c[0])), this.set.length === 0)
                this.set = [first];
              else if (this.set.length > 1) {
                for (const c of this.set)
                  if (c.length === 1 && isAny$1(c[0])) {
                    this.set = [c];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(range2) {
            range2 = range2.trim();
            const memoKey = `parseRange:${Object.keys(this.options).join(",")}:${range2}`, cached = cache$1.get(memoKey);
            if (cached)
              return cached;
            const loose = this.options.loose, hr = loose ? re$7[t$6.HYPHENRANGELOOSE] : re$7[t$6.HYPHENRANGE];
            range2 = range2.replace(hr, hyphenReplace$1(this.options.includePrerelease)), debug$5("hyphen replace", range2), range2 = range2.replace(re$7[t$6.COMPARATORTRIM], comparatorTrimReplace$1), debug$5("comparator trim", range2, re$7[t$6.COMPARATORTRIM]), range2 = (range2 = (range2 = range2.replace(re$7[t$6.TILDETRIM], tildeTrimReplace$1)).replace(re$7[t$6.CARETTRIM], caretTrimReplace$1)).split(/\s+/).join(" ");
            const compRe = loose ? re$7[t$6.COMPARATORLOOSE] : re$7[t$6.COMPARATOR], rangeList = range2.split(" ").map((comp) => parseComparator$1(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0$1(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$7(comp, this.options));
            rangeList.length;
            const rangeMap = /* @__PURE__ */ new Map();
            for (const comp of rangeList) {
              if (isNullSet$1(comp))
                return [comp];
              rangeMap.set(comp.value, comp);
            }
            rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
            const result = [...rangeMap.values()];
            return cache$1.set(memoKey, result), result;
          }
          intersects(range2, options) {
            if (!(range2 instanceof Range$l))
              throw new TypeError("a Range is required");
            return this.set.some((thisComparators) => isSatisfiable$1(thisComparators, options) && range2.set.some((rangeComparators) => isSatisfiable$1(rangeComparators, options) && thisComparators.every((thisComparator) => rangeComparators.every((rangeComparator) => thisComparator.intersects(rangeComparator, options)))));
          }
          test(version3) {
            if (!version3)
              return false;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer$k(version3, this.options);
              } catch (er) {
                return false;
              }
            for (let i = 0; i < this.set.length; i++)
              if (testSet$1(this.set[i], version3, this.options))
                return true;
            return false;
          }
        }
        var range$1 = Range$l;
        const cache$1 = new lruCache$1({ max: 1e3 }), parseOptions$6 = parseOptions_1$1, Comparator$7 = comparator$1, debug$5 = debug_1$1, SemVer$k = semver$5, { re: re$7, t: t$6, comparatorTrimReplace: comparatorTrimReplace$1, tildeTrimReplace: tildeTrimReplace$1, caretTrimReplace: caretTrimReplace$1 } = re$b.exports, isNullSet$1 = (c) => c.value === "<0.0.0-0", isAny$1 = (c) => c.value === "", isSatisfiable$1 = (comparators, options) => {
          let result = true;
          const remainingComparators = comparators.slice();
          let testComparator = remainingComparators.pop();
          for (; result && remainingComparators.length; )
            result = remainingComparators.every((otherComparator) => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
          return result;
        }, parseComparator$1 = (comp, options) => (debug$5("comp", comp, options), comp = replaceCarets$1(comp, options), debug$5("caret", comp), comp = replaceTildes$1(comp, options), debug$5("tildes", comp), comp = replaceXRanges$1(comp, options), debug$5("xrange", comp), comp = replaceStars$1(comp, options), debug$5("stars", comp), comp), isX$1 = (id) => !id || id.toLowerCase() === "x" || id === "*", replaceTildes$1 = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceTilde$1(comp2, options)).join(" "), replaceTilde$1 = (comp, options) => {
          const r = options.loose ? re$7[t$6.TILDELOOSE] : re$7[t$6.TILDE];
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug$5("tilde", comp, _, M, m, p, pr), isX$1(M) ? ret = "" : isX$1(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX$1(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug$5("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug$5("tilde return", ret), ret;
          });
        }, replaceCarets$1 = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceCaret$1(comp2, options)).join(" "), replaceCaret$1 = (comp, options) => {
          debug$5("caret", comp, options);
          const r = options.loose ? re$7[t$6.CARETLOOSE] : re$7[t$6.CARET], z = options.includePrerelease ? "-0" : "";
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug$5("caret", comp, _, M, m, p, pr), isX$1(M) ? ret = "" : isX$1(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX$1(p) ? ret = M === "0" ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug$5("replaceCaret pr", pr), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug$5("no pr"), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug$5("caret return", ret), ret;
          });
        }, replaceXRanges$1 = (comp, options) => (debug$5("replaceXRanges", comp, options), comp.split(/\s+/).map((comp2) => replaceXRange$1(comp2, options)).join(" ")), replaceXRange$1 = (comp, options) => {
          comp = comp.trim();
          const r = options.loose ? re$7[t$6.XRANGELOOSE] : re$7[t$6.XRANGE];
          return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
            debug$5("xRange", comp, ret, gtlt, M, m, p, pr);
            const xM = isX$1(M), xm = xM || isX$1(m), xp = xm || isX$1(p), anyX = xp;
            return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? ret = gtlt === ">" || gtlt === "<" ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug$5("xRange return", ret), ret;
          });
        }, replaceStars$1 = (comp, options) => (debug$5("replaceStars", comp, options), comp.trim().replace(re$7[t$6.STAR], "")), replaceGTE0$1 = (comp, options) => (debug$5("replaceGTE0", comp, options), comp.trim().replace(re$7[options.includePrerelease ? t$6.GTE0PRE : t$6.GTE0], "")), hyphenReplace$1 = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX$1(fM) ? "" : isX$1(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX$1(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX$1(tM) ? "" : isX$1(tm) ? `<${+tM + 1}.0.0-0` : isX$1(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet$1 = (set, version3, options) => {
          for (let i = 0; i < set.length; i++)
            if (!set[i].test(version3))
              return false;
          if (version3.prerelease.length && !options.includePrerelease) {
            for (let i = 0; i < set.length; i++)
              if (debug$5(set[i].semver), set[i].semver !== Comparator$7.ANY && set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch)
                  return true;
              }
            return false;
          }
          return true;
        }, ANY$5 = Symbol("SemVer ANY");
        class Comparator$6 {
          static get ANY() {
            return ANY$5;
          }
          constructor(comp, options) {
            if (options = parseOptions$5(options), comp instanceof Comparator$6) {
              if (comp.loose === !!options.loose)
                return comp;
              comp = comp.value;
            }
            debug$4("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY$5 ? this.value = "" : this.value = this.operator + this.semver.version, debug$4("comp", this);
          }
          parse(comp) {
            const r = this.options.loose ? re$6[t$5.COMPARATORLOOSE] : re$6[t$5.COMPARATOR], m = comp.match(r);
            if (!m)
              throw new TypeError(`Invalid comparator: ${comp}`);
            this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer$j(m[2], this.options.loose) : this.semver = ANY$5;
          }
          toString() {
            return this.value;
          }
          test(version3) {
            if (debug$4("Comparator.test", version3, this.options.loose), this.semver === ANY$5 || version3 === ANY$5)
              return true;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer$j(version3, this.options);
              } catch (er) {
                return false;
              }
            return cmp$2(version3, this.operator, this.semver, this.options);
          }
          intersects(comp, options) {
            if (!(comp instanceof Comparator$6))
              throw new TypeError("a Comparator is required");
            if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), this.operator === "")
              return this.value === "" || new Range$k(comp.value, options).test(this.value);
            if (comp.operator === "")
              return comp.value === "" || new Range$k(this.value, options).test(comp.semver);
            const sameDirectionIncreasing = !(this.operator !== ">=" && this.operator !== ">" || comp.operator !== ">=" && comp.operator !== ">"), sameDirectionDecreasing = !(this.operator !== "<=" && this.operator !== "<" || comp.operator !== "<=" && comp.operator !== "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(this.operator !== ">=" && this.operator !== "<=" || comp.operator !== ">=" && comp.operator !== "<="), oppositeDirectionsLessThan = cmp$2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp$2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
          }
        }
        var comparator$1 = Comparator$6;
        const parseOptions$5 = parseOptions_1$1, { re: re$6, t: t$5 } = re$b.exports, cmp$2 = cmp_1$1, debug$4 = debug_1$1, SemVer$j = semver$5, Range$k = range$1, Range$j = range$1;
        var satisfies_1$1 = (version3, range2, options) => {
          try {
            range2 = new Range$j(range2, options);
          } catch (er) {
            return false;
          }
          return range2.test(version3);
        };
        const Range$i = range$1;
        var toComparators_1$1 = (range2, options) => new Range$i(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
        const SemVer$i = semver$5, Range$h = range$1;
        var maxSatisfying_1$1 = (versions, range2, options) => {
          let max = null, maxSV = null, rangeObj = null;
          try {
            rangeObj = new Range$h(range2, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (max = v, maxSV = new SemVer$i(max, options)));
          }), max;
        };
        const SemVer$h = semver$5, Range$g = range$1;
        var minSatisfying_1$1 = (versions, range2, options) => {
          let min = null, minSV = null, rangeObj = null;
          try {
            rangeObj = new Range$g(range2, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (min && minSV.compare(v) !== 1 || (min = v, minSV = new SemVer$h(min, options)));
          }), min;
        };
        const SemVer$g = semver$5, Range$f = range$1, gt$5 = gt_1$1;
        var minVersion_1$1 = (range2, loose) => {
          range2 = new Range$f(range2, loose);
          let minver = new SemVer$g("0.0.0");
          if (range2.test(minver))
            return minver;
          if (minver = new SemVer$g("0.0.0-0"), range2.test(minver))
            return minver;
          minver = null;
          for (let i = 0; i < range2.set.length; ++i) {
            const comparators = range2.set[i];
            let setMin = null;
            comparators.forEach((comparator2) => {
              const compver = new SemVer$g(comparator2.semver.version);
              switch (comparator2.operator) {
                case ">":
                  compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  setMin && !gt$5(compver, setMin) || (setMin = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${comparator2.operator}`);
              }
            }), !setMin || minver && !gt$5(minver, setMin) || (minver = setMin);
          }
          return minver && range2.test(minver) ? minver : null;
        };
        const Range$e = range$1;
        var valid$2 = (range2, options) => {
          try {
            return new Range$e(range2, options).range || "*";
          } catch (er) {
            return null;
          }
        };
        const SemVer$f = semver$5, Comparator$5 = comparator$1, { ANY: ANY$4 } = Comparator$5, Range$d = range$1, satisfies$6 = satisfies_1$1, gt$4 = gt_1$1, lt$3 = lt_1$1, lte$3 = lte_1$1, gte$3 = gte_1$1;
        var outside_1$1 = (version3, range2, hilo, options) => {
          let gtfn, ltefn, ltfn, comp, ecomp;
          switch (version3 = new SemVer$f(version3, options), range2 = new Range$d(range2, options), hilo) {
            case ">":
              gtfn = gt$4, ltefn = lte$3, ltfn = lt$3, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt$3, ltefn = gte$3, ltfn = gt$4, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies$6(version3, range2, options))
            return false;
          for (let i = 0; i < range2.set.length; ++i) {
            const comparators = range2.set[i];
            let high = null, low = null;
            if (comparators.forEach((comparator2) => {
              comparator2.semver === ANY$4 && (comparator2 = new Comparator$5(">=0.0.0")), high = high || comparator2, low = low || comparator2, gtfn(comparator2.semver, high.semver, options) ? high = comparator2 : ltfn(comparator2.semver, low.semver, options) && (low = comparator2);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version3, low.semver))
              return false;
          }
          return true;
        };
        const outside$4 = outside_1$1;
        var gtr_1$1 = (version3, range2, options) => outside$4(version3, range2, ">", options);
        const outside$3 = outside_1$1;
        var ltr_1$1 = (version3, range2, options) => outside$3(version3, range2, "<", options);
        const Range$c = range$1;
        var intersects_1$1 = (r1, r2, options) => (r1 = new Range$c(r1, options), r2 = new Range$c(r2, options), r1.intersects(r2));
        const satisfies$5 = satisfies_1$1, compare$c = compare_1$1;
        const Range$b = range$1, Comparator$4 = comparator$1, { ANY: ANY$3 } = Comparator$4, satisfies$4 = satisfies_1$1, compare$b = compare_1$1, simpleSubset$1 = (sub, dom, options) => {
          if (sub === dom)
            return true;
          if (sub.length === 1 && sub[0].semver === ANY$3) {
            if (dom.length === 1 && dom[0].semver === ANY$3)
              return true;
            sub = options.includePrerelease ? [new Comparator$4(">=0.0.0-0")] : [new Comparator$4(">=0.0.0")];
          }
          if (dom.length === 1 && dom[0].semver === ANY$3) {
            if (options.includePrerelease)
              return true;
            dom = [new Comparator$4(">=0.0.0")];
          }
          const eqSet = /* @__PURE__ */ new Set();
          let gt2, lt2, gtltComp, higher, lower, hasDomLT, hasDomGT;
          for (const c of sub)
            c.operator === ">" || c.operator === ">=" ? gt2 = higherGT$1(gt2, c, options) : c.operator === "<" || c.operator === "<=" ? lt2 = lowerLT$1(lt2, c, options) : eqSet.add(c.semver);
          if (eqSet.size > 1)
            return null;
          if (gt2 && lt2) {
            if (gtltComp = compare$b(gt2.semver, lt2.semver, options), gtltComp > 0)
              return null;
            if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
              return null;
          }
          for (const eq2 of eqSet) {
            if (gt2 && !satisfies$4(eq2, String(gt2), options))
              return null;
            if (lt2 && !satisfies$4(eq2, String(lt2), options))
              return null;
            for (const c of dom)
              if (!satisfies$4(eq2, String(c), options))
                return false;
            return true;
          }
          let needDomLTPre = !(!lt2 || options.includePrerelease || !lt2.semver.prerelease.length) && lt2.semver, needDomGTPre = !(!gt2 || options.includePrerelease || !gt2.semver.prerelease.length) && gt2.semver;
          needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = false);
          for (const c of dom) {
            if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt2) {
              if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = false), c.operator === ">" || c.operator === ">=") {
                if (higher = higherGT$1(gt2, c, options), higher === c && higher !== gt2)
                  return false;
              } else if (gt2.operator === ">=" && !satisfies$4(gt2.semver, String(c), options))
                return false;
            }
            if (lt2) {
              if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = false), c.operator === "<" || c.operator === "<=") {
                if (lower = lowerLT$1(lt2, c, options), lower === c && lower !== lt2)
                  return false;
              } else if (lt2.operator === "<=" && !satisfies$4(lt2.semver, String(c), options))
                return false;
            }
            if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
              return false;
          }
          return !(gt2 && hasDomLT && !lt2 && gtltComp !== 0) && (!(lt2 && hasDomGT && !gt2 && gtltComp !== 0) && (!needDomGTPre && !needDomLTPre));
        }, higherGT$1 = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare$b(a.semver, b.semver, options);
          return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
        }, lowerLT$1 = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare$b(a.semver, b.semver, options);
          return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
        };
        var subset_1$1 = (sub, dom, options = {}) => {
          if (sub === dom)
            return true;
          sub = new Range$b(sub, options), dom = new Range$b(dom, options);
          let sawNonNull = false;
          OUTER:
            for (const simpleSub of sub.set) {
              for (const simpleDom of dom.set) {
                const isSub = simpleSubset$1(simpleSub, simpleDom, options);
                if (sawNonNull = sawNonNull || isSub !== null, isSub)
                  continue OUTER;
              }
              if (sawNonNull)
                return false;
            }
          return true;
        };
        const internalRe$1 = re$b.exports;
        var semver$4 = { re: internalRe$1.re, src: internalRe$1.src, tokens: internalRe$1.t, SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION, SemVer: semver$5, compareIdentifiers: identifiers$1.compareIdentifiers, rcompareIdentifiers: identifiers$1.rcompareIdentifiers, parse: parse_1$1, valid: valid_1$1, clean: clean_1$1, inc: inc_1$1, diff: diff_1$1, major: major_1$1, minor: minor_1$1, patch: patch_1$1, prerelease: prerelease_1$1, compare: compare_1$1, rcompare: rcompare_1$1, compareLoose: compareLoose_1$1, compareBuild: compareBuild_1$1, sort: sort_1$1, rsort: rsort_1$1, gt: gt_1$1, lt: lt_1$1, eq: eq_1$1, neq: neq_1$1, gte: gte_1$1, lte: lte_1$1, cmp: cmp_1$1, coerce: coerce_1$1, Comparator: comparator$1, Range: range$1, satisfies: satisfies_1$1, toComparators: toComparators_1$1, maxSatisfying: maxSatisfying_1$1, minSatisfying: minSatisfying_1$1, minVersion: minVersion_1$1, validRange: valid$2, outside: outside_1$1, gtr: gtr_1$1, ltr: ltr_1$1, intersects: intersects_1$1, simplifyRange: (versions, range2, options) => {
          const set = [];
          let min = null, prev = null;
          const v = versions.sort((a, b) => compare$c(a, b, options));
          for (const version3 of v) {
            satisfies$5(version3, range2, options) ? (prev = version3, min || (min = version3)) : (prev && set.push([min, prev]), prev = null, min = null);
          }
          min && set.push([min, null]);
          const ranges = [];
          for (const [min2, max] of set)
            min2 === max ? ranges.push(min2) : max || min2 !== v[0] ? max ? min2 === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min2} - ${max}`) : ranges.push(`>=${min2}`) : ranges.push("*");
          const simplified = ranges.join(" || "), original = typeof range2.raw == "string" ? range2.raw : String(range2);
          return simplified.length < original.length ? simplified : range2;
        }, subset: subset_1$1 }, semver$3 = semver$4;
        const packageJsonReader$1 = { read: function(jsonPath) {
          return find$1(external_path_.dirname(jsonPath));
        } };
        function find$1(dir) {
          try {
            return { string: external_fs_.readFileSync(external_path_.toNamespacedPath(external_path_.join(dir, "package.json")), "utf8") };
          } catch (error) {
            if (error.code === "ENOENT") {
              const parent = external_path_.dirname(dir);
              return dir !== parent ? find$1(parent) : { string: void 0 };
            }
            throw error;
          }
        }
        const isWindows$1 = process.platform === "win32", own$3 = {}.hasOwnProperty, codes$1 = {}, messages$1 = /* @__PURE__ */ new Map();
        let userStackTraceLimit$1;
        function createError$1(sym, value, def) {
          return messages$1.set(sym, value), function(Base, key) {
            return NodeError;
            function NodeError(...args) {
              const limit = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable$1() && (Error.stackTraceLimit = 0);
              const error = new Base();
              isErrorStackTraceLimitWritable$1() && (Error.stackTraceLimit = limit);
              const message = function(key2, args2, self2) {
                const message2 = messages$1.get(key2);
                if (typeof message2 == "function")
                  return external_assert_namespaceObject(message2.length <= args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${message2.length}).`), Reflect.apply(message2, self2, args2);
                const expectedLength = (message2.match(/%[dfijoOs]/g) || []).length;
                return external_assert_namespaceObject(expectedLength === args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), args2.length === 0 ? message2 : (args2.unshift(message2), Reflect.apply(external_util_.format, null, args2));
              }(key, args, error);
              return Object.defineProperty(error, "message", { value: message, enumerable: false, writable: true, configurable: true }), Object.defineProperty(error, "toString", { value() {
                return `${this.name} [${key}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true }), addCodeToName$1(error, Base.name, key), error.code = key, error;
            }
          }(def, sym);
        }
        codes$1.ERR_INVALID_MODULE_SPECIFIER = createError$1("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError), codes$1.ERR_INVALID_PACKAGE_CONFIG = createError$1("ERR_INVALID_PACKAGE_CONFIG", (path, base, message) => `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error), codes$1.ERR_INVALID_PACKAGE_TARGET = createError$1("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base) => {
          const relError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
          return key === "." ? (external_assert_namespaceObject(isImport === false), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }, Error), codes$1.ERR_MODULE_NOT_FOUND = createError$1("ERR_MODULE_NOT_FOUND", (path, base, type = "package") => `Cannot find ${type} '${path}' imported from ${base}`, Error), codes$1.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError$1("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError), codes$1.ERR_PACKAGE_PATH_NOT_EXPORTED = createError$1("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base) => subpath === "." ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`, Error), codes$1.ERR_UNSUPPORTED_DIR_IMPORT = createError$1("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), codes$1.ERR_UNKNOWN_FILE_EXTENSION = createError$1("ERR_UNKNOWN_FILE_EXTENSION", 'Unknown file extension "%s" for %s', TypeError), codes$1.ERR_INVALID_ARG_VALUE = createError$1("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
          let inspected = (0, external_util_.inspect)(value);
          inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`);
          return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
        }, TypeError), codes$1.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError$1("ERR_UNSUPPORTED_ESM_URL_SCHEME", (url) => {
          let message = "Only file and data URLs are supported by the default ESM loader";
          return isWindows$1 && url.protocol.length === 2 && (message += ". On Windows, absolute paths must be valid file:// URLs"), message += `. Received protocol '${url.protocol}'`, message;
        }, Error);
        const addCodeToName$1 = hideStackFrames$1(function(error, name, code) {
          (error = captureLargerStackTrace$1(error)).name = `${name} [${code}]`, error.stack, name === "SystemError" ? Object.defineProperty(error, "name", { value: name, enumerable: false, writable: true, configurable: true }) : delete error.name;
        });
        function isErrorStackTraceLimitWritable$1() {
          const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return desc === void 0 ? Object.isExtensible(Error) : own$3.call(desc, "writable") ? desc.writable : desc.set !== void 0;
        }
        function hideStackFrames$1(fn) {
          const hidden = "__node_internal_" + fn.name;
          return Object.defineProperty(fn, "name", { value: hidden }), fn;
        }
        const captureLargerStackTrace$1 = hideStackFrames$1(function(error) {
          const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable$1();
          return stackTraceLimitIsWritable && (userStackTraceLimit$1 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit$1), error;
        });
        const { ERR_UNKNOWN_FILE_EXTENSION: ERR_UNKNOWN_FILE_EXTENSION$1 } = codes$1, extensionFormatMap$1 = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".mjs": "module" };
        function defaultGetFormat$1(url) {
          if (url.startsWith("node:"))
            return { format: "builtin" };
          const parsed = new external_url_namespaceObject.URL(url);
          if (parsed.protocol === "data:") {
            const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null];
            return { format: mime === "text/javascript" ? "module" : null };
          }
          if (parsed.protocol === "file:") {
            const ext = external_path_.extname(parsed.pathname);
            let format;
            if (format = ext === ".js" ? function(url2) {
              return getPackageScopeConfig$1(url2).type;
            }(parsed.href) === "module" ? "module" : "commonjs" : extensionFormatMap$1[ext], !format)
              throw new ERR_UNKNOWN_FILE_EXTENSION$1(ext, (0, external_url_namespaceObject.fileURLToPath)(url));
            return { format: format || null };
          }
          return { format: null };
        }
        !function({ version: version3 = process.version, experimental = false } = {}) {
          var coreModules = ["assert", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "module", "net", "os", "path", "punycode", "querystring", "readline", "repl", "stream", "string_decoder", "sys", "timers", "tls", "tty", "url", "util", "vm", "zlib"];
          semver$3.lt(version3, "6.0.0") && coreModules.push("freelist"), semver$3.gte(version3, "1.0.0") && coreModules.push("v8"), semver$3.gte(version3, "1.1.0") && coreModules.push("process"), semver$3.gte(version3, "8.0.0") && coreModules.push("inspector"), semver$3.gte(version3, "8.1.0") && coreModules.push("async_hooks"), semver$3.gte(version3, "8.4.0") && coreModules.push("http2"), semver$3.gte(version3, "8.5.0") && coreModules.push("perf_hooks"), semver$3.gte(version3, "10.0.0") && coreModules.push("trace_events"), semver$3.gte(version3, "10.5.0") && (experimental || semver$3.gte(version3, "12.0.0")) && coreModules.push("worker_threads"), semver$3.gte(version3, "12.16.0") && experimental && coreModules.push("wasi");
        }();
        const { ERR_INVALID_MODULE_SPECIFIER: ERR_INVALID_MODULE_SPECIFIER$1, ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1, ERR_INVALID_PACKAGE_TARGET: ERR_INVALID_PACKAGE_TARGET$1, ERR_MODULE_NOT_FOUND: ERR_MODULE_NOT_FOUND$1, ERR_PACKAGE_IMPORT_NOT_DEFINED: ERR_PACKAGE_IMPORT_NOT_DEFINED$1, ERR_PACKAGE_PATH_NOT_EXPORTED: ERR_PACKAGE_PATH_NOT_EXPORTED$1, ERR_UNSUPPORTED_DIR_IMPORT: ERR_UNSUPPORTED_DIR_IMPORT$1, ERR_UNSUPPORTED_ESM_URL_SCHEME: ERR_UNSUPPORTED_ESM_URL_SCHEME$1, ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE$1 } = codes$1, own$2 = {}.hasOwnProperty;
        Object.freeze(["node", "import"]);
        const invalidSegmentRegEx$1 = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/, patternRegEx$1 = /\*/g, encodedSepRegEx$1 = /%2f|%2c/i, emittedPackageWarnings$1 = /* @__PURE__ */ new Set(), packageJsonCache$1 = /* @__PURE__ */ new Map();
        function emitFolderMapDeprecation$1(match, pjsonUrl, isExports, base) {
          const pjsonPath = (0, external_url_namespaceObject.fileURLToPath)(pjsonUrl);
          emittedPackageWarnings$1.has(pjsonPath + "|" + match) || (emittedPackageWarnings$1.add(pjsonPath + "|" + match), process.emitWarning(`Use of deprecated folder mapping "${match}" in the ${isExports ? '"exports"' : '"imports"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, external_url_namespaceObject.fileURLToPath)(base)}` : ""}.
Update this package.json to use a subpath pattern like "${match}*".`, "DeprecationWarning", "DEP0148"));
        }
        function emitLegacyIndexDeprecation$1(url, packageJsonUrl, base, main) {
          const { format } = defaultGetFormat$1(url.href);
          if (format !== "module")
            return;
          const path = (0, external_url_namespaceObject.fileURLToPath)(url.href), pkgPath = (0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".", packageJsonUrl)), basePath = (0, external_url_namespaceObject.fileURLToPath)(base);
          main ? process.emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path.slice(pkgPath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : process.emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(pkgPath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync$1(path) {
          try {
            return (0, external_fs_.statSync)(path);
          } catch {
            return new external_fs_.Stats();
          }
        }
        function getPackageConfig$1(path, specifier, base) {
          const existing = packageJsonCache$1.get(path);
          if (existing !== void 0)
            return existing;
          const source = packageJsonReader$1.read(path).string;
          if (source === void 0) {
            const packageConfig2 = { pjsonPath: path, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return packageJsonCache$1.set(path, packageConfig2), packageConfig2;
          }
          let packageJson;
          try {
            packageJson = JSON.parse(source);
          } catch (error) {
            throw new ERR_INVALID_PACKAGE_CONFIG$1(path, (base ? `"${specifier}" from ` : "") + (0, external_url_namespaceObject.fileURLToPath)(base || specifier), error.message);
          }
          const { exports: exports2, imports, main, name, type } = packageJson, packageConfig = { pjsonPath: path, exists: true, main: typeof main == "string" ? main : void 0, name: typeof name == "string" ? name : void 0, type: type === "module" || type === "commonjs" ? type : "none", exports: exports2, imports: imports && typeof imports == "object" ? imports : void 0 };
          return packageJsonCache$1.set(path, packageConfig), packageConfig;
        }
        function getPackageScopeConfig$1(resolved) {
          let packageJsonUrl = new external_url_namespaceObject.URL("./package.json", resolved);
          for (; ; ) {
            if (packageJsonUrl.pathname.endsWith("node_modules/package.json"))
              break;
            const packageConfig2 = getPackageConfig$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl), resolved);
            if (packageConfig2.exists)
              return packageConfig2;
            const lastPackageJsonUrl = packageJsonUrl;
            if (packageJsonUrl = new external_url_namespaceObject.URL("../package.json", packageJsonUrl), packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
              break;
          }
          const packageJsonPath = (0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl), packageConfig = { pjsonPath: packageJsonPath, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return packageJsonCache$1.set(packageJsonPath, packageConfig), packageConfig;
        }
        function fileExists$1(url) {
          return tryStatSync$1((0, external_url_namespaceObject.fileURLToPath)(url)).isFile();
        }
        function legacyMainResolve$1(packageJsonUrl, packageConfig, base) {
          let guess;
          if (packageConfig.main !== void 0) {
            if (guess = new external_url_namespaceObject.URL(`./${packageConfig.main}`, packageJsonUrl), fileExists$1(guess))
              return guess;
            const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
            let i2 = -1;
            for (; ++i2 < tries2.length && (guess = new external_url_namespaceObject.URL(tries2[i2], packageJsonUrl), !fileExists$1(guess)); )
              guess = void 0;
            if (guess)
              return emitLegacyIndexDeprecation$1(guess, packageJsonUrl, base, packageConfig.main), guess;
          }
          const tries = ["./index.js", "./index.json", "./index.node"];
          let i = -1;
          for (; ++i < tries.length && (guess = new external_url_namespaceObject.URL(tries[i], packageJsonUrl), !fileExists$1(guess)); )
            guess = void 0;
          if (guess)
            return emitLegacyIndexDeprecation$1(guess, packageJsonUrl, base, packageConfig.main), guess;
          throw new ERR_MODULE_NOT_FOUND$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".", packageJsonUrl)), (0, external_url_namespaceObject.fileURLToPath)(base));
        }
        function throwExportsNotFound$1(subpath, packageJsonUrl, base) {
          throw new ERR_PACKAGE_PATH_NOT_EXPORTED$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".", packageJsonUrl)), subpath, base && (0, external_url_namespaceObject.fileURLToPath)(base));
        }
        function throwInvalidPackageTarget$1(subpath, target, packageJsonUrl, internal, base) {
          throw target = typeof target == "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET$1((0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".", packageJsonUrl)), subpath, target, internal, base && (0, external_url_namespaceObject.fileURLToPath)(base));
        }
        function resolvePackageTargetString$1(target, subpath, match, packageJsonUrl, base, pattern, internal, conditions) {
          if (subpath === "" || pattern || target[target.length - 1] === "/" || throwInvalidPackageTarget$1(match, target, packageJsonUrl, internal, base), !target.startsWith("./")) {
            if (internal && !target.startsWith("../") && !target.startsWith("/")) {
              let isURL = false;
              try {
                new external_url_namespaceObject.URL(target), isURL = true;
              } catch {
              }
              if (!isURL) {
                return packageResolve$1(pattern ? target.replace(patternRegEx$1, subpath) : target + subpath, packageJsonUrl, conditions);
              }
            }
            throwInvalidPackageTarget$1(match, target, packageJsonUrl, internal, base);
          }
          invalidSegmentRegEx$1.test(target.slice(2)) && throwInvalidPackageTarget$1(match, target, packageJsonUrl, internal, base);
          const resolved = new external_url_namespaceObject.URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new external_url_namespaceObject.URL(".", packageJsonUrl).pathname;
          return resolvedPath.startsWith(packagePath) || throwInvalidPackageTarget$1(match, target, packageJsonUrl, internal, base), subpath === "" ? resolved : (invalidSegmentRegEx$1.test(subpath) && function(subpath2, packageJsonUrl2, internal2, base2) {
            const reason = `request is not a valid subpath for the "${internal2 ? "imports" : "exports"}" resolution of ${(0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl2)}`;
            throw new ERR_INVALID_MODULE_SPECIFIER$1(subpath2, reason, base2 && (0, external_url_namespaceObject.fileURLToPath)(base2));
          }(match + subpath, packageJsonUrl, internal, base), pattern ? new external_url_namespaceObject.URL(resolved.href.replace(patternRegEx$1, subpath)) : new external_url_namespaceObject.URL(subpath, resolved));
        }
        function isArrayIndex$1(key) {
          const keyNumber = Number(key);
          return `${keyNumber}` === key && (keyNumber >= 0 && keyNumber < 4294967295);
        }
        function resolvePackageTarget$1(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
          if (typeof target == "string")
            return resolvePackageTargetString$1(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, conditions);
          if (Array.isArray(target)) {
            const targetList = target;
            if (targetList.length === 0)
              return null;
            let lastException, i = -1;
            for (; ++i < targetList.length; ) {
              const targetItem = targetList[i];
              let resolved;
              try {
                resolved = resolvePackageTarget$1(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);
              } catch (error) {
                if (lastException = error, error.code === "ERR_INVALID_PACKAGE_TARGET")
                  continue;
                throw error;
              }
              if (resolved !== void 0) {
                if (resolved !== null)
                  return resolved;
                lastException = null;
              }
            }
            if (lastException == null)
              return lastException;
            throw lastException;
          }
          if (typeof target != "object" || target === null) {
            if (target === null)
              return null;
            throwInvalidPackageTarget$1(packageSubpath, target, packageJsonUrl, internal, base);
          } else {
            const keys = Object.getOwnPropertyNames(target);
            let i = -1;
            for (; ++i < keys.length; ) {
              if (isArrayIndex$1(keys[i]))
                throw new ERR_INVALID_PACKAGE_CONFIG$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
            }
            for (i = -1; ++i < keys.length; ) {
              const key = keys[i];
              if (key === "default" || conditions && conditions.has(key)) {
                const resolved = resolvePackageTarget$1(packageJsonUrl, target[key], subpath, packageSubpath, base, pattern, internal, conditions);
                if (resolved === void 0)
                  continue;
                return resolved;
              }
            }
          }
        }
        function packageExportsResolve$1(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
          let exports2 = packageConfig.exports;
          if (function(exports3, packageJsonUrl2, base2) {
            if (typeof exports3 == "string" || Array.isArray(exports3))
              return true;
            if (typeof exports3 != "object" || exports3 === null)
              return false;
            const keys2 = Object.getOwnPropertyNames(exports3);
            let isConditionalSugar = false, i2 = 0, j = -1;
            for (; ++j < keys2.length; ) {
              const key = keys2[j], curIsConditionalSugar = key === "" || key[0] !== ".";
              if (i2++ == 0)
                isConditionalSugar = curIsConditionalSugar;
              else if (isConditionalSugar !== curIsConditionalSugar)
                throw new ERR_INVALID_PACKAGE_CONFIG$1((0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl2), base2, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return isConditionalSugar;
          }(exports2, packageJsonUrl, base) && (exports2 = { ".": exports2 }), own$2.call(exports2, packageSubpath)) {
            const resolved = resolvePackageTarget$1(packageJsonUrl, exports2[packageSubpath], "", packageSubpath, base, false, false, conditions);
            return resolved == null && throwExportsNotFound$1(packageSubpath, packageJsonUrl, base), { resolved, exact: true };
          }
          let bestMatch = "";
          const keys = Object.getOwnPropertyNames(exports2);
          let i = -1;
          for (; ++i < keys.length; ) {
            const key = keys[i];
            (key[key.length - 1] === "*" && packageSubpath.startsWith(key.slice(0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length || key[key.length - 1] === "/" && packageSubpath.startsWith(key) && key.length > bestMatch.length) && (bestMatch = key);
          }
          if (bestMatch) {
            const target = exports2[bestMatch], pattern = bestMatch[bestMatch.length - 1] === "*", resolved = resolvePackageTarget$1(packageJsonUrl, target, packageSubpath.slice(bestMatch.length - (pattern ? 1 : 0)), bestMatch, base, pattern, false, conditions);
            return resolved == null && throwExportsNotFound$1(packageSubpath, packageJsonUrl, base), pattern || emitFolderMapDeprecation$1(bestMatch, packageJsonUrl, true, base), { resolved, exact: pattern };
          }
          throwExportsNotFound$1(packageSubpath, packageJsonUrl, base);
        }
        function packageImportsResolve$1(name, base, conditions) {
          if (name === "#" || name.startsWith("#/")) {
            throw new ERR_INVALID_MODULE_SPECIFIER$1(name, "is not a valid internal imports specifier name", (0, external_url_namespaceObject.fileURLToPath)(base));
          }
          let packageJsonUrl;
          const packageConfig = getPackageScopeConfig$1(base);
          if (packageConfig.exists) {
            packageJsonUrl = (0, external_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);
            const imports = packageConfig.imports;
            if (imports)
              if (own$2.call(imports, name)) {
                const resolved = resolvePackageTarget$1(packageJsonUrl, imports[name], "", name, base, false, true, conditions);
                if (resolved !== null)
                  return { resolved, exact: true };
              } else {
                let bestMatch = "";
                const keys = Object.getOwnPropertyNames(imports);
                let i = -1;
                for (; ++i < keys.length; ) {
                  const key = keys[i];
                  (key[key.length - 1] === "*" && name.startsWith(key.slice(0, -1)) && name.length >= key.length && key.length > bestMatch.length || key[key.length - 1] === "/" && name.startsWith(key) && key.length > bestMatch.length) && (bestMatch = key);
                }
                if (bestMatch) {
                  const target = imports[bestMatch], pattern = bestMatch[bestMatch.length - 1] === "*", resolved = resolvePackageTarget$1(packageJsonUrl, target, name.slice(bestMatch.length - (pattern ? 1 : 0)), bestMatch, base, pattern, true, conditions);
                  if (resolved !== null)
                    return pattern || emitFolderMapDeprecation$1(bestMatch, packageJsonUrl, false, base), { resolved, exact: pattern };
                }
              }
          }
          !function(specifier, packageJsonUrl2, base2) {
            throw new ERR_PACKAGE_IMPORT_NOT_DEFINED$1(specifier, packageJsonUrl2 && (0, external_url_namespaceObject.fileURLToPath)(new external_url_namespaceObject.URL(".", packageJsonUrl2)), (0, external_url_namespaceObject.fileURLToPath)(base2));
          }(name, packageJsonUrl, base);
        }
        function packageResolve$1(specifier, base, conditions) {
          const { packageName, packageSubpath, isScoped } = function(specifier2, base2) {
            let separatorIndex = specifier2.indexOf("/"), validPackageName = true, isScoped2 = false;
            specifier2[0] === "@" && (isScoped2 = true, separatorIndex === -1 || specifier2.length === 0 ? validPackageName = false : separatorIndex = specifier2.indexOf("/", separatorIndex + 1));
            const packageName2 = separatorIndex === -1 ? specifier2 : specifier2.slice(0, separatorIndex);
            let i = -1;
            for (; ++i < packageName2.length; )
              if (packageName2[i] === "%" || packageName2[i] === "\\") {
                validPackageName = false;
                break;
              }
            if (!validPackageName)
              throw new ERR_INVALID_MODULE_SPECIFIER$1(specifier2, "is not a valid package name", (0, external_url_namespaceObject.fileURLToPath)(base2));
            return { packageName: packageName2, packageSubpath: "." + (separatorIndex === -1 ? "" : specifier2.slice(separatorIndex)), isScoped: isScoped2 };
          }(specifier, base), packageConfig = getPackageScopeConfig$1(base);
          if (packageConfig.exists) {
            const packageJsonUrl2 = (0, external_url_namespaceObject.pathToFileURL)(packageConfig.pjsonPath);
            if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
              return packageExportsResolve$1(packageJsonUrl2, packageSubpath, packageConfig, base, conditions).resolved;
          }
          let lastPath, packageJsonUrl = new external_url_namespaceObject.URL("./node_modules/" + packageName + "/package.json", base), packageJsonPath = (0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl);
          do {
            if (!tryStatSync$1(packageJsonPath.slice(0, -13)).isDirectory()) {
              lastPath = packageJsonPath, packageJsonUrl = new external_url_namespaceObject.URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl), packageJsonPath = (0, external_url_namespaceObject.fileURLToPath)(packageJsonUrl);
              continue;
            }
            const packageConfig2 = getPackageConfig$1(packageJsonPath, specifier, base);
            return packageConfig2.exports !== void 0 && packageConfig2.exports !== null ? packageExportsResolve$1(packageJsonUrl, packageSubpath, packageConfig2, base, conditions).resolved : packageSubpath === "." ? legacyMainResolve$1(packageJsonUrl, packageConfig2, base) : new external_url_namespaceObject.URL(packageSubpath, packageJsonUrl);
          } while (packageJsonPath.length !== lastPath.length);
          throw new ERR_MODULE_NOT_FOUND$1(packageName, (0, external_url_namespaceObject.fileURLToPath)(base));
        }
        function moduleResolve$1(specifier, base, conditions) {
          let resolved;
          if (function(specifier2) {
            return specifier2 !== "" && (specifier2[0] === "/" || function(specifier3) {
              if (specifier3[0] === ".") {
                if (specifier3.length === 1 || specifier3[1] === "/")
                  return true;
                if (specifier3[1] === "." && (specifier3.length === 2 || specifier3[2] === "/"))
                  return true;
              }
              return false;
            }(specifier2));
          }(specifier))
            resolved = new external_url_namespaceObject.URL(specifier, base);
          else if (specifier[0] === "#")
            ({ resolved } = packageImportsResolve$1(specifier, base, conditions));
          else
            try {
              resolved = new external_url_namespaceObject.URL(specifier);
            } catch {
              resolved = packageResolve$1(specifier, base, conditions);
            }
          return function(resolved2, base2) {
            if (encodedSepRegEx$1.test(resolved2.pathname))
              throw new ERR_INVALID_MODULE_SPECIFIER$1(resolved2.pathname, 'must not include encoded "/" or "\\" characters', (0, external_url_namespaceObject.fileURLToPath)(base2));
            const path = (0, external_url_namespaceObject.fileURLToPath)(resolved2), stats = tryStatSync$1(path.endsWith("/") ? path.slice(-1) : path);
            if (stats.isDirectory()) {
              const error = new ERR_UNSUPPORTED_DIR_IMPORT$1(path, (0, external_url_namespaceObject.fileURLToPath)(base2));
              throw error.url = String(resolved2), error;
            }
            if (!stats.isFile())
              throw new ERR_MODULE_NOT_FOUND$1(path || resolved2.pathname, base2 && (0, external_url_namespaceObject.fileURLToPath)(base2), "module");
            return resolved2;
          }(resolved, base);
        }
        const DEFAULT_CONDITIONS_SET$1 = /* @__PURE__ */ new Set(["node", "import"]), DEFAULT_URL$1 = (0, external_url_namespaceObject.pathToFileURL)(process.cwd()), DEFAULT_EXTENSIONS$1 = [".mjs", ".cjs", ".js", ".json"], NOT_FOUND_ERRORS$1 = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND"]);
        function _tryModuleResolve$1(id, url, conditions) {
          try {
            return moduleResolve$1(id, url, conditions);
          } catch (err) {
            if (!NOT_FOUND_ERRORS$1.has(err.code))
              throw err;
            return null;
          }
        }
        function _resolve$1(id, opts2 = {}) {
          if (/(node|data|http|https):/.test(id))
            return id;
          if (BUILTIN_MODULES$1.has(id))
            return "node:" + id;
          if (isAbsolute$1(id) && (0, external_fs_.existsSync)(id)) {
            const realPath2 = (0, external_fs_.realpathSync)(fileURLToPath$1(id));
            return (0, external_url_namespaceObject.pathToFileURL)(realPath2).toString();
          }
          const conditionsSet = opts2.conditions ? new Set(opts2.conditions) : DEFAULT_CONDITIONS_SET$1, _urls = (Array.isArray(opts2.url) ? opts2.url : [opts2.url]).filter(Boolean).map((u) => new URL(function(id2) {
            return typeof id2 != "string" && (id2 = id2.toString()), /(node|data|http|https|file):/.test(id2) ? id2 : BUILTIN_MODULES$1.has(id2) ? "node:" + id2 : "file://" + normalizeSlash$1(id2);
          }(u.toString())));
          _urls.length || _urls.push(DEFAULT_URL$1);
          const urls = [..._urls];
          for (const url of _urls)
            if (url.protocol === "file:" && !url.pathname.includes("node_modules")) {
              const newURL = new URL(url);
              newURL.pathname += "/node_modules", urls.push(newURL);
            }
          let resolved;
          for (const url of urls) {
            if (resolved = _tryModuleResolve$1(id, url, conditionsSet), resolved)
              break;
            for (const prefix of ["", "/index"]) {
              for (const ext of opts2.extensions || DEFAULT_EXTENSIONS$1)
                if (resolved = _tryModuleResolve$1(id + prefix + ext, url, conditionsSet), resolved)
                  break;
              if (resolved)
                break;
            }
          }
          if (!resolved) {
            const err = new Error(`Cannot find module ${id} imported from ${urls.join(", ")}`);
            throw err.code = "ERR_MODULE_NOT_FOUND", err;
          }
          const realPath = (0, external_fs_.realpathSync)(fileURLToPath$1(resolved));
          return (0, external_url_namespaceObject.pathToFileURL)(realPath).toString();
        }
        function resolveSync$1(id, opts2) {
          return _resolve$1(id, opts2);
        }
        function resolvePathSync$1(id, opts2) {
          return fileURLToPath$1(resolveSync$1(id, opts2));
        }
        var ParseOptions;
        !function(ParseOptions2) {
          ParseOptions2.DEFAULT = { allowTrailingComma: false };
        }(ParseOptions || (ParseOptions = {}));
        new Set(external_module_.builtinModules);
        var re$5 = { exports: {} };
        var constants2 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 };
        var debug_1 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        };
        !function(module3, exports2) {
          const { MAX_SAFE_COMPONENT_LENGTH } = constants2, debug2 = debug_1, re2 = (exports2 = module3.exports = {}).re = [], src = exports2.src = [], t2 = exports2.t = {};
          let R = 0;
          const createToken = (name, value, isGlobal) => {
            const index = R++;
            debug2(index, value), t2[name] = index, src[index] = value, re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
          };
          createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`), createToken("FULL", `^${src[t2.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`), createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t2.COERCE], true), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true), exports2.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true), exports2.caretTrimReplace = "$1^", createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true), exports2.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        }(re$5, re$5.exports);
        const opts = ["includePrerelease", "loose", "rtl"];
        var parseOptions_1 = (options) => options ? typeof options != "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => (options2[k] = true, options2), {}) : {};
        const numeric = /^[0-9]+$/, compareIdentifiers$1 = (a, b) => {
          const anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        var identifiers = { compareIdentifiers: compareIdentifiers$1, rcompareIdentifiers: (a, b) => compareIdentifiers$1(b, a) };
        const debug$2 = debug_1, { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants2, { re: re$4, t: t$4 } = re$5.exports, parseOptions$3 = parseOptions_1, { compareIdentifiers } = identifiers;
        class SemVer$e {
          constructor(version3, options) {
            if (options = parseOptions$3(options), version3 instanceof SemVer$e) {
              if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease)
                return version3;
              version3 = version3.version;
            } else if (typeof version3 != "string")
              throw new TypeError(`Invalid Version: ${version3}`);
            if (version3.length > MAX_LENGTH$1)
              throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
            debug$2("SemVer", version3, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
            const m = version3.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
            if (!m)
              throw new TypeError(`Invalid Version: ${version3}`);
            if (this.raw = version3, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m[4] ? this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug$2("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer$e)) {
              if (typeof other == "string" && other === this.version)
                return 0;
              other = new SemVer$e(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof SemVer$e || (other = new SemVer$e(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
          }
          comparePre(other) {
            if (other instanceof SemVer$e || (other = new SemVer$e(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              const a = this.prerelease[i], b = other.prerelease[i];
              if (debug$2("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof SemVer$e || (other = new SemVer$e(other, this.options));
            let i = 0;
            do {
              const a = this.build[i], b = other.build[i];
              if (debug$2("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          inc(release, identifier) {
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                  i === -1 && this.prerelease.push(0);
                }
                identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        var semver$2 = SemVer$e;
        const { MAX_LENGTH } = constants2, { re: re$3, t: t$3 } = re$5.exports, SemVer$d = semver$2, parseOptions$2 = parseOptions_1;
        var parse_1 = (version3, options) => {
          if (options = parseOptions$2(options), version3 instanceof SemVer$d)
            return version3;
          if (typeof version3 != "string")
            return null;
          if (version3.length > MAX_LENGTH)
            return null;
          if (!(options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL]).test(version3))
            return null;
          try {
            return new SemVer$d(version3, options);
          } catch (er) {
            return null;
          }
        };
        const parse$4 = parse_1;
        var valid_1 = (version3, options) => {
          const v = parse$4(version3, options);
          return v ? v.version : null;
        };
        const parse$3 = parse_1;
        var clean_1 = (version3, options) => {
          const s = parse$3(version3.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        };
        const SemVer$c = semver$2;
        var inc_1 = (version3, release, options, identifier) => {
          typeof options == "string" && (identifier = options, options = void 0);
          try {
            return new SemVer$c(version3, options).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        };
        const SemVer$b = semver$2;
        var compare_1 = (a, b, loose) => new SemVer$b(a, loose).compare(new SemVer$b(b, loose));
        const compare$9 = compare_1;
        var eq_1 = (a, b, loose) => compare$9(a, b, loose) === 0;
        const parse$2 = parse_1, eq$1 = eq_1;
        var diff_1 = (version1, version22) => {
          if (eq$1(version1, version22))
            return null;
          {
            const v1 = parse$2(version1), v2 = parse$2(version22), hasPre = v1.prerelease.length || v2.prerelease.length, prefix = hasPre ? "pre" : "", defaultResult = hasPre ? "prerelease" : "";
            for (const key in v1)
              if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
                return prefix + key;
            return defaultResult;
          }
        };
        const SemVer$a = semver$2;
        var major_1 = (a, loose) => new SemVer$a(a, loose).major;
        const SemVer$9 = semver$2;
        var minor_1 = (a, loose) => new SemVer$9(a, loose).minor;
        const SemVer$8 = semver$2;
        var patch_1 = (a, loose) => new SemVer$8(a, loose).patch;
        const parse$1 = parse_1;
        var prerelease_1 = (version3, options) => {
          const parsed = parse$1(version3, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
        const compare$8 = compare_1;
        var rcompare_1 = (a, b, loose) => compare$8(b, a, loose);
        const compare$7 = compare_1;
        var compareLoose_1 = (a, b) => compare$7(a, b, true);
        const SemVer$7 = semver$2;
        var compareBuild_1 = (a, b, loose) => {
          const versionA = new SemVer$7(a, loose), versionB = new SemVer$7(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
        const compareBuild$1 = compareBuild_1;
        var sort_1 = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
        const compareBuild = compareBuild_1;
        var rsort_1 = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
        const compare$6 = compare_1;
        var gt_1 = (a, b, loose) => compare$6(a, b, loose) > 0;
        const compare$5 = compare_1;
        var lt_1 = (a, b, loose) => compare$5(a, b, loose) < 0;
        const compare$4 = compare_1;
        var neq_1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
        const compare$3 = compare_1;
        var gte_1 = (a, b, loose) => compare$3(a, b, loose) >= 0;
        const compare$2 = compare_1;
        var lte_1 = (a, b, loose) => compare$2(a, b, loose) <= 0;
        const eq = eq_1, neq = neq_1, gt$2 = gt_1, gte$1 = gte_1, lt$1 = lt_1, lte$1 = lte_1;
        var cmp_1 = (a, op, b, loose) => {
          switch (op) {
            case "===":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
            case "!==":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt$2(a, b, loose);
            case ">=":
              return gte$1(a, b, loose);
            case "<":
              return lt$1(a, b, loose);
            case "<=":
              return lte$1(a, b, loose);
            default:
              throw new TypeError(`Invalid operator: ${op}`);
          }
        };
        const SemVer$6 = semver$2, parse2 = parse_1, { re: re$2, t: t$2 } = re$5.exports;
        var coerce_1 = (version3, options) => {
          if (version3 instanceof SemVer$6)
            return version3;
          if (typeof version3 == "number" && (version3 = String(version3)), typeof version3 != "string")
            return null;
          let match = null;
          if ((options = options || {}).rtl) {
            let next;
            for (; (next = re$2[t$2.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re$2[t$2.COERCERTL].lastIndex = -1;
          } else
            match = version3.match(re$2[t$2.COERCE]);
          return match === null ? null : parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
        }, yallist = Yallist$1;
        function Yallist$1(list) {
          var self2 = this;
          if (self2 instanceof Yallist$1 || (self2 = new Yallist$1()), self2.tail = null, self2.head = null, self2.length = 0, list && typeof list.forEach == "function")
            list.forEach(function(item) {
              self2.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self2.push(arguments[i]);
          return self2;
        }
        function insert(self2, node, value) {
          var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
          return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
        }
        function push(self2, item) {
          self2.tail = new Node2(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
        }
        function unshift(self2, item) {
          self2.head = new Node2(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
        }
        function Node2(value, prev, next, list) {
          if (!(this instanceof Node2))
            return new Node2(value, prev, next, list);
          this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
        Yallist$1.Node = Node2, Yallist$1.create = Yallist$1, Yallist$1.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
        }, Yallist$1.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist$1.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist$1.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push(this, arguments[i]);
          return this.length;
        }, Yallist$1.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift(this, arguments[i]);
          return this.length;
        }, Yallist$1.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist$1.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist$1.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist$1.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist$1.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++)
            walker = walker.next;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist$1.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
            walker = walker.prev;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist$1.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist$1(), walker = this.head; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist$1.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist$1(), walker = this.tail; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist$1.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.head.next, acc = this.head.value;
          }
          for (var i = 0; walker !== null; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist$1.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.tail.prev, acc = this.tail.value;
          }
          for (var i = this.length - 1; walker !== null; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist$1.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist$1.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist$1.prototype.slice = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist$1();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; walker !== null && i < from; i++)
            walker = walker.next;
          for (; walker !== null && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist$1.prototype.sliceReverse = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist$1();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
            walker = walker.prev;
          for (; walker !== null && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
          start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
          for (var i = 0, walker = this.head; walker !== null && i < start; i++)
            walker = walker.next;
          var ret = [];
          for (i = 0; walker && i < deleteCount; i++)
            ret.push(walker.value), walker = this.removeNode(walker);
          walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
          for (i = 0; i < nodes.length; i++)
            walker = insert(this, walker, nodes[i]);
          return ret;
        }, Yallist$1.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        try {
          require("./iterator.js")(Yallist$1);
        } catch (er) {
        }
        const Yallist = yallist, MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
        const get = (self2, key, doUse) => {
          const node = self2[CACHE].get(key);
          if (node) {
            const hit = node.value;
            if (isStale(self2, hit)) {
              if (del(self2, node), !self2[ALLOW_STALE])
                return;
            } else
              doUse && (self2[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self2[LRU_LIST].unshiftNode(node));
            return hit.value;
          }
        }, isStale = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE])
            return false;
          const diff = Date.now() - hit.now;
          return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
        }, trim = (self2) => {
          if (self2[LENGTH] > self2[MAX])
            for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
              const prev = walker.prev;
              del(self2, walker), walker = prev;
            }
        }, del = (self2, node) => {
          if (node) {
            const hit = node.value;
            self2[DISPOSE] && self2[DISPOSE](hit.key, hit.value), self2[LENGTH] -= hit.length, self2[CACHE].delete(hit.key), self2[LRU_LIST].removeNode(node);
          }
        };
        class Entry {
          constructor(key, value, length, now, maxAge) {
            this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
          }
        }
        const forEachStep = (self2, fn, node, thisp) => {
          let hit = node.value;
          isStale(self2, hit) && (del(self2, node), self2[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
        };
        var lruCache = class {
          constructor(options) {
            if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX] = options.max || 1 / 0;
            const lc = options.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || false, options.maxAge && typeof options.maxAge != "number")
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false, this.reset();
          }
          set max(mL) {
            if (typeof mL != "number" || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX] = mL || 1 / 0, trim(this);
          }
          get max() {
            return this[MAX];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE];
          }
          set maxAge(mA) {
            if (typeof mA != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA, trim(this);
          }
          get maxAge() {
            return this[MAX_AGE];
          }
          set lengthCalculator(lC) {
            typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
            })), trim(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR];
          }
          get length() {
            return this[LENGTH];
          }
          get itemCount() {
            return this[LRU_LIST].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].tail; walker !== null; ) {
              const prev = walker.prev;
              forEachStep(this, fn, walker, thisp), walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].head; walker !== null; ) {
              const next = walker.next;
              forEachStep(this, fn, walker, thisp), walker = next;
            }
          }
          keys() {
            return this[LRU_LIST].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST].toArray().map((k) => k.value);
          }
          reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
          }
          dump() {
            return this[LRU_LIST].map((hit) => !isStale(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST];
          }
          set(key, value, maxAge) {
            if ((maxAge = maxAge || this[MAX_AGE]) && typeof maxAge != "number")
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX])
                return del(this, this[CACHE].get(key)), false;
              const item = this[CACHE].get(key).value;
              return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), true;
            }
            const hit = new Entry(key, value, len, now, maxAge);
            return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), false) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), true);
          }
          has(key) {
            if (!this[CACHE].has(key))
              return false;
            const hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
          get(key) {
            return get(this, key, true);
          }
          peek(key) {
            return get(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST].tail;
            return node ? (del(this, node), node.value) : null;
          }
          del(key) {
            del(this, this[CACHE].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l], expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
          prune() {
            this[CACHE].forEach((value, key) => get(this, key, false));
          }
        };
        class Range$a {
          constructor(range2, options) {
            if (options = parseOptions$1(options), range2 instanceof Range$a)
              return range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease ? range2 : new Range$a(range2.raw, options);
            if (range2 instanceof Comparator$3)
              return this.raw = range2.value, this.set = [[range2]], this.format(), this;
            if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range2, this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${range2}`);
            if (this.set.length > 1) {
              const first = this.set[0];
              if (this.set = this.set.filter((c) => !isNullSet(c[0])), this.set.length === 0)
                this.set = [first];
              else if (this.set.length > 1) {
                for (const c of this.set)
                  if (c.length === 1 && isAny(c[0])) {
                    this.set = [c];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(range2) {
            range2 = range2.trim();
            const memoKey = `parseRange:${Object.keys(this.options).join(",")}:${range2}`, cached = cache.get(memoKey);
            if (cached)
              return cached;
            const loose = this.options.loose, hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
            range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease)), debug$1("hyphen replace", range2), range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace), debug$1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]), range2 = (range2 = (range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace)).replace(re$1[t$1.CARETTRIM], caretTrimReplace)).split(/\s+/).join(" ");
            const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR], rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$3(comp, this.options));
            rangeList.length;
            const rangeMap = /* @__PURE__ */ new Map();
            for (const comp of rangeList) {
              if (isNullSet(comp))
                return [comp];
              rangeMap.set(comp.value, comp);
            }
            rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
            const result = [...rangeMap.values()];
            return cache.set(memoKey, result), result;
          }
          intersects(range2, options) {
            if (!(range2 instanceof Range$a))
              throw new TypeError("a Range is required");
            return this.set.some((thisComparators) => isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => rangeComparators.every((rangeComparator) => thisComparator.intersects(rangeComparator, options)))));
          }
          test(version3) {
            if (!version3)
              return false;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer$5(version3, this.options);
              } catch (er) {
                return false;
              }
            for (let i = 0; i < this.set.length; i++)
              if (testSet(this.set[i], version3, this.options))
                return true;
            return false;
          }
        }
        var range = Range$a;
        const cache = new lruCache({ max: 1e3 }), parseOptions$1 = parseOptions_1, Comparator$3 = comparator, debug$1 = debug_1, SemVer$5 = semver$2, { re: re$1, t: t$1, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = re$5.exports, isNullSet = (c) => c.value === "<0.0.0-0", isAny = (c) => c.value === "", isSatisfiable = (comparators, options) => {
          let result = true;
          const remainingComparators = comparators.slice();
          let testComparator = remainingComparators.pop();
          for (; result && remainingComparators.length; )
            result = remainingComparators.every((otherComparator) => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
          return result;
        }, parseComparator = (comp, options) => (debug$1("comp", comp, options), comp = replaceCarets(comp, options), debug$1("caret", comp), comp = replaceTildes(comp, options), debug$1("tildes", comp), comp = replaceXRanges(comp, options), debug$1("xrange", comp), comp = replaceStars(comp, options), debug$1("stars", comp), comp), isX = (id) => !id || id.toLowerCase() === "x" || id === "*", replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceTilde(comp2, options)).join(" "), replaceTilde = (comp, options) => {
          const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug$1("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug$1("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug$1("tilde return", ret), ret;
          });
        }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceCaret(comp2, options)).join(" "), replaceCaret = (comp, options) => {
          debug$1("caret", comp, options);
          const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET], z = options.includePrerelease ? "-0" : "";
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug$1("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = M === "0" ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug$1("replaceCaret pr", pr), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug$1("no pr"), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug$1("caret return", ret), ret;
          });
        }, replaceXRanges = (comp, options) => (debug$1("replaceXRanges", comp, options), comp.split(/\s+/).map((comp2) => replaceXRange(comp2, options)).join(" ")), replaceXRange = (comp, options) => {
          comp = comp.trim();
          const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
          return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
            debug$1("xRange", comp, ret, gtlt, M, m, p, pr);
            const xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
            return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? ret = gtlt === ">" || gtlt === "<" ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug$1("xRange return", ret), ret;
          });
        }, replaceStars = (comp, options) => (debug$1("replaceStars", comp, options), comp.trim().replace(re$1[t$1.STAR], "")), replaceGTE0 = (comp, options) => (debug$1("replaceGTE0", comp, options), comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "")), hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version3, options) => {
          for (let i = 0; i < set.length; i++)
            if (!set[i].test(version3))
              return false;
          if (version3.prerelease.length && !options.includePrerelease) {
            for (let i = 0; i < set.length; i++)
              if (debug$1(set[i].semver), set[i].semver !== Comparator$3.ANY && set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch)
                  return true;
              }
            return false;
          }
          return true;
        }, ANY$2 = Symbol("SemVer ANY");
        class Comparator$2 {
          static get ANY() {
            return ANY$2;
          }
          constructor(comp, options) {
            if (options = parseOptions(options), comp instanceof Comparator$2) {
              if (comp.loose === !!options.loose)
                return comp;
              comp = comp.value;
            }
            debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY$2 ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
          }
          parse(comp) {
            const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
            if (!m)
              throw new TypeError(`Invalid comparator: ${comp}`);
            this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer$4(m[2], this.options.loose) : this.semver = ANY$2;
          }
          toString() {
            return this.value;
          }
          test(version3) {
            if (debug("Comparator.test", version3, this.options.loose), this.semver === ANY$2 || version3 === ANY$2)
              return true;
            if (typeof version3 == "string")
              try {
                version3 = new SemVer$4(version3, this.options);
              } catch (er) {
                return false;
              }
            return cmp(version3, this.operator, this.semver, this.options);
          }
          intersects(comp, options) {
            if (!(comp instanceof Comparator$2))
              throw new TypeError("a Comparator is required");
            if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), this.operator === "")
              return this.value === "" || new Range$9(comp.value, options).test(this.value);
            if (comp.operator === "")
              return comp.value === "" || new Range$9(this.value, options).test(comp.semver);
            const sameDirectionIncreasing = !(this.operator !== ">=" && this.operator !== ">" || comp.operator !== ">=" && comp.operator !== ">"), sameDirectionDecreasing = !(this.operator !== "<=" && this.operator !== "<" || comp.operator !== "<=" && comp.operator !== "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(this.operator !== ">=" && this.operator !== "<=" || comp.operator !== ">=" && comp.operator !== "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
          }
        }
        var comparator = Comparator$2;
        const parseOptions = parseOptions_1, { re, t } = re$5.exports, cmp = cmp_1, debug = debug_1, SemVer$4 = semver$2, Range$9 = range, Range$8 = range;
        var satisfies_1 = (version3, range2, options) => {
          try {
            range2 = new Range$8(range2, options);
          } catch (er) {
            return false;
          }
          return range2.test(version3);
        };
        const Range$7 = range;
        var toComparators_1 = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
        const SemVer$3 = semver$2, Range$6 = range;
        var maxSatisfying_1 = (versions, range2, options) => {
          let max = null, maxSV = null, rangeObj = null;
          try {
            rangeObj = new Range$6(range2, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (max = v, maxSV = new SemVer$3(max, options)));
          }), max;
        };
        const SemVer$2 = semver$2, Range$5 = range;
        var minSatisfying_1 = (versions, range2, options) => {
          let min = null, minSV = null, rangeObj = null;
          try {
            rangeObj = new Range$5(range2, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (min && minSV.compare(v) !== 1 || (min = v, minSV = new SemVer$2(min, options)));
          }), min;
        };
        const SemVer$1 = semver$2, Range$4 = range, gt$1 = gt_1;
        var minVersion_1 = (range2, loose) => {
          range2 = new Range$4(range2, loose);
          let minver = new SemVer$1("0.0.0");
          if (range2.test(minver))
            return minver;
          if (minver = new SemVer$1("0.0.0-0"), range2.test(minver))
            return minver;
          minver = null;
          for (let i = 0; i < range2.set.length; ++i) {
            const comparators = range2.set[i];
            let setMin = null;
            comparators.forEach((comparator2) => {
              const compver = new SemVer$1(comparator2.semver.version);
              switch (comparator2.operator) {
                case ">":
                  compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  setMin && !gt$1(compver, setMin) || (setMin = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${comparator2.operator}`);
              }
            }), !setMin || minver && !gt$1(minver, setMin) || (minver = setMin);
          }
          return minver && range2.test(minver) ? minver : null;
        };
        const Range$3 = range;
        var valid = (range2, options) => {
          try {
            return new Range$3(range2, options).range || "*";
          } catch (er) {
            return null;
          }
        };
        const SemVer = semver$2, Comparator$1 = comparator, { ANY: ANY$1 } = Comparator$1, Range$2 = range, satisfies$2 = satisfies_1, gt = gt_1, lt = lt_1, lte = lte_1, gte = gte_1;
        var outside_1 = (version3, range2, hilo, options) => {
          let gtfn, ltefn, ltfn, comp, ecomp;
          switch (version3 = new SemVer(version3, options), range2 = new Range$2(range2, options), hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies$2(version3, range2, options))
            return false;
          for (let i = 0; i < range2.set.length; ++i) {
            const comparators = range2.set[i];
            let high = null, low = null;
            if (comparators.forEach((comparator2) => {
              comparator2.semver === ANY$1 && (comparator2 = new Comparator$1(">=0.0.0")), high = high || comparator2, low = low || comparator2, gtfn(comparator2.semver, high.semver, options) ? high = comparator2 : ltfn(comparator2.semver, low.semver, options) && (low = comparator2);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version3, low.semver))
              return false;
          }
          return true;
        };
        const outside$1 = outside_1;
        var gtr_1 = (version3, range2, options) => outside$1(version3, range2, ">", options);
        const outside = outside_1;
        var ltr_1 = (version3, range2, options) => outside(version3, range2, "<", options);
        const Range$1 = range;
        var intersects_1 = (r1, r2, options) => (r1 = new Range$1(r1, options), r2 = new Range$1(r2, options), r1.intersects(r2));
        const satisfies$1 = satisfies_1, compare$1 = compare_1;
        const Range3 = range, Comparator = comparator, { ANY } = Comparator, satisfies = satisfies_1, compare = compare_1, simpleSubset = (sub, dom, options) => {
          if (sub === dom)
            return true;
          if (sub.length === 1 && sub[0].semver === ANY) {
            if (dom.length === 1 && dom[0].semver === ANY)
              return true;
            sub = options.includePrerelease ? [new Comparator(">=0.0.0-0")] : [new Comparator(">=0.0.0")];
          }
          if (dom.length === 1 && dom[0].semver === ANY) {
            if (options.includePrerelease)
              return true;
            dom = [new Comparator(">=0.0.0")];
          }
          const eqSet = /* @__PURE__ */ new Set();
          let gt2, lt2, gtltComp, higher, lower, hasDomLT, hasDomGT;
          for (const c of sub)
            c.operator === ">" || c.operator === ">=" ? gt2 = higherGT(gt2, c, options) : c.operator === "<" || c.operator === "<=" ? lt2 = lowerLT(lt2, c, options) : eqSet.add(c.semver);
          if (eqSet.size > 1)
            return null;
          if (gt2 && lt2) {
            if (gtltComp = compare(gt2.semver, lt2.semver, options), gtltComp > 0)
              return null;
            if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
              return null;
          }
          for (const eq2 of eqSet) {
            if (gt2 && !satisfies(eq2, String(gt2), options))
              return null;
            if (lt2 && !satisfies(eq2, String(lt2), options))
              return null;
            for (const c of dom)
              if (!satisfies(eq2, String(c), options))
                return false;
            return true;
          }
          let needDomLTPre = !(!lt2 || options.includePrerelease || !lt2.semver.prerelease.length) && lt2.semver, needDomGTPre = !(!gt2 || options.includePrerelease || !gt2.semver.prerelease.length) && gt2.semver;
          needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = false);
          for (const c of dom) {
            if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt2) {
              if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = false), c.operator === ">" || c.operator === ">=") {
                if (higher = higherGT(gt2, c, options), higher === c && higher !== gt2)
                  return false;
              } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
                return false;
            }
            if (lt2) {
              if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = false), c.operator === "<" || c.operator === "<=") {
                if (lower = lowerLT(lt2, c, options), lower === c && lower !== lt2)
                  return false;
              } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
                return false;
            }
            if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
              return false;
          }
          return !(gt2 && hasDomLT && !lt2 && gtltComp !== 0) && (!(lt2 && hasDomGT && !gt2 && gtltComp !== 0) && (!needDomGTPre && !needDomLTPre));
        }, higherGT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
        }, lowerLT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare(a.semver, b.semver, options);
          return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
        };
        var subset_1 = (sub, dom, options = {}) => {
          if (sub === dom)
            return true;
          sub = new Range3(sub, options), dom = new Range3(dom, options);
          let sawNonNull = false;
          OUTER:
            for (const simpleSub of sub.set) {
              for (const simpleDom of dom.set) {
                const isSub = simpleSubset(simpleSub, simpleDom, options);
                if (sawNonNull = sawNonNull || isSub !== null, isSub)
                  continue OUTER;
              }
              if (sawNonNull)
                return false;
            }
          return true;
        };
        const internalRe = re$5.exports;
        var semver$1 = { re: internalRe.re, src: internalRe.src, tokens: internalRe.t, SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION, SemVer: semver$2, compareIdentifiers: identifiers.compareIdentifiers, rcompareIdentifiers: identifiers.rcompareIdentifiers, parse: parse_1, valid: valid_1, clean: clean_1, inc: inc_1, diff: diff_1, major: major_1, minor: minor_1, patch: patch_1, prerelease: prerelease_1, compare: compare_1, rcompare: rcompare_1, compareLoose: compareLoose_1, compareBuild: compareBuild_1, sort: sort_1, rsort: rsort_1, gt: gt_1, lt: lt_1, eq: eq_1, neq: neq_1, gte: gte_1, lte: lte_1, cmp: cmp_1, coerce: coerce_1, Comparator: comparator, Range: range, satisfies: satisfies_1, toComparators: toComparators_1, maxSatisfying: maxSatisfying_1, minSatisfying: minSatisfying_1, minVersion: minVersion_1, validRange: valid, outside: outside_1, gtr: gtr_1, ltr: ltr_1, intersects: intersects_1, simplifyRange: (versions, range2, options) => {
          const set = [];
          let min = null, prev = null;
          const v = versions.sort((a, b) => compare$1(a, b, options));
          for (const version3 of v) {
            satisfies$1(version3, range2, options) ? (prev = version3, min || (min = version3)) : (prev && set.push([min, prev]), prev = null, min = null);
          }
          min && set.push([min, null]);
          const ranges = [];
          for (const [min2, max] of set)
            min2 === max ? ranges.push(min2) : max || min2 !== v[0] ? max ? min2 === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min2} - ${max}`) : ranges.push(`>=${min2}`) : ranges.push("*");
          const simplified = ranges.join(" || "), original = typeof range2.raw == "string" ? range2.raw : String(range2);
          return simplified.length < original.length ? simplified : range2;
        }, subset: subset_1 }, dist_semver = semver$1;
        const isWindows = process.platform === "win32", own$1 = {}.hasOwnProperty, codes = {}, messages = /* @__PURE__ */ new Map();
        let userStackTraceLimit;
        function createError(sym, value, def) {
          return messages.set(sym, value), function(Base, key) {
            return NodeError;
            function NodeError(...args) {
              const limit = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
              const error = new Base();
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = limit);
              const message = function(key2, args2, self2) {
                const message2 = messages.get(key2);
                if (typeof message2 == "function")
                  return external_assert_namespaceObject(message2.length <= args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${message2.length}).`), Reflect.apply(message2, self2, args2);
                const expectedLength = (message2.match(/%[dfijoOs]/g) || []).length;
                return external_assert_namespaceObject(expectedLength === args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), args2.length === 0 ? message2 : (args2.unshift(message2), Reflect.apply(external_util_.format, null, args2));
              }(key, args, error);
              return Object.defineProperty(error, "message", { value: message, enumerable: false, writable: true, configurable: true }), Object.defineProperty(error, "toString", { value() {
                return `${this.name} [${key}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true }), addCodeToName(error, Base.name, key), error.code = key, error;
            }
          }(def, sym);
        }
        codes.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError), codes.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (path, base, message) => `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error), codes.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base) => {
          const relError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
          return key === "." ? (external_assert_namespaceObject(isImport === false), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }, Error), codes.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (path, base, type = "package") => `Cannot find ${type} '${path}' imported from ${base}`, Error), codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError), codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base) => subpath === "." ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`, Error), codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), codes.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", 'Unknown file extension "%s" for %s', TypeError), codes.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
          let inspected = (0, external_util_.inspect)(value);
          inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`);
          return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
        }, TypeError), codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError("ERR_UNSUPPORTED_ESM_URL_SCHEME", (url) => {
          let message = "Only file and data URLs are supported by the default ESM loader";
          return isWindows && url.protocol.length === 2 && (message += ". On Windows, absolute paths must be valid file:// URLs"), message += `. Received protocol '${url.protocol}'`, message;
        }, Error);
        const addCodeToName = hideStackFrames(function(error, name, code) {
          (error = captureLargerStackTrace(error)).name = `${name} [${code}]`, error.stack, name === "SystemError" ? Object.defineProperty(error, "name", { value: name, enumerable: false, writable: true, configurable: true }) : delete error.name;
        });
        function isErrorStackTraceLimitWritable() {
          const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return desc === void 0 ? Object.isExtensible(Error) : own$1.call(desc, "writable") ? desc.writable : desc.set !== void 0;
        }
        function hideStackFrames(fn) {
          const hidden = "__node_internal_" + fn.name;
          return Object.defineProperty(fn, "name", { value: hidden }), fn;
        }
        const captureLargerStackTrace = hideStackFrames(function(error) {
          const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
          return stackTraceLimitIsWritable && (userStackTraceLimit = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit), error;
        });
        const { ERR_UNKNOWN_FILE_EXTENSION } = codes;
        !function({ version: version3 = process.version, experimental = false } = {}) {
          var coreModules = ["assert", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "module", "net", "os", "path", "punycode", "querystring", "readline", "repl", "stream", "string_decoder", "sys", "timers", "tls", "tty", "url", "util", "vm", "zlib"];
          dist_semver.lt(version3, "6.0.0") && coreModules.push("freelist"), dist_semver.gte(version3, "1.0.0") && coreModules.push("v8"), dist_semver.gte(version3, "1.1.0") && coreModules.push("process"), dist_semver.gte(version3, "8.0.0") && coreModules.push("inspector"), dist_semver.gte(version3, "8.1.0") && coreModules.push("async_hooks"), dist_semver.gte(version3, "8.4.0") && coreModules.push("http2"), dist_semver.gte(version3, "8.5.0") && coreModules.push("perf_hooks"), dist_semver.gte(version3, "10.0.0") && coreModules.push("trace_events"), dist_semver.gte(version3, "10.5.0") && (experimental || dist_semver.gte(version3, "12.0.0")) && coreModules.push("worker_threads"), dist_semver.gte(version3, "12.16.0") && experimental && coreModules.push("wasi");
        }();
        const { ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_ESM_URL_SCHEME, ERR_INVALID_ARG_VALUE } = codes;
        Object.freeze(["node", "import"]);
        /* @__PURE__ */ new Set(), /* @__PURE__ */ new Map();
        /* @__PURE__ */ new Set(["node", "import"]), (0, external_url_namespaceObject.pathToFileURL)(process.cwd()), /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND"]);
        const ESM_RE = /([\s;]|^)(import[\w,{}\s*]*from|import\s*['"*{]|export\b\s*(?:[*{]|default|type|function|const|var|let|async function)|import\.meta\b)/m;
        /* @__PURE__ */ new Set([".mjs", ".cjs", ".node", ".wasm"]);
        function hasESMSyntax(code) {
          return ESM_RE.test(code);
        }
        var external_crypto_ = __webpack_require__("crypto");
        function md5(content, len = 8) {
          return (0, external_crypto_.createHash)("md5").update(content).digest("hex").slice(0, len);
        }
        const _EnvDebug = dist(process.env.JITI_DEBUG), _EnvCache = dist(process.env.JITI_CACHE), _EnvESMReolve = dist(process.env.JITI_ESM_RESOLVE), _EnvRequireCache = dist(process.env.JITI_REQUIRE_CACHE), _EnvSourceMaps = dist(process.env.JITI_SOURCE_MAPS), jiti_isWindows = (0, external_os_namespaceObject.platform)() === "win32", defaults = { debug: _EnvDebug, cache: _EnvCache === void 0 || !!_EnvCache, requireCache: _EnvRequireCache === void 0 || !!_EnvRequireCache, sourceMaps: _EnvSourceMaps !== void 0 && !!_EnvSourceMaps, interopDefault: false, esmResolve: _EnvESMReolve || false, cacheVersion: "6", legacy: (0, semver.lt)(process.version || "0.0.0", "14.0.0"), extensions: [".js", ".mjs", ".cjs", ".ts"] };
        function createJITI(_filename, opts2 = {}, parentModule) {
          function debug2(...args) {
            opts2.debug && console.log("[jiti]", ...args);
          }
          if ((opts2 = Object.assign(Object.assign({}, defaults), opts2)).legacy && (opts2.cacheVersion += "-legacy"), opts2.transformOptions && (opts2.cacheVersion += "-" + object_hash_default()(opts2.transformOptions)), _filename || (_filename = process.cwd()), function(filename) {
            try {
              return (0, external_fs_.lstatSync)(filename).isDirectory();
            } catch (e2) {
              return false;
            }
          }(_filename) && (_filename = (0, external_path_.join)(_filename, "index.js")), opts2.cache === true && (opts2.cache = (0, external_path_.join)((0, external_os_namespaceObject.tmpdir)(), "node-jiti")), opts2.cache)
            try {
              if ((0, mkdirp.sync)(opts2.cache), !function(filename) {
                try {
                  return (0, external_fs_.accessSync)(filename, external_fs_.constants.W_OK), true;
                } catch (e2) {
                  return false;
                }
              }(opts2.cache))
                throw new Error("directory is not writable");
            } catch (err) {
              debug2("Error creating cache directory at ", opts2.cache, err), opts2.cache = false;
            }
          const nativeRequire = create_require_default()(jiti_isWindows ? _filename.replace(/\//g, "\\") : _filename), tryResolve = (id, options) => {
            try {
              return nativeRequire.resolve(id, options);
            } catch (e2) {
            }
          }, _url = (0, external_url_namespaceObject.pathToFileURL)(_filename), _additionalExts = [...opts2.extensions].filter((ext) => ext !== ".js"), _resolve = (id, options) => {
            let resolved, err;
            if (opts2.esmResolve) {
              try {
                resolved = resolvePathSync$1(id, { url: _url, conditions: ["node", "require", "import"] });
              } catch (_err) {
                err = _err;
              }
              if (resolved)
                return resolved;
            }
            if (opts2.extensions.includes((0, external_path_.extname)(id)))
              return nativeRequire.resolve(id, options);
            try {
              return nativeRequire.resolve(id, options);
            } catch (_err) {
              err = _err;
            }
            for (const ext of _additionalExts)
              if (resolved = tryResolve(id + ext, options) || tryResolve(id + "/index" + ext, options), resolved)
                return resolved;
            throw err;
          };
          function transform(topts) {
            let code = function(filename, source, get2) {
              if (!opts2.cache || !filename)
                return get2();
              const sourceHash = ` /* v${opts2.cacheVersion}-${md5(source, 16)} */`, filebase = (0, external_path_.basename)((0, external_path_.dirname)(filename)) + "-" + (0, external_path_.basename)(filename), cacheFile = (0, external_path_.join)(opts2.cache, filebase + "." + md5(filename) + ".js");
              if ((0, external_fs_.existsSync)(cacheFile)) {
                const cacheSource = (0, external_fs_.readFileSync)(cacheFile, "utf-8");
                if (cacheSource.endsWith(sourceHash))
                  return debug2("[cache hit]", filename, "~>", cacheFile), cacheSource;
              }
              debug2("[cache miss]", filename);
              const result = get2();
              return result.includes("__JITI_ERROR__") || (0, external_fs_.writeFileSync)(cacheFile, result + sourceHash, "utf-8"), result;
            }(topts.filename, topts.source, () => {
              var _a;
              const res = opts2.transform(Object.assign(Object.assign(Object.assign({ legacy: opts2.legacy }, opts2.transformOptions), { babel: Object.assign(Object.assign({}, opts2.sourceMaps ? { sourceFileName: topts.filename, sourceMaps: "inline" } : {}), (_a = opts2.transformOptions) === null || _a === void 0 ? void 0 : _a.babel) }), topts));
              return res.error && opts2.debug && debug2(res.error), res.code;
            });
            return code.startsWith("#!") && (code = "// " + code), code;
          }
          function _interopDefault(mod) {
            return opts2.interopDefault ? function(sourceModule) {
              if ((val = sourceModule) === null || typeof val != "object" || !("default" in sourceModule))
                return sourceModule;
              var val;
              const newModule = sourceModule.default;
              for (const key in sourceModule)
                if (key === "default")
                  try {
                    key in newModule || Object.defineProperty(newModule, key, { enumerable: false, configurable: false, get: () => newModule });
                  } catch (_err) {
                  }
                else
                  try {
                    key in newModule || Object.defineProperty(newModule, key, { enumerable: true, configurable: true, get: () => sourceModule[key] });
                  } catch (_err) {
                  }
              return newModule;
            }(mod) : mod;
          }
          function jiti2(id) {
            var _a;
            if (id.startsWith("node:") ? id = id.substr(5) : id.startsWith("file:") && (id = (0, external_url_namespaceObject.fileURLToPath)(id)), external_module_.builtinModules.includes(id) || id === ".pnp.js")
              return nativeRequire(id);
            const filename = _resolve(id), ext = (0, external_path_.extname)(filename);
            if (ext && !opts2.extensions.includes(ext))
              return debug2("[unknown]", filename), nativeRequire(id);
            if (opts2.requireCache && nativeRequire.cache[filename])
              return _interopDefault((_a = nativeRequire.cache[filename]) === null || _a === void 0 ? void 0 : _a.exports);
            let source = (0, external_fs_.readFileSync)(filename, "utf-8");
            const isTypescript = ext === ".ts";
            if (!(ext === ".cjs") && (isTypescript || ext === ".mjs" || hasESMSyntax(source) || opts2.legacy && source.match(/\?\.|\?\?/) || filename.includes("node_modules/config/")))
              debug2("[transpile]", filename), source = transform({ filename, source, ts: isTypescript });
            else
              try {
                return debug2("[native]", filename), _interopDefault(nativeRequire(id));
              } catch (err) {
                debug2("Native require error:", err), debug2("[fallback]", filename), source = transform({ filename, source, ts: isTypescript });
              }
            const mod = new external_module_.Module(filename);
            let compiled;
            mod.filename = filename, parentModule && (mod.parent = parentModule, Array.isArray(parentModule.children) && !parentModule.children.includes(mod) && parentModule.children.push(mod)), mod.require = createJITI(filename, opts2, mod), mod.path = (0, external_path_.dirname)(filename), mod.paths = external_module_.Module._nodeModulePaths(mod.path), opts2.requireCache && (nativeRequire.cache[filename] = mod);
            try {
              compiled = external_vm_default().runInThisContext(external_module_.Module.wrap(source), { filename, lineOffset: 0, displayErrors: false });
            } catch (err) {
              opts2.requireCache && delete nativeRequire.cache[filename], opts2.onError(err);
            }
            try {
              compiled(mod.exports, mod.require, mod, mod.filename, (0, external_path_.dirname)(mod.filename));
            } catch (err) {
              opts2.requireCache && delete nativeRequire.cache[filename], opts2.onError(err);
            }
            if (mod.exports && mod.exports.__JITI_ERROR__) {
              const { filename: filename2, line, column, code, message } = mod.exports.__JITI_ERROR__, err = new Error(`${code}: ${message} 
 ${`${filename2}:${line}:${column}`}`);
              Error.captureStackTrace(err, jiti2), opts2.onError(err);
            }
            mod.loaded = true;
            return _interopDefault(mod.exports);
          }
          return _resolve.paths = nativeRequire.resolve.paths, jiti2.resolve = _resolve, jiti2.cache = opts2.requireCache ? nativeRequire.cache : {}, jiti2.extensions = nativeRequire.extensions, jiti2.main = nativeRequire.main, jiti2.transform = transform, jiti2.register = function() {
            return (0, lib.addHook)((source, filename) => jiti2.transform({ source, filename, ts: !!filename.match(/.ts$/) }), { exts: opts2.extensions });
          }, jiti2;
        }
      })(), module2.exports = __webpack_exports__.default;
    })();
  }
});

// ../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/dist/babel.js
var require_babel = __commonJS({
  "../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/dist/babel.js"(exports, module2) {
    (() => {
      var __webpack_modules__ = { "./node_modules/@babel/core/lib/config/cache-contexts.js": () => {
      }, "./node_modules/@babel/core/lib/config/caching.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.assertSimpleType = assertSimpleType, exports2.makeStrongCache = makeStrongCache, exports2.makeStrongCacheSync = function(handler) {
          return synchronize(makeStrongCache(handler));
        }, exports2.makeWeakCache = makeWeakCache, exports2.makeWeakCacheSync = function(handler) {
          return synchronize(makeWeakCache(handler));
        };
        var _async = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/async.js"), _util = __webpack_require__2("./node_modules/@babel/core/lib/config/util.js");
        const synchronize = (gen) => _gensync()(gen).sync;
        function* genTrue() {
          return true;
        }
        function makeWeakCache(handler) {
          return makeCachedFunction(WeakMap, handler);
        }
        function makeStrongCache(handler) {
          return makeCachedFunction(Map, handler);
        }
        function makeCachedFunction(CallCache, handler) {
          const callCacheSync = new CallCache(), callCacheAsync = new CallCache(), futureCache = new CallCache();
          return function* (arg, data) {
            const asyncContext = yield* (0, _async.isAsync)(), callCache = asyncContext ? callCacheAsync : callCacheSync, cached = yield* function* (asyncContext2, callCache2, futureCache2, arg2, data2) {
              const cached2 = yield* getCachedValue(callCache2, arg2, data2);
              if (cached2.valid)
                return cached2;
              if (asyncContext2) {
                const cached3 = yield* getCachedValue(futureCache2, arg2, data2);
                if (cached3.valid) {
                  return { valid: true, value: yield* (0, _async.waitFor)(cached3.value.promise) };
                }
              }
              return { valid: false, value: null };
            }(asyncContext, callCache, futureCache, arg, data);
            if (cached.valid)
              return cached.value;
            const cache = new CacheConfigurator(data), handlerResult = handler(arg, cache);
            let finishLock, value;
            if ((0, _util.isIterableIterator)(handlerResult)) {
              const gen = handlerResult;
              value = yield* (0, _async.onFirstPause)(gen, () => {
                finishLock = function(config, futureCache2, arg2) {
                  const finishLock2 = new Lock();
                  return updateFunctionCache(futureCache2, config, arg2, finishLock2), finishLock2;
                }(cache, futureCache, arg);
              });
            } else
              value = handlerResult;
            return updateFunctionCache(callCache, cache, arg, value), finishLock && (futureCache.delete(arg), finishLock.release(value)), value;
          };
        }
        function* getCachedValue(cache, arg, data) {
          const cachedValue = cache.get(arg);
          if (cachedValue) {
            for (const { value, valid } of cachedValue)
              if (yield* valid(data))
                return { valid: true, value };
          }
          return { valid: false, value: null };
        }
        function updateFunctionCache(cache, config, arg, value) {
          config.configured() || config.forever();
          let cachedValue = cache.get(arg);
          switch (config.deactivate(), config.mode()) {
            case "forever":
              cachedValue = [{ value, valid: genTrue }], cache.set(arg, cachedValue);
              break;
            case "invalidate":
              cachedValue = [{ value, valid: config.validator() }], cache.set(arg, cachedValue);
              break;
            case "valid":
              cachedValue ? cachedValue.push({ value, valid: config.validator() }) : (cachedValue = [{ value, valid: config.validator() }], cache.set(arg, cachedValue));
          }
        }
        class CacheConfigurator {
          constructor(data) {
            this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = data;
          }
          simple() {
            return function(cache) {
              function cacheFn(val) {
                if (typeof val != "boolean")
                  return cache.using(() => assertSimpleType(val()));
                val ? cache.forever() : cache.never();
              }
              return cacheFn.forever = () => cache.forever(), cacheFn.never = () => cache.never(), cacheFn.using = (cb) => cache.using(() => assertSimpleType(cb())), cacheFn.invalidate = (cb) => cache.invalidate(() => assertSimpleType(cb())), cacheFn;
            }(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never)
              throw new Error("Caching has already been configured with .never()");
            this._forever = true, this._configured = true;
          }
          never() {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever)
              throw new Error("Caching has already been configured with .forever()");
            this._never = true, this._configured = true;
          }
          using(handler) {
            if (!this._active)
              throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever)
              throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = true;
            const key = handler(this._data), fn = (0, _async.maybeAsync)(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, _async.isThenable)(key) ? key.then((key2) => (this._pairs.push([key2, fn]), key2)) : (this._pairs.push([key, fn]), key);
          }
          invalidate(handler) {
            return this._invalidate = true, this.using(handler);
          }
          validator() {
            const pairs = this._pairs;
            return function* (data) {
              for (const [key, fn] of pairs)
                if (key !== (yield* fn(data)))
                  return false;
              return true;
            };
          }
          deactivate() {
            this._active = false;
          }
          configured() {
            return this._configured;
          }
        }
        function assertSimpleType(value) {
          if ((0, _async.isThenable)(value))
            throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (value != null && typeof value != "string" && typeof value != "boolean" && typeof value != "number")
            throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return value;
        }
        class Lock {
          constructor() {
            this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((resolve5) => {
              this._resolve = resolve5;
            });
          }
          release(value) {
            this.released = true, this._resolve(value);
          }
        }
      }, "./node_modules/@babel/core/lib/config/config-chain.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _debug() {
          const data = __webpack_require__2("./node_modules/debug/src/index.js");
          return _debug = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.buildPresetChain = function* (arg, context) {
          const chain = yield* buildPresetChainWalker(arg, context);
          return chain ? { plugins: dedupDescriptors(chain.plugins), presets: dedupDescriptors(chain.presets), options: chain.options.map((o) => normalizeOptions(o)), files: /* @__PURE__ */ new Set() } : null;
        }, exports2.buildPresetChainWalker = void 0, exports2.buildRootChain = function* (opts, context) {
          let configReport, babelRcReport;
          const programmaticLogger = new _printer.ConfigPrinter(), programmaticChain = yield* loadProgrammaticChain({ options: opts, dirname: context.cwd }, context, void 0, programmaticLogger);
          if (!programmaticChain)
            return null;
          const programmaticReport = yield* programmaticLogger.output();
          let configFile;
          typeof opts.configFile == "string" ? configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller) : opts.configFile !== false && (configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller));
          let { babelrc, babelrcRoots } = opts, babelrcRootsDirectory = context.cwd;
          const configFileChain = emptyChain(), configFileLogger = new _printer.ConfigPrinter();
          if (configFile) {
            const validatedFile = validateConfigFile(configFile), result = yield* loadFileChain(validatedFile, context, void 0, configFileLogger);
            if (!result)
              return null;
            configReport = yield* configFileLogger.output(), babelrc === void 0 && (babelrc = validatedFile.options.babelrc), babelrcRoots === void 0 && (babelrcRootsDirectory = validatedFile.dirname, babelrcRoots = validatedFile.options.babelrcRoots), mergeChain(configFileChain, result);
          }
          let ignoreFile, babelrcFile, isIgnored = false;
          const fileChain = emptyChain();
          if ((babelrc === true || babelrc === void 0) && typeof context.filename == "string") {
            const pkgData = yield* (0, _files.findPackageData)(context.filename);
            if (pkgData && function(context2, pkgData2, babelrcRoots2, babelrcRootsDirectory2) {
              if (typeof babelrcRoots2 == "boolean")
                return babelrcRoots2;
              const absoluteRoot = context2.root;
              if (babelrcRoots2 === void 0)
                return pkgData2.directories.indexOf(absoluteRoot) !== -1;
              let babelrcPatterns = babelrcRoots2;
              Array.isArray(babelrcPatterns) || (babelrcPatterns = [babelrcPatterns]);
              if (babelrcPatterns = babelrcPatterns.map((pat) => typeof pat == "string" ? _path().resolve(babelrcRootsDirectory2, pat) : pat), babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot)
                return pkgData2.directories.indexOf(absoluteRoot) !== -1;
              return babelrcPatterns.some((pat) => (typeof pat == "string" && (pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory2)), pkgData2.directories.some((directory) => matchPattern(pat, babelrcRootsDirectory2, directory, context2))));
            }(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
              if ({ ignore: ignoreFile, config: babelrcFile } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller), ignoreFile && fileChain.files.add(ignoreFile.filepath), ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname) && (isIgnored = true), babelrcFile && !isIgnored) {
                const validatedFile = validateBabelrcFile(babelrcFile), babelrcLogger = new _printer.ConfigPrinter(), result = yield* loadFileChain(validatedFile, context, void 0, babelrcLogger);
                result ? (babelRcReport = yield* babelrcLogger.output(), mergeChain(fileChain, result)) : isIgnored = true;
              }
              babelrcFile && isIgnored && fileChain.files.add(babelrcFile.filepath);
            }
          }
          context.showConfig && console.log(`Babel configs on "${context.filename}" (ascending priority):
` + [configReport, babelRcReport, programmaticReport].filter((x) => !!x).join("\n\n") + "\n-----End Babel configs-----");
          const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
          return { plugins: isIgnored ? [] : dedupDescriptors(chain.plugins), presets: isIgnored ? [] : dedupDescriptors(chain.presets), options: isIgnored ? [] : chain.options.map((o) => normalizeOptions(o)), fileHandling: isIgnored ? "ignored" : "transpile", ignore: ignoreFile || void 0, babelrc: babelrcFile || void 0, config: configFile || void 0, files: chain.files };
        };
        var _options = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/options.js"), _patternToRegex = __webpack_require__2("./node_modules/@babel/core/lib/config/pattern-to-regex.js"), _printer = __webpack_require__2("./node_modules/@babel/core/lib/config/printer.js"), _files = __webpack_require__2("./node_modules/@babel/core/lib/config/files/index.js"), _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js"), _configDescriptors = __webpack_require__2("./node_modules/@babel/core/lib/config/config-descriptors.js");
        const debug = _debug()("babel:config:config-chain");
        const buildPresetChainWalker = makeChainWalker({ root: (preset) => loadPresetDescriptors(preset), env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName), overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index), overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName), createLogger: () => () => {
        } });
        exports2.buildPresetChainWalker = buildPresetChainWalker;
        const loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors)), loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName))), loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index))), loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));
        const validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("configfile", file.options) })), validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("babelrcfile", file.options) })), validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({ filepath: file.filepath, dirname: file.dirname, options: (0, _options.validate)("extendsfile", file.options) })), loadProgrammaticChain = makeChainWalker({ root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors), env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName), overrides: (input, index) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index), overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index, envName), createLogger: (input, context, baseLogger) => function(_, context2, baseLogger2) {
          var _context$caller;
          if (!baseLogger2)
            return () => {
            };
          return baseLogger2.configure(context2.showConfig, _printer.ChainFormatter.Programmatic, { callerName: (_context$caller = context2.caller) == null ? void 0 : _context$caller.name });
        }(0, context, baseLogger) }), loadFileChainWalker = makeChainWalker({ root: (file) => loadFileDescriptors(file), env: (file, envName) => loadFileEnvDescriptors(file)(envName), overrides: (file, index) => loadFileOverridesDescriptors(file)(index), overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName), createLogger: (file, context, baseLogger) => function(filepath, context2, baseLogger2) {
          if (!baseLogger2)
            return () => {
            };
          return baseLogger2.configure(context2.showConfig, _printer.ChainFormatter.Config, { filepath });
        }(file.filepath, context, baseLogger) });
        function* loadFileChain(input, context, files, baseLogger) {
          const chain = yield* loadFileChainWalker(input, context, files, baseLogger);
          return chain && chain.files.add(input.filepath), chain;
        }
        const loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors)), loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName))), loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index))), loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));
        function buildRootDescriptors({ dirname: dirname3, options }, alias, descriptors) {
          return descriptors(dirname3, options, alias);
        }
        function buildEnvDescriptors({ dirname: dirname3, options }, alias, descriptors, envName) {
          const opts = options.env && options.env[envName];
          return opts ? descriptors(dirname3, opts, `${alias}.env["${envName}"]`) : null;
        }
        function buildOverrideDescriptors({ dirname: dirname3, options }, alias, descriptors, index) {
          const opts = options.overrides && options.overrides[index];
          if (!opts)
            throw new Error("Assertion failure - missing override");
          return descriptors(dirname3, opts, `${alias}.overrides[${index}]`);
        }
        function buildOverrideEnvDescriptors({ dirname: dirname3, options }, alias, descriptors, index, envName) {
          const override = options.overrides && options.overrides[index];
          if (!override)
            throw new Error("Assertion failure - missing override");
          const opts = override.env && override.env[envName];
          return opts ? descriptors(dirname3, opts, `${alias}.overrides[${index}].env["${envName}"]`) : null;
        }
        function makeChainWalker({ root, env, overrides, overridesEnv, createLogger }) {
          return function* (input, context, files = /* @__PURE__ */ new Set(), baseLogger) {
            const { dirname: dirname3 } = input, flattenedConfigs = [], rootOpts = root(input);
            if (configIsApplicable(rootOpts, dirname3, context)) {
              flattenedConfigs.push({ config: rootOpts, envName: void 0, index: void 0 });
              const envOpts = env(input, context.envName);
              envOpts && configIsApplicable(envOpts, dirname3, context) && flattenedConfigs.push({ config: envOpts, envName: context.envName, index: void 0 }), (rootOpts.options.overrides || []).forEach((_, index) => {
                const overrideOps = overrides(input, index);
                if (configIsApplicable(overrideOps, dirname3, context)) {
                  flattenedConfigs.push({ config: overrideOps, index, envName: void 0 });
                  const overrideEnvOpts = overridesEnv(input, index, context.envName);
                  overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname3, context) && flattenedConfigs.push({ config: overrideEnvOpts, index, envName: context.envName });
                }
              });
            }
            if (flattenedConfigs.some(({ config: { options: { ignore, only } } }) => shouldIgnore(context, ignore, only, dirname3)))
              return null;
            const chain = emptyChain(), logger = createLogger(input, context, baseLogger);
            for (const { config, index, envName } of flattenedConfigs) {
              if (!(yield* mergeExtendsChain(chain, config.options, dirname3, context, files, baseLogger)))
                return null;
              logger(config, index, envName), yield* mergeChainOpts(chain, config);
            }
            return chain;
          };
        }
        function* mergeExtendsChain(chain, opts, dirname3, context, files, baseLogger) {
          if (opts.extends === void 0)
            return true;
          const file = yield* (0, _files.loadConfig)(opts.extends, dirname3, context.envName, context.caller);
          if (files.has(file))
            throw new Error(`Configuration cycle detected loading ${file.filepath}.
File already loaded following the config chain:
` + Array.from(files, (file2) => ` - ${file2.filepath}`).join("\n"));
          files.add(file);
          const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
          return files.delete(file), !!fileChain && (mergeChain(chain, fileChain), true);
        }
        function mergeChain(target, source) {
          target.options.push(...source.options), target.plugins.push(...source.plugins), target.presets.push(...source.presets);
          for (const file of source.files)
            target.files.add(file);
          return target;
        }
        function* mergeChainOpts(target, { options, plugins, presets }) {
          return target.options.push(options), target.plugins.push(...yield* plugins()), target.presets.push(...yield* presets()), target;
        }
        function emptyChain() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function normalizeOptions(opts) {
          const options = Object.assign({}, opts);
          return delete options.extends, delete options.env, delete options.overrides, delete options.plugins, delete options.presets, delete options.passPerPreset, delete options.ignore, delete options.only, delete options.test, delete options.include, delete options.exclude, Object.prototype.hasOwnProperty.call(options, "sourceMap") && (options.sourceMaps = options.sourceMap, delete options.sourceMap), options;
        }
        function dedupDescriptors(items) {
          const map = /* @__PURE__ */ new Map(), descriptors = [];
          for (const item of items)
            if (typeof item.value == "function") {
              const fnKey = item.value;
              let nameMap = map.get(fnKey);
              nameMap || (nameMap = /* @__PURE__ */ new Map(), map.set(fnKey, nameMap));
              let desc = nameMap.get(item.name);
              desc ? desc.value = item : (desc = { value: item }, descriptors.push(desc), item.ownPass || nameMap.set(item.name, desc));
            } else
              descriptors.push({ value: item });
          return descriptors.reduce((acc, desc) => (acc.push(desc.value), acc), []);
        }
        function configIsApplicable({ options }, dirname3, context) {
          return (options.test === void 0 || configFieldIsApplicable(context, options.test, dirname3)) && (options.include === void 0 || configFieldIsApplicable(context, options.include, dirname3)) && (options.exclude === void 0 || !configFieldIsApplicable(context, options.exclude, dirname3));
        }
        function configFieldIsApplicable(context, test, dirname3) {
          return matchesPatterns(context, Array.isArray(test) ? test : [test], dirname3);
        }
        function ignoreListReplacer(_key, value) {
          return value instanceof RegExp ? String(value) : value;
        }
        function shouldIgnore(context, ignore, only, dirname3) {
          if (ignore && matchesPatterns(context, ignore, dirname3)) {
            var _context$filename;
            const message = `No config is applied to "${(_context$filename = context.filename) != null ? _context$filename : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from "${dirname3}"`;
            return debug(message), context.showConfig && console.log(message), true;
          }
          if (only && !matchesPatterns(context, only, dirname3)) {
            var _context$filename2;
            const message = `No config is applied to "${(_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname3}"`;
            return debug(message), context.showConfig && console.log(message), true;
          }
          return false;
        }
        function matchesPatterns(context, patterns, dirname3) {
          return patterns.some((pattern) => matchPattern(pattern, dirname3, context.filename, context));
        }
        function matchPattern(pattern, dirname3, pathToTest, context) {
          if (typeof pattern == "function")
            return !!pattern(pathToTest, { dirname: dirname3, envName: context.envName, caller: context.caller });
          if (typeof pathToTest != "string")
            throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
          return typeof pattern == "string" && (pattern = (0, _patternToRegex.default)(pattern, dirname3)), pattern.test(pathToTest);
        }
      }, "./node_modules/@babel/core/lib/config/config-descriptors.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.createCachedDescriptors = function(dirname3, options, alias) {
          const { plugins, presets, passPerPreset } = options;
          return { options: optionsWithResolvedBrowserslistConfigFile(options, dirname3), plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname3)(alias) : () => handlerOf([]), presets: presets ? () => createCachedPresetDescriptors(presets, dirname3)(alias)(!!passPerPreset) : () => handlerOf([]) };
        }, exports2.createDescriptor = createDescriptor, exports2.createUncachedDescriptors = function(dirname3, options, alias) {
          let plugins, presets;
          return { options: optionsWithResolvedBrowserslistConfigFile(options, dirname3), *plugins() {
            return plugins || (plugins = yield* createPluginDescriptors(options.plugins || [], dirname3, alias)), plugins;
          }, *presets() {
            return presets || (presets = yield* createPresetDescriptors(options.presets || [], dirname3, alias, !!options.passPerPreset)), presets;
          } };
        };
        var _files = __webpack_require__2("./node_modules/@babel/core/lib/config/files/index.js"), _item = __webpack_require__2("./node_modules/@babel/core/lib/config/item.js"), _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js"), _resolveTargets = __webpack_require__2("./node_modules/@babel/core/lib/config/resolve-targets.js");
        function* handlerOf(value) {
          return value;
        }
        function optionsWithResolvedBrowserslistConfigFile(options, dirname3) {
          return typeof options.browserslistConfigFile == "string" && (options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname3)), options;
        }
        const PRESET_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
          const dirname3 = cache.using((dir) => dir);
          return (0, _caching.makeStrongCacheSync)((alias) => (0, _caching.makeStrongCache)(function* (passPerPreset) {
            return (yield* createPresetDescriptors(items, dirname3, alias, passPerPreset)).map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));
          }));
        }), PLUGIN_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap(), createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache) => {
          const dirname3 = cache.using((dir) => dir);
          return (0, _caching.makeStrongCache)(function* (alias) {
            return (yield* createPluginDescriptors(items, dirname3, alias)).map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));
          });
        }), DEFAULT_OPTIONS = {};
        function loadCachedDescriptor(cache, desc) {
          const { value, options = DEFAULT_OPTIONS } = desc;
          if (options === false)
            return desc;
          let cacheByOptions = cache.get(value);
          cacheByOptions || (cacheByOptions = /* @__PURE__ */ new WeakMap(), cache.set(value, cacheByOptions));
          let possibilities = cacheByOptions.get(options);
          if (possibilities || (possibilities = [], cacheByOptions.set(options, possibilities)), possibilities.indexOf(desc) === -1) {
            const matches = possibilities.filter((possibility) => {
              return b = desc, (a = possibility).name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
              var a, b;
            });
            if (matches.length > 0)
              return matches[0];
            possibilities.push(desc);
          }
          return desc;
        }
        function* createPresetDescriptors(items, dirname3, alias, passPerPreset) {
          return yield* createDescriptors("preset", items, dirname3, alias, passPerPreset);
        }
        function* createPluginDescriptors(items, dirname3, alias) {
          return yield* createDescriptors("plugin", items, dirname3, alias);
        }
        function* createDescriptors(type, items, dirname3, alias, ownPass) {
          const descriptors = yield* _gensync().all(items.map((item, index) => createDescriptor(item, dirname3, { type, alias: `${alias}$${index}`, ownPass: !!ownPass })));
          return function(items2) {
            const map = /* @__PURE__ */ new Map();
            for (const item of items2) {
              if (typeof item.value != "function")
                continue;
              let nameMap = map.get(item.value);
              if (nameMap || (nameMap = /* @__PURE__ */ new Set(), map.set(item.value, nameMap)), nameMap.has(item.name)) {
                const conflicts = items2.filter((i) => i.value === item.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(conflicts, null, 2)}`].join("\n"));
              }
              nameMap.add(item.name);
            }
          }(descriptors), descriptors;
        }
        function* createDescriptor(pair, dirname3, { type, alias, ownPass }) {
          const desc = (0, _item.getItemDescriptor)(pair);
          if (desc)
            return desc;
          let name, options, file, value = pair;
          Array.isArray(value) && (value.length === 3 ? [value, options, name] = value : [value, options] = value);
          let filepath = null;
          if (typeof value == "string") {
            if (typeof type != "string")
              throw new Error("To resolve a string-based item, the type of item must be given");
            const resolver = type === "plugin" ? _files.loadPlugin : _files.loadPreset, request = value;
            ({ filepath, value } = yield* resolver(value, dirname3)), file = { request, resolved: filepath };
          }
          if (!value)
            throw new Error(`Unexpected falsy value: ${String(value)}`);
          if (typeof value == "object" && value.__esModule) {
            if (!value.default)
              throw new Error("Must export a default export when using ES6 modules.");
            value = value.default;
          }
          if (typeof value != "object" && typeof value != "function")
            throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);
          if (filepath !== null && typeof value == "object" && value)
            throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
          return { name, alias: filepath || alias, value, options, dirname: dirname3, ownPass, file };
        }
      }, "./node_modules/@babel/core/lib/config/files/configuration.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _debug() {
          const data = __webpack_require__2("./node_modules/debug/src/index.js");
          return _debug = function() {
            return data;
          }, data;
        }
        function _fs() {
          const data = __webpack_require__2("fs");
          return _fs = function() {
            return data;
          }, data;
        }
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _json() {
          const data = __webpack_require__2("./node_modules/json5/dist/index.mjs");
          return _json = function() {
            return data;
          }, data;
        }
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ROOT_CONFIG_FILENAMES = void 0, exports2.findConfigUpwards = function(rootDir) {
          let dirname3 = rootDir;
          for (; ; ) {
            for (const filename of ROOT_CONFIG_FILENAMES)
              if (_fs().existsSync(_path().join(dirname3, filename)))
                return dirname3;
            const nextDir = _path().dirname(dirname3);
            if (dirname3 === nextDir)
              break;
            dirname3 = nextDir;
          }
          return null;
        }, exports2.findRelativeConfig = function* (packageData, envName, caller) {
          let config = null, ignore = null;
          const dirname3 = _path().dirname(packageData.filepath);
          for (const loc of packageData.directories) {
            var _packageData$pkg;
            if (!config)
              config = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);
            if (!ignore) {
              const ignoreLoc = _path().join(loc, ".babelignore");
              ignore = yield* readIgnoreConfig(ignoreLoc), ignore && debug("Found ignore %o from %o.", ignore.filepath, dirname3);
            }
          }
          return { config, ignore };
        }, exports2.findRootConfig = function(dirname3, envName, caller) {
          return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname3, envName, caller);
        }, exports2.loadConfig = function* (name, dirname3, envName, caller) {
          const filepath = (v = process.versions.node, w = "8.9", v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1] ? __webpack_require__2("./node_modules/@babel/core/lib/config/files sync recursive").resolve : (r, { paths: [b] }, M = __webpack_require__2("module")) => {
            let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
            if (f)
              return f;
            throw f = new Error(`Cannot resolve module '${r}'`), f.code = "MODULE_NOT_FOUND", f;
          })(name, { paths: [dirname3] }), conf = yield* readConfig(filepath, envName, caller);
          var v, w;
          if (!conf)
            throw new Error(`Config file ${filepath} contains no configuration data`);
          return debug("Loaded config %o from %o.", name, dirname3), conf;
        }, exports2.resolveShowConfigPath = function* (dirname3) {
          const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
          if (targetPath != null) {
            const absolutePath = _path().resolve(dirname3, targetPath);
            if (!(yield* fs3.stat(absolutePath)).isFile())
              throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return absolutePath;
          }
          return null;
        };
        var _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js"), _configApi = __webpack_require__2("./node_modules/@babel/core/lib/config/helpers/config-api.js"), _utils = __webpack_require__2("./node_modules/@babel/core/lib/config/files/utils.js"), _moduleTypes = __webpack_require__2("./node_modules/@babel/core/lib/config/files/module-types.js"), _patternToRegex = __webpack_require__2("./node_modules/@babel/core/lib/config/pattern-to-regex.js"), fs3 = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/fs.js");
        const debug = _debug()("babel:config:loading:files:configuration"), ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json"];
        exports2.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;
        const RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json"];
        function* loadOneConfig(names, dirname3, envName, caller, previousConfig = null) {
          const config = (yield* _gensync().all(names.map((filename) => readConfig(_path().join(dirname3, filename), envName, caller)))).reduce((previousConfig2, config2) => {
            if (config2 && previousConfig2)
              throw new Error(`Multiple configuration files found. Please remove one:
 - ${_path().basename(previousConfig2.filepath)}
 - ${config2.filepath}
from ${dirname3}`);
            return config2 || previousConfig2;
          }, previousConfig);
          return config && debug("Found configuration %o from %o.", config.filepath, dirname3), config;
        }
        function readConfig(filepath, envName, caller) {
          const ext = _path().extname(filepath);
          return ext === ".js" || ext === ".cjs" || ext === ".mjs" ? readConfigJS(filepath, { envName, caller }) : readConfigJSON5(filepath);
        }
        const LOADING_CONFIGS = /* @__PURE__ */ new Set(), readConfigJS = (0, _caching.makeStrongCache)(function* (filepath, cache) {
          if (!_fs().existsSync(filepath))
            return cache.never(), null;
          if (LOADING_CONFIGS.has(filepath))
            return cache.never(), debug("Auto-ignoring usage of config %o.", filepath), { filepath, dirname: _path().dirname(filepath), options: {} };
          let options;
          try {
            LOADING_CONFIGS.add(filepath), options = yield* (0, _moduleTypes.default)(filepath, "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously.");
          } catch (err) {
            throw err.message = `${filepath}: Error while loading config - ${err.message}`, err;
          } finally {
            LOADING_CONFIGS.delete(filepath);
          }
          let assertCache = false;
          if (typeof options == "function" && (yield* [], options = options((0, _configApi.makeConfigAPI)(cache)), assertCache = true), !options || typeof options != "object" || Array.isArray(options))
            throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);
          if (typeof options.then == "function")
            throw new Error("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.");
          return assertCache && !cache.configured() && function() {
            throw new Error(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`);
          }(), { filepath, dirname: _path().dirname(filepath), options };
        }), packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
          const babel = file.options.babel;
          if (babel === void 0)
            return null;
          if (typeof babel != "object" || Array.isArray(babel) || babel === null)
            throw new Error(`${file.filepath}: .babel property must be an object`);
          return { filepath: file.filepath, dirname: file.dirname, options: babel };
        }), readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
          let options;
          try {
            options = _json().parse(content);
          } catch (err) {
            throw err.message = `${filepath}: Error while parsing config - ${err.message}`, err;
          }
          if (!options)
            throw new Error(`${filepath}: No config detected`);
          if (typeof options != "object")
            throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
          if (Array.isArray(options))
            throw new Error(`${filepath}: Expected config object but found array`);
          return delete options.$schema, { filepath, dirname: _path().dirname(filepath), options };
        }), readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
          const ignoreDir = _path().dirname(filepath), ignorePatterns = content.split("\n").map((line) => line.replace(/#(.*?)$/, "").trim()).filter((line) => !!line);
          for (const pattern of ignorePatterns)
            if (pattern[0] === "!")
              throw new Error("Negation of file paths is not supported.");
          return { filepath, dirname: _path().dirname(filepath), ignore: ignorePatterns.map((pattern) => (0, _patternToRegex.default)(pattern, ignoreDir)) };
        });
      }, "./node_modules/@babel/core/lib/config/files/import-meta-resolve.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(_x, _x2) {
          return _resolve.apply(this, arguments);
        };
        var _importMetaResolve = __webpack_require__2("./node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve5(value) : Promise.resolve(value).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve5, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        let import_;
        try {
          import_ = __webpack_require__2("./node_modules/@babel/core/lib/config/files/import.js").Z;
        } catch (_unused) {
        }
        const importMetaResolveP = import_ && process.execArgv.includes("--experimental-import-meta-resolve") ? import_("data:text/javascript,export default import.meta.resolve").then((m) => m.default || _importMetaResolve.resolve, () => _importMetaResolve.resolve) : Promise.resolve(_importMetaResolve.resolve);
        function _resolve() {
          return (_resolve = _asyncToGenerator(function* (specifier, parent) {
            return (yield importMetaResolveP)(specifier, parent);
          })).apply(this, arguments);
        }
      }, "./node_modules/@babel/core/lib/config/files/import.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        exports2.Z = function(filepath) {
          return __webpack_require__2("./node_modules/@babel/core/lib/config/files lazy recursive")(filepath);
        };
      }, "./node_modules/@babel/core/lib/config/files/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "ROOT_CONFIG_FILENAMES", { enumerable: true, get: function() {
          return _configuration.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(exports2, "findConfigUpwards", { enumerable: true, get: function() {
          return _configuration.findConfigUpwards;
        } }), Object.defineProperty(exports2, "findPackageData", { enumerable: true, get: function() {
          return _package.findPackageData;
        } }), Object.defineProperty(exports2, "findRelativeConfig", { enumerable: true, get: function() {
          return _configuration.findRelativeConfig;
        } }), Object.defineProperty(exports2, "findRootConfig", { enumerable: true, get: function() {
          return _configuration.findRootConfig;
        } }), Object.defineProperty(exports2, "loadConfig", { enumerable: true, get: function() {
          return _configuration.loadConfig;
        } }), Object.defineProperty(exports2, "loadPlugin", { enumerable: true, get: function() {
          return plugins.loadPlugin;
        } }), Object.defineProperty(exports2, "loadPreset", { enumerable: true, get: function() {
          return plugins.loadPreset;
        } }), exports2.resolvePreset = exports2.resolvePlugin = void 0, Object.defineProperty(exports2, "resolveShowConfigPath", { enumerable: true, get: function() {
          return _configuration.resolveShowConfigPath;
        } });
        var _package = __webpack_require__2("./node_modules/@babel/core/lib/config/files/package.js"), _configuration = __webpack_require__2("./node_modules/@babel/core/lib/config/files/configuration.js"), plugins = __webpack_require__2("./node_modules/@babel/core/lib/config/files/plugins.js");
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        const resolvePlugin = _gensync()(plugins.resolvePlugin).sync;
        exports2.resolvePlugin = resolvePlugin;
        const resolvePreset = _gensync()(plugins.resolvePreset).sync;
        exports2.resolvePreset = resolvePreset;
      }, "./node_modules/@babel/core/lib/config/files/module-types.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function* (filepath, asyncError, fallbackToTranspiledModule = false) {
          switch (function(filename) {
            switch (_path().extname(filename)) {
              case ".cjs":
                return "cjs";
              case ".mjs":
                return "mjs";
              default:
                return "unknown";
            }
          }(filepath)) {
            case "cjs":
              return loadCjsDefault(filepath, fallbackToTranspiledModule);
            case "unknown":
              try {
                return loadCjsDefault(filepath, fallbackToTranspiledModule);
              } catch (e2) {
                if (e2.code !== "ERR_REQUIRE_ESM")
                  throw e2;
              }
            case "mjs":
              if (yield* (0, _async.isAsync)())
                return yield* (0, _async.waitFor)(function(_x) {
                  return _loadMjsDefault.apply(this, arguments);
                }(filepath));
              throw new Error(asyncError);
          }
        }, exports2.supportsESM = void 0;
        var _async = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/async.js");
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _url() {
          const data = __webpack_require__2("url");
          return _url = function() {
            return data;
          }, data;
        }
        function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve5(value) : Promise.resolve(value).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve5, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        let import_;
        try {
          import_ = __webpack_require__2("./node_modules/@babel/core/lib/config/files/import.js").Z;
        } catch (_unused) {
        }
        const supportsESM = !!import_;
        function loadCjsDefault(filepath, fallbackToTranspiledModule) {
          const module3 = __webpack_require__2("./node_modules/@babel/core/lib/config/files sync recursive")(filepath);
          return module3 != null && module3.__esModule ? module3.default || (fallbackToTranspiledModule ? module3 : void 0) : module3;
        }
        function _loadMjsDefault() {
          return (_loadMjsDefault = _asyncToGenerator(function* (filepath) {
            if (!import_)
              throw new Error("Internal error: Native ECMAScript modules aren't supported by this platform.\n");
            return (yield import_((0, _url().pathToFileURL)(filepath))).default;
          })).apply(this, arguments);
        }
        exports2.supportsESM = supportsESM;
      }, "./node_modules/@babel/core/lib/config/files/package.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.findPackageData = function* (filepath) {
          let pkg = null;
          const directories = [];
          let isPackage = true, dirname3 = _path().dirname(filepath);
          for (; !pkg && _path().basename(dirname3) !== "node_modules"; ) {
            directories.push(dirname3), pkg = yield* readConfigPackage(_path().join(dirname3, "package.json"));
            const nextLoc = _path().dirname(dirname3);
            if (dirname3 === nextLoc) {
              isPackage = false;
              break;
            }
            dirname3 = nextLoc;
          }
          return { filepath, directories, pkg, isPackage };
        };
        var _utils = __webpack_require__2("./node_modules/@babel/core/lib/config/files/utils.js");
        const readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
          let options;
          try {
            options = JSON.parse(content);
          } catch (err) {
            throw err.message = `${filepath}: Error while parsing JSON - ${err.message}`, err;
          }
          if (!options)
            throw new Error(`${filepath}: No config detected`);
          if (typeof options != "object")
            throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
          if (Array.isArray(options))
            throw new Error(`${filepath}: Expected config object but found array`);
          return { filepath, dirname: _path().dirname(filepath), options };
        });
      }, "./node_modules/@babel/core/lib/config/files/plugins.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _debug() {
          const data = __webpack_require__2("./node_modules/debug/src/index.js");
          return _debug = function() {
            return data;
          }, data;
        }
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.loadPlugin = function* (name, dirname3) {
          const filepath = yield* resolvePlugin(name, dirname3), value = yield* requireModule("plugin", filepath);
          return debug("Loaded plugin %o from %o.", name, dirname3), { filepath, value };
        }, exports2.loadPreset = function* (name, dirname3) {
          const filepath = yield* resolvePreset(name, dirname3), value = yield* requireModule("preset", filepath);
          return debug("Loaded preset %o from %o.", name, dirname3), { filepath, value };
        }, exports2.resolvePlugin = resolvePlugin, exports2.resolvePreset = resolvePreset;
        var _async = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/async.js"), _moduleTypes = __webpack_require__2("./node_modules/@babel/core/lib/config/files/module-types.js");
        function _url() {
          const data = __webpack_require__2("url");
          return _url = function() {
            return data;
          }, data;
        }
        var _importMetaResolve = __webpack_require__2("./node_modules/@babel/core/lib/config/files/import-meta-resolve.js");
        function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve5(value) : Promise.resolve(value).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve5, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        const debug = _debug()("babel:config:loading:files:plugins"), EXACT_RE = /^module:/, BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/, BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/, BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/, BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/, OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;
        function* resolvePlugin(name, dirname3) {
          return yield* resolveStandardizedName("plugin", name, dirname3);
        }
        function* resolvePreset(name, dirname3) {
          return yield* resolveStandardizedName("preset", name, dirname3);
        }
        function standardizeName(type, name) {
          if (_path().isAbsolute(name))
            return name;
          const isPreset = type === "preset";
          return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, "");
        }
        function* resolveAlternativesHelper(type, name) {
          const standardizedName = standardizeName(type, name), { error, value } = yield standardizedName;
          if (!error)
            return value;
          if (error.code !== "MODULE_NOT_FOUND")
            throw error;
          standardizedName === name || (yield name).error || (error.message += `
- If you want to resolve "${name}", use "module:${name}"`), (yield standardizeName(type, "@babel/" + name)).error || (error.message += `
- Did you mean "@babel/${name}"?`);
          const oppositeType = type === "preset" ? "plugin" : "preset";
          throw (yield standardizeName(oppositeType, name)).error || (error.message += `
- Did you accidentally pass a ${oppositeType} as a ${type}?`), error;
        }
        function tryRequireResolve(id, { paths: [dirname3] }) {
          try {
            return { error: null, value: (v = process.versions.node, w = "8.9", v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1] ? __webpack_require__2("./node_modules/@babel/core/lib/config/files sync recursive").resolve : (r, { paths: [b] }, M = __webpack_require__2("module")) => {
              let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
              if (f)
                return f;
              throw f = new Error(`Cannot resolve module '${r}'`), f.code = "MODULE_NOT_FOUND", f;
            })(id, { paths: [dirname3] }) };
          } catch (error) {
            return { error, value: null };
          }
          var v, w;
        }
        function tryImportMetaResolve(_x, _x2) {
          return _tryImportMetaResolve.apply(this, arguments);
        }
        function _tryImportMetaResolve() {
          return (_tryImportMetaResolve = _asyncToGenerator(function* (id, options) {
            try {
              return { error: null, value: yield (0, _importMetaResolve.default)(id, options) };
            } catch (error) {
              return { error, value: null };
            }
          })).apply(this, arguments);
        }
        function resolveStandardizedNameForRequrie(type, name, dirname3) {
          const it = resolveAlternativesHelper(type, name);
          let res = it.next();
          for (; !res.done; )
            res = it.next(tryRequireResolve(res.value, { paths: [dirname3] }));
          return res.value;
        }
        function _resolveStandardizedNameForImport() {
          return (_resolveStandardizedNameForImport = _asyncToGenerator(function* (type, name, dirname3) {
            const parentUrl = (0, _url().pathToFileURL)(_path().join(dirname3, "./babel-virtual-resolve-base.js")).href, it = resolveAlternativesHelper(type, name);
            let res = it.next();
            for (; !res.done; )
              res = it.next(yield tryImportMetaResolve(res.value, parentUrl));
            return (0, _url().fileURLToPath)(res.value);
          })).apply(this, arguments);
        }
        const resolveStandardizedName = _gensync()({ sync: (type, name, dirname3 = process.cwd()) => resolveStandardizedNameForRequrie(type, name, dirname3), async: (type, name, dirname3 = process.cwd()) => _asyncToGenerator(function* () {
          if (!_moduleTypes.supportsESM)
            return resolveStandardizedNameForRequrie(type, name, dirname3);
          try {
            return yield function(_x3, _x4, _x5) {
              return _resolveStandardizedNameForImport.apply(this, arguments);
            }(type, name, dirname3);
          } catch (e2) {
            try {
              return resolveStandardizedNameForRequrie(type, name, dirname3);
            } catch (e22) {
              if (e2.type === "MODULE_NOT_FOUND")
                throw e2;
              if (e22.type === "MODULE_NOT_FOUND")
                throw e22;
              throw e2;
            }
          }
        })() });
        var LOADING_MODULES = /* @__PURE__ */ new Set();
        function* requireModule(type, name) {
          if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name))
            throw new Error(`Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return LOADING_MODULES.add(name), yield* (0, _moduleTypes.default)(name, `You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously.`, true);
          } catch (err) {
            throw err.message = `[BABEL]: ${err.message} (While processing: ${name})`, err;
          } finally {
            LOADING_MODULES.delete(name);
          }
        }
      }, "./node_modules/@babel/core/lib/config/files/utils.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.makeStaticFileCache = function(fn) {
          return (0, _caching.makeStrongCache)(function* (filepath, cache) {
            const cached = cache.invalidate(() => function(filepath2) {
              if (!_fs2().existsSync(filepath2))
                return null;
              try {
                return +_fs2().statSync(filepath2).mtime;
              } catch (e2) {
                if (e2.code !== "ENOENT" && e2.code !== "ENOTDIR")
                  throw e2;
              }
              return null;
            }(filepath));
            return cached === null ? null : fn(filepath, yield* fs3.readFile(filepath, "utf8"));
          });
        };
        var _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js"), fs3 = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/fs.js");
        function _fs2() {
          const data = __webpack_require__2("fs");
          return _fs2 = function() {
            return data;
          }, data;
        }
      }, "./node_modules/@babel/core/lib/config/files lazy recursive": (module3) => {
        function webpackEmptyAsyncContext(req) {
          return Promise.resolve().then(() => {
            var e2 = new Error("Cannot find module '" + req + "'");
            throw e2.code = "MODULE_NOT_FOUND", e2;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/@babel/core/lib/config/files lazy recursive", module3.exports = webpackEmptyAsyncContext;
      }, "./node_modules/@babel/core/lib/config/files sync recursive": (module3) => {
        function webpackEmptyContext(req) {
          var e2 = new Error("Cannot find module '" + req + "'");
          throw e2.code = "MODULE_NOT_FOUND", e2;
        }
        webpackEmptyContext.keys = () => [], webpackEmptyContext.resolve = webpackEmptyContext, webpackEmptyContext.id = "./node_modules/@babel/core/lib/config/files sync recursive", module3.exports = webpackEmptyContext;
      }, "./node_modules/@babel/core/lib/config/full.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _async = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/async.js"), _util = __webpack_require__2("./node_modules/@babel/core/lib/config/util.js"), context = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _plugin = __webpack_require__2("./node_modules/@babel/core/lib/config/plugin.js"), _item = __webpack_require__2("./node_modules/@babel/core/lib/config/item.js"), _configChain = __webpack_require__2("./node_modules/@babel/core/lib/config/config-chain.js");
        function _traverse() {
          const data = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data;
          }, data;
        }
        var _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js"), _options = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/options.js"), _plugins = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/plugins.js"), _configApi = __webpack_require__2("./node_modules/@babel/core/lib/config/helpers/config-api.js"), _partial = __webpack_require__2("./node_modules/@babel/core/lib/config/partial.js"), _default = (__webpack_require__2("./node_modules/@babel/core/lib/config/cache-contexts.js"), _gensync()(function* (inputOpts) {
          var _opts$assumptions;
          const result = yield* (0, _partial.default)(inputOpts);
          if (!result)
            return null;
          const { options, context: context2, fileHandling } = result;
          if (fileHandling === "ignored")
            return null;
          const optionDefaults = {}, { plugins, presets } = options;
          if (!plugins || !presets)
            throw new Error("Assertion failure - plugins and presets exist");
          const presetContext = Object.assign({}, context2, { targets: options.targets }), toDescriptor = (item) => {
            const desc = (0, _item.getItemDescriptor)(item);
            if (!desc)
              throw new Error("Assertion failure - must be config item");
            return desc;
          }, presetsDescriptors = presets.map(toDescriptor), initialPluginsDescriptors = plugins.map(toDescriptor), pluginDescriptorsByPass = [[]], passes = [], ignored = yield* enhanceError(context2, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
            const presets2 = [];
            for (let i = 0; i < rawPresets.length; i++) {
              const descriptor = rawPresets[i];
              if (descriptor.options !== false)
                try {
                  descriptor.ownPass ? presets2.push({ preset: yield* loadPresetDescriptor(descriptor, presetContext), pass: [] }) : presets2.unshift({ preset: yield* loadPresetDescriptor(descriptor, presetContext), pass: pluginDescriptorsPass });
                } catch (e2) {
                  throw e2.code === "BABEL_UNKNOWN_OPTION" && (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e2), e2;
                }
            }
            if (presets2.length > 0) {
              pluginDescriptorsByPass.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pluginDescriptorsPass));
              for (const { preset, pass } of presets2) {
                if (!preset)
                  return true;
                pass.push(...preset.plugins);
                if (yield* recursePresetDescriptors(preset.presets, pass))
                  return true;
                preset.options.forEach((opts2) => {
                  (0, _util.mergeOptions)(optionDefaults, opts2);
                });
              }
            }
          })(presetsDescriptors, pluginDescriptorsByPass[0]);
          if (ignored)
            return null;
          const opts = optionDefaults;
          (0, _util.mergeOptions)(opts, options);
          const pluginContext = Object.assign({}, presetContext, { assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {} });
          return yield* enhanceError(context2, function* () {
            pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
            for (const descs of pluginDescriptorsByPass) {
              const pass = [];
              passes.push(pass);
              for (let i = 0; i < descs.length; i++) {
                const descriptor = descs[i];
                if (descriptor.options !== false)
                  try {
                    pass.push(yield* loadPluginDescriptor(descriptor, pluginContext));
                  } catch (e2) {
                    throw e2.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e2), e2;
                  }
              }
            }
          })(), opts.plugins = passes[0], opts.presets = passes.slice(1).filter((plugins2) => plugins2.length > 0).map((plugins2) => ({ plugins: plugins2 })), opts.passPerPreset = opts.presets.length > 0, { options: opts, passes };
        }));
        function enhanceError(context2, fn) {
          return function* (arg1, arg2) {
            try {
              return yield* fn(arg1, arg2);
            } catch (e2) {
              throw /^\[BABEL\]/.test(e2.message) || (e2.message = `[BABEL] ${context2.filename || "unknown"}: ${e2.message}`), e2;
            }
          };
        }
        exports2.default = _default;
        const makeDescriptorLoader = (apiFactory) => (0, _caching.makeWeakCache)(function* ({ value, options, dirname: dirname3, alias }, cache) {
          if (options === false)
            throw new Error("Assertion failure");
          options = options || {};
          let item = value;
          if (typeof value == "function") {
            const factory = (0, _async.maybeAsync)(value, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), api = Object.assign({}, context, apiFactory(cache));
            try {
              item = yield* factory(api, options, dirname3);
            } catch (e2) {
              throw alias && (e2.message += ` (While processing: ${JSON.stringify(alias)})`), e2;
            }
          }
          if (!item || typeof item != "object")
            throw new Error("Plugin/Preset did not return an object.");
          if ((0, _async.isThenable)(item))
            throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);
          return { value: item, options, dirname: dirname3, alias };
        }), pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI), presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);
        function* loadPluginDescriptor(descriptor, context2) {
          if (descriptor.value instanceof _plugin.default) {
            if (descriptor.options)
              throw new Error("Passed options to an existing Plugin instance will not work.");
            return descriptor.value;
          }
          return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context2), context2);
        }
        const instantiatePlugin = (0, _caching.makeWeakCache)(function* ({ value, options, dirname: dirname3, alias }, cache) {
          const pluginObj = (0, _plugins.validatePluginObject)(value), plugin = Object.assign({}, pluginObj);
          if (plugin.visitor && (plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor))), plugin.inherits) {
            const inheritsDescriptor = { name: void 0, alias: `${alias}$inherits`, value: plugin.inherits, options, dirname: dirname3 }, inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, (run) => cache.invalidate((data) => run(inheritsDescriptor, data)));
            plugin.pre = chain(inherits.pre, plugin.pre), plugin.post = chain(inherits.post, plugin.post), plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions), plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);
          }
          return new _plugin.default(plugin, options, alias);
        }), validateIfOptionNeedsFilename = (options, descriptor) => {
          if (options.test || options.include || options.exclude) {
            const formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
            throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, "```", `babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
          }
        };
        function* loadPresetDescriptor(descriptor, context2) {
          const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context2));
          return ((preset2, context3, descriptor2) => {
            if (!context3.filename) {
              const { options } = preset2;
              validateIfOptionNeedsFilename(options, descriptor2), options.overrides && options.overrides.forEach((overrideOptions) => validateIfOptionNeedsFilename(overrideOptions, descriptor2));
            }
          })(preset, context2, descriptor), yield* (0, _configChain.buildPresetChain)(preset, context2);
        }
        const instantiatePreset = (0, _caching.makeWeakCacheSync)(({ value, dirname: dirname3, alias }) => ({ options: (0, _options.validate)("preset", value), alias, dirname: dirname3 }));
        function chain(a, b) {
          const fns = [a, b].filter(Boolean);
          return fns.length <= 1 ? fns[0] : function(...args) {
            for (const fn of fns)
              fn.apply(this, args);
          };
        }
      }, "./node_modules/@babel/core/lib/config/helpers/config-api.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _semver() {
          const data = __webpack_require__2("./node_modules/@babel/core/node_modules/semver/semver.js");
          return _semver = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.makeConfigAPI = makeConfigAPI, exports2.makePluginAPI = function(cache) {
          return Object.assign({}, makePresetAPI(cache), { assumption: (name) => cache.using((data) => data.assumptions[name]) });
        }, exports2.makePresetAPI = makePresetAPI;
        var _ = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _caching = __webpack_require__2("./node_modules/@babel/core/lib/config/caching.js");
        __webpack_require__2("./node_modules/@babel/core/lib/config/cache-contexts.js");
        function makeConfigAPI(cache) {
          return { version: _.version, cache: cache.simple(), env: (value) => cache.using((data) => value === void 0 ? data.envName : typeof value == "function" ? (0, _caching.assertSimpleType)(value(data.envName)) : (Array.isArray(value) || (value = [value]), value.some((entry) => {
            if (typeof entry != "string")
              throw new Error("Unexpected non-string value");
            return entry === data.envName;
          }))), async: () => false, caller: (cb) => cache.using((data) => (0, _caching.assertSimpleType)(cb(data.caller))), assertVersion };
        }
        function makePresetAPI(cache) {
          return Object.assign({}, makeConfigAPI(cache), { targets: () => JSON.parse(cache.using((data) => JSON.stringify(data.targets))) });
        }
        function assertVersion(range) {
          if (typeof range == "number") {
            if (!Number.isInteger(range))
              throw new Error("Expected string or integer value.");
            range = `^${range}.0.0-0`;
          }
          if (typeof range != "string")
            throw new Error("Expected string or integer value.");
          if (_semver().satisfies(_.version, range))
            return;
          const limit = Error.stackTraceLimit;
          typeof limit == "number" && limit < 25 && (Error.stackTraceLimit = 25);
          const err = new Error(`Requires Babel "${range}", but was loaded with "${_.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw typeof limit == "number" && (Error.stackTraceLimit = limit), Object.assign(err, { code: "BABEL_VERSION_UNSUPPORTED", version: _.version, range });
        }
      }, "./node_modules/@babel/core/lib/config/helpers/environment.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.getEnv = function(defaultValue = "development") {
          return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
        };
      }, "./node_modules/@babel/core/lib/config/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.createConfigItem = function(target, options, callback) {
          return callback !== void 0 ? createConfigItemRunner.errback(target, options, callback) : typeof options == "function" ? createConfigItemRunner.errback(target, void 0, callback) : createConfigItemRunner.sync(target, options);
        }, exports2.createConfigItemSync = exports2.createConfigItemAsync = void 0, Object.defineProperty(exports2, "default", { enumerable: true, get: function() {
          return _full.default;
        } }), exports2.loadPartialConfigSync = exports2.loadPartialConfigAsync = exports2.loadPartialConfig = exports2.loadOptionsSync = exports2.loadOptionsAsync = exports2.loadOptions = void 0;
        var _full = __webpack_require__2("./node_modules/@babel/core/lib/config/full.js"), _partial = __webpack_require__2("./node_modules/@babel/core/lib/config/partial.js"), _item = __webpack_require__2("./node_modules/@babel/core/lib/config/item.js");
        const loadOptionsRunner = _gensync()(function* (opts) {
          var _config$options;
          const config = yield* (0, _full.default)(opts);
          return (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null;
        }), createConfigItemRunner = _gensync()(_item.createConfigItem), maybeErrback = (runner) => (opts, callback) => (callback === void 0 && typeof opts == "function" && (callback = opts, opts = void 0), callback ? runner.errback(opts, callback) : runner.sync(opts)), loadPartialConfig = maybeErrback(_partial.loadPartialConfig);
        exports2.loadPartialConfig = loadPartialConfig;
        const loadPartialConfigSync = _partial.loadPartialConfig.sync;
        exports2.loadPartialConfigSync = loadPartialConfigSync;
        const loadPartialConfigAsync = _partial.loadPartialConfig.async;
        exports2.loadPartialConfigAsync = loadPartialConfigAsync;
        const loadOptions = maybeErrback(loadOptionsRunner);
        exports2.loadOptions = loadOptions;
        const loadOptionsSync = loadOptionsRunner.sync;
        exports2.loadOptionsSync = loadOptionsSync;
        const loadOptionsAsync = loadOptionsRunner.async;
        exports2.loadOptionsAsync = loadOptionsAsync;
        const createConfigItemSync = createConfigItemRunner.sync;
        exports2.createConfigItemSync = createConfigItemSync;
        const createConfigItemAsync = createConfigItemRunner.async;
        exports2.createConfigItemAsync = createConfigItemAsync;
      }, "./node_modules/@babel/core/lib/config/item.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.createConfigItem = function* (value, { dirname: dirname3 = ".", type } = {}) {
          return createItemFromDescriptor(yield* (0, _configDescriptors.createDescriptor)(value, _path().resolve(dirname3), { type, alias: "programmatic item" }));
        }, exports2.createItemFromDescriptor = createItemFromDescriptor, exports2.getItemDescriptor = function(item) {
          if (item != null && item[CONFIG_ITEM_BRAND])
            return item._descriptor;
          return;
        };
        var _configDescriptors = __webpack_require__2("./node_modules/@babel/core/lib/config/config-descriptors.js");
        function createItemFromDescriptor(desc) {
          return new ConfigItem(desc);
        }
        const CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");
        class ConfigItem {
          constructor(descriptor) {
            this._descriptor = void 0, this[CONFIG_ITEM_BRAND] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = descriptor, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, CONFIG_ITEM_BRAND, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(ConfigItem.prototype);
      }, "./node_modules/@babel/core/lib/config/partial.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = loadPrivatePartialConfig, exports2.loadPartialConfig = void 0;
        var _plugin = __webpack_require__2("./node_modules/@babel/core/lib/config/plugin.js"), _util = __webpack_require__2("./node_modules/@babel/core/lib/config/util.js"), _item = __webpack_require__2("./node_modules/@babel/core/lib/config/item.js"), _configChain = __webpack_require__2("./node_modules/@babel/core/lib/config/config-chain.js"), _environment = __webpack_require__2("./node_modules/@babel/core/lib/config/helpers/environment.js"), _options = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/options.js"), _files = __webpack_require__2("./node_modules/@babel/core/lib/config/files/index.js"), _resolveTargets = __webpack_require__2("./node_modules/@babel/core/lib/config/resolve-targets.js");
        const _excluded = ["showIgnoredFiles"];
        function* loadPrivatePartialConfig(inputOpts) {
          if (inputOpts != null && (typeof inputOpts != "object" || Array.isArray(inputOpts)))
            throw new Error("Babel options must be an object, null, or undefined");
          const args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {}, { envName = (0, _environment.getEnv)(), cwd = ".", root: rootDir = ".", rootMode = "root", caller, cloneInputAst = true } = args, absoluteCwd = _path().resolve(cwd), absoluteRootDir = function(rootDir2, rootMode2) {
            switch (rootMode2) {
              case "root":
                return rootDir2;
              case "upward-optional": {
                const upwardRootDir = (0, _files.findConfigUpwards)(rootDir2);
                return upwardRootDir === null ? rootDir2 : upwardRootDir;
              }
              case "upward": {
                const upwardRootDir = (0, _files.findConfigUpwards)(rootDir2);
                if (upwardRootDir !== null)
                  return upwardRootDir;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir2}".
One of the following config files must be in the directory tree: "${_files.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: rootDir2 });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          }(_path().resolve(absoluteCwd, rootDir), rootMode), filename = typeof args.filename == "string" ? _path().resolve(cwd, args.filename) : void 0, context = { filename, cwd: absoluteCwd, root: absoluteRootDir, envName, caller, showConfig: (yield* (0, _files.resolveShowConfigPath)(absoluteCwd)) === filename }, configChain = yield* (0, _configChain.buildRootChain)(args, context);
          if (!configChain)
            return null;
          const merged = { assumptions: {} };
          configChain.options.forEach((opts) => {
            (0, _util.mergeOptions)(merged, opts);
          });
          return { options: Object.assign({}, merged, { targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir), cloneInputAst, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: context.envName, cwd: context.cwd, root: context.root, rootMode: "root", filename: typeof context.filename == "string" ? context.filename : void 0, plugins: configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)), presets: configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)) }), context, fileHandling: configChain.fileHandling, ignore: configChain.ignore, babelrc: configChain.babelrc, config: configChain.config, files: configChain.files };
        }
        const loadPartialConfig = _gensync()(function* (opts) {
          let showIgnoredFiles = false;
          if (typeof opts == "object" && opts !== null && !Array.isArray(opts)) {
            var _opts = opts;
            ({ showIgnoredFiles } = _opts), opts = function(source, excluded) {
              if (source == null)
                return {};
              var key, i, target = {}, sourceKeys = Object.keys(source);
              for (i = 0; i < sourceKeys.length; i++)
                key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
              return target;
            }(_opts, _excluded);
          }
          const result = yield* loadPrivatePartialConfig(opts);
          if (!result)
            return null;
          const { options, babelrc, ignore, config, fileHandling, files } = result;
          return fileHandling !== "ignored" || showIgnoredFiles ? ((options.plugins || []).forEach((item) => {
            if (item.value instanceof _plugin.default)
              throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new PartialConfig(options, babelrc ? babelrc.filepath : void 0, ignore ? ignore.filepath : void 0, config ? config.filepath : void 0, fileHandling, files)) : null;
        });
        exports2.loadPartialConfig = loadPartialConfig;
        class PartialConfig {
          constructor(options, babelrc, ignore, config, fileHandling, files) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = options, this.babelignore = ignore, this.babelrc = babelrc, this.config = config, this.fileHandling = fileHandling, this.files = files, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return this.babelrc !== void 0 || this.config !== void 0;
          }
        }
        Object.freeze(PartialConfig.prototype);
      }, "./node_modules/@babel/core/lib/config/pattern-to-regex.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(pattern, dirname3) {
          const parts = _path().resolve(dirname3, pattern).split(_path().sep);
          return new RegExp(["^", ...parts.map((part, i) => {
            const last = i === parts.length - 1;
            return part === "**" ? last ? starStarPatLast : starStarPat : part === "*" ? last ? starPatLast : starPat : part.indexOf("*.") === 0 ? substitution + escapeRegExp2(part.slice(1)) + (last ? endSep : sep) : escapeRegExp2(part) + (last ? endSep : sep);
          })].join(""));
        };
        const sep = `\\${_path().sep}`, endSep = `(?:${sep}|$)`, substitution = `[^${sep}]+`, starPat = `(?:${substitution}${sep})`, starPatLast = `(?:${substitution}${endSep})`, starStarPat = `${starPat}*?`, starStarPatLast = `${starPat}*?${starPatLast}?`;
        function escapeRegExp2(string) {
          return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/@babel/core/lib/config/plugin.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        exports2.default = class {
          constructor(plugin, options, key) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.key = plugin.name || key, this.manipulateOptions = plugin.manipulateOptions, this.post = plugin.post, this.pre = plugin.pre, this.visitor = plugin.visitor || {}, this.parserOverride = plugin.parserOverride, this.generatorOverride = plugin.generatorOverride, this.options = options;
          }
        };
      }, "./node_modules/@babel/core/lib/config/printer.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ConfigPrinter = exports2.ChainFormatter = void 0;
        const ChainFormatter = { Programmatic: 0, Config: 1 };
        exports2.ChainFormatter = ChainFormatter;
        const Formatter = { title(type, callerName, filepath) {
          let title = "";
          return type === ChainFormatter.Programmatic ? (title = "programmatic options", callerName && (title += " from " + callerName)) : title = "config " + filepath, title;
        }, loc(index, envName) {
          let loc = "";
          return index != null && (loc += `.overrides[${index}]`), envName != null && (loc += `.env["${envName}"]`), loc;
        }, *optionsAndDescriptors(opt) {
          const content = Object.assign({}, opt.options);
          delete content.overrides, delete content.env;
          const pluginDescriptors = [...yield* opt.plugins()];
          pluginDescriptors.length && (content.plugins = pluginDescriptors.map((d) => descriptorToConfig(d)));
          const presetDescriptors = [...yield* opt.presets()];
          return presetDescriptors.length && (content.presets = [...presetDescriptors].map((d) => descriptorToConfig(d))), JSON.stringify(content, void 0, 2);
        } };
        function descriptorToConfig(d) {
          var _d$file;
          let name = (_d$file = d.file) == null ? void 0 : _d$file.request;
          return name == null && (typeof d.value == "object" ? name = d.value : typeof d.value == "function" && (name = `[Function: ${d.value.toString().substr(0, 50)} ... ]`)), name == null && (name = "[Unknown]"), d.options === void 0 ? name : d.name == null ? [name, d.options] : [name, d.options, d.name];
        }
        class ConfigPrinter {
          constructor() {
            this._stack = [];
          }
          configure(enabled, type, { callerName, filepath }) {
            return enabled ? (content, index, envName) => {
              this._stack.push({ type, callerName, filepath, content, index, envName });
            } : () => {
            };
          }
          static *format(config) {
            let title = Formatter.title(config.type, config.callerName, config.filepath);
            const loc = Formatter.loc(config.index, config.envName);
            loc && (title += ` ${loc}`);
            return `${title}
${yield* Formatter.optionsAndDescriptors(config.content)}`;
          }
          *output() {
            if (this._stack.length === 0)
              return "";
            return (yield* _gensync().all(this._stack.map((s) => ConfigPrinter.format(s)))).join("\n\n");
          }
        }
        exports2.ConfigPrinter = ConfigPrinter;
      }, "./node_modules/@babel/core/lib/config/resolve-targets.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _helperCompilationTargets() {
          const data = __webpack_require__2("./stubs/helper_compilation_targets.js");
          return _helperCompilationTargets = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.resolveBrowserslistConfigFile = function(browserslistConfigFile, configFileDir) {
          return _path().resolve(configFileDir, browserslistConfigFile);
        }, exports2.resolveTargets = function(options, root) {
          let targets = options.targets;
          (typeof targets == "string" || Array.isArray(targets)) && (targets = { browsers: targets });
          targets && targets.esmodules && (targets = Object.assign({}, targets, { esmodules: "intersect" }));
          const { browserslistConfigFile } = options;
          let configFile, ignoreBrowserslistConfig = false;
          typeof browserslistConfigFile == "string" ? configFile = browserslistConfigFile : ignoreBrowserslistConfig = browserslistConfigFile === false;
          return (0, _helperCompilationTargets().default)(targets, { ignoreBrowserslistConfig, configFile, configPath: root, browserslistEnv: options.browserslistEnv });
        };
      }, "./node_modules/@babel/core/lib/config/util.js": (__unused_webpack_module, exports2) => {
        "use strict";
        function mergeDefaultFields(target, source) {
          for (const k of Object.keys(source)) {
            const val = source[k];
            val !== void 0 && (target[k] = val);
          }
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.isIterableIterator = function(value) {
          return !!value && typeof value.next == "function" && typeof value[Symbol.iterator] == "function";
        }, exports2.mergeOptions = function(target, source) {
          for (const k of Object.keys(source))
            if (k !== "parserOpts" && k !== "generatorOpts" && k !== "assumptions" || !source[k]) {
              const val = source[k];
              val !== void 0 && (target[k] = val);
            } else {
              const parserOpts = source[k];
              mergeDefaultFields(target[k] || (target[k] = {}), parserOpts);
            }
        };
      }, "./node_modules/@babel/core/lib/config/validation/option-assertions.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _helperCompilationTargets() {
          const data = __webpack_require__2("./stubs/helper_compilation_targets.js");
          return _helperCompilationTargets = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.access = access, exports2.assertArray = assertArray, exports2.assertAssumptions = function(loc, value) {
          if (value === void 0)
            return;
          if (typeof value != "object" || value === null)
            throw new Error(`${msg(loc)} must be an object or undefined.`);
          let root = loc;
          do {
            root = root.parent;
          } while (root.type !== "root");
          const inPreset = root.source === "preset";
          for (const name of Object.keys(value)) {
            const subLoc = access(loc, name);
            if (!_options.assumptionsNames.has(name))
              throw new Error(`${msg(subLoc)} is not a supported assumption.`);
            if (typeof value[name] != "boolean")
              throw new Error(`${msg(subLoc)} must be a boolean.`);
            if (inPreset && value[name] === false)
              throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);
          }
          return value;
        }, exports2.assertBabelrcSearch = function(loc, value) {
          if (value === void 0 || typeof value == "boolean")
            return value;
          if (Array.isArray(value))
            value.forEach((item, i) => {
              if (!checkValidTest(item))
                throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
            });
          else if (!checkValidTest(value))
            throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value)}`);
          return value;
        }, exports2.assertBoolean = assertBoolean, exports2.assertCallerMetadata = function(loc, value) {
          const obj = assertObject(loc, value);
          if (obj) {
            if (typeof obj.name != "string")
              throw new Error(`${msg(loc)} set but does not contain "name" property string`);
            for (const prop of Object.keys(obj)) {
              const propLoc = access(loc, prop), value2 = obj[prop];
              if (value2 != null && typeof value2 != "boolean" && typeof value2 != "string" && typeof value2 != "number")
                throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return value;
        }, exports2.assertCompact = function(loc, value) {
          if (value !== void 0 && typeof value != "boolean" && value !== "auto")
            throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
          return value;
        }, exports2.assertConfigApplicableTest = function(loc, value) {
          if (value === void 0)
            return value;
          if (Array.isArray(value))
            value.forEach((item, i) => {
              if (!checkValidTest(item))
                throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
            });
          else if (!checkValidTest(value))
            throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
          return value;
        }, exports2.assertConfigFileSearch = function(loc, value) {
          if (value !== void 0 && typeof value != "boolean" && typeof value != "string")
            throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value)}`);
          return value;
        }, exports2.assertFunction = function(loc, value) {
          if (value !== void 0 && typeof value != "function")
            throw new Error(`${msg(loc)} must be a function, or undefined`);
          return value;
        }, exports2.assertIgnoreList = function(loc, value) {
          const arr = assertArray(loc, value);
          arr && arr.forEach((item, i) => function(loc2, value2) {
            if (typeof value2 != "string" && typeof value2 != "function" && !(value2 instanceof RegExp))
              throw new Error(`${msg(loc2)} must be an array of string/Function/RegExp values, or undefined`);
            return value2;
          }(access(loc, i), item));
          return arr;
        }, exports2.assertInputSourceMap = function(loc, value) {
          if (value !== void 0 && typeof value != "boolean" && (typeof value != "object" || !value))
            throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
          return value;
        }, exports2.assertObject = assertObject, exports2.assertPluginList = function(loc, value) {
          const arr = assertArray(loc, value);
          arr && arr.forEach((item, i) => function(loc2, value2) {
            if (Array.isArray(value2)) {
              if (value2.length === 0)
                throw new Error(`${msg(loc2)} must include an object`);
              if (value2.length > 3)
                throw new Error(`${msg(loc2)} may only be a two-tuple or three-tuple`);
              if (assertPluginTarget(access(loc2, 0), value2[0]), value2.length > 1) {
                const opts = value2[1];
                if (opts !== void 0 && opts !== false && (typeof opts != "object" || Array.isArray(opts) || opts === null))
                  throw new Error(`${msg(access(loc2, 1))} must be an object, false, or undefined`);
              }
              if (value2.length === 3) {
                const name = value2[2];
                if (name !== void 0 && typeof name != "string")
                  throw new Error(`${msg(access(loc2, 2))} must be a string, or undefined`);
              }
            } else
              assertPluginTarget(loc2, value2);
            return value2;
          }(access(loc, i), item));
          return arr;
        }, exports2.assertRootMode = function(loc, value) {
          if (value !== void 0 && value !== "root" && value !== "upward" && value !== "upward-optional")
            throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
          return value;
        }, exports2.assertSourceMaps = function(loc, value) {
          if (value !== void 0 && typeof value != "boolean" && value !== "inline" && value !== "both")
            throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
          return value;
        }, exports2.assertSourceType = function(loc, value) {
          if (value !== void 0 && value !== "module" && value !== "script" && value !== "unambiguous")
            throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
          return value;
        }, exports2.assertString = function(loc, value) {
          if (value !== void 0 && typeof value != "string")
            throw new Error(`${msg(loc)} must be a string, or undefined`);
          return value;
        }, exports2.assertTargets = function(loc, value) {
          if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value))
            return value;
          if (typeof value != "object" || !value || Array.isArray(value))
            throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);
          const browsersLoc = access(loc, "browsers"), esmodulesLoc = access(loc, "esmodules");
          assertBrowsersList(browsersLoc, value.browsers), assertBoolean(esmodulesLoc, value.esmodules);
          for (const key of Object.keys(value)) {
            const val = value[key], subLoc = access(loc, key);
            if (key === "esmodules")
              assertBoolean(subLoc, val);
            else if (key === "browsers")
              assertBrowsersList(subLoc, val);
            else {
              if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {
                const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
                throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
              }
              assertBrowserVersion(subLoc, val);
            }
          }
          return value;
        }, exports2.msg = msg;
        var _options = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/options.js");
        function msg(loc) {
          switch (loc.type) {
            case "root":
              return "";
            case "env":
              return `${msg(loc.parent)}.env["${loc.name}"]`;
            case "overrides":
              return `${msg(loc.parent)}.overrides[${loc.index}]`;
            case "option":
              return `${msg(loc.parent)}.${loc.name}`;
            case "access":
              return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${loc.type}`);
          }
        }
        function access(loc, name) {
          return { type: "access", name, parent: loc };
        }
        function assertBoolean(loc, value) {
          if (value !== void 0 && typeof value != "boolean")
            throw new Error(`${msg(loc)} must be a boolean, or undefined`);
          return value;
        }
        function assertObject(loc, value) {
          if (value !== void 0 && (typeof value != "object" || Array.isArray(value) || !value))
            throw new Error(`${msg(loc)} must be an object, or undefined`);
          return value;
        }
        function assertArray(loc, value) {
          if (value != null && !Array.isArray(value))
            throw new Error(`${msg(loc)} must be an array, or undefined`);
          return value;
        }
        function checkValidTest(value) {
          return typeof value == "string" || typeof value == "function" || value instanceof RegExp;
        }
        function assertPluginTarget(loc, value) {
          if ((typeof value != "object" || !value) && typeof value != "string" && typeof value != "function")
            throw new Error(`${msg(loc)} must be a string, object, function`);
          return value;
        }
        function assertBrowsersList(loc, value) {
          if (value !== void 0 && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value))
            throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);
        }
        function assertBrowserVersion(loc, value) {
          if ((typeof value != "number" || Math.round(value) !== value) && typeof value != "string")
            throw new Error(`${msg(loc)} must be a string or an integer number`);
        }
      }, "./node_modules/@babel/core/lib/config/validation/options.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.assumptionsNames = void 0, exports2.checkNoUnwrappedItemOptionPairs = function(items, index, type, e2) {
          if (index === 0)
            return;
          const lastItem = items[index - 1], thisItem = items[index];
          lastItem.file && lastItem.options === void 0 && typeof thisItem.value == "object" && (e2.message += `
- Maybe you meant to use
"${type}s": [
  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, void 0, 2)}]
]
To be a valid ${type}, its name and options should be wrapped in a pair of brackets`);
        }, exports2.validate = function(type, opts) {
          return validateNested({ type: "root", source: type }, opts);
        };
        __webpack_require__2("./node_modules/@babel/core/lib/config/plugin.js");
        var _removed = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/removed.js"), _optionAssertions = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const ROOT_VALIDATORS = { cwd: _optionAssertions.assertString, root: _optionAssertions.assertString, rootMode: _optionAssertions.assertRootMode, configFile: _optionAssertions.assertConfigFileSearch, caller: _optionAssertions.assertCallerMetadata, filename: _optionAssertions.assertString, filenameRelative: _optionAssertions.assertString, code: _optionAssertions.assertBoolean, ast: _optionAssertions.assertBoolean, cloneInputAst: _optionAssertions.assertBoolean, envName: _optionAssertions.assertString }, BABELRC_VALIDATORS = { babelrc: _optionAssertions.assertBoolean, babelrcRoots: _optionAssertions.assertBabelrcSearch }, NONPRESET_VALIDATORS = { extends: _optionAssertions.assertString, ignore: _optionAssertions.assertIgnoreList, only: _optionAssertions.assertIgnoreList, targets: _optionAssertions.assertTargets, browserslistConfigFile: _optionAssertions.assertConfigFileSearch, browserslistEnv: _optionAssertions.assertString }, COMMON_VALIDATORS = { inputSourceMap: _optionAssertions.assertInputSourceMap, presets: _optionAssertions.assertPluginList, plugins: _optionAssertions.assertPluginList, passPerPreset: _optionAssertions.assertBoolean, assumptions: _optionAssertions.assertAssumptions, env: function(loc, value) {
          if (loc.parent.type === "env")
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
          const parent = loc.parent, obj = (0, _optionAssertions.assertObject)(loc, value);
          if (obj)
            for (const envName of Object.keys(obj)) {
              const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
              if (!env)
                continue;
              validateNested({ type: "env", name: envName, parent }, env);
            }
          return obj;
        }, overrides: function(loc, value) {
          if (loc.parent.type === "env")
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
          if (loc.parent.type === "overrides")
            throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
          const parent = loc.parent, arr = (0, _optionAssertions.assertArray)(loc, value);
          if (arr)
            for (const [index, item] of arr.entries()) {
              const objLoc = (0, _optionAssertions.access)(loc, index), env = (0, _optionAssertions.assertObject)(objLoc, item);
              if (!env)
                throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
              validateNested({ type: "overrides", index, parent }, env);
            }
          return arr;
        }, test: _optionAssertions.assertConfigApplicableTest, include: _optionAssertions.assertConfigApplicableTest, exclude: _optionAssertions.assertConfigApplicableTest, retainLines: _optionAssertions.assertBoolean, comments: _optionAssertions.assertBoolean, shouldPrintComment: _optionAssertions.assertFunction, compact: _optionAssertions.assertCompact, minified: _optionAssertions.assertBoolean, auxiliaryCommentBefore: _optionAssertions.assertString, auxiliaryCommentAfter: _optionAssertions.assertString, sourceType: _optionAssertions.assertSourceType, wrapPluginVisitorMethod: _optionAssertions.assertFunction, highlightCode: _optionAssertions.assertBoolean, sourceMaps: _optionAssertions.assertSourceMaps, sourceMap: _optionAssertions.assertSourceMaps, sourceFileName: _optionAssertions.assertString, sourceRoot: _optionAssertions.assertString, parserOpts: _optionAssertions.assertObject, generatorOpts: _optionAssertions.assertObject };
        Object.assign(COMMON_VALIDATORS, { getModuleId: _optionAssertions.assertFunction, moduleRoot: _optionAssertions.assertString, moduleIds: _optionAssertions.assertBoolean, moduleId: _optionAssertions.assertString });
        const assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function getSource(loc) {
          return loc.type === "root" ? loc.source : getSource(loc.parent);
        }
        function validateNested(loc, opts) {
          const type = getSource(loc);
          return function(opts2) {
            if (has(opts2, "sourceMap") && has(opts2, "sourceMaps"))
              throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          }(opts), Object.keys(opts).forEach((key) => {
            const optLoc = { type: "option", name: key, parent: loc };
            if (type === "preset" && NONPRESET_VALIDATORS[key])
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
            if (type !== "arguments" && ROOT_VALIDATORS[key])
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
            if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
              if (type === "babelrcfile" || type === "extendsfile")
                throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
              throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            }
            (COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError)(optLoc, opts[key]);
          }), opts;
        }
        function throwUnknownError(loc) {
          const key = loc.name;
          if (_removed.default[key]) {
            const { message, version: version3 = 5 } = _removed.default[key];
            throw new Error(`Using removed Babel ${version3} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
          }
          {
            const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw unknownOptErr.code = "BABEL_UNKNOWN_OPTION", unknownOptErr;
          }
        }
        function has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports2.assumptionsNames = assumptionsNames;
      }, "./node_modules/@babel/core/lib/config/validation/plugins.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.validatePluginObject = function(obj) {
          const rootPath = { type: "root", source: "plugin" };
          return Object.keys(obj).forEach((key) => {
            const validator = VALIDATORS[key];
            if (!validator) {
              const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
              throw invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", invalidPluginPropertyError;
            }
            validator({ type: "option", name: key, parent: rootPath }, obj[key]);
          }), obj;
        };
        var _optionAssertions = __webpack_require__2("./node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const VALIDATORS = { name: _optionAssertions.assertString, manipulateOptions: _optionAssertions.assertFunction, pre: _optionAssertions.assertFunction, post: _optionAssertions.assertFunction, inherits: _optionAssertions.assertFunction, visitor: function(loc, value) {
          const obj = (0, _optionAssertions.assertObject)(loc, value);
          if (obj && (Object.keys(obj).forEach((prop) => function(key, value2) {
            if (value2 && typeof value2 == "object")
              Object.keys(value2).forEach((handler) => {
                if (handler !== "enter" && handler !== "exit")
                  throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
              });
            else if (typeof value2 != "function")
              throw new Error(`.visitor["${key}"] must be a function`);
            return value2;
          }(prop, obj[prop])), obj.enter || obj.exit))
            throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return obj;
        }, parserOverride: _optionAssertions.assertFunction, generatorOverride: _optionAssertions.assertFunction };
      }, "./node_modules/@babel/core/lib/config/validation/removed.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        exports2.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/@babel/core/lib/gensync-utils/async.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.forwardAsync = function(action, cb) {
          const g = _gensync()(action);
          return withKind((kind) => {
            const adapted = g[kind];
            return cb(adapted);
          });
        }, exports2.isAsync = void 0, exports2.isThenable = isThenable, exports2.maybeAsync = function(fn, message) {
          return _gensync()({ sync(...args) {
            const result = fn.apply(this, args);
            if (isThenable(result))
              throw new Error(message);
            return result;
          }, async(...args) {
            return Promise.resolve(fn.apply(this, args));
          } });
        }, exports2.waitFor = exports2.onFirstPause = void 0;
        const id = (x) => x, runGenerator = _gensync()(function* (item) {
          return yield* item;
        }), isAsync = _gensync()({ sync: () => false, errback: (cb) => cb(null, true) });
        exports2.isAsync = isAsync;
        const withKind = _gensync()({ sync: (cb) => cb("sync"), async: (cb) => cb("async") });
        const onFirstPause = _gensync()({ name: "onFirstPause", arity: 2, sync: function(item) {
          return runGenerator.sync(item);
        }, errback: function(item, firstPause, cb) {
          let completed = false;
          runGenerator.errback(item, (err, value) => {
            completed = true, cb(err, value);
          }), completed || firstPause();
        } });
        exports2.onFirstPause = onFirstPause;
        const waitFor = _gensync()({ sync: id, async: id });
        function isThenable(val) {
          return !(!val || typeof val != "object" && typeof val != "function" || !val.then || typeof val.then != "function");
        }
        exports2.waitFor = waitFor;
      }, "./node_modules/@babel/core/lib/gensync-utils/fs.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _fs() {
          const data = __webpack_require__2("fs");
          return _fs = function() {
            return data;
          }, data;
        }
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.stat = exports2.readFile = void 0;
        const readFile = _gensync()({ sync: _fs().readFileSync, errback: _fs().readFile });
        exports2.readFile = readFile;
        const stat = _gensync()({ sync: _fs().statSync, errback: _fs().stat });
        exports2.stat = stat;
      }, "./node_modules/@babel/core/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(exports2, "File", { enumerable: true, get: function() {
          return _file.default;
        } }), exports2.OptionManager = void 0, exports2.Plugin = function(alias) {
          throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
        }, Object.defineProperty(exports2, "buildExternalHelpers", { enumerable: true, get: function() {
          return _buildExternalHelpers.default;
        } }), Object.defineProperty(exports2, "createConfigItem", { enumerable: true, get: function() {
          return _config.createConfigItem;
        } }), Object.defineProperty(exports2, "createConfigItemAsync", { enumerable: true, get: function() {
          return _config.createConfigItemAsync;
        } }), Object.defineProperty(exports2, "createConfigItemSync", { enumerable: true, get: function() {
          return _config.createConfigItemSync;
        } }), Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
          return _environment.getEnv;
        } }), Object.defineProperty(exports2, "loadOptions", { enumerable: true, get: function() {
          return _config.loadOptions;
        } }), Object.defineProperty(exports2, "loadOptionsAsync", { enumerable: true, get: function() {
          return _config.loadOptionsAsync;
        } }), Object.defineProperty(exports2, "loadOptionsSync", { enumerable: true, get: function() {
          return _config.loadOptionsSync;
        } }), Object.defineProperty(exports2, "loadPartialConfig", { enumerable: true, get: function() {
          return _config.loadPartialConfig;
        } }), Object.defineProperty(exports2, "loadPartialConfigAsync", { enumerable: true, get: function() {
          return _config.loadPartialConfigAsync;
        } }), Object.defineProperty(exports2, "loadPartialConfigSync", { enumerable: true, get: function() {
          return _config.loadPartialConfigSync;
        } }), Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
          return _parse.parse;
        } }), Object.defineProperty(exports2, "parseAsync", { enumerable: true, get: function() {
          return _parse.parseAsync;
        } }), Object.defineProperty(exports2, "parseSync", { enumerable: true, get: function() {
          return _parse.parseSync;
        } }), Object.defineProperty(exports2, "resolvePlugin", { enumerable: true, get: function() {
          return _files.resolvePlugin;
        } }), Object.defineProperty(exports2, "resolvePreset", { enumerable: true, get: function() {
          return _files.resolvePreset;
        } }), Object.defineProperty(exports2, "template", { enumerable: true, get: function() {
          return _template().default;
        } }), Object.defineProperty(exports2, "tokTypes", { enumerable: true, get: function() {
          return _parser().tokTypes;
        } }), Object.defineProperty(exports2, "transform", { enumerable: true, get: function() {
          return _transform.transform;
        } }), Object.defineProperty(exports2, "transformAsync", { enumerable: true, get: function() {
          return _transform.transformAsync;
        } }), Object.defineProperty(exports2, "transformFile", { enumerable: true, get: function() {
          return _transformFile.transformFile;
        } }), Object.defineProperty(exports2, "transformFileAsync", { enumerable: true, get: function() {
          return _transformFile.transformFileAsync;
        } }), Object.defineProperty(exports2, "transformFileSync", { enumerable: true, get: function() {
          return _transformFile.transformFileSync;
        } }), Object.defineProperty(exports2, "transformFromAst", { enumerable: true, get: function() {
          return _transformAst.transformFromAst;
        } }), Object.defineProperty(exports2, "transformFromAstAsync", { enumerable: true, get: function() {
          return _transformAst.transformFromAstAsync;
        } }), Object.defineProperty(exports2, "transformFromAstSync", { enumerable: true, get: function() {
          return _transformAst.transformFromAstSync;
        } }), Object.defineProperty(exports2, "transformSync", { enumerable: true, get: function() {
          return _transform.transformSync;
        } }), Object.defineProperty(exports2, "traverse", { enumerable: true, get: function() {
          return _traverse().default;
        } }), exports2.version = exports2.types = void 0;
        var _file = __webpack_require__2("./node_modules/@babel/core/lib/transformation/file/file.js"), _buildExternalHelpers = __webpack_require__2("./node_modules/@babel/core/lib/tools/build-external-helpers.js"), _files = __webpack_require__2("./node_modules/@babel/core/lib/config/files/index.js"), _environment = __webpack_require__2("./node_modules/@babel/core/lib/config/helpers/environment.js");
        function _types() {
          const data = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
          return _types = function() {
            return data;
          }, data;
        }
        function _parser() {
          const data = __webpack_require__2("./node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return data;
          }, data;
        }
        function _traverse() {
          const data = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data;
          }, data;
        }
        function _template() {
          const data = __webpack_require__2("./node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "types", { enumerable: true, get: function() {
          return _types();
        } });
        var _config = __webpack_require__2("./node_modules/@babel/core/lib/config/index.js"), _transform = __webpack_require__2("./node_modules/@babel/core/lib/transform.js"), _transformFile = __webpack_require__2("./node_modules/@babel/core/lib/transform-file.js"), _transformAst = __webpack_require__2("./node_modules/@babel/core/lib/transform-ast.js"), _parse = __webpack_require__2("./node_modules/@babel/core/lib/parse.js");
        exports2.version = "7.16.12";
        const DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
        exports2.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;
        exports2.OptionManager = class {
          init(opts) {
            return (0, _config.loadOptions)(opts);
          }
        };
      }, "./node_modules/@babel/core/lib/parse.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.parseSync = exports2.parseAsync = exports2.parse = void 0;
        var _config = __webpack_require__2("./node_modules/@babel/core/lib/config/index.js"), _parser = __webpack_require__2("./node_modules/@babel/core/lib/parser/index.js"), _normalizeOpts = __webpack_require__2("./node_modules/@babel/core/lib/transformation/normalize-opts.js");
        const parseRunner = _gensync()(function* (code, opts) {
          const config = yield* (0, _config.default)(opts);
          return config === null ? null : yield* (0, _parser.default)(config.passes, (0, _normalizeOpts.default)(config), code);
        });
        exports2.parse = function(code, opts, callback) {
          if (typeof opts == "function" && (callback = opts, opts = void 0), callback === void 0)
            return parseRunner.sync(code, opts);
          parseRunner.errback(code, opts, callback);
        };
        const parseSync = parseRunner.sync;
        exports2.parseSync = parseSync;
        const parseAsync = parseRunner.async;
        exports2.parseAsync = parseAsync;
      }, "./node_modules/@babel/core/lib/parser/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _parser() {
          const data = __webpack_require__2("./node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return data;
          }, data;
        }
        function _codeFrame() {
          const data = __webpack_require__2("./stubs/babel_codeframe.js");
          return _codeFrame = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function* (pluginPasses, { parserOpts, highlightCode = true, filename = "unknown" }, code) {
          try {
            const results = [];
            for (const plugins of pluginPasses)
              for (const plugin of plugins) {
                const { parserOverride } = plugin;
                if (parserOverride) {
                  const ast = parserOverride(code, parserOpts, _parser().parse);
                  ast !== void 0 && results.push(ast);
                }
              }
            if (results.length === 0)
              return (0, _parser().parse)(code, parserOpts);
            if (results.length === 1) {
              if (yield* [], typeof results[0].then == "function")
                throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return results[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (err) {
            err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
            const { loc, missingPlugin } = err;
            if (loc) {
              const codeFrame = (0, _codeFrame().codeFrameColumns)(code, { start: { line: loc.line, column: loc.column + 1 } }, { highlightCode });
              err.message = missingPlugin ? `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame) : `${filename}: ${err.message}

` + codeFrame, err.code = "BABEL_PARSE_ERROR";
            }
            throw err;
          }
        };
        var _missingPluginHelper = __webpack_require__2("./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(missingPluginName, loc, codeFrame) {
          let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column + 1}):

` + codeFrame;
          const pluginInfo = pluginNameMap[missingPluginName];
          if (pluginInfo) {
            const { syntax: syntaxPlugin, transform: transformPlugin } = pluginInfo;
            if (syntaxPlugin) {
              const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
              if (transformPlugin) {
                const transformPluginInfo = getNameURLCombination(transformPlugin), sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
                helpMessage += `

Add ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;
              } else
                helpMessage += `

Add ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return helpMessage;
        };
        const pluginNameMap = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://git.io/JYer8" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-class-properties", url: "https://git.io/vb4SL" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-class-properties", url: "https://git.io/vb4SL" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-private-methods", url: "https://git.io/JvpRG" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://git.io/JTLB6" }, transform: { name: "@babel/plugin-proposal-class-static-block", url: "https://git.io/JTLBP" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://git.io/JfKOH" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://git.io/vb4y9" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://git.io/vb4ST" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://git.io/vb4yh" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://git.io/vb4S3" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://git.io/vb4Sv" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://git.io/vb4SO" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://git.io/vb4yH" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://git.io/vb4Sf" }, transform: { name: "@babel/plugin-proposal-export-namespace-from", url: "https://git.io/vb4SG" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://git.io/vb4yb" }, transform: { name: "@babel/preset-flow", url: "https://git.io/JfeDn" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://git.io/vb4y7" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://git.io/vb4St" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://git.io/vb4yN" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://git.io/vb4SZ" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://git.io/vbKK6" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://git.io/vb4yA" }, transform: { name: "@babel/preset-react", url: "https://git.io/JfeDR" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://git.io/JUbkv" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://git.io/JTL8G" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://git.io/vb4Sq" }, transform: { name: "@babel/plugin-proposal-numeric-separator", url: "https://git.io/vb4yS" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://git.io/vb4Sc" }, transform: { name: "@babel/plugin-proposal-optional-chaining", url: "https://git.io/vb4Sk" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://git.io/vb4yj" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://git.io/vb4SU" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://git.io/JfK3q" }, transform: { name: "@babel/plugin-proposal-private-property-in-object", url: "https://git.io/JfK3O" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://git.io/JvKp3" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://git.io/vb4SJ" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://git.io/vb4yF" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://git.io/vb4SC" }, transform: { name: "@babel/preset-typescript", url: "https://git.io/JfeDz" } }, asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://git.io/vb4SY" }, transform: { name: "@babel/plugin-proposal-async-generator-functions", url: "https://git.io/vb4yp" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://git.io/vAlBp" }, transform: { name: "@babel/plugin-proposal-logical-assignment-operators", url: "https://git.io/vAlRe" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://git.io/vb4yx" }, transform: { name: "@babel/plugin-proposal-nullish-coalescing-operator", url: "https://git.io/vb4Se" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://git.io/vb4y5" }, transform: { name: "@babel/plugin-proposal-object-rest-spread", url: "https://git.io/vb4Ss" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://git.io/vb4Sn" }, transform: { name: "@babel/plugin-proposal-optional-catch-binding", url: "https://git.io/vb4SI" } } };
        pluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform;
        const getNameURLCombination = ({ name, url }) => `${name} (${url})`;
      }, "./node_modules/@babel/core/lib/tools/build-external-helpers.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function helpers() {
          const data = __webpack_require__2("./node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return data;
          }, data;
        }
        function _generator() {
          const data = __webpack_require__2("./node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return data;
          }, data;
        }
        function _template() {
          const data = __webpack_require__2("./node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return data;
          }, data;
        }
        function _t() {
          const data = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(allowlist, outputType = "global") {
          let tree;
          const build = { global: buildGlobal, module: buildModule, umd: buildUmd, var: buildVar }[outputType];
          if (!build)
            throw new Error(`Unsupported output type ${outputType}`);
          tree = build(allowlist);
          return (0, _generator().default)(tree).code;
        };
        var _file = __webpack_require__2("./node_modules/@babel/core/lib/transformation/file/file.js");
        const { arrayExpression, assignmentExpression, binaryExpression, blockStatement, callExpression, cloneNode, conditionalExpression, exportNamedDeclaration, exportSpecifier, expressionStatement, functionExpression, identifier, memberExpression, objectExpression, program, stringLiteral, unaryExpression, variableDeclaration, variableDeclarator } = _t();
        function buildGlobal(allowlist) {
          const namespace = identifier("babelHelpers"), body = [], container = functionExpression(null, [identifier("global")], blockStatement(body)), tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
          return body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))])), buildHelpers(body, namespace, allowlist), tree;
        }
        function buildModule(allowlist) {
          const body = [], refs = buildHelpers(body, null, allowlist);
          return body.unshift(exportNamedDeclaration(null, Object.keys(refs).map((name) => exportSpecifier(cloneNode(refs[name]), identifier(name))))), program(body, [], "module");
        }
        function buildUmd(allowlist) {
          const namespace = identifier("babelHelpers"), body = [];
          return body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))])), buildHelpers(body, namespace, allowlist), program([(replacements = { FACTORY_PARAMETERS: identifier("global"), BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])), COMMON_ARGUMENTS: identifier("exports"), AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]), FACTORY_BODY: body, UMD_ROOT: identifier("this") }, _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements))]);
          var replacements;
        }
        function buildVar(allowlist) {
          const namespace = identifier("babelHelpers"), body = [];
          body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
          const tree = program(body);
          return buildHelpers(body, namespace, allowlist), body.push(expressionStatement(namespace)), tree;
        }
        function buildHelpers(body, namespace, allowlist) {
          const getHelperReference = (name) => namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`), refs = {};
          return helpers().list.forEach(function(name) {
            if (allowlist && allowlist.indexOf(name) < 0)
              return;
            const ref = refs[name] = getHelperReference(name);
            helpers().ensure(name, _file.default);
            const { nodes } = helpers().get(name, getHelperReference, ref);
            body.push(...nodes);
          }), refs;
        }
      }, "./node_modules/@babel/core/lib/transform-ast.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.transformFromAstSync = exports2.transformFromAstAsync = exports2.transformFromAst = void 0;
        var _config = __webpack_require__2("./node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/@babel/core/lib/transformation/index.js");
        const transformFromAstRunner = _gensync()(function* (ast, code, opts) {
          const config = yield* (0, _config.default)(opts);
          if (config === null)
            return null;
          if (!ast)
            throw new Error("No AST given");
          return yield* (0, _transformation.run)(config, code, ast);
        });
        exports2.transformFromAst = function(ast, code, opts, callback) {
          if (typeof opts == "function" && (callback = opts, opts = void 0), callback === void 0)
            return transformFromAstRunner.sync(ast, code, opts);
          transformFromAstRunner.errback(ast, code, opts, callback);
        };
        const transformFromAstSync = transformFromAstRunner.sync;
        exports2.transformFromAstSync = transformFromAstSync;
        const transformFromAstAsync = transformFromAstRunner.async;
        exports2.transformFromAstAsync = transformFromAstAsync;
      }, "./node_modules/@babel/core/lib/transform-file.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.transformFileSync = exports2.transformFileAsync = exports2.transformFile = void 0;
        var _config = __webpack_require__2("./node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/@babel/core/lib/transformation/index.js"), fs3 = __webpack_require__2("./node_modules/@babel/core/lib/gensync-utils/fs.js");
        const transformFileRunner = _gensync()(function* (filename, opts) {
          const options = Object.assign({}, opts, { filename }), config = yield* (0, _config.default)(options);
          if (config === null)
            return null;
          const code = yield* fs3.readFile(filename, "utf8");
          return yield* (0, _transformation.run)(config, code);
        }), transformFile = transformFileRunner.errback;
        exports2.transformFile = transformFile;
        const transformFileSync = transformFileRunner.sync;
        exports2.transformFileSync = transformFileSync;
        const transformFileAsync = transformFileRunner.async;
        exports2.transformFileAsync = transformFileAsync;
      }, "./node_modules/@babel/core/lib/transform.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _gensync() {
          const data = __webpack_require__2("./node_modules/gensync/index.js");
          return _gensync = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.transformSync = exports2.transformAsync = exports2.transform = void 0;
        var _config = __webpack_require__2("./node_modules/@babel/core/lib/config/index.js"), _transformation = __webpack_require__2("./node_modules/@babel/core/lib/transformation/index.js");
        const transformRunner = _gensync()(function* (code, opts) {
          const config = yield* (0, _config.default)(opts);
          return config === null ? null : yield* (0, _transformation.run)(config, code);
        });
        exports2.transform = function(code, opts, callback) {
          if (typeof opts == "function" && (callback = opts, opts = void 0), callback === void 0)
            return transformRunner.sync(code, opts);
          transformRunner.errback(code, opts, callback);
        };
        const transformSync = transformRunner.sync;
        exports2.transformSync = transformSync;
        const transformAsync = transformRunner.async;
        exports2.transformAsync = transformAsync;
      }, "./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _traverse() {
          const data = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function() {
          LOADED_PLUGIN || (LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, { visitor: _traverse().default.explode(blockHoistPlugin.visitor) }), {}));
          return LOADED_PLUGIN;
        };
        var _plugin = __webpack_require__2("./node_modules/@babel/core/lib/config/plugin.js");
        let LOADED_PLUGIN;
        function priority(bodyNode) {
          const priority2 = bodyNode == null ? void 0 : bodyNode._blockHoist;
          return priority2 == null ? 1 : priority2 === true ? 2 : priority2;
        }
        const blockHoistPlugin = { name: "internal.blockHoist", visitor: { Block: { exit({ node }) {
          const { body } = node;
          let max = Math.pow(2, 30) - 1, hasChange = false;
          for (let i = 0; i < body.length; i++) {
            const p = priority(body[i]);
            if (p > max) {
              hasChange = true;
              break;
            }
            max = p;
          }
          hasChange && (node.body = function(body2) {
            const buckets = /* @__PURE__ */ Object.create(null);
            for (let i = 0; i < body2.length; i++) {
              const n = body2[i], p = priority(n);
              (buckets[p] || (buckets[p] = [])).push(n);
            }
            const keys = Object.keys(buckets).map((k) => +k).sort((a, b) => b - a);
            let index = 0;
            for (const key of keys) {
              const bucket = buckets[key];
              for (const n of bucket)
                body2[index++] = n;
            }
            return body2;
          }(body.slice()));
        } } } };
      }, "./node_modules/@babel/core/lib/transformation/file/file.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function helpers() {
          const data = __webpack_require__2("./node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return data;
          }, data;
        }
        function _traverse() {
          const data = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data;
          }, data;
        }
        function _codeFrame() {
          const data = __webpack_require__2("./stubs/babel_codeframe.js");
          return _codeFrame = function() {
            return data;
          }, data;
        }
        function _t() {
          const data = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data;
          }, data;
        }
        function _helperModuleTransforms() {
          const data = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/index.js");
          return _helperModuleTransforms = function() {
            return data;
          }, data;
        }
        function _semver() {
          const data = __webpack_require__2("./node_modules/@babel/core/node_modules/semver/semver.js");
          return _semver = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        const { cloneNode, interpreterDirective } = _t(), errorVisitor = { enter(path, state) {
          const loc = path.node.loc;
          loc && (state.loc = loc, path.stop());
        } };
        class File {
          constructor(options, { code, ast, inputMap }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = null, this.ast = {}, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = null, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = options, this.code = code, this.ast = ast, this.inputMap = inputMap, this.path = _traverse().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter } = this.path.node;
            return interpreter ? interpreter.value : "";
          }
          set shebang(value) {
            value ? this.path.get("interpreter").replaceWith(interpreterDirective(value)) : this.path.get("interpreter").remove();
          }
          set(key, val) {
            if (key === "helpersNamespace")
              throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(key, val);
          }
          get(key) {
            return this._map.get(key);
          }
          has(key) {
            return this._map.has(key);
          }
          getModuleName() {
            return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);
          }
          addImport() {
            throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
          }
          availableHelper(name, versionRange) {
            let minVersion;
            try {
              minVersion = helpers().minVersion(name);
            } catch (err) {
              if (err.code !== "BABEL_HELPER_UNKNOWN")
                throw err;
              return false;
            }
            return typeof versionRange != "string" || (_semver().valid(versionRange) && (versionRange = `^${versionRange}`), !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(">=8.0.0", versionRange));
          }
          addHelper(name) {
            const declar = this.declarations[name];
            if (declar)
              return cloneNode(declar);
            const generator = this.get("helperGenerator");
            if (generator) {
              const res = generator(name);
              if (res)
                return res;
            }
            helpers().ensure(name, File);
            const uid = this.declarations[name] = this.scope.generateUidIdentifier(name), dependencies = {};
            for (const dep of helpers().getDependencies(name))
              dependencies[dep] = this.addHelper(dep);
            const { nodes, globals } = helpers().get(name, (dep) => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));
            return globals.forEach((name2) => {
              this.path.scope.hasBinding(name2, true) && this.path.scope.rename(name2);
            }), nodes.forEach((node) => {
              node._compact = true;
            }), this.path.unshiftContainer("body", nodes), this.path.get("body").forEach((path) => {
              nodes.indexOf(path.node) !== -1 && path.isVariableDeclaration() && this.scope.registerDeclaration(path);
            }), uid;
          }
          addTemplateObject() {
            throw new Error("This function has been moved into the template literal transform itself.");
          }
          buildCodeFrameError(node, msg, _Error = SyntaxError) {
            let loc = node && (node.loc || node._loc);
            if (!loc && node) {
              const state = { loc: null };
              (0, _traverse().default)(node, errorVisitor, this.scope, state), loc = state.loc;
              let txt = "This is an error on an internal node. Probably an internal error.";
              loc && (txt += " Location has been estimated."), msg += ` (${txt})`;
            }
            if (loc) {
              const { highlightCode = true } = this.opts;
              msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, { start: { line: loc.start.line, column: loc.start.column + 1 }, end: loc.end && loc.start.line === loc.end.line ? { line: loc.end.line, column: loc.end.column + 1 } : void 0 }, { highlightCode });
            }
            return new _Error(msg);
          }
        }
        exports2.default = File;
      }, "./node_modules/@babel/core/lib/transformation/file/generate.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _convertSourceMap() {
          const data = __webpack_require__2("./node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return data;
          }, data;
        }
        function _generator() {
          const data = __webpack_require__2("./node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(pluginPasses, file) {
          const { opts, ast, code, inputMap } = file, results = [];
          for (const plugins of pluginPasses)
            for (const plugin of plugins) {
              const { generatorOverride } = plugin;
              if (generatorOverride) {
                const result2 = generatorOverride(ast, opts.generatorOpts, code, _generator().default);
                result2 !== void 0 && results.push(result2);
              }
            }
          let result;
          if (results.length === 0)
            result = (0, _generator().default)(ast, opts.generatorOpts, code);
          else {
            if (results.length !== 1)
              throw new Error("More than one plugin attempted to override codegen.");
            if (result = results[0], typeof result.then == "function")
              throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: outputCode, map: outputMap } = result;
          outputMap && inputMap && (outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap));
          opts.sourceMaps !== "inline" && opts.sourceMaps !== "both" || (outputCode += "\n" + _convertSourceMap().fromObject(outputMap).toComment());
          opts.sourceMaps === "inline" && (outputMap = null);
          return { outputCode, outputMap };
        };
        var _mergeMap = __webpack_require__2("./node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/@babel/core/lib/transformation/file/merge-map.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _sourceMap() {
          const data = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/source-map.js");
          return _sourceMap = function() {
            return data;
          }, data;
        }
        function makeMappingKey(item) {
          return `${item.line}/${item.columnStart}`;
        }
        function buildMappingData(map) {
          const consumer = new (_sourceMap()).SourceMapConsumer(Object.assign({}, map, { sourceRoot: null })), sources = /* @__PURE__ */ new Map(), mappings = /* @__PURE__ */ new Map();
          let last = null;
          return consumer.computeColumnSpans(), consumer.eachMapping((m) => {
            if (m.originalLine === null)
              return;
            let source = sources.get(m.source);
            source || (source = { path: m.source, content: consumer.sourceContentFor(m.source, true) }, sources.set(m.source, source));
            let sourceData = mappings.get(source);
            sourceData || (sourceData = { source, mappings: [] }, mappings.set(source, sourceData));
            const obj = { line: m.originalLine, columnStart: m.originalColumn, columnEnd: 1 / 0, name: m.name };
            last && last.source === source && last.mapping.line === m.originalLine && (last.mapping.columnEnd = m.originalColumn), last = { source, mapping: obj }, sourceData.mappings.push({ original: obj, generated: consumer.allGeneratedPositionsFor({ source: m.source, line: m.originalLine, column: m.originalColumn }).map((item) => ({ line: item.line, columnStart: item.column, columnEnd: item.lastColumn + 1 })) });
          }, null, _sourceMap().SourceMapConsumer.ORIGINAL_ORDER), { file: map.file, sourceRoot: map.sourceRoot, sources: Array.from(mappings.values()) };
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(inputMap, map) {
          const input = buildMappingData(inputMap), output = buildMappingData(map), mergedGenerator = new (_sourceMap()).SourceMapGenerator();
          for (const { source } of input.sources)
            typeof source.content == "string" && mergedGenerator.setSourceContent(source.path, source.content);
          if (output.sources.length === 1) {
            const defaultSource = output.sources[0], insertedMappings = /* @__PURE__ */ new Map();
            !function(map2, callback) {
              for (const { source, mappings } of map2.sources)
                for (const { original, generated } of mappings)
                  for (const item of generated)
                    callback(item, original, source);
            }(input, (generated, original, source) => {
              !function(outputFile, inputGeneratedRange, callback) {
                const overlappingOriginal = function({ mappings }, { line, columnStart, columnEnd }) {
                  return function(array, callback2) {
                    const start = function(array2, callback3) {
                      let left = 0, right = array2.length;
                      for (; left < right; ) {
                        const mid = Math.floor((left + right) / 2), result2 = callback3(array2[mid]);
                        if (result2 === 0) {
                          left = mid;
                          break;
                        }
                        result2 >= 0 ? right = mid : left = mid + 1;
                      }
                      let i = left;
                      if (i < array2.length) {
                        for (; i >= 0 && callback3(array2[i]) >= 0; )
                          i--;
                        return i + 1;
                      }
                      return i;
                    }(array, callback2), results = [];
                    for (let i = start; i < array.length && callback2(array[i]) === 0; i++)
                      results.push(array[i]);
                    return results;
                  }(mappings, ({ original: outOriginal }) => line > outOriginal.line ? -1 : line < outOriginal.line ? 1 : columnStart >= outOriginal.columnEnd ? -1 : columnEnd <= outOriginal.columnStart ? 1 : 0);
                }(outputFile, inputGeneratedRange);
                for (const { generated: generated2 } of overlappingOriginal)
                  for (const item of generated2)
                    callback(item);
              }(defaultSource, generated, (item) => {
                const key = makeMappingKey(item);
                insertedMappings.has(key) || (insertedMappings.set(key, item), mergedGenerator.addMapping({ source: source.path, original: { line: original.line, column: original.columnStart }, generated: { line: item.line, column: item.columnStart }, name: original.name }));
              });
            });
            for (const item of insertedMappings.values()) {
              if (item.columnEnd === 1 / 0)
                continue;
              const clearItem = { line: item.line, columnStart: item.columnEnd }, key = makeMappingKey(clearItem);
              insertedMappings.has(key) || mergedGenerator.addMapping({ generated: { line: clearItem.line, column: clearItem.columnStart } });
            }
          }
          const result = mergedGenerator.toJSON();
          typeof input.sourceRoot == "string" && (result.sourceRoot = input.sourceRoot);
          return result;
        };
      }, "./node_modules/@babel/core/lib/transformation/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _traverse() {
          const data = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.run = function* (config, code, ast) {
          const file = yield* (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast), opts = file.opts;
          try {
            yield* function* (file2, pluginPasses) {
              for (const pluginPairs of pluginPasses) {
                const passPairs = [], passes = [], visitors = [];
                for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
                  const pass = new _pluginPass.default(file2, plugin.key, plugin.options);
                  passPairs.push([plugin, pass]), passes.push(pass), visitors.push(plugin.visitor);
                }
                for (const [plugin, pass] of passPairs) {
                  const fn = plugin.pre;
                  if (fn) {
                    const result = fn.call(pass, file2);
                    if (yield* [], isThenable(result))
                      throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
                const visitor = _traverse().default.visitors.merge(visitors, passes, file2.opts.wrapPluginVisitorMethod);
                (0, _traverse().default)(file2.ast, visitor, file2.scope);
                for (const [plugin, pass] of passPairs) {
                  const fn = plugin.post;
                  if (fn) {
                    const result = fn.call(pass, file2);
                    if (yield* [], isThenable(result))
                      throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
              }
            }(file, config.passes);
          } catch (e2) {
            var _opts$filename;
            throw e2.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : "unknown"}: ${e2.message}`, e2.code || (e2.code = "BABEL_TRANSFORM_ERROR"), e2;
          }
          let outputCode, outputMap;
          try {
            opts.code !== false && ({ outputCode, outputMap } = (0, _generate.default)(config.passes, file));
          } catch (e2) {
            var _opts$filename2;
            throw e2.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown"}: ${e2.message}`, e2.code || (e2.code = "BABEL_GENERATE_ERROR"), e2;
          }
          return { metadata: file.metadata, options: opts, ast: opts.ast === true ? file.ast : null, code: outputCode === void 0 ? null : outputCode, map: outputMap === void 0 ? null : outputMap, sourceType: file.ast.program.sourceType };
        };
        var _pluginPass = __webpack_require__2("./node_modules/@babel/core/lib/transformation/plugin-pass.js"), _blockHoistPlugin = __webpack_require__2("./node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), _normalizeOpts = __webpack_require__2("./node_modules/@babel/core/lib/transformation/normalize-opts.js"), _normalizeFile = __webpack_require__2("./node_modules/@babel/core/lib/transformation/normalize-file.js"), _generate = __webpack_require__2("./node_modules/@babel/core/lib/transformation/file/generate.js");
        function isThenable(val) {
          return !(!val || typeof val != "object" && typeof val != "function" || !val.then || typeof val.then != "function");
        }
      }, "./node_modules/@babel/core/lib/transformation/normalize-file.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _fs() {
          const data = __webpack_require__2("fs");
          return _fs = function() {
            return data;
          }, data;
        }
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _debug() {
          const data = __webpack_require__2("./node_modules/debug/src/index.js");
          return _debug = function() {
            return data;
          }, data;
        }
        function _t() {
          const data = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return data;
          }, data;
        }
        function _convertSourceMap() {
          const data = __webpack_require__2("./node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function* (pluginPasses, options, code, ast) {
          if (code = `${code || ""}`, ast) {
            if (ast.type === "Program")
              ast = file(ast, [], []);
            else if (ast.type !== "File")
              throw new Error("AST root must be a Program or File node");
            options.cloneInputAst && (ast = (0, _cloneDeep.default)(ast));
          } else
            ast = yield* (0, _parser.default)(pluginPasses, options, code);
          let inputMap = null;
          if (options.inputSourceMap !== false) {
            if (typeof options.inputSourceMap == "object" && (inputMap = _convertSourceMap().fromObject(options.inputSourceMap)), !inputMap) {
              const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
              if (lastComment)
                try {
                  inputMap = _convertSourceMap().fromComment(lastComment);
                } catch (err) {
                  debug("discarding unknown inline input sourcemap", err);
                }
            }
            if (!inputMap) {
              const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
              if (typeof options.filename == "string" && lastComment)
                try {
                  const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment), inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));
                  inputMapContent.length > 1e6 ? debug("skip merging input map > 1 MB") : inputMap = _convertSourceMap().fromJSON(inputMapContent);
                } catch (err) {
                  debug("discarding unknown file input sourcemap", err);
                }
              else
                lastComment && debug("discarding un-loadable file input sourcemap");
            }
          }
          return new _file.default(options, { code, ast, inputMap });
        };
        var _file = __webpack_require__2("./node_modules/@babel/core/lib/transformation/file/file.js"), _parser = __webpack_require__2("./node_modules/@babel/core/lib/parser/index.js"), _cloneDeep = __webpack_require__2("./node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file, traverseFast } = _t(), debug = _debug()("babel:transform:file");
        const INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function extractCommentsFromList(regex, comments, lastComment) {
          return comments && (comments = comments.filter(({ value }) => !regex.test(value) || (lastComment = value, false))), [comments, lastComment];
        }
        function extractComments(regex, ast) {
          let lastComment = null;
          return traverseFast(ast, (node) => {
            [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment), [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment), [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);
          }), lastComment;
        }
      }, "./node_modules/@babel/core/lib/transformation/normalize-opts.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(config) {
          const { filename, cwd, filenameRelative = typeof filename == "string" ? _path().relative(cwd, filename) : "unknown", sourceType = "module", inputSourceMap, sourceMaps = !!inputSourceMap, sourceRoot = config.options.moduleRoot, sourceFileName = _path().basename(filenameRelative), comments = true, compact = "auto" } = config.options, opts = config.options, options = Object.assign({}, opts, { parserOpts: Object.assign({ sourceType: _path().extname(filenameRelative) === ".mjs" ? "module" : sourceType, sourceFileName: filename, plugins: [] }, opts.parserOpts), generatorOpts: Object.assign({ filename, auxiliaryCommentBefore: opts.auxiliaryCommentBefore, auxiliaryCommentAfter: opts.auxiliaryCommentAfter, retainLines: opts.retainLines, comments, shouldPrintComment: opts.shouldPrintComment, compact, minified: opts.minified, sourceMaps, sourceRoot, sourceFileName }, opts.generatorOpts) });
          for (const plugins of config.passes)
            for (const plugin of plugins)
              plugin.manipulateOptions && plugin.manipulateOptions(options, options.parserOpts);
          return options;
        };
      }, "./node_modules/@babel/core/lib/transformation/plugin-pass.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        class PluginPass {
          constructor(file, key, options) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = key, this.file = file, this.opts = options || {}, this.cwd = file.opts.cwd, this.filename = file.opts.filename;
          }
          set(key, val) {
            this._map.set(key, val);
          }
          get(key) {
            return this._map.get(key);
          }
          availableHelper(name, versionRange) {
            return this.file.availableHelper(name, versionRange);
          }
          addHelper(name) {
            return this.file.addHelper(name);
          }
          addImport() {
            return this.file.addImport();
          }
          buildCodeFrameError(node, msg, _Error) {
            return this.file.buildCodeFrameError(node, msg, _Error);
          }
        }
        exports2.default = PluginPass, PluginPass.prototype.getModuleName = function() {
          return this.file.getModuleName();
        };
      }, "./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(value) {
          return JSON.parse(JSON.stringify(value, serialize), revive);
        };
        const serialized = "$$ babel internal serialized type" + Math.random();
        function serialize(key, value) {
          return typeof value != "bigint" ? value : { [serialized]: "BigInt", value: value.toString() };
        }
        function revive(key, value) {
          return value && typeof value == "object" ? value[serialized] !== "BigInt" ? value : BigInt(value.value) : value;
        }
      }, "./node_modules/@babel/core/lib/transformation/util/clone-deep.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _v() {
          const data = __webpack_require__2("v8");
          return _v = function() {
            return data;
          }, data;
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(value) {
          if (_v().deserialize && _v().serialize)
            return _v().deserialize(_v().serialize(value));
          return (0, _cloneDeepBrowser.default)(value);
        };
        var _cloneDeepBrowser = __webpack_require__2("./node_modules/@babel/core/lib/transformation/util/clone-deep-browser.js");
      }, "./node_modules/@babel/core/lib/vendor/import-meta-resolve.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _url() {
          const data = __webpack_require__2("url");
          return _url = function() {
            return data;
          }, data;
        }
        function _fs() {
          const data = function(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule)
              return obj;
            if (obj === null || typeof obj != "object" && typeof obj != "function")
              return { default: obj };
            var cache2 = _getRequireWildcardCache(nodeInterop);
            if (cache2 && cache2.has(obj))
              return cache2.get(obj);
            var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var key in obj)
              if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
              }
            newObj.default = obj, cache2 && cache2.set(obj, newObj);
            return newObj;
          }(__webpack_require__2("fs"), true);
          return _fs = function() {
            return data;
          }, data;
        }
        function _path() {
          const data = __webpack_require__2("path");
          return _path = function() {
            return data;
          }, data;
        }
        function _assert() {
          const data = __webpack_require__2("assert");
          return _assert = function() {
            return data;
          }, data;
        }
        function _util() {
          const data = __webpack_require__2("util");
          return _util = function() {
            return data;
          }, data;
        }
        function _getRequireWildcardCache(nodeInterop) {
          if (typeof WeakMap != "function")
            return null;
          var cacheBabelInterop = /* @__PURE__ */ new WeakMap(), cacheNodeInterop = /* @__PURE__ */ new WeakMap();
          return (_getRequireWildcardCache = function(nodeInterop2) {
            return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
          })(nodeInterop);
        }
        function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg), value = info.value;
          } catch (error) {
            return void reject(error);
          }
          info.done ? resolve5(value) : Promise.resolve(value).then(_next, _throw);
        }
        function _asyncToGenerator(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve5, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.moduleResolve = moduleResolve, exports2.resolve = function(_x, _x2) {
          return _resolve.apply(this, arguments);
        };
        var constants2 = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 };
        var debug_1 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
        }, re_1 = function(fn) {
          var module3 = { exports: {} };
          return fn(module3, module3.exports), module3.exports;
        }(function(module3, exports3) {
          const { MAX_SAFE_COMPONENT_LENGTH } = constants2, re2 = (exports3 = module3.exports = {}).re = [], src = exports3.src = [], t2 = exports3.t = {};
          let R = 0;
          const createToken = (name, value, isGlobal) => {
            const index = R++;
            debug_1(index, value), t2[name] = index, src[index] = value, re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
          };
          createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`), createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`), createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`), createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`), createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`), createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`), createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`), createToken("FULL", `^${src[t2.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`), createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`), createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), createToken("COERCERTL", src[t2.COERCE], true), createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true), exports3.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true), exports3.caretTrimReplace = "$1^", createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`), createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true), exports3.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`), createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`), createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        });
        const opts = ["includePrerelease", "loose", "rtl"];
        var parseOptions_1 = (options) => options ? typeof options != "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => (options2[k] = true, options2), {}) : {};
        const numeric = /^[0-9]+$/, compareIdentifiers$1 = (a, b) => {
          const anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        };
        var identifiers = { compareIdentifiers: compareIdentifiers$1, rcompareIdentifiers: (a, b) => compareIdentifiers$1(b, a) };
        const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants2, { re: re$4, t: t$4 } = re_1, { compareIdentifiers } = identifiers;
        class SemVer {
          constructor(version3, options) {
            if (options = parseOptions_1(options), version3 instanceof SemVer) {
              if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease)
                return version3;
              version3 = version3.version;
            } else if (typeof version3 != "string")
              throw new TypeError(`Invalid Version: ${version3}`);
            if (version3.length > MAX_LENGTH$1)
              throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
            debug_1("SemVer", version3, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
            const m = version3.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
            if (!m)
              throw new TypeError(`Invalid Version: ${version3}`);
            if (this.raw = version3, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
              throw new TypeError("Invalid major version");
            if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
              throw new TypeError("Invalid minor version");
            if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
              throw new TypeError("Invalid patch version");
            m[4] ? this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER)
                  return num;
              }
              return id;
            }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(other) {
            if (debug_1("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
              if (typeof other == "string" && other === this.version)
                return 0;
              other = new SemVer(other, this.options);
            }
            return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
          }
          compareMain(other) {
            return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
          }
          comparePre(other) {
            if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
              return -1;
            if (!this.prerelease.length && other.prerelease.length)
              return 1;
            if (!this.prerelease.length && !other.prerelease.length)
              return 0;
            let i = 0;
            do {
              const a = this.prerelease[i], b = other.prerelease[i];
              if (debug_1("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          compareBuild(other) {
            other instanceof SemVer || (other = new SemVer(other, this.options));
            let i = 0;
            do {
              const a = this.build[i], b = other.build[i];
              if (debug_1("prerelease compare", i, a, b), a === void 0 && b === void 0)
                return 0;
              if (b === void 0)
                return 1;
              if (a === void 0)
                return -1;
              if (a !== b)
                return compareIdentifiers(a, b);
            } while (++i);
          }
          inc(release, identifier) {
            switch (release) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre":
                if (this.prerelease.length === 0)
                  this.prerelease = [0];
                else {
                  let i = this.prerelease.length;
                  for (; --i >= 0; )
                    typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                  i === -1 && this.prerelease.push(0);
                }
                identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
                break;
              default:
                throw new Error(`invalid increment argument: ${release}`);
            }
            return this.format(), this.raw = this.version, this;
          }
        }
        var semver$1 = SemVer;
        const { MAX_LENGTH } = constants2, { re: re$3, t: t$3 } = re_1;
        var parse_1 = (version3, options) => {
          if (options = parseOptions_1(options), version3 instanceof semver$1)
            return version3;
          if (typeof version3 != "string")
            return null;
          if (version3.length > MAX_LENGTH)
            return null;
          if (!(options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL]).test(version3))
            return null;
          try {
            return new semver$1(version3, options);
          } catch (er) {
            return null;
          }
        };
        var valid_1 = (version3, options) => {
          const v = parse_1(version3, options);
          return v ? v.version : null;
        };
        var clean_1 = (version3, options) => {
          const s = parse_1(version3.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        };
        var inc_1 = (version3, release, options, identifier) => {
          typeof options == "string" && (identifier = options, options = void 0);
          try {
            return new semver$1(version3, options).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        };
        var compare_1 = (a, b, loose) => new semver$1(a, loose).compare(new semver$1(b, loose));
        var eq_1 = (a, b, loose) => compare_1(a, b, loose) === 0;
        var diff_1 = (version1, version22) => {
          if (eq_1(version1, version22))
            return null;
          {
            const v1 = parse_1(version1), v2 = parse_1(version22), hasPre = v1.prerelease.length || v2.prerelease.length, prefix = hasPre ? "pre" : "", defaultResult = hasPre ? "prerelease" : "";
            for (const key in v1)
              if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
                return prefix + key;
            return defaultResult;
          }
        };
        var major_1 = (a, loose) => new semver$1(a, loose).major;
        var minor_1 = (a, loose) => new semver$1(a, loose).minor;
        var patch_1 = (a, loose) => new semver$1(a, loose).patch;
        var prerelease_1 = (version3, options) => {
          const parsed = parse_1(version3, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        };
        var rcompare_1 = (a, b, loose) => compare_1(b, a, loose);
        var compareLoose_1 = (a, b) => compare_1(a, b, true);
        var compareBuild_1 = (a, b, loose) => {
          const versionA = new semver$1(a, loose), versionB = new semver$1(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        };
        var sort_1 = (list, loose) => list.sort((a, b) => compareBuild_1(a, b, loose));
        var rsort_1 = (list, loose) => list.sort((a, b) => compareBuild_1(b, a, loose));
        var gt_1 = (a, b, loose) => compare_1(a, b, loose) > 0;
        var lt_1 = (a, b, loose) => compare_1(a, b, loose) < 0;
        var neq_1 = (a, b, loose) => compare_1(a, b, loose) !== 0;
        var gte_1 = (a, b, loose) => compare_1(a, b, loose) >= 0;
        var lte_1 = (a, b, loose) => compare_1(a, b, loose) <= 0;
        var cmp_1 = (a, op, b, loose) => {
          switch (op) {
            case "===":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
            case "!==":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq_1(a, b, loose);
            case "!=":
              return neq_1(a, b, loose);
            case ">":
              return gt_1(a, b, loose);
            case ">=":
              return gte_1(a, b, loose);
            case "<":
              return lt_1(a, b, loose);
            case "<=":
              return lte_1(a, b, loose);
            default:
              throw new TypeError(`Invalid operator: ${op}`);
          }
        };
        const { re: re$2, t: t$2 } = re_1;
        var coerce_1 = (version3, options) => {
          if (version3 instanceof semver$1)
            return version3;
          if (typeof version3 == "number" && (version3 = String(version3)), typeof version3 != "string")
            return null;
          let match = null;
          if ((options = options || {}).rtl) {
            let next;
            for (; (next = re$2[t$2.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re$2[t$2.COERCERTL].lastIndex = -1;
          } else
            match = version3.match(re$2[t$2.COERCE]);
          return match === null ? null : parse_1(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
        }, yallist = Yallist;
        function Yallist(list) {
          var self2 = this;
          if (self2 instanceof Yallist || (self2 = new Yallist()), self2.tail = null, self2.head = null, self2.length = 0, list && typeof list.forEach == "function")
            list.forEach(function(item) {
              self2.push(item);
            });
          else if (arguments.length > 0)
            for (var i = 0, l = arguments.length; i < l; i++)
              self2.push(arguments[i]);
          return self2;
        }
        function insert(self2, node, value) {
          var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
          return inserted.next === null && (self2.tail = inserted), inserted.prev === null && (self2.head = inserted), self2.length++, inserted;
        }
        function push(self2, item) {
          self2.tail = new Node2(item, self2.tail, null, self2), self2.head || (self2.head = self2.tail), self2.length++;
        }
        function unshift(self2, item) {
          self2.head = new Node2(item, null, self2.head, self2), self2.tail || (self2.tail = self2.head), self2.length++;
        }
        function Node2(value, prev, next, list) {
          if (!(this instanceof Node2))
            return new Node2(value, prev, next, list);
          this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
        }
        Yallist.Node = Node2, Yallist.create = Yallist, Yallist.prototype.removeNode = function(node) {
          if (node.list !== this)
            throw new Error("removing node which does not belong to this list");
          var next = node.next, prev = node.prev;
          return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
        }, Yallist.prototype.unshiftNode = function(node) {
          if (node !== this.head) {
            node.list && node.list.removeNode(node);
            var head = this.head;
            node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
          }
        }, Yallist.prototype.pushNode = function(node) {
          if (node !== this.tail) {
            node.list && node.list.removeNode(node);
            var tail = this.tail;
            node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
          }
        }, Yallist.prototype.push = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            push(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.unshift = function() {
          for (var i = 0, l = arguments.length; i < l; i++)
            unshift(this, arguments[i]);
          return this.length;
        }, Yallist.prototype.pop = function() {
          if (this.tail) {
            var res = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
          }
        }, Yallist.prototype.shift = function() {
          if (this.head) {
            var res = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
          }
        }, Yallist.prototype.forEach = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.head, i = 0; walker !== null; i++)
            fn.call(thisp, walker.value, i, this), walker = walker.next;
        }, Yallist.prototype.forEachReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
            fn.call(thisp, walker.value, i, this), walker = walker.prev;
        }, Yallist.prototype.get = function(n) {
          for (var i = 0, walker = this.head; walker !== null && i < n; i++)
            walker = walker.next;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.getReverse = function(n) {
          for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
            walker = walker.prev;
          if (i === n && walker !== null)
            return walker.value;
        }, Yallist.prototype.map = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.head; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
          return res;
        }, Yallist.prototype.mapReverse = function(fn, thisp) {
          thisp = thisp || this;
          for (var res = new Yallist(), walker = this.tail; walker !== null; )
            res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
          return res;
        }, Yallist.prototype.reduce = function(fn, initial) {
          var acc, walker = this.head;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.head)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.head.next, acc = this.head.value;
          }
          for (var i = 0; walker !== null; i++)
            acc = fn(acc, walker.value, i), walker = walker.next;
          return acc;
        }, Yallist.prototype.reduceReverse = function(fn, initial) {
          var acc, walker = this.tail;
          if (arguments.length > 1)
            acc = initial;
          else {
            if (!this.tail)
              throw new TypeError("Reduce of empty list with no initial value");
            walker = this.tail.prev, acc = this.tail.value;
          }
          for (var i = this.length - 1; walker !== null; i--)
            acc = fn(acc, walker.value, i), walker = walker.prev;
          return acc;
        }, Yallist.prototype.toArray = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
            arr[i] = walker.value, walker = walker.next;
          return arr;
        }, Yallist.prototype.toArrayReverse = function() {
          for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
            arr[i] = walker.value, walker = walker.prev;
          return arr;
        }, Yallist.prototype.slice = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = 0, walker = this.head; walker !== null && i < from; i++)
            walker = walker.next;
          for (; walker !== null && i < to; i++, walker = walker.next)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.sliceReverse = function(from, to) {
          (to = to || this.length) < 0 && (to += this.length), (from = from || 0) < 0 && (from += this.length);
          var ret = new Yallist();
          if (to < from || to < 0)
            return ret;
          from < 0 && (from = 0), to > this.length && (to = this.length);
          for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
            walker = walker.prev;
          for (; walker !== null && i > from; i--, walker = walker.prev)
            ret.push(walker.value);
          return ret;
        }, Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
          start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
          for (var i = 0, walker = this.head; walker !== null && i < start; i++)
            walker = walker.next;
          var ret = [];
          for (i = 0; walker && i < deleteCount; i++)
            ret.push(walker.value), walker = this.removeNode(walker);
          walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
          for (i = 0; i < nodes.length; i++)
            walker = insert(this, walker, nodes[i]);
          return ret;
        }, Yallist.prototype.reverse = function() {
          for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
            var p = walker.prev;
            walker.prev = walker.next, walker.next = p;
          }
          return this.head = tail, this.tail = head, this;
        };
        try {
          !function(Yallist2) {
            Yallist2.prototype[Symbol.iterator] = function* () {
              for (let walker = this.head; walker; walker = walker.next)
                yield walker.value;
            };
          }(Yallist);
        } catch (er) {
        }
        const MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
        const get = (self2, key, doUse) => {
          const node = self2[CACHE].get(key);
          if (node) {
            const hit = node.value;
            if (isStale(self2, hit)) {
              if (del(self2, node), !self2[ALLOW_STALE])
                return;
            } else
              doUse && (self2[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self2[LRU_LIST].unshiftNode(node));
            return hit.value;
          }
        }, isStale = (self2, hit) => {
          if (!hit || !hit.maxAge && !self2[MAX_AGE])
            return false;
          const diff = Date.now() - hit.now;
          return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
        }, trim = (self2) => {
          if (self2[LENGTH] > self2[MAX])
            for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
              const prev = walker.prev;
              del(self2, walker), walker = prev;
            }
        }, del = (self2, node) => {
          if (node) {
            const hit = node.value;
            self2[DISPOSE] && self2[DISPOSE](hit.key, hit.value), self2[LENGTH] -= hit.length, self2[CACHE].delete(hit.key), self2[LRU_LIST].removeNode(node);
          }
        };
        class Entry {
          constructor(key, value, length, now, maxAge) {
            this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
          }
        }
        const forEachStep = (self2, fn, node, thisp) => {
          let hit = node.value;
          isStale(self2, hit) && (del(self2, node), self2[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self2);
        };
        var lruCache = class {
          constructor(options) {
            if (typeof options == "number" && (options = { max: options }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0))
              throw new TypeError("max must be a non-negative number");
            this[MAX] = options.max || 1 / 0;
            const lc = options.length || naiveLength;
            if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || false, options.maxAge && typeof options.maxAge != "number")
              throw new TypeError("maxAge must be a number");
            this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false, this.reset();
          }
          set max(mL) {
            if (typeof mL != "number" || mL < 0)
              throw new TypeError("max must be a non-negative number");
            this[MAX] = mL || 1 / 0, trim(this);
          }
          get max() {
            return this[MAX];
          }
          set allowStale(allowStale) {
            this[ALLOW_STALE] = !!allowStale;
          }
          get allowStale() {
            return this[ALLOW_STALE];
          }
          set maxAge(mA) {
            if (typeof mA != "number")
              throw new TypeError("maxAge must be a non-negative number");
            this[MAX_AGE] = mA, trim(this);
          }
          get maxAge() {
            return this[MAX_AGE];
          }
          set lengthCalculator(lC) {
            typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
            })), trim(this);
          }
          get lengthCalculator() {
            return this[LENGTH_CALCULATOR];
          }
          get length() {
            return this[LENGTH];
          }
          get itemCount() {
            return this[LRU_LIST].length;
          }
          rforEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].tail; walker !== null; ) {
              const prev = walker.prev;
              forEachStep(this, fn, walker, thisp), walker = prev;
            }
          }
          forEach(fn, thisp) {
            thisp = thisp || this;
            for (let walker = this[LRU_LIST].head; walker !== null; ) {
              const next = walker.next;
              forEachStep(this, fn, walker, thisp), walker = next;
            }
          }
          keys() {
            return this[LRU_LIST].toArray().map((k) => k.key);
          }
          values() {
            return this[LRU_LIST].toArray().map((k) => k.value);
          }
          reset() {
            this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new yallist(), this[LENGTH] = 0;
          }
          dump() {
            return this[LRU_LIST].map((hit) => !isStale(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }).toArray().filter((h) => h);
          }
          dumpLru() {
            return this[LRU_LIST];
          }
          set(key, value, maxAge) {
            if ((maxAge = maxAge || this[MAX_AGE]) && typeof maxAge != "number")
              throw new TypeError("maxAge must be a number");
            const now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
            if (this[CACHE].has(key)) {
              if (len > this[MAX])
                return del(this, this[CACHE].get(key)), false;
              const item = this[CACHE].get(key).value;
              return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), true;
            }
            const hit = new Entry(key, value, len, now, maxAge);
            return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), false) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), true);
          }
          has(key) {
            if (!this[CACHE].has(key))
              return false;
            const hit = this[CACHE].get(key).value;
            return !isStale(this, hit);
          }
          get(key) {
            return get(this, key, true);
          }
          peek(key) {
            return get(this, key, false);
          }
          pop() {
            const node = this[LRU_LIST].tail;
            return node ? (del(this, node), node.value) : null;
          }
          del(key) {
            del(this, this[CACHE].get(key));
          }
          load(arr) {
            this.reset();
            const now = Date.now();
            for (let l = arr.length - 1; l >= 0; l--) {
              const hit = arr[l], expiresAt = hit.e || 0;
              if (expiresAt === 0)
                this.set(hit.k, hit.v);
              else {
                const maxAge = expiresAt - now;
                maxAge > 0 && this.set(hit.k, hit.v, maxAge);
              }
            }
          }
          prune() {
            this[CACHE].forEach((value, key) => get(this, key, false));
          }
        };
        class Range3 {
          constructor(range2, options) {
            if (options = parseOptions_1(options), range2 instanceof Range3)
              return range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease ? range2 : new Range3(range2.raw, options);
            if (range2 instanceof comparator)
              return this.raw = range2.value, this.set = [[range2]], this.format(), this;
            if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range2, this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length), !this.set.length)
              throw new TypeError(`Invalid SemVer Range: ${range2}`);
            if (this.set.length > 1) {
              const first = this.set[0];
              if (this.set = this.set.filter((c) => !isNullSet(c[0])), this.set.length === 0)
                this.set = [first];
              else if (this.set.length > 1) {
                for (const c of this.set)
                  if (c.length === 1 && isAny(c[0])) {
                    this.set = [c];
                    break;
                  }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(range2) {
            range2 = range2.trim();
            const memoKey = `parseRange:${Object.keys(this.options).join(",")}:${range2}`, cached = cache.get(memoKey);
            if (cached)
              return cached;
            const loose = this.options.loose, hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
            range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease)), debug_1("hyphen replace", range2), range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace), debug_1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]), range2 = (range2 = (range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace)).replace(re$1[t$1.CARETTRIM], caretTrimReplace)).split(/\s+/).join(" ");
            const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR], rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new comparator(comp, this.options));
            rangeList.length;
            const rangeMap = /* @__PURE__ */ new Map();
            for (const comp of rangeList) {
              if (isNullSet(comp))
                return [comp];
              rangeMap.set(comp.value, comp);
            }
            rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
            const result = [...rangeMap.values()];
            return cache.set(memoKey, result), result;
          }
          intersects(range2, options) {
            if (!(range2 instanceof Range3))
              throw new TypeError("a Range is required");
            return this.set.some((thisComparators) => isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => rangeComparators.every((rangeComparator) => thisComparator.intersects(rangeComparator, options)))));
          }
          test(version3) {
            if (!version3)
              return false;
            if (typeof version3 == "string")
              try {
                version3 = new semver$1(version3, this.options);
              } catch (er) {
                return false;
              }
            for (let i = 0; i < this.set.length; i++)
              if (testSet(this.set[i], version3, this.options))
                return true;
            return false;
          }
        }
        var range = Range3;
        const cache = new lruCache({ max: 1e3 }), { re: re$1, t: t$1, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = re_1, isNullSet = (c) => c.value === "<0.0.0-0", isAny = (c) => c.value === "", isSatisfiable = (comparators, options) => {
          let result = true;
          const remainingComparators = comparators.slice();
          let testComparator = remainingComparators.pop();
          for (; result && remainingComparators.length; )
            result = remainingComparators.every((otherComparator) => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
          return result;
        }, parseComparator = (comp, options) => (debug_1("comp", comp, options), comp = replaceCarets(comp, options), debug_1("caret", comp), comp = replaceTildes(comp, options), debug_1("tildes", comp), comp = replaceXRanges(comp, options), debug_1("xrange", comp), comp = replaceStars(comp, options), debug_1("stars", comp), comp), isX = (id) => !id || id.toLowerCase() === "x" || id === "*", replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceTilde(comp2, options)).join(" "), replaceTilde = (comp, options) => {
          const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug_1("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug_1("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug_1("tilde return", ret), ret;
          });
        }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => replaceCaret(comp2, options)).join(" "), replaceCaret = (comp, options) => {
          debug_1("caret", comp, options);
          const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET], z = options.includePrerelease ? "-0" : "";
          return comp.replace(r, (_, M, m, p, pr) => {
            let ret;
            return debug_1("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = M === "0" ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug_1("replaceCaret pr", pr), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug_1("no pr"), ret = M === "0" ? m === "0" ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug_1("caret return", ret), ret;
          });
        }, replaceXRanges = (comp, options) => (debug_1("replaceXRanges", comp, options), comp.split(/\s+/).map((comp2) => replaceXRange(comp2, options)).join(" ")), replaceXRange = (comp, options) => {
          comp = comp.trim();
          const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
          return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
            debug_1("xRange", comp, ret, gtlt, M, m, p, pr);
            const xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
            return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? ret = gtlt === ">" || gtlt === "<" ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug_1("xRange return", ret), ret;
          });
        }, replaceStars = (comp, options) => (debug_1("replaceStars", comp, options), comp.trim().replace(re$1[t$1.STAR], "")), replaceGTE0 = (comp, options) => (debug_1("replaceGTE0", comp, options), comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "")), hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version3, options) => {
          for (let i = 0; i < set.length; i++)
            if (!set[i].test(version3))
              return false;
          if (version3.prerelease.length && !options.includePrerelease) {
            for (let i = 0; i < set.length; i++)
              if (debug_1(set[i].semver), set[i].semver !== comparator.ANY && set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch)
                  return true;
              }
            return false;
          }
          return true;
        }, ANY$2 = Symbol("SemVer ANY");
        class Comparator {
          static get ANY() {
            return ANY$2;
          }
          constructor(comp, options) {
            if (options = parseOptions_1(options), comp instanceof Comparator) {
              if (comp.loose === !!options.loose)
                return comp;
              comp = comp.value;
            }
            debug_1("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY$2 ? this.value = "" : this.value = this.operator + this.semver.version, debug_1("comp", this);
          }
          parse(comp) {
            const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
            if (!m)
              throw new TypeError(`Invalid comparator: ${comp}`);
            this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new semver$1(m[2], this.options.loose) : this.semver = ANY$2;
          }
          toString() {
            return this.value;
          }
          test(version3) {
            if (debug_1("Comparator.test", version3, this.options.loose), this.semver === ANY$2 || version3 === ANY$2)
              return true;
            if (typeof version3 == "string")
              try {
                version3 = new semver$1(version3, this.options);
              } catch (er) {
                return false;
              }
            return cmp_1(version3, this.operator, this.semver, this.options);
          }
          intersects(comp, options) {
            if (!(comp instanceof Comparator))
              throw new TypeError("a Comparator is required");
            if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), this.operator === "")
              return this.value === "" || new range(comp.value, options).test(this.value);
            if (comp.operator === "")
              return comp.value === "" || new range(this.value, options).test(comp.semver);
            const sameDirectionIncreasing = !(this.operator !== ">=" && this.operator !== ">" || comp.operator !== ">=" && comp.operator !== ">"), sameDirectionDecreasing = !(this.operator !== "<=" && this.operator !== "<" || comp.operator !== "<=" && comp.operator !== "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(this.operator !== ">=" && this.operator !== "<=" || comp.operator !== ">=" && comp.operator !== "<="), oppositeDirectionsLessThan = cmp_1(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp_1(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
          }
        }
        var comparator = Comparator;
        const { re, t } = re_1;
        var satisfies_1 = (version3, range$1, options) => {
          try {
            range$1 = new range(range$1, options);
          } catch (er) {
            return false;
          }
          return range$1.test(version3);
        };
        var toComparators_1 = (range$1, options) => new range(range$1, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
        var maxSatisfying_1 = (versions, range$1, options) => {
          let max = null, maxSV = null, rangeObj = null;
          try {
            rangeObj = new range(range$1, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (max = v, maxSV = new semver$1(max, options)));
          }), max;
        };
        var minSatisfying_1 = (versions, range$1, options) => {
          let min = null, minSV = null, rangeObj = null;
          try {
            rangeObj = new range(range$1, options);
          } catch (er) {
            return null;
          }
          return versions.forEach((v) => {
            rangeObj.test(v) && (min && minSV.compare(v) !== 1 || (min = v, minSV = new semver$1(min, options)));
          }), min;
        };
        var minVersion_1 = (range$1, loose) => {
          range$1 = new range(range$1, loose);
          let minver = new semver$1("0.0.0");
          if (range$1.test(minver))
            return minver;
          if (minver = new semver$1("0.0.0-0"), range$1.test(minver))
            return minver;
          minver = null;
          for (let i = 0; i < range$1.set.length; ++i) {
            const comparators = range$1.set[i];
            let setMin = null;
            comparators.forEach((comparator2) => {
              const compver = new semver$1(comparator2.semver.version);
              switch (comparator2.operator) {
                case ">":
                  compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  setMin && !gt_1(compver, setMin) || (setMin = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${comparator2.operator}`);
              }
            }), !setMin || minver && !gt_1(minver, setMin) || (minver = setMin);
          }
          return minver && range$1.test(minver) ? minver : null;
        };
        var valid = (range$1, options) => {
          try {
            return new range(range$1, options).range || "*";
          } catch (er) {
            return null;
          }
        };
        const { ANY: ANY$1 } = comparator;
        var outside_1 = (version3, range$1, hilo, options) => {
          let gtfn, ltefn, ltfn, comp, ecomp;
          switch (version3 = new semver$1(version3, options), range$1 = new range(range$1, options), hilo) {
            case ">":
              gtfn = gt_1, ltefn = lte_1, ltfn = lt_1, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt_1, ltefn = gte_1, ltfn = gt_1, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies_1(version3, range$1, options))
            return false;
          for (let i = 0; i < range$1.set.length; ++i) {
            const comparators = range$1.set[i];
            let high = null, low = null;
            if (comparators.forEach((comparator$1) => {
              comparator$1.semver === ANY$1 && (comparator$1 = new comparator(">=0.0.0")), high = high || comparator$1, low = low || comparator$1, gtfn(comparator$1.semver, high.semver, options) ? high = comparator$1 : ltfn(comparator$1.semver, low.semver, options) && (low = comparator$1);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version3, low.semver))
              return false;
          }
          return true;
        };
        var gtr_1 = (version3, range2, options) => outside_1(version3, range2, ">", options);
        var ltr_1 = (version3, range2, options) => outside_1(version3, range2, "<", options);
        var intersects_1 = (r1, r2, options) => (r1 = new range(r1, options), r2 = new range(r2, options), r1.intersects(r2));
        const { ANY } = comparator, simpleSubset = (sub, dom, options) => {
          if (sub === dom)
            return true;
          if (sub.length === 1 && sub[0].semver === ANY) {
            if (dom.length === 1 && dom[0].semver === ANY)
              return true;
            sub = options.includePrerelease ? [new comparator(">=0.0.0-0")] : [new comparator(">=0.0.0")];
          }
          if (dom.length === 1 && dom[0].semver === ANY) {
            if (options.includePrerelease)
              return true;
            dom = [new comparator(">=0.0.0")];
          }
          const eqSet = /* @__PURE__ */ new Set();
          let gt, lt, gtltComp, higher, lower, hasDomLT, hasDomGT;
          for (const c of sub)
            c.operator === ">" || c.operator === ">=" ? gt = higherGT(gt, c, options) : c.operator === "<" || c.operator === "<=" ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
          if (eqSet.size > 1)
            return null;
          if (gt && lt) {
            if (gtltComp = compare_1(gt.semver, lt.semver, options), gtltComp > 0)
              return null;
            if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
              return null;
          }
          for (const eq of eqSet) {
            if (gt && !satisfies_1(eq, String(gt), options))
              return null;
            if (lt && !satisfies_1(eq, String(lt), options))
              return null;
            for (const c of dom)
              if (!satisfies_1(eq, String(c), options))
                return false;
            return true;
          }
          let needDomLTPre = !(!lt || options.includePrerelease || !lt.semver.prerelease.length) && lt.semver, needDomGTPre = !(!gt || options.includePrerelease || !gt.semver.prerelease.length) && gt.semver;
          needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = false);
          for (const c of dom) {
            if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt) {
              if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = false), c.operator === ">" || c.operator === ">=") {
                if (higher = higherGT(gt, c, options), higher === c && higher !== gt)
                  return false;
              } else if (gt.operator === ">=" && !satisfies_1(gt.semver, String(c), options))
                return false;
            }
            if (lt) {
              if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = false), c.operator === "<" || c.operator === "<=") {
                if (lower = lowerLT(lt, c, options), lower === c && lower !== lt)
                  return false;
              } else if (lt.operator === "<=" && !satisfies_1(lt.semver, String(c), options))
                return false;
            }
            if (!c.operator && (lt || gt) && gtltComp !== 0)
              return false;
          }
          return !(gt && hasDomLT && !lt && gtltComp !== 0) && (!(lt && hasDomGT && !gt && gtltComp !== 0) && (!needDomGTPre && !needDomLTPre));
        }, higherGT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare_1(a.semver, b.semver, options);
          return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
        }, lowerLT = (a, b, options) => {
          if (!a)
            return b;
          const comp = compare_1(a.semver, b.semver, options);
          return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
        };
        var subset_1 = (sub, dom, options = {}) => {
          if (sub === dom)
            return true;
          sub = new range(sub, options), dom = new range(dom, options);
          let sawNonNull = false;
          OUTER:
            for (const simpleSub of sub.set) {
              for (const simpleDom of dom.set) {
                const isSub = simpleSubset(simpleSub, simpleDom, options);
                if (sawNonNull = sawNonNull || isSub !== null, isSub)
                  continue OUTER;
              }
              if (sawNonNull)
                return false;
            }
          return true;
        }, semver = { re: re_1.re, src: re_1.src, tokens: re_1.t, SEMVER_SPEC_VERSION: constants2.SEMVER_SPEC_VERSION, SemVer: semver$1, compareIdentifiers: identifiers.compareIdentifiers, rcompareIdentifiers: identifiers.rcompareIdentifiers, parse: parse_1, valid: valid_1, clean: clean_1, inc: inc_1, diff: diff_1, major: major_1, minor: minor_1, patch: patch_1, prerelease: prerelease_1, compare: compare_1, rcompare: rcompare_1, compareLoose: compareLoose_1, compareBuild: compareBuild_1, sort: sort_1, rsort: rsort_1, gt: gt_1, lt: lt_1, eq: eq_1, neq: neq_1, gte: gte_1, lte: lte_1, cmp: cmp_1, coerce: coerce_1, Comparator: comparator, Range: range, satisfies: satisfies_1, toComparators: toComparators_1, maxSatisfying: maxSatisfying_1, minSatisfying: minSatisfying_1, minVersion: minVersion_1, validRange: valid, outside: outside_1, gtr: gtr_1, ltr: ltr_1, intersects: intersects_1, simplifyRange: (versions, range2, options) => {
          const set = [];
          let min = null, prev = null;
          const v = versions.sort((a, b) => compare_1(a, b, options));
          for (const version3 of v) {
            satisfies_1(version3, range2, options) ? (prev = version3, min || (min = version3)) : (prev && set.push([min, prev]), prev = null, min = null);
          }
          min && set.push([min, null]);
          const ranges = [];
          for (const [min2, max] of set)
            min2 === max ? ranges.push(min2) : max || min2 !== v[0] ? max ? min2 === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min2} - ${max}`) : ranges.push(`>=${min2}`) : ranges.push("*");
          const simplified = ranges.join(" || "), original = typeof range2.raw == "string" ? range2.raw : String(range2);
          return simplified.length < original.length ? simplified : range2;
        }, subset: subset_1 };
        const reader = { read: function(jsonPath) {
          return find(_path().dirname(jsonPath));
        } };
        function find(dir) {
          try {
            return { string: _fs().default.readFileSync(_path().toNamespacedPath(_path().join(dir, "package.json")), "utf8") };
          } catch (error) {
            if (error.code === "ENOENT") {
              const parent = _path().dirname(dir);
              return dir !== parent ? find(parent) : { string: void 0 };
            }
            throw error;
          }
        }
        const isWindows = process.platform === "win32", own$1 = {}.hasOwnProperty, codes = {}, messages = /* @__PURE__ */ new Map();
        let userStackTraceLimit;
        function createError(sym, value, def) {
          return messages.set(sym, value), function(Base, key) {
            return NodeError;
            function NodeError(...args) {
              const limit = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
              const error = new Base();
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = limit);
              const message = function(key2, args2, self2) {
                const message2 = messages.get(key2);
                if (typeof message2 == "function")
                  return _assert()(message2.length <= args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${message2.length}).`), Reflect.apply(message2, self2, args2);
                const expectedLength = (message2.match(/%[dfijoOs]/g) || []).length;
                return _assert()(expectedLength === args2.length, `Code: ${key2}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), args2.length === 0 ? message2 : (args2.unshift(message2), Reflect.apply(_util().format, null, args2));
              }(key, args, error);
              return Object.defineProperty(error, "message", { value: message, enumerable: false, writable: true, configurable: true }), Object.defineProperty(error, "toString", { value() {
                return `${this.name} [${key}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true }), addCodeToName(error, Base.name, key), error.code = key, error;
            }
          }(def, sym);
        }
        codes.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base) => `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`, TypeError), codes.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (path, base, message) => `Invalid package config ${path}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`, Error), codes.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (pkgPath, key, target, isImport = false, base) => {
          const relError = typeof target == "string" && !isImport && target.length > 0 && !target.startsWith("./");
          return key === "." ? (_assert()(isImport === false), `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`) : `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }, Error), codes.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (path, base, type = "package") => `Cannot find ${type} '${path}' imported from ${base}`, Error), codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`, TypeError), codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (pkgPath, subpath, base) => subpath === "." ? `No "exports" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}` : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base ? ` imported from ${base}` : ""}`, Error), codes.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), codes.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", 'Unknown file extension "%s" for %s', TypeError), codes.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
          let inspected = (0, _util().inspect)(value);
          inspected.length > 128 && (inspected = `${inspected.slice(0, 128)}...`);
          return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
        }, TypeError), codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError("ERR_UNSUPPORTED_ESM_URL_SCHEME", (url) => {
          let message = "Only file and data URLs are supported by the default ESM loader";
          return isWindows && url.protocol.length === 2 && (message += ". On Windows, absolute paths must be valid file:// URLs"), message += `. Received protocol '${url.protocol}'`, message;
        }, Error);
        const addCodeToName = hideStackFrames(function(error, name, code) {
          (error = captureLargerStackTrace(error)).name = `${name} [${code}]`, error.stack, name === "SystemError" ? Object.defineProperty(error, "name", { value: name, enumerable: false, writable: true, configurable: true }) : delete error.name;
        });
        function isErrorStackTraceLimitWritable() {
          const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return desc === void 0 ? Object.isExtensible(Error) : own$1.call(desc, "writable") ? desc.writable : desc.set !== void 0;
        }
        function hideStackFrames(fn) {
          const hidden = "__node_internal_" + fn.name;
          return Object.defineProperty(fn, "name", { value: hidden }), fn;
        }
        const captureLargerStackTrace = hideStackFrames(function(error) {
          const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
          return stackTraceLimitIsWritable && (userStackTraceLimit = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(error), stackTraceLimitIsWritable && (Error.stackTraceLimit = userStackTraceLimit), error;
        });
        const { ERR_UNKNOWN_FILE_EXTENSION } = codes, extensionFormatMap = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".mjs": "module" };
        function defaultGetFormat(url) {
          if (url.startsWith("node:"))
            return { format: "builtin" };
          const parsed = new (_url()).URL(url);
          if (parsed.protocol === "data:") {
            const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null];
            return { format: mime === "text/javascript" ? "module" : null };
          }
          if (parsed.protocol === "file:") {
            const ext = _path().extname(parsed.pathname);
            let format;
            if (format = ext === ".js" ? function(url2) {
              return getPackageScopeConfig(url2).type;
            }(parsed.href) === "module" ? "module" : "commonjs" : extensionFormatMap[ext], !format)
              throw new ERR_UNKNOWN_FILE_EXTENSION(ext, (0, _url().fileURLToPath)(url));
            return { format: format || null };
          }
          return { format: null };
        }
        const listOfBuiltins = function({ version: version3 = process.version, experimental = false } = {}) {
          var coreModules = ["assert", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "module", "net", "os", "path", "punycode", "querystring", "readline", "repl", "stream", "string_decoder", "sys", "timers", "tls", "tty", "url", "util", "vm", "zlib"];
          return semver.lt(version3, "6.0.0") && coreModules.push("freelist"), semver.gte(version3, "1.0.0") && coreModules.push("v8"), semver.gte(version3, "1.1.0") && coreModules.push("process"), semver.gte(version3, "8.0.0") && coreModules.push("inspector"), semver.gte(version3, "8.1.0") && coreModules.push("async_hooks"), semver.gte(version3, "8.4.0") && coreModules.push("http2"), semver.gte(version3, "8.5.0") && coreModules.push("perf_hooks"), semver.gte(version3, "10.0.0") && coreModules.push("trace_events"), semver.gte(version3, "10.5.0") && (experimental || semver.gte(version3, "12.0.0")) && coreModules.push("worker_threads"), semver.gte(version3, "12.16.0") && experimental && coreModules.push("wasi"), coreModules;
        }(), { ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_ESM_URL_SCHEME, ERR_INVALID_ARG_VALUE } = codes, own = {}.hasOwnProperty, DEFAULT_CONDITIONS = Object.freeze(["node", "import"]), DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS), invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/, patternRegEx = /\*/g, encodedSepRegEx = /%2f|%2c/i, emittedPackageWarnings = /* @__PURE__ */ new Set(), packageJsonCache = /* @__PURE__ */ new Map();
        function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {
          const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
          emittedPackageWarnings.has(pjsonPath + "|" + match) || (emittedPackageWarnings.add(pjsonPath + "|" + match), process.emitWarning(`Use of deprecated folder mapping "${match}" in the ${isExports ? '"exports"' : '"imports"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}.
Update this package.json to use a subpath pattern like "${match}*".`, "DeprecationWarning", "DEP0148"));
        }
        function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
          const { format } = defaultGetFormat(url.href);
          if (format !== "module")
            return;
          const path = (0, _url().fileURLToPath)(url.href), pkgPath = (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), basePath = (0, _url().fileURLToPath)(base);
          main ? process.emitWarning(`Package ${pkgPath} has a "main" field set to ${JSON.stringify(main)}, excluding the full filename and extension to the resolved file at "${path.slice(pkgPath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field isdeprecated for ES modules.`, "DeprecationWarning", "DEP0151") : process.emitWarning(`No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(pkgPath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync(path) {
          try {
            return (0, _fs().statSync)(path);
          } catch (_unused) {
            return new (_fs()).Stats();
          }
        }
        function getPackageConfig(path, specifier, base) {
          const existing = packageJsonCache.get(path);
          if (existing !== void 0)
            return existing;
          const source = reader.read(path).string;
          if (source === void 0) {
            const packageConfig2 = { pjsonPath: path, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
            return packageJsonCache.set(path, packageConfig2), packageConfig2;
          }
          let packageJson;
          try {
            packageJson = JSON.parse(source);
          } catch (error) {
            throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `"${specifier}" from ` : "") + (0, _url().fileURLToPath)(base || specifier), error.message);
          }
          const { exports: exports3, imports, main, name, type } = packageJson, packageConfig = { pjsonPath: path, exists: true, main: typeof main == "string" ? main : void 0, name: typeof name == "string" ? name : void 0, type: type === "module" || type === "commonjs" ? type : "none", exports: exports3, imports: imports && typeof imports == "object" ? imports : void 0 };
          return packageJsonCache.set(path, packageConfig), packageConfig;
        }
        function getPackageScopeConfig(resolved) {
          let packageJsonUrl = new (_url()).URL("./package.json", resolved);
          for (; ; ) {
            if (packageJsonUrl.pathname.endsWith("node_modules/package.json"))
              break;
            const packageConfig2 = getPackageConfig((0, _url().fileURLToPath)(packageJsonUrl), resolved);
            if (packageConfig2.exists)
              return packageConfig2;
            const lastPackageJsonUrl = packageJsonUrl;
            if (packageJsonUrl = new (_url()).URL("../package.json", packageJsonUrl), packageJsonUrl.pathname === lastPackageJsonUrl.pathname)
              break;
          }
          const packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl), packageConfig = { pjsonPath: packageJsonPath, exists: false, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          return packageJsonCache.set(packageJsonPath, packageConfig), packageConfig;
        }
        function fileExists(url) {
          return tryStatSync((0, _url().fileURLToPath)(url)).isFile();
        }
        function legacyMainResolve(packageJsonUrl, packageConfig, base) {
          let guess;
          if (packageConfig.main !== void 0) {
            if (guess = new (_url()).URL(`./${packageConfig.main}`, packageJsonUrl), fileExists(guess))
              return guess;
            const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
            let i2 = -1;
            for (; ++i2 < tries2.length && (guess = new (_url()).URL(tries2[i2], packageJsonUrl), !fileExists(guess)); )
              guess = void 0;
            if (guess)
              return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
          }
          const tries = ["./index.js", "./index.json", "./index.node"];
          let i = -1;
          for (; ++i < tries.length && (guess = new (_url()).URL(tries[i], packageJsonUrl), !fileExists(guess)); )
            guess = void 0;
          if (guess)
            return emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main), guess;
          throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
        }
        function throwExportsNotFound(subpath, packageJsonUrl, base) {
          throw new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
        }
        function throwInvalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
          throw target = typeof target == "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`, new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
        }
        function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, conditions) {
          if (subpath === "" || pattern || target[target.length - 1] === "/" || throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base), !target.startsWith("./")) {
            if (internal && !target.startsWith("../") && !target.startsWith("/")) {
              let isURL = false;
              try {
                new (_url()).URL(target), isURL = true;
              } catch (_unused2) {
              }
              if (!isURL) {
                return packageResolve(pattern ? target.replace(patternRegEx, subpath) : target + subpath, packageJsonUrl, conditions);
              }
            }
            throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
          }
          invalidSegmentRegEx.test(target.slice(2)) && throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base);
          const resolved = new (_url()).URL(target, packageJsonUrl), resolvedPath = resolved.pathname, packagePath = new (_url()).URL(".", packageJsonUrl).pathname;
          return resolvedPath.startsWith(packagePath) || throwInvalidPackageTarget(match, target, packageJsonUrl, internal, base), subpath === "" ? resolved : (invalidSegmentRegEx.test(subpath) && function(subpath2, packageJsonUrl2, internal2, base2) {
            const reason = `request is not a valid subpath for the "${internal2 ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl2)}`;
            throw new ERR_INVALID_MODULE_SPECIFIER(subpath2, reason, base2 && (0, _url().fileURLToPath)(base2));
          }(match + subpath, packageJsonUrl, internal, base), pattern ? new (_url()).URL(resolved.href.replace(patternRegEx, subpath)) : new (_url()).URL(subpath, resolved));
        }
        function isArrayIndex(key) {
          const keyNumber = Number(key);
          return `${keyNumber}` === key && (keyNumber >= 0 && keyNumber < 4294967295);
        }
        function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
          if (typeof target == "string")
            return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, conditions);
          if (Array.isArray(target)) {
            const targetList = target;
            if (targetList.length === 0)
              return null;
            let lastException, i = -1;
            for (; ++i < targetList.length; ) {
              const targetItem = targetList[i];
              let resolved;
              try {
                resolved = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);
              } catch (error) {
                if (lastException = error, error.code === "ERR_INVALID_PACKAGE_TARGET")
                  continue;
                throw error;
              }
              if (resolved !== void 0) {
                if (resolved !== null)
                  return resolved;
                lastException = null;
              }
            }
            if (lastException == null)
              return lastException;
            throw lastException;
          }
          if (typeof target != "object" || target === null) {
            if (target === null)
              return null;
            throwInvalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
          } else {
            const keys = Object.getOwnPropertyNames(target);
            let i = -1;
            for (; ++i < keys.length; ) {
              if (isArrayIndex(keys[i]))
                throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
            }
            for (i = -1; ++i < keys.length; ) {
              const key = keys[i];
              if (key === "default" || conditions && conditions.has(key)) {
                const resolved = resolvePackageTarget(packageJsonUrl, target[key], subpath, packageSubpath, base, pattern, internal, conditions);
                if (resolved === void 0)
                  continue;
                return resolved;
              }
            }
          }
        }
        function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
          let exports3 = packageConfig.exports;
          if (function(exports4, packageJsonUrl2, base2) {
            if (typeof exports4 == "string" || Array.isArray(exports4))
              return true;
            if (typeof exports4 != "object" || exports4 === null)
              return false;
            const keys2 = Object.getOwnPropertyNames(exports4);
            let isConditionalSugar = false, i2 = 0, j = -1;
            for (; ++j < keys2.length; ) {
              const key = keys2[j], curIsConditionalSugar = key === "" || key[0] !== ".";
              if (i2++ == 0)
                isConditionalSugar = curIsConditionalSugar;
              else if (isConditionalSugar !== curIsConditionalSugar)
                throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl2), base2, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return isConditionalSugar;
          }(exports3, packageJsonUrl, base) && (exports3 = { ".": exports3 }), own.call(exports3, packageSubpath)) {
            const resolved = resolvePackageTarget(packageJsonUrl, exports3[packageSubpath], "", packageSubpath, base, false, false, conditions);
            return resolved == null && throwExportsNotFound(packageSubpath, packageJsonUrl, base), { resolved, exact: true };
          }
          let bestMatch = "";
          const keys = Object.getOwnPropertyNames(exports3);
          let i = -1;
          for (; ++i < keys.length; ) {
            const key = keys[i];
            (key[key.length - 1] === "*" && packageSubpath.startsWith(key.slice(0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length || key[key.length - 1] === "/" && packageSubpath.startsWith(key) && key.length > bestMatch.length) && (bestMatch = key);
          }
          if (bestMatch) {
            const target = exports3[bestMatch], pattern = bestMatch[bestMatch.length - 1] === "*", resolved = resolvePackageTarget(packageJsonUrl, target, packageSubpath.slice(bestMatch.length - (pattern ? 1 : 0)), bestMatch, base, pattern, false, conditions);
            return resolved == null && throwExportsNotFound(packageSubpath, packageJsonUrl, base), pattern || emitFolderMapDeprecation(bestMatch, packageJsonUrl, true, base), { resolved, exact: pattern };
          }
          throwExportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        function packageImportsResolve(name, base, conditions) {
          if (name === "#" || name.startsWith("#/")) {
            throw new ERR_INVALID_MODULE_SPECIFIER(name, "is not a valid internal imports specifier name", (0, _url().fileURLToPath)(base));
          }
          let packageJsonUrl;
          const packageConfig = getPackageScopeConfig(base);
          if (packageConfig.exists) {
            packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
            const imports = packageConfig.imports;
            if (imports)
              if (own.call(imports, name)) {
                const resolved = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, conditions);
                if (resolved !== null)
                  return { resolved, exact: true };
              } else {
                let bestMatch = "";
                const keys = Object.getOwnPropertyNames(imports);
                let i = -1;
                for (; ++i < keys.length; ) {
                  const key = keys[i];
                  (key[key.length - 1] === "*" && name.startsWith(key.slice(0, -1)) && name.length >= key.length && key.length > bestMatch.length || key[key.length - 1] === "/" && name.startsWith(key) && key.length > bestMatch.length) && (bestMatch = key);
                }
                if (bestMatch) {
                  const target = imports[bestMatch], pattern = bestMatch[bestMatch.length - 1] === "*", resolved = resolvePackageTarget(packageJsonUrl, target, name.slice(bestMatch.length - (pattern ? 1 : 0)), bestMatch, base, pattern, true, conditions);
                  if (resolved !== null)
                    return pattern || emitFolderMapDeprecation(bestMatch, packageJsonUrl, false, base), { resolved, exact: pattern };
                }
              }
          }
          !function(specifier, packageJsonUrl2, base2) {
            throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl2 && (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl2)), (0, _url().fileURLToPath)(base2));
          }(name, packageJsonUrl, base);
        }
        function packageResolve(specifier, base, conditions) {
          const { packageName, packageSubpath, isScoped } = function(specifier2, base2) {
            let separatorIndex = specifier2.indexOf("/"), validPackageName = true, isScoped2 = false;
            specifier2[0] === "@" && (isScoped2 = true, separatorIndex === -1 || specifier2.length === 0 ? validPackageName = false : separatorIndex = specifier2.indexOf("/", separatorIndex + 1));
            const packageName2 = separatorIndex === -1 ? specifier2 : specifier2.slice(0, separatorIndex);
            let i = -1;
            for (; ++i < packageName2.length; )
              if (packageName2[i] === "%" || packageName2[i] === "\\") {
                validPackageName = false;
                break;
              }
            if (!validPackageName)
              throw new ERR_INVALID_MODULE_SPECIFIER(specifier2, "is not a valid package name", (0, _url().fileURLToPath)(base2));
            return { packageName: packageName2, packageSubpath: "." + (separatorIndex === -1 ? "" : specifier2.slice(separatorIndex)), isScoped: isScoped2 };
          }(specifier, base), packageConfig = getPackageScopeConfig(base);
          if (packageConfig.exists) {
            const packageJsonUrl2 = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
            if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
              return packageExportsResolve(packageJsonUrl2, packageSubpath, packageConfig, base, conditions).resolved;
          }
          let lastPath, packageJsonUrl = new (_url()).URL("./node_modules/" + packageName + "/package.json", base), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
          do {
            if (!tryStatSync(packageJsonPath.slice(0, -13)).isDirectory()) {
              lastPath = packageJsonPath, packageJsonUrl = new (_url()).URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl), packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
              continue;
            }
            const packageConfig2 = getPackageConfig(packageJsonPath, specifier, base);
            return packageConfig2.exports !== void 0 && packageConfig2.exports !== null ? packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig2, base, conditions).resolved : packageSubpath === "." ? legacyMainResolve(packageJsonUrl, packageConfig2, base) : new (_url()).URL(packageSubpath, packageJsonUrl);
          } while (packageJsonPath.length !== lastPath.length);
          throw new ERR_MODULE_NOT_FOUND(packageName, (0, _url().fileURLToPath)(base));
        }
        function moduleResolve(specifier, base, conditions) {
          let resolved;
          if (function(specifier2) {
            return specifier2 !== "" && (specifier2[0] === "/" || function(specifier3) {
              if (specifier3[0] === ".") {
                if (specifier3.length === 1 || specifier3[1] === "/")
                  return true;
                if (specifier3[1] === "." && (specifier3.length === 2 || specifier3[2] === "/"))
                  return true;
              }
              return false;
            }(specifier2));
          }(specifier))
            resolved = new (_url()).URL(specifier, base);
          else if (specifier[0] === "#")
            ({ resolved } = packageImportsResolve(specifier, base, conditions));
          else
            try {
              resolved = new (_url()).URL(specifier);
            } catch (_unused3) {
              resolved = packageResolve(specifier, base, conditions);
            }
          return function(resolved2, base2) {
            if (encodedSepRegEx.test(resolved2.pathname))
              throw new ERR_INVALID_MODULE_SPECIFIER(resolved2.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base2));
            const path = (0, _url().fileURLToPath)(resolved2), stats = tryStatSync(path.endsWith("/") ? path.slice(-1) : path);
            if (stats.isDirectory()) {
              const error = new ERR_UNSUPPORTED_DIR_IMPORT(path, (0, _url().fileURLToPath)(base2));
              throw error.url = String(resolved2), error;
            }
            if (!stats.isFile())
              throw new ERR_MODULE_NOT_FOUND(path || resolved2.pathname, base2 && (0, _url().fileURLToPath)(base2), "module");
            return resolved2;
          }(resolved, base);
        }
        function defaultResolve(specifier, context = {}) {
          const { parentURL } = context;
          let parsed;
          try {
            if (parsed = new (_url()).URL(specifier), parsed.protocol === "data:")
              return { url: specifier };
          } catch (_unused4) {
          }
          if (parsed && parsed.protocol === "node:")
            return { url: specifier };
          if (parsed && parsed.protocol !== "file:" && parsed.protocol !== "data:")
            throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);
          if (listOfBuiltins.includes(specifier))
            return { url: "node:" + specifier };
          parentURL.startsWith("data:") && new (_url()).URL(specifier, parentURL);
          const conditions = function(conditions2) {
            if (conditions2 !== void 0 && conditions2 !== DEFAULT_CONDITIONS) {
              if (!Array.isArray(conditions2))
                throw new ERR_INVALID_ARG_VALUE("conditions", conditions2, "expected an array");
              return new Set(conditions2);
            }
            return DEFAULT_CONDITIONS_SET;
          }(context.conditions);
          let url = moduleResolve(specifier, new (_url()).URL(parentURL), conditions);
          const urlPath = (0, _url().fileURLToPath)(url), real = (0, _fs().realpathSync)(urlPath), old = url;
          return url = (0, _url().pathToFileURL)(real + (urlPath.endsWith(_path().sep) ? "/" : "")), url.search = old.search, url.hash = old.hash, { url: `${url}` };
        }
        function _resolve() {
          return (_resolve = _asyncToGenerator(function* (specifier, parent) {
            if (!parent)
              throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
            try {
              return defaultResolve(specifier, { parentURL: parent }).url;
            } catch (error) {
              return error.code === "ERR_UNSUPPORTED_DIR_IMPORT" ? error.url : Promise.reject(error);
            }
          })).apply(this, arguments);
        }
      }, "./node_modules/@babel/core/node_modules/semver/semver.js": (module3, exports2) => {
        var debug;
        exports2 = module3.exports = SemVer, debug = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
          var args = Array.prototype.slice.call(arguments, 0);
          args.unshift("SEMVER"), console.log.apply(console, args);
        } : function() {
        }, exports2.SEMVER_SPEC_VERSION = "2.0.0";
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, re = exports2.re = [], src = exports2.src = [], t = exports2.tokens = {}, R = 0;
        function tok(n) {
          t[n] = R++;
        }
        tok("NUMERICIDENTIFIER"), src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*", tok("NUMERICIDENTIFIERLOOSE"), src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+", tok("NONNUMERICIDENTIFIER"), src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", tok("MAINVERSION"), src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")", tok("MAINVERSIONLOOSE"), src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")", tok("PRERELEASEIDENTIFIER"), src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASEIDENTIFIERLOOSE"), src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASE"), src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))", tok("PRERELEASELOOSE"), src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))", tok("BUILDIDENTIFIER"), src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+", tok("BUILD"), src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))", tok("FULL"), tok("FULLPLAIN"), src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?", src[t.FULL] = "^" + src[t.FULLPLAIN] + "$", tok("LOOSEPLAIN"), src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?", tok("LOOSE"), src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$", tok("GTLT"), src[t.GTLT] = "((?:<|>)?=?)", tok("XRANGEIDENTIFIERLOOSE"), src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", tok("XRANGEIDENTIFIER"), src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*", tok("XRANGEPLAIN"), src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?", tok("XRANGEPLAINLOOSE"), src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?", tok("XRANGE"), src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$", tok("XRANGELOOSE"), src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$", tok("COERCE"), src[t.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", tok("COERCERTL"), re[t.COERCERTL] = new RegExp(src[t.COERCE], "g"), tok("LONETILDE"), src[t.LONETILDE] = "(?:~>?)", tok("TILDETRIM"), src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+", re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
        tok("TILDE"), src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$", tok("TILDELOOSE"), src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$", tok("LONECARET"), src[t.LONECARET] = "(?:\\^)", tok("CARETTRIM"), src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+", re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
        tok("CARET"), src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$", tok("CARETLOOSE"), src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$", tok("COMPARATORLOOSE"), src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$", tok("COMPARATOR"), src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$", tok("COMPARATORTRIM"), src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
        tok("HYPHENRANGE"), src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$", tok("HYPHENRANGELOOSE"), src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$", tok("STAR"), src[t.STAR] = "(<|>)?=?\\s*\\*";
        for (var i = 0; i < R; i++)
          debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
        function parse2(version3, options) {
          if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), version3 instanceof SemVer)
            return version3;
          if (typeof version3 != "string")
            return null;
          if (version3.length > 256)
            return null;
          if (!(options.loose ? re[t.LOOSE] : re[t.FULL]).test(version3))
            return null;
          try {
            return new SemVer(version3, options);
          } catch (er) {
            return null;
          }
        }
        function SemVer(version3, options) {
          if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), version3 instanceof SemVer) {
            if (version3.loose === options.loose)
              return version3;
            version3 = version3.version;
          } else if (typeof version3 != "string")
            throw new TypeError("Invalid Version: " + version3);
          if (version3.length > 256)
            throw new TypeError("version is longer than 256 characters");
          if (!(this instanceof SemVer))
            return new SemVer(version3, options);
          debug("SemVer", version3, options), this.options = options, this.loose = !!options.loose;
          var m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m)
            throw new TypeError("Invalid Version: " + version3);
          if (this.raw = version3, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
            throw new TypeError("Invalid patch version");
          m[4] ? this.prerelease = m[4].split(".").map(function(id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER)
                return num;
            }
            return id;
          }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
        }
        exports2.parse = parse2, exports2.valid = function(version3, options) {
          var v = parse2(version3, options);
          return v ? v.version : null;
        }, exports2.clean = function(version3, options) {
          var s = parse2(version3.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        }, exports2.SemVer = SemVer, SemVer.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, SemVer.prototype.toString = function() {
          return this.version;
        }, SemVer.prototype.compare = function(other) {
          return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
        }, SemVer.prototype.compareMain = function(other) {
          return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }, SemVer.prototype.comparePre = function(other) {
          if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length)
            return -1;
          if (!this.prerelease.length && other.prerelease.length)
            return 1;
          if (!this.prerelease.length && !other.prerelease.length)
            return 0;
          var i2 = 0;
          do {
            var a = this.prerelease[i2], b = other.prerelease[i2];
            if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
              return 0;
            if (b === void 0)
              return 1;
            if (a === void 0)
              return -1;
            if (a !== b)
              return compareIdentifiers(a, b);
          } while (++i2);
        }, SemVer.prototype.compareBuild = function(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          var i2 = 0;
          do {
            var a = this.build[i2], b = other.build[i2];
            if (debug("prerelease compare", i2, a, b), a === void 0 && b === void 0)
              return 0;
            if (b === void 0)
              return 1;
            if (a === void 0)
              return -1;
            if (a !== b)
              return compareIdentifiers(a, b);
          } while (++i2);
        }, SemVer.prototype.inc = function(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                for (var i2 = this.prerelease.length; --i2 >= 0; )
                  typeof this.prerelease[i2] == "number" && (this.prerelease[i2]++, i2 = -2);
                i2 === -1 && this.prerelease.push(0);
              }
              identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + release);
          }
          return this.format(), this.raw = this.version, this;
        }, exports2.inc = function(version3, release, loose, identifier) {
          typeof loose == "string" && (identifier = loose, loose = void 0);
          try {
            return new SemVer(version3, loose).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        }, exports2.diff = function(version1, version22) {
          if (eq(version1, version22))
            return null;
          var v1 = parse2(version1), v2 = parse2(version22), prefix = "";
          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = "pre";
            var defaultResult = "prerelease";
          }
          for (var key in v1)
            if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key])
              return prefix + key;
          return defaultResult;
        }, exports2.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        function compareIdentifiers(a, b) {
          var anum = numeric.test(a), bnum = numeric.test(b);
          return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }
        function compare(a, b, loose) {
          return new SemVer(a, loose).compare(new SemVer(b, loose));
        }
        function gt(a, b, loose) {
          return compare(a, b, loose) > 0;
        }
        function lt(a, b, loose) {
          return compare(a, b, loose) < 0;
        }
        function eq(a, b, loose) {
          return compare(a, b, loose) === 0;
        }
        function neq(a, b, loose) {
          return compare(a, b, loose) !== 0;
        }
        function gte(a, b, loose) {
          return compare(a, b, loose) >= 0;
        }
        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0;
        }
        function cmp(a, op, b, loose) {
          switch (op) {
            case "===":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
            case "!==":
              return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
            case "":
            case "=":
            case "==":
              return eq(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError("Invalid operator: " + op);
          }
        }
        function Comparator(comp, options) {
          if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), comp instanceof Comparator) {
            if (comp.loose === !!options.loose)
              return comp;
            comp = comp.value;
          }
          if (!(this instanceof Comparator))
            return new Comparator(comp, options);
          debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
        }
        exports2.rcompareIdentifiers = function(a, b) {
          return compareIdentifiers(b, a);
        }, exports2.major = function(a, loose) {
          return new SemVer(a, loose).major;
        }, exports2.minor = function(a, loose) {
          return new SemVer(a, loose).minor;
        }, exports2.patch = function(a, loose) {
          return new SemVer(a, loose).patch;
        }, exports2.compare = compare, exports2.compareLoose = function(a, b) {
          return compare(a, b, true);
        }, exports2.compareBuild = function(a, b, loose) {
          var versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        }, exports2.rcompare = function(a, b, loose) {
          return compare(b, a, loose);
        }, exports2.sort = function(list, loose) {
          return list.sort(function(a, b) {
            return exports2.compareBuild(a, b, loose);
          });
        }, exports2.rsort = function(list, loose) {
          return list.sort(function(a, b) {
            return exports2.compareBuild(b, a, loose);
          });
        }, exports2.gt = gt, exports2.lt = lt, exports2.eq = eq, exports2.neq = neq, exports2.gte = gte, exports2.lte = lte, exports2.cmp = cmp, exports2.Comparator = Comparator;
        var ANY = {};
        function Range3(range, options) {
          if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), range instanceof Range3)
            return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range3(range.raw, options);
          if (range instanceof Comparator)
            return new Range3(range.value, options);
          if (!(this instanceof Range3))
            return new Range3(range, options);
          if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range, this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
            return this.parseRange(range2.trim());
          }, this).filter(function(c) {
            return c.length;
          }), !this.set.length)
            throw new TypeError("Invalid SemVer Range: " + range);
          this.format();
        }
        function isSatisfiable(comparators, options) {
          for (var result = true, remainingComparators = comparators.slice(), testComparator = remainingComparators.pop(); result && remainingComparators.length; )
            result = remainingComparators.every(function(otherComparator) {
              return testComparator.intersects(otherComparator, options);
            }), testComparator = remainingComparators.pop();
          return result;
        }
        function isX(id) {
          return !id || id.toLowerCase() === "x" || id === "*";
        }
        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
          return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
        }
        function testSet(set, version3, options) {
          for (var i2 = 0; i2 < set.length; i2++)
            if (!set[i2].test(version3))
              return false;
          if (version3.prerelease.length && !options.includePrerelease) {
            for (i2 = 0; i2 < set.length; i2++)
              if (debug(set[i2].semver), set[i2].semver !== ANY && set[i2].semver.prerelease.length > 0) {
                var allowed = set[i2].semver;
                if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch)
                  return true;
              }
            return false;
          }
          return true;
        }
        function satisfies(version3, range, options) {
          try {
            range = new Range3(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version3);
        }
        function outside(version3, range, hilo, options) {
          var gtfn, ltefn, ltfn, comp, ecomp;
          switch (version3 = new SemVer(version3, options), range = new Range3(range, options), hilo) {
            case ">":
              gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
              break;
            case "<":
              gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies(version3, range, options))
            return false;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2], high = null, low = null;
            if (comparators.forEach(function(comparator) {
              comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
            }), high.operator === comp || high.operator === ecomp)
              return false;
            if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver))
              return false;
            if (low.operator === ecomp && ltfn(version3, low.semver))
              return false;
          }
          return true;
        }
        Comparator.prototype.parse = function(comp) {
          var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
          if (!m)
            throw new TypeError("Invalid comparator: " + comp);
          this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
        }, Comparator.prototype.toString = function() {
          return this.value;
        }, Comparator.prototype.test = function(version3) {
          if (debug("Comparator.test", version3, this.options.loose), this.semver === ANY || version3 === ANY)
            return true;
          if (typeof version3 == "string")
            try {
              version3 = new SemVer(version3, this.options);
            } catch (er) {
              return false;
            }
          return cmp(version3, this.operator, this.semver, this.options);
        }, Comparator.prototype.intersects = function(comp, options) {
          if (!(comp instanceof Comparator))
            throw new TypeError("a Comparator is required");
          var rangeTmp;
          if (options && typeof options == "object" || (options = { loose: !!options, includePrerelease: false }), this.operator === "")
            return this.value === "" || (rangeTmp = new Range3(comp.value, options), satisfies(this.value, rangeTmp, options));
          if (comp.operator === "")
            return comp.value === "" || (rangeTmp = new Range3(this.value, options), satisfies(comp.semver, rangeTmp, options));
          var sameDirectionIncreasing = !(this.operator !== ">=" && this.operator !== ">" || comp.operator !== ">=" && comp.operator !== ">"), sameDirectionDecreasing = !(this.operator !== "<=" && this.operator !== "<" || comp.operator !== "<=" && comp.operator !== "<"), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(this.operator !== ">=" && this.operator !== "<=" || comp.operator !== ">=" && comp.operator !== "<="), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }, exports2.Range = Range3, Range3.prototype.format = function() {
          return this.range = this.set.map(function(comps) {
            return comps.join(" ").trim();
          }).join("||").trim(), this.range;
        }, Range3.prototype.toString = function() {
          return this.range;
        }, Range3.prototype.parseRange = function(range) {
          var loose = this.options.loose;
          range = range.trim();
          var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], "$1$2$3"), debug("comparator trim", range, re[t.COMPARATORTRIM]), range = (range = (range = range.replace(re[t.TILDETRIM], "$1~")).replace(re[t.CARETTRIM], "$1^")).split(/\s+/).join(" ");
          var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], set = range.split(" ").map(function(comp) {
            return function(comp2, options) {
              return debug("comp", comp2, options), comp2 = function(comp3, options2) {
                return comp3.trim().split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    debug("caret", comp5, options3);
                    var r = options3.loose ? re[t.CARETLOOSE] : re[t.CARET];
                    return comp5.replace(r, function(_, M, m, p, pr) {
                      var ret;
                      return debug("caret", comp5, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = M === "0" ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), ret = M === "0" ? m === "0" ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), ret = M === "0" ? m === "0" ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("caret", comp2), comp2 = function(comp3, options2) {
                return comp3.trim().split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    var r = options3.loose ? re[t.TILDELOOSE] : re[t.TILDE];
                    return comp5.replace(r, function(_, M, m, p, pr) {
                      var ret;
                      return debug("tilde", comp5, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("tildes", comp2), comp2 = function(comp3, options2) {
                return debug("replaceXRanges", comp3, options2), comp3.split(/\s+/).map(function(comp4) {
                  return function(comp5, options3) {
                    comp5 = comp5.trim();
                    var r = options3.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
                    return comp5.replace(r, function(ret, gtlt, M, m, p, pr) {
                      debug("xRange", comp5, ret, gtlt, M, m, p, pr);
                      var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
                      return gtlt === "=" && anyX && (gtlt = ""), pr = options3.includePrerelease ? "-0" : "", xM ? ret = gtlt === ">" || gtlt === "<" ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p + pr) : xm ? ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr : xp && (ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr), debug("xRange return", ret), ret;
                    });
                  }(comp4, options2);
                }).join(" ");
              }(comp2, options), debug("xrange", comp2), comp2 = function(comp3, options2) {
                return debug("replaceStars", comp3, options2), comp3.trim().replace(re[t.STAR], "");
              }(comp2, options), debug("stars", comp2), comp2;
            }(comp, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (set = set.filter(function(comp) {
            return !!comp.match(compRe);
          })), set = set.map(function(comp) {
            return new Comparator(comp, this.options);
          }, this);
        }, Range3.prototype.intersects = function(range, options) {
          if (!(range instanceof Range3))
            throw new TypeError("a Range is required");
          return this.set.some(function(thisComparators) {
            return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
              return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                return rangeComparators.every(function(rangeComparator) {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }, exports2.toComparators = function(range, options) {
          return new Range3(range, options).set.map(function(comp) {
            return comp.map(function(c) {
              return c.value;
            }).join(" ").trim().split(" ");
          });
        }, Range3.prototype.test = function(version3) {
          if (!version3)
            return false;
          if (typeof version3 == "string")
            try {
              version3 = new SemVer(version3, this.options);
            } catch (er) {
              return false;
            }
          for (var i2 = 0; i2 < this.set.length; i2++)
            if (testSet(this.set[i2], version3, this.options))
              return true;
          return false;
        }, exports2.satisfies = satisfies, exports2.maxSatisfying = function(versions, range, options) {
          var max = null, maxSV = null;
          try {
            var rangeObj = new Range3(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach(function(v) {
            rangeObj.test(v) && (max && maxSV.compare(v) !== -1 || (maxSV = new SemVer(max = v, options)));
          }), max;
        }, exports2.minSatisfying = function(versions, range, options) {
          var min = null, minSV = null;
          try {
            var rangeObj = new Range3(range, options);
          } catch (er) {
            return null;
          }
          return versions.forEach(function(v) {
            rangeObj.test(v) && (min && minSV.compare(v) !== 1 || (minSV = new SemVer(min = v, options)));
          }), min;
        }, exports2.minVersion = function(range, loose) {
          range = new Range3(range, loose);
          var minver = new SemVer("0.0.0");
          if (range.test(minver))
            return minver;
          if (minver = new SemVer("0.0.0-0"), range.test(minver))
            return minver;
          minver = null;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            range.set[i2].forEach(function(comparator) {
              var compver = new SemVer(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
                case "":
                case ">=":
                  minver && !gt(minver, compver) || (minver = compver);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + comparator.operator);
              }
            });
          }
          if (minver && range.test(minver))
            return minver;
          return null;
        }, exports2.validRange = function(range, options) {
          try {
            return new Range3(range, options).range || "*";
          } catch (er) {
            return null;
          }
        }, exports2.ltr = function(version3, range, options) {
          return outside(version3, range, "<", options);
        }, exports2.gtr = function(version3, range, options) {
          return outside(version3, range, ">", options);
        }, exports2.outside = outside, exports2.prerelease = function(version3, options) {
          var parsed = parse2(version3, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }, exports2.intersects = function(r1, r2, options) {
          return r1 = new Range3(r1, options), r2 = new Range3(r2, options), r1.intersects(r2);
        }, exports2.coerce = function(version3, options) {
          if (version3 instanceof SemVer)
            return version3;
          typeof version3 == "number" && (version3 = String(version3));
          if (typeof version3 != "string")
            return null;
          var match = null;
          if ((options = options || {}).rtl) {
            for (var next; (next = re[t.COERCERTL].exec(version3)) && (!match || match.index + match[0].length !== version3.length); )
              match && next.index + next[0].length === match.index + match[0].length || (match = next), re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            re[t.COERCERTL].lastIndex = -1;
          } else
            match = version3.match(re[t.COERCE]);
          if (match === null)
            return null;
          return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/array-set.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/util.js"), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map != "undefined";
        function ArraySet() {
          this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        }
        ArraySet.fromArray = function(aArray, aAllowDuplicates) {
          for (var set = new ArraySet(), i = 0, len = aArray.length; i < len; i++)
            set.add(aArray[i], aAllowDuplicates);
          return set;
        }, ArraySet.prototype.size = function() {
          return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }, ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
          var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
          isDuplicate && !aAllowDuplicates || this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
        }, ArraySet.prototype.has = function(aStr) {
          if (hasNativeMap)
            return this._set.has(aStr);
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }, ArraySet.prototype.indexOf = function(aStr) {
          if (hasNativeMap) {
            var idx = this._set.get(aStr);
            if (idx >= 0)
              return idx;
          } else {
            var sStr = util.toSetString(aStr);
            if (has.call(this._set, sStr))
              return this._set[sStr];
          }
          throw new Error('"' + aStr + '" is not in the set.');
        }, ArraySet.prototype.at = function(aIdx) {
          if (aIdx >= 0 && aIdx < this._array.length)
            return this._array[aIdx];
          throw new Error("No element indexed by " + aIdx);
        }, ArraySet.prototype.toArray = function() {
          return this._array.slice();
        }, exports2.I = ArraySet;
      }, "./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var base64 = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/base64.js");
        exports2.encode = function(aValue) {
          var digit, encoded = "", vlq = function(aValue2) {
            return aValue2 < 0 ? 1 + (-aValue2 << 1) : 0 + (aValue2 << 1);
          }(aValue);
          do {
            digit = 31 & vlq, (vlq >>>= 5) > 0 && (digit |= 32), encoded += base64.encode(digit);
          } while (vlq > 0);
          return encoded;
        }, exports2.decode = function(aStr, aIndex, aOutParam) {
          var continuation, digit, aValue, shifted, strLen = aStr.length, result = 0, shift = 0;
          do {
            if (aIndex >= strLen)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if ((digit = base64.decode(aStr.charCodeAt(aIndex++))) === -1)
              throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
            continuation = !!(32 & digit), result += (digit &= 31) << shift, shift += 5;
          } while (continuation);
          aOutParam.value = (shifted = (aValue = result) >> 1, (1 & aValue) == 1 ? -shifted : shifted), aOutParam.rest = aIndex;
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/base64.js": (__unused_webpack_module, exports2) => {
        var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        exports2.encode = function(number) {
          if (0 <= number && number < intToCharMap.length)
            return intToCharMap[number];
          throw new TypeError("Must be between 0 and 63: " + number);
        }, exports2.decode = function(charCode) {
          return 65 <= charCode && charCode <= 90 ? charCode - 65 : 97 <= charCode && charCode <= 122 ? charCode - 97 + 26 : 48 <= charCode && charCode <= 57 ? charCode - 48 + 52 : charCode == 43 ? 62 : charCode == 47 ? 63 : -1;
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js": (__unused_webpack_module, exports2) => {
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
          var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], true);
          return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
        }
        exports2.GREATEST_LOWER_BOUND = 1, exports2.LEAST_UPPER_BOUND = 2, exports2.search = function(aNeedle, aHaystack, aCompare, aBias) {
          if (aHaystack.length === 0)
            return -1;
          var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
          if (index < 0)
            return -1;
          for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], true) === 0; )
            --index;
          return index;
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/util.js");
        function MappingList() {
          this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
        }
        MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        }, MappingList.prototype.add = function(aMapping) {
          var mappingA, mappingB, lineA, lineB, columnA, columnB;
          mappingA = this._last, mappingB = aMapping, lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn, lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0 ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = false, this._array.push(aMapping));
        }, MappingList.prototype.toArray = function() {
          return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
        }, exports2.H = MappingList;
      }, "./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js": (__unused_webpack_module, exports2) => {
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y], ary[y] = temp;
        }
        function doQuickSort(ary, comparator, p, r) {
          if (p < r) {
            var i = p - 1;
            swap(ary, (low = p, high = r, Math.round(low + Math.random() * (high - low))), r);
            for (var pivot = ary[r], j = p; j < r; j++)
              comparator(ary[j], pivot) <= 0 && swap(ary, i += 1, j);
            swap(ary, i + 1, j);
            var q = i + 1;
            doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
          }
          var low, high;
        }
        exports2.U = function(ary, comparator) {
          doQuickSort(ary, comparator, 0, ary.length - 1);
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/util.js"), binarySearch = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/binary-search.js"), ArraySet = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I, base64VLQ = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"), quickSort = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/quick-sort.js").U;
        function SourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          return typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""))), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
        }
        function BasicSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
          var version3 = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
          if (version3 != this._version)
            throw new Error("Unsupported version: " + version3);
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          }), this._names = ArraySet.fromArray(names.map(String), true), this._sources = ArraySet.fromArray(sources, true), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this.file = file;
        }
        function Mapping() {
          this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
        }
        function IndexedSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
          var version3 = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
          if (version3 != this._version)
            throw new Error("Unsupported version: " + version3);
          this._sources = new ArraySet(), this._names = new ArraySet();
          var lastOffset = { line: -1, column: 0 };
          this._sections = sections.map(function(s) {
            if (s.url)
              throw new Error("Support for url field in sections not implemented.");
            var offset = util.getArg(s, "offset"), offsetLine = util.getArg(offset, "line"), offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
              throw new Error("Section offsets must be ordered and non-overlapping.");
            return lastOffset = offset, { generatedOffset: { generatedLine: offsetLine + 1, generatedColumn: offsetColumn + 1 }, consumer: new SourceMapConsumer(util.getArg(s, "map")) };
          });
        }
        SourceMapConsumer.fromSourceMap = function(aSourceMap) {
          return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
        }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", { get: function() {
          return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
        } }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", { get: function() {
          return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
        } }), SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        }, SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
          var mappings, context = aContext || null;
          switch (aOrder || SourceMapConsumer.GENERATED_ORDER) {
            case SourceMapConsumer.GENERATED_ORDER:
              mappings = this._generatedMappings;
              break;
            case SourceMapConsumer.ORIGINAL_ORDER:
              mappings = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var sourceRoot = this.sourceRoot;
          mappings.map(function(mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            return source != null && sourceRoot != null && (source = util.join(sourceRoot, source)), { source, generatedLine: mapping.generatedLine, generatedColumn: mapping.generatedColumn, originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name: mapping.name === null ? null : this._names.at(mapping.name) };
          }, this).forEach(aCallback, context);
        }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
          var line = util.getArg(aArgs, "line"), needle = { source: util.getArg(aArgs, "source"), originalLine: line, originalColumn: util.getArg(aArgs, "column", 0) };
          if (this.sourceRoot != null && (needle.source = util.relative(this.sourceRoot, needle.source)), !this._sources.has(needle.source))
            return [];
          needle.source = this._sources.indexOf(needle.source);
          var mappings = [], index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (aArgs.column === void 0)
              for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) }), mapping = this._originalMappings[++index];
            else
              for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) }), mapping = this._originalMappings[++index];
          }
          return mappings;
        }, exports2.SourceMapConsumer = SourceMapConsumer, BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.fromSourceMap = function(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot), smc.file = aSourceMap._file;
          for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i], destMapping = new Mapping();
            destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
          }
          return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
        }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
          return this._sources.toArray().map(function(s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        } }), BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          for (var mapping, str, segment, end, value, generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = []; index < length; )
            if (aStr.charAt(index) === ";")
              generatedLine++, index++, previousGeneratedColumn = 0;
            else if (aStr.charAt(index) === ",")
              index++;
            else {
              for ((mapping = new Mapping()).generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
                ;
              if (segment = cachedSegments[str = aStr.slice(index, end)])
                index += str.length;
              else {
                for (segment = []; index < end; )
                  base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
                if (segment.length === 2)
                  throw new Error("Found a source, but no line and column");
                if (segment.length === 3)
                  throw new Error("Found a source and line, but no column");
                cachedSegments[str] = segment;
              }
              mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
            }
          quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
        }, BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
          if (aNeedle[aLineName] <= 0)
            throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
          if (aNeedle[aColumnName] < 0)
            throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
            mapping.lastGeneratedColumn = 1 / 0;
          }
        }, BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") }, index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, "source", null);
              source !== null && (source = this._sources.at(source), this.sourceRoot != null && (source = util.join(this.sourceRoot, source)));
              var name = util.getArg(mapping, "name", null);
              return name !== null && (name = this._names.at(name)), { source, line: util.getArg(mapping, "originalLine", null), column: util.getArg(mapping, "originalColumn", null), name };
            }
          }
          return { source: null, line: null, column: null, name: null };
        }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
          return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
            return sc == null;
          }));
        }, BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
          if (!this.sourcesContent)
            return null;
          if (this.sourceRoot != null && (aSource = util.relative(this.sourceRoot, aSource)), this._sources.has(aSource))
            return this.sourcesContent[this._sources.indexOf(aSource)];
          var url;
          if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            if ((!url.path || url.path == "/") && this._sources.has("/" + aSource))
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
          }
          if (nullOnMissing)
            return null;
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
          var source = util.getArg(aArgs, "source");
          if (this.sourceRoot != null && (source = util.relative(this.sourceRoot, source)), !this._sources.has(source))
            return { line: null, column: null, lastColumn: null };
          var needle = { source: source = this._sources.indexOf(source), originalLine: util.getArg(aArgs, "line"), originalColumn: util.getArg(aArgs, "column") }, index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (mapping.source === needle.source)
              return { line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) };
          }
          return { line: null, column: null, lastColumn: null };
        }, IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
          for (var sources = [], i = 0; i < this._sections.length; i++)
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++)
              sources.push(this._sections[i].consumer.sources[j]);
          return sources;
        } }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") }, sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }), section = this._sections[sectionIndex];
          return section ? section.consumer.originalPositionFor({ line: needle.generatedLine - (section.generatedOffset.generatedLine - 1), column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), bias: aArgs.bias }) : { source: null, line: null, column: null, name: null };
        }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
          return this._sections.every(function(s) {
            return s.consumer.hasContentsOfAllSources();
          });
        }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var content = this._sections[i].consumer.sourceContentFor(aSource, true);
            if (content)
              return content;
          }
          if (nullOnMissing)
            return null;
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) !== -1) {
              var generatedPosition = section.consumer.generatedPositionFor(aArgs);
              if (generatedPosition)
                return { line: generatedPosition.line + (section.generatedOffset.generatedLine - 1), column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0) };
            }
          }
          return { line: null, column: null };
        }, IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          this.__generatedMappings = [], this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++)
            for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
              section.consumer.sourceRoot !== null && (source = util.join(section.consumer.sourceRoot, source)), this._sources.add(source), source = this._sources.indexOf(source);
              var name = section.consumer._names.at(mapping.name);
              this._names.add(name), name = this._names.indexOf(name);
              var adjustedMapping = { source, generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1), generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name };
              this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
            }
          quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
      }, "./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var base64VLQ = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/base64-vlq.js"), util = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/util.js"), ArraySet = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/array-set.js").I, MappingList = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/mapping-list.js").H;
        function SourceMapGenerator(aArgs) {
          aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", false), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
        }
        SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({ file: aSourceMapConsumer.file, sourceRoot });
          return aSourceMapConsumer.eachMapping(function(mapping) {
            var newMapping = { generated: { line: mapping.generatedLine, column: mapping.generatedColumn } };
            mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = { line: mapping.originalLine, column: mapping.originalColumn }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
          }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            content != null && generator.setSourceContent(sourceFile, content);
          }), generator;
        }, SourceMapGenerator.prototype.addMapping = function(aArgs) {
          var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
          this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({ generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name });
        }, SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        }, SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null)
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
          var newSources = new ArraySet(), newNames = new ArraySet();
          this._mappings.unsortedForEach(function(mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({ line: mapping.originalLine, column: mapping.originalColumn });
              original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
            }
            var source = mapping.source;
            source == null || newSources.has(source) || newSources.add(source);
            var name = mapping.name;
            name == null || newNames.has(name) || newNames.add(name);
          }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
            content != null && (aSourceMapPath != null && (sourceFile2 = util.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
          }, this);
        }, SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
          if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          if ((!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0) || aOriginal || aSource || aName) && !(aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource))
            throw new Error("Invalid mapping: " + JSON.stringify({ generated: aGenerated, source: aSource, original: aOriginal, name: aName }));
        }, SourceMapGenerator.prototype._serializeMappings = function() {
          for (var next, mapping, nameIdx, sourceIdx, previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
            if (next = "", (mapping = mappings[i]).generatedLine !== previousGeneratedLine)
              for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
                next += ";", previousGeneratedLine++;
            else if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1]))
                continue;
              next += ",";
            }
            next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
          }
          return result;
        }, SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
          return aSources.map(function(source) {
            if (!this._sourcesContents)
              return null;
            aSourceRoot != null && (source = util.relative(aSourceRoot, source));
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
          }, this);
        }, SourceMapGenerator.prototype.toJSON = function() {
          var map = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
          return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
        }, SourceMapGenerator.prototype.toString = function() {
          return JSON.stringify(this.toJSON());
        }, exports2.SourceMapGenerator = SourceMapGenerator;
      }, "./node_modules/@babel/core/node_modules/source-map/lib/source-node.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var SourceMapGenerator = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator, util = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/util.js"), REGEX_NEWLINE = /(\r?\n)/, isSourceNode = "$$$isSourceNode$$$";
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
          this.children = [], this.sourceContents = {}, this.line = aLine == null ? null : aLine, this.column = aColumn == null ? null : aColumn, this.source = aSource == null ? null : aSource, this.name = aName == null ? null : aName, this[isSourceNode] = true, aChunks != null && this.add(aChunks);
        }
        SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
            return getNextLine() + (getNextLine() || "");
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
            }
          }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
          return aSourceMapConsumer.eachMapping(function(mapping) {
            if (lastMapping !== null) {
              if (!(lastGeneratedLine < mapping.generatedLine)) {
                var code = (nextLine = remainingLines[remainingLinesIndex]).substr(0, mapping.generatedColumn - lastGeneratedColumn);
                return remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), void (lastMapping = mapping);
              }
              addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
            }
            for (; lastGeneratedLine < mapping.generatedLine; )
              node.add(shiftNextLine()), lastGeneratedLine++;
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[remainingLinesIndex];
              node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
          }), node;
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === void 0)
              node.add(code);
            else {
              var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
              node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
            }
          }
        }, SourceNode.prototype.add = function(aChunk) {
          if (Array.isArray(aChunk))
            aChunk.forEach(function(chunk) {
              this.add(chunk);
            }, this);
          else {
            if (!aChunk[isSourceNode] && typeof aChunk != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            aChunk && this.children.push(aChunk);
          }
          return this;
        }, SourceNode.prototype.prepend = function(aChunk) {
          if (Array.isArray(aChunk))
            for (var i = aChunk.length - 1; i >= 0; i--)
              this.prepend(aChunk[i]);
          else {
            if (!aChunk[isSourceNode] && typeof aChunk != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            this.children.unshift(aChunk);
          }
          return this;
        }, SourceNode.prototype.walk = function(aFn) {
          for (var chunk, i = 0, len = this.children.length; i < len; i++)
            (chunk = this.children[i])[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, { source: this.source, line: this.line, column: this.column, name: this.name });
        }, SourceNode.prototype.join = function(aSep) {
          var newChildren, i, len = this.children.length;
          if (len > 0) {
            for (newChildren = [], i = 0; i < len - 1; i++)
              newChildren.push(this.children[i]), newChildren.push(aSep);
            newChildren.push(this.children[i]), this.children = newChildren;
          }
          return this;
        }, SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
          var lastChild = this.children[this.children.length - 1];
          return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
        }, SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        }, SourceNode.prototype.walkSourceContents = function(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++)
            this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
          var sources = Object.keys(this.sourceContents);
          for (i = 0, len = sources.length; i < len; i++)
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }, SourceNode.prototype.toString = function() {
          var str = "";
          return this.walk(function(chunk) {
            str += chunk;
          }), str;
        }, SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
          var generated = { code: "", line: 1, column: 0 }, map = new SourceMapGenerator(aArgs), sourceMappingActive = false, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
          return this.walk(function(chunk, original) {
            generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? (lastOriginalSource === original.source && lastOriginalLine === original.line && lastOriginalColumn === original.column && lastOriginalName === original.name || map.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = true) : sourceMappingActive && (map.addMapping({ generated: { line: generated.line, column: generated.column } }), lastOriginalSource = null, sourceMappingActive = false);
            for (var idx = 0, length = chunk.length; idx < length; idx++)
              chunk.charCodeAt(idx) === 10 ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = false) : sourceMappingActive && map.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name })) : generated.column++;
          }), this.walkSourceContents(function(sourceFile, sourceContent) {
            map.setSourceContent(sourceFile, sourceContent);
          }), { code: generated.code, map };
        }, exports2.SourceNode = SourceNode;
      }, "./node_modules/@babel/core/node_modules/source-map/lib/util.js": (__unused_webpack_module, exports2) => {
        exports2.getArg = function(aArgs, aName, aDefaultValue) {
          if (aName in aArgs)
            return aArgs[aName];
          if (arguments.length === 3)
            return aDefaultValue;
          throw new Error('"' + aName + '" is a required argument.');
        };
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/, dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
          var match = aUrl.match(urlRegexp);
          return match ? { scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5] } : null;
        }
        function urlGenerate(aParsedUrl) {
          var url = "";
          return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
        }
        function normalize(aPath) {
          var path = aPath, url = urlParse(aPath);
          if (url) {
            if (!url.path)
              return aPath;
            path = url.path;
          }
          for (var part, isAbsolute2 = exports2.isAbsolute(path), parts = path.split(/\/+/), up = 0, i = parts.length - 1; i >= 0; i--)
            (part = parts[i]) === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
          return (path = parts.join("/")) === "" && (path = isAbsolute2 ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
        }
        exports2.urlParse = urlParse, exports2.urlGenerate = urlGenerate, exports2.normalize = normalize, exports2.join = function(aRoot, aPath) {
          aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
          var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
          if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
            return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
          if (aPathUrl || aPath.match(dataUrlRegexp))
            return aPath;
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
            return aRootUrl.host = aPath, urlGenerate(aRootUrl);
          var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
          return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
        }, exports2.isAbsolute = function(aPath) {
          return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
        }, exports2.relative = function(aRoot, aPath) {
          aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
          for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0)
              return aPath;
            if ((aRoot = aRoot.slice(0, index)).match(/^([^\/]+:\/)?\/*$/))
              return aPath;
            ++level;
          }
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        };
        var supportsNullProto = !("__proto__" in /* @__PURE__ */ Object.create(null));
        function identity(s) {
          return s;
        }
        function isProtoString(s) {
          if (!s)
            return false;
          var length = s.length;
          if (length < 9)
            return false;
          if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95)
            return false;
          for (var i = length - 10; i >= 0; i--)
            if (s.charCodeAt(i) !== 36)
              return false;
          return true;
        }
        function strcmp(aStr1, aStr2) {
          return aStr1 === aStr2 ? 0 : aStr1 > aStr2 ? 1 : -1;
        }
        exports2.toSetString = supportsNullProto ? identity : function(aStr) {
          return isProtoString(aStr) ? "$" + aStr : aStr;
        }, exports2.fromSetString = supportsNullProto ? identity : function(aStr) {
          return isProtoString(aStr) ? aStr.slice(1) : aStr;
        }, exports2.compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
          var cmp = mappingA.source - mappingB.source;
          return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 || onlyCompareOriginal || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || (cmp = mappingA.generatedLine - mappingB.generatedLine) !== 0 ? cmp : mappingA.name - mappingB.name;
        }, exports2.compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || onlyCompareGenerated || (cmp = mappingA.source - mappingB.source) !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 ? cmp : mappingA.name - mappingB.name;
        }, exports2.compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || (cmp = strcmp(mappingA.source, mappingB.source)) !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 ? cmp : strcmp(mappingA.name, mappingB.name);
        };
      }, "./node_modules/@babel/core/node_modules/source-map/source-map.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        exports2.SourceMapGenerator = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator, exports2.SourceMapConsumer = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer, exports2.SourceNode = __webpack_require__2("./node_modules/@babel/core/node_modules/source-map/lib/source-node.js").SourceNode;
      }, "./node_modules/@babel/generator/lib/buffer.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        const SPACES_RE = /^[ \t]+$/;
        exports2.default = class {
          constructor(map) {
            this._map = null, this._buf = "", this._last = 0, this._queue = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: null, line: null, column: null, filename: null }, this._disallowedPop = null, this._map = map;
          }
          get() {
            this._flush();
            const map = this._map, result = { code: this._buf.trimRight(), map: null, rawMappings: map == null ? void 0 : map.getRawMappings() };
            return map && Object.defineProperty(result, "map", { configurable: true, enumerable: true, get() {
              return this.map = map.get();
            }, set(value) {
              Object.defineProperty(this, "map", { value, writable: true });
            } }), result;
          }
          append(str) {
            this._flush();
            const { line, column, filename, identifierName, force } = this._sourcePosition;
            this._append(str, line, column, identifierName, filename, force);
          }
          queue(str) {
            if (str === "\n")
              for (; this._queue.length > 0 && SPACES_RE.test(this._queue[0][0]); )
                this._queue.shift();
            const { line, column, filename, identifierName, force } = this._sourcePosition;
            this._queue.unshift([str, line, column, identifierName, filename, force]);
          }
          _flush() {
            let item;
            for (; item = this._queue.pop(); )
              this._append(...item);
          }
          _append(str, line, column, identifierName, filename, force) {
            this._buf += str, this._last = str.charCodeAt(str.length - 1);
            let i = str.indexOf("\n"), last = 0;
            for (i !== 0 && this._mark(line, column, identifierName, filename, force); i !== -1; )
              this._position.line++, this._position.column = 0, last = i + 1, last < str.length && this._mark(++line, 0, identifierName, filename, force), i = str.indexOf("\n", last);
            this._position.column += str.length - last;
          }
          _mark(line, column, identifierName, filename, force) {
            var _this$_map;
            (_this$_map = this._map) == null || _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
          }
          removeTrailingNewline() {
            this._queue.length > 0 && this._queue[0][0] === "\n" && this._queue.shift();
          }
          removeLastSemicolon() {
            this._queue.length > 0 && this._queue[0][0] === ";" && this._queue.shift();
          }
          getLastChar() {
            let last;
            if (this._queue.length > 0) {
              last = this._queue[0][0].charCodeAt(0);
            } else
              last = this._last;
            return last;
          }
          endsWithCharAndNewline() {
            const queue = this._queue;
            if (queue.length > 0) {
              if (queue[0][0].charCodeAt(0) !== 10)
                return;
              if (queue.length > 1) {
                return queue[1][0].charCodeAt(0);
              }
              return this._last;
            }
          }
          hasContent() {
            return this._queue.length > 0 || !!this._last;
          }
          exactSource(loc, cb) {
            this.source("start", loc, true), cb(), this.source("end", loc), this._disallowPop("start", loc);
          }
          source(prop, loc, force) {
            prop && !loc || this._normalizePosition(prop, loc, this._sourcePosition, force);
          }
          withSource(prop, loc, cb) {
            if (!this._map)
              return cb();
            const originalLine = this._sourcePosition.line, originalColumn = this._sourcePosition.column, originalFilename = this._sourcePosition.filename, originalIdentifierName = this._sourcePosition.identifierName;
            this.source(prop, loc), cb(), this._sourcePosition.force && this._sourcePosition.line === originalLine && this._sourcePosition.column === originalColumn && this._sourcePosition.filename === originalFilename || this._disallowedPop && this._disallowedPop.line === originalLine && this._disallowedPop.column === originalColumn && this._disallowedPop.filename === originalFilename || (this._sourcePosition.line = originalLine, this._sourcePosition.column = originalColumn, this._sourcePosition.filename = originalFilename, this._sourcePosition.identifierName = originalIdentifierName, this._sourcePosition.force = false, this._disallowedPop = null);
          }
          _disallowPop(prop, loc) {
            prop && !loc || (this._disallowedPop = this._normalizePosition(prop, loc));
          }
          _normalizePosition(prop, loc, targetObj, force) {
            const pos = loc ? loc[prop] : null;
            targetObj === void 0 && (targetObj = { identifierName: null, line: null, column: null, filename: null, force: false });
            const origLine = targetObj.line, origColumn = targetObj.column, origFilename = targetObj.filename;
            return targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null, targetObj.line = pos == null ? void 0 : pos.line, targetObj.column = pos == null ? void 0 : pos.column, targetObj.filename = loc == null ? void 0 : loc.filename, (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) && (targetObj.force = force), targetObj;
          }
          getCurrentColumn() {
            const extra = this._queue.reduce((acc, item) => item[0] + acc, ""), lastIndex = extra.lastIndexOf("\n");
            return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
          }
          getCurrentLine() {
            const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
            let count = 0;
            for (let i = 0; i < extra.length; i++)
              extra[i] === "\n" && count++;
            return this._position.line + count;
          }
        };
      }, "./node_modules/@babel/generator/lib/generators/base.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.BlockStatement = function(node) {
          var _node$directives;
          this.token("{"), this.printInnerComments(node);
          const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
          node.body.length || hasDirectives ? (this.newline(), this.printSequence(node.directives, node, { indent: true }), hasDirectives && this.newline(), this.printSequence(node.body, node, { indent: true }), this.removeTrailingNewline(), this.source("end", node.loc), this.endsWith(10) || this.newline(), this.rightBrace()) : (this.source("end", node.loc), this.token("}"));
        }, exports2.Directive = function(node) {
          this.print(node.value, node), this.semicolon();
        }, exports2.DirectiveLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw != null)
            return void this.token(raw);
          const { value } = node;
          if (unescapedDoubleQuoteRE.test(value)) {
            if (unescapedSingleQuoteRE.test(value))
              throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${value}'`);
          } else
            this.token(`"${value}"`);
        }, exports2.File = function(node) {
          node.program && this.print(node.program.interpreter, node);
          this.print(node.program, node);
        }, exports2.InterpreterDirective = function(node) {
          this.token(`#!${node.value}
`);
        }, exports2.Placeholder = function(node) {
          this.token("%%"), this.print(node.name), this.token("%%"), node.expectedNode === "Statement" && this.semicolon();
        }, exports2.Program = function(node) {
          this.printInnerComments(node, false), this.printSequence(node.directives, node), node.directives && node.directives.length && this.newline();
          this.printSequence(node.body, node);
        };
        const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/@babel/generator/lib/generators/classes.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ClassBody = function(node) {
          this.token("{"), this.printInnerComments(node), node.body.length === 0 ? this.token("}") : (this.newline(), this.indent(), this.printSequence(node.body, node), this.dedent(), this.endsWith(10) || this.newline(), this.rightBrace());
        }, exports2.ClassExpression = exports2.ClassDeclaration = function(node, parent) {
          this.format.decoratorsBeforeExport && (isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent)) || this.printJoin(node.decorators, node);
          node.declare && (this.word("declare"), this.space());
          node.abstract && (this.word("abstract"), this.space());
          this.word("class"), this.printInnerComments(node), node.id && (this.space(), this.print(node.id, node));
          this.print(node.typeParameters, node), node.superClass && (this.space(), this.word("extends"), this.space(), this.print(node.superClass, node), this.print(node.superTypeParameters, node));
          node.implements && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
          this.space(), this.print(node.body, node);
        }, exports2.ClassMethod = function(node) {
          this._classMethodHead(node), this.space(), this.print(node.body, node);
        }, exports2.ClassPrivateMethod = function(node) {
          this._classMethodHead(node), this.space(), this.print(node.body, node);
        }, exports2.ClassPrivateProperty = function(node) {
          this.printJoin(node.decorators, node), node.static && (this.word("static"), this.space());
          this.print(node.key, node), this.print(node.typeAnnotation, node), node.value && (this.space(), this.token("="), this.space(), this.print(node.value, node));
          this.semicolon();
        }, exports2.ClassProperty = function(node) {
          this.printJoin(node.decorators, node), this.source("end", node.key.loc), this.tsPrintClassMemberModifiers(node, true), node.computed ? (this.token("["), this.print(node.key, node), this.token("]")) : (this._variance(node), this.print(node.key, node));
          node.optional && this.token("?");
          node.definite && this.token("!");
          this.print(node.typeAnnotation, node), node.value && (this.space(), this.token("="), this.space(), this.print(node.value, node));
          this.semicolon();
        }, exports2.StaticBlock = function(node) {
          this.word("static"), this.space(), this.token("{"), node.body.length === 0 ? this.token("}") : (this.newline(), this.printSequence(node.body, node, { indent: true }), this.rightBrace());
        }, exports2._classMethodHead = function(node) {
          this.printJoin(node.decorators, node), this.source("end", node.key.loc), this.tsPrintClassMemberModifiers(node, false), this._methodHead(node);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration, isExportNamedDeclaration } = _t;
      }, "./node_modules/@babel/generator/lib/generators/expressions.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = function(node, parent) {
          const parens = this.inForStatementInitCounter && node.operator === "in" && !n.needsParens(node, parent);
          parens && this.token("(");
          this.print(node.left, node), this.space(), node.operator === "in" || node.operator === "instanceof" ? this.word(node.operator) : this.token(node.operator);
          this.space(), this.print(node.right, node), parens && this.token(")");
        }, exports2.AssignmentPattern = function(node) {
          this.print(node.left, node), node.left.optional && this.token("?");
          this.print(node.left.typeAnnotation, node), this.space(), this.token("="), this.space(), this.print(node.right, node);
        }, exports2.AwaitExpression = void 0, exports2.BindExpression = function(node) {
          this.print(node.object, node), this.token("::"), this.print(node.callee, node);
        }, exports2.CallExpression = function(node) {
          this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), this.token("("), this.printList(node.arguments, node), this.token(")");
        }, exports2.ConditionalExpression = function(node) {
          this.print(node.test, node), this.space(), this.token("?"), this.space(), this.print(node.consequent, node), this.space(), this.token(":"), this.space(), this.print(node.alternate, node);
        }, exports2.Decorator = function(node) {
          this.token("@"), this.print(node.expression, node), this.newline();
        }, exports2.DoExpression = function(node) {
          node.async && (this.word("async"), this.space());
          this.word("do"), this.space(), this.print(node.body, node);
        }, exports2.EmptyStatement = function() {
          this.semicolon(true);
        }, exports2.ExpressionStatement = function(node) {
          this.print(node.expression, node), this.semicolon();
        }, exports2.Import = function() {
          this.word("import");
        }, exports2.MemberExpression = function(node) {
          if (this.print(node.object, node), !node.computed && isMemberExpression(node.property))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          let computed = node.computed;
          isLiteral(node.property) && typeof node.property.value == "number" && (computed = true);
          computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (this.token("."), this.print(node.property, node));
        }, exports2.MetaProperty = function(node) {
          this.print(node.meta, node), this.token("."), this.print(node.property, node);
        }, exports2.ModuleExpression = function(node) {
          this.word("module"), this.space(), this.token("{"), node.body.body.length === 0 ? this.token("}") : (this.newline(), this.printSequence(node.body.body, node, { indent: true }), this.rightBrace());
        }, exports2.NewExpression = function(node, parent) {
          if (this.word("new"), this.space(), this.print(node.callee, node), this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, { callee: node }) && !isMemberExpression(parent) && !isNewExpression(parent))
            return;
          this.print(node.typeArguments, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
          this.token("("), this.printList(node.arguments, node), this.token(")");
        }, exports2.OptionalCallExpression = function(node) {
          this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
          this.token("("), this.printList(node.arguments, node), this.token(")");
        }, exports2.OptionalMemberExpression = function(node) {
          if (this.print(node.object, node), !node.computed && isMemberExpression(node.property))
            throw new TypeError("Got a MemberExpression for MemberExpression property");
          let computed = node.computed;
          isLiteral(node.property) && typeof node.property.value == "number" && (computed = true);
          node.optional && this.token("?.");
          computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (node.optional || this.token("."), this.print(node.property, node));
        }, exports2.ParenthesizedExpression = function(node) {
          this.token("("), this.print(node.expression, node), this.token(")");
        }, exports2.PrivateName = function(node) {
          this.token("#"), this.print(node.id, node);
        }, exports2.SequenceExpression = function(node) {
          this.printList(node.expressions, node);
        }, exports2.Super = function() {
          this.word("super");
        }, exports2.ThisExpression = function() {
          this.word("this");
        }, exports2.UnaryExpression = function(node) {
          node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw" ? (this.word(node.operator), this.space()) : this.token(node.operator);
          this.print(node.argument, node);
        }, exports2.UpdateExpression = function(node) {
          node.prefix ? (this.token(node.operator), this.print(node.argument, node)) : (this.startTerminatorless(true), this.print(node.argument, node), this.endTerminatorless(), this.token(node.operator));
        }, exports2.V8IntrinsicIdentifier = function(node) {
          this.token("%"), this.word(node.name);
        }, exports2.YieldExpression = void 0;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), n = __webpack_require__2("./node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression, isLiteral, isMemberExpression, isNewExpression } = _t;
        function buildYieldAwait(keyword) {
          return function(node) {
            if (this.word(keyword), node.delegate && this.token("*"), node.argument) {
              this.space();
              const terminatorState = this.startTerminatorless();
              this.print(node.argument, node), this.endTerminatorless(terminatorState);
            }
          };
        }
        const YieldExpression = buildYieldAwait("yield");
        exports2.YieldExpression = YieldExpression;
        const AwaitExpression = buildYieldAwait("await");
        exports2.AwaitExpression = AwaitExpression;
      }, "./node_modules/@babel/generator/lib/generators/flow.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.AnyTypeAnnotation = function() {
          this.word("any");
        }, exports2.ArrayTypeAnnotation = function(node) {
          this.print(node.elementType, node), this.token("["), this.token("]");
        }, exports2.BooleanLiteralTypeAnnotation = function(node) {
          this.word(node.value ? "true" : "false");
        }, exports2.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, exports2.DeclareClass = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("class"), this.space(), this._interfaceish(node);
        }, exports2.DeclareExportAllDeclaration = function() {
          this.word("declare"), this.space(), _modules.ExportAllDeclaration.apply(this, arguments);
        }, exports2.DeclareExportDeclaration = function(node) {
          this.word("declare"), this.space(), this.word("export"), this.space(), node.default && (this.word("default"), this.space());
          FlowExportDeclaration.apply(this, arguments);
        }, exports2.DeclareFunction = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("function"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation.typeAnnotation, node), node.predicate && (this.space(), this.print(node.predicate, node));
          this.semicolon();
        }, exports2.DeclareInterface = function(node) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(node);
        }, exports2.DeclareModule = function(node) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(node.id, node), this.space(), this.print(node.body, node);
        }, exports2.DeclareModuleExports = function(node) {
          this.word("declare"), this.space(), this.word("module"), this.token("."), this.word("exports"), this.print(node.typeAnnotation, node);
        }, exports2.DeclareOpaqueType = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.OpaqueType(node);
        }, exports2.DeclareTypeAlias = function(node) {
          this.word("declare"), this.space(), this.TypeAlias(node);
        }, exports2.DeclareVariable = function(node, parent) {
          isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
          this.word("var"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation, node), this.semicolon();
        }, exports2.DeclaredPredicate = function(node) {
          this.token("%"), this.word("checks"), this.token("("), this.print(node.value, node), this.token(")");
        }, exports2.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, exports2.EnumBooleanBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "boolean", explicitType), enumBody(this, node);
        }, exports2.EnumBooleanMember = function(node) {
          enumInitializedMember(this, node);
        }, exports2.EnumDeclaration = function(node) {
          const { id, body } = node;
          this.word("enum"), this.space(), this.print(id, node), this.print(body, node);
        }, exports2.EnumDefaultedMember = function(node) {
          const { id } = node;
          this.print(id, node), this.token(",");
        }, exports2.EnumNumberBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "number", explicitType), enumBody(this, node);
        }, exports2.EnumNumberMember = function(node) {
          enumInitializedMember(this, node);
        }, exports2.EnumStringBody = function(node) {
          const { explicitType } = node;
          enumExplicitType(this, "string", explicitType), enumBody(this, node);
        }, exports2.EnumStringMember = function(node) {
          enumInitializedMember(this, node);
        }, exports2.EnumSymbolBody = function(node) {
          enumExplicitType(this, "symbol", true), enumBody(this, node);
        }, exports2.ExistsTypeAnnotation = function() {
          this.token("*");
        }, exports2.FunctionTypeAnnotation = function(node, parent) {
          this.print(node.typeParameters, node), this.token("("), node.this && (this.word("this"), this.token(":"), this.space(), this.print(node.this.typeAnnotation, node), (node.params.length || node.rest) && (this.token(","), this.space()));
          this.printList(node.params, node), node.rest && (node.params.length && (this.token(","), this.space()), this.token("..."), this.print(node.rest, node));
          this.token(")"), parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) ? this.token(":") : (this.space(), this.token("=>"));
          this.space(), this.print(node.returnType, node);
        }, exports2.FunctionTypeParam = function(node) {
          this.print(node.name, node), node.optional && this.token("?");
          node.name && (this.token(":"), this.space());
          this.print(node.typeAnnotation, node);
        }, exports2.IndexedAccessType = function(node) {
          this.print(node.objectType, node), this.token("["), this.print(node.indexType, node), this.token("]");
        }, exports2.InferredPredicate = function() {
          this.token("%"), this.word("checks");
        }, exports2.InterfaceDeclaration = function(node) {
          this.word("interface"), this.space(), this._interfaceish(node);
        }, exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = function(node) {
          this.print(node.id, node), this.print(node.typeParameters, node);
        }, exports2.InterfaceTypeAnnotation = function(node) {
          this.word("interface"), node.extends && node.extends.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends, node));
          this.space(), this.print(node.body, node);
        }, exports2.IntersectionTypeAnnotation = function(node) {
          this.printJoin(node.types, node, { separator: andSeparator });
        }, exports2.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, exports2.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, exports2.NullableTypeAnnotation = function(node) {
          this.token("?"), this.print(node.typeAnnotation, node);
        }, Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _types2.NumericLiteral;
        } }), exports2.NumberTypeAnnotation = function() {
          this.word("number");
        }, exports2.ObjectTypeAnnotation = function(node) {
          node.exact ? this.token("{|") : this.token("{");
          const props = [...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || []];
          props.length && (this.space(), this.printJoin(props, node, { addNewlines(leading) {
            if (leading && !props[0])
              return 1;
          }, indent: true, statement: true, iterator: () => {
            (props.length !== 1 || node.inexact) && (this.token(","), this.space());
          } }), this.space());
          node.inexact && (this.indent(), this.token("..."), props.length && this.newline(), this.dedent());
          node.exact ? this.token("|}") : this.token("}");
        }, exports2.ObjectTypeCallProperty = function(node) {
          node.static && (this.word("static"), this.space());
          this.print(node.value, node);
        }, exports2.ObjectTypeIndexer = function(node) {
          node.static && (this.word("static"), this.space());
          this._variance(node), this.token("["), node.id && (this.print(node.id, node), this.token(":"), this.space());
          this.print(node.key, node), this.token("]"), this.token(":"), this.space(), this.print(node.value, node);
        }, exports2.ObjectTypeInternalSlot = function(node) {
          node.static && (this.word("static"), this.space());
          this.token("["), this.token("["), this.print(node.id, node), this.token("]"), this.token("]"), node.optional && this.token("?");
          node.method || (this.token(":"), this.space());
          this.print(node.value, node);
        }, exports2.ObjectTypeProperty = function(node) {
          node.proto && (this.word("proto"), this.space());
          node.static && (this.word("static"), this.space());
          node.kind !== "get" && node.kind !== "set" || (this.word(node.kind), this.space());
          this._variance(node), this.print(node.key, node), node.optional && this.token("?");
          node.method || (this.token(":"), this.space());
          this.print(node.value, node);
        }, exports2.ObjectTypeSpreadProperty = function(node) {
          this.token("..."), this.print(node.argument, node);
        }, exports2.OpaqueType = function(node) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), node.supertype && (this.token(":"), this.space(), this.print(node.supertype, node));
          node.impltype && (this.space(), this.token("="), this.space(), this.print(node.impltype, node));
          this.semicolon();
        }, exports2.OptionalIndexedAccessType = function(node) {
          this.print(node.objectType, node), node.optional && this.token("?.");
          this.token("["), this.print(node.indexType, node), this.token("]");
        }, exports2.QualifiedTypeIdentifier = function(node) {
          this.print(node.qualification, node), this.token("."), this.print(node.id, node);
        }, Object.defineProperty(exports2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _types2.StringLiteral;
        } }), exports2.StringTypeAnnotation = function() {
          this.word("string");
        }, exports2.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, exports2.ThisTypeAnnotation = function() {
          this.word("this");
        }, exports2.TupleTypeAnnotation = function(node) {
          this.token("["), this.printList(node.types, node), this.token("]");
        }, exports2.TypeAlias = function(node) {
          this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), this.space(), this.token("="), this.space(), this.print(node.right, node), this.semicolon();
        }, exports2.TypeAnnotation = function(node) {
          this.token(":"), this.space(), node.optional && this.token("?");
          this.print(node.typeAnnotation, node);
        }, exports2.TypeCastExpression = function(node) {
          this.token("("), this.print(node.expression, node), this.print(node.typeAnnotation, node), this.token(")");
        }, exports2.TypeParameter = function(node) {
          this._variance(node), this.word(node.name), node.bound && this.print(node.bound, node);
          node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
        }, exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = function(node) {
          this.token("<"), this.printList(node.params, node, {}), this.token(">");
        }, exports2.TypeofTypeAnnotation = function(node) {
          this.word("typeof"), this.space(), this.print(node.argument, node);
        }, exports2.UnionTypeAnnotation = function(node) {
          this.printJoin(node.types, node, { separator: orSeparator });
        }, exports2.Variance = function(node) {
          node.kind === "plus" ? this.token("+") : this.token("-");
        }, exports2.VoidTypeAnnotation = function() {
          this.word("void");
        }, exports2._interfaceish = function(node) {
          var _node$extends;
          this.print(node.id, node), this.print(node.typeParameters, node), (_node$extends = node.extends) != null && _node$extends.length && (this.space(), this.word("extends"), this.space(), this.printList(node.extends, node));
          node.mixins && node.mixins.length && (this.space(), this.word("mixins"), this.space(), this.printList(node.mixins, node));
          node.implements && node.implements.length && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
          this.space(), this.print(node.body, node);
        }, exports2._variance = function(node) {
          node.variance && (node.variance.kind === "plus" ? this.token("+") : node.variance.kind === "minus" && this.token("-"));
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _modules = __webpack_require__2("./node_modules/@babel/generator/lib/generators/modules.js"), _types2 = __webpack_require__2("./node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration, isStatement } = _t;
        function enumExplicitType(context, name, hasExplicitType) {
          hasExplicitType && (context.space(), context.word("of"), context.space(), context.word(name)), context.space();
        }
        function enumBody(context, node) {
          const { members } = node;
          context.token("{"), context.indent(), context.newline();
          for (const member of members)
            context.print(member, node), context.newline();
          node.hasUnknownMembers && (context.token("..."), context.newline()), context.dedent(), context.token("}");
        }
        function enumInitializedMember(context, node) {
          const { id, init } = node;
          context.print(id, node), context.space(), context.token("="), context.space(), context.print(init, node), context.token(",");
        }
        function FlowExportDeclaration(node) {
          if (node.declaration) {
            const declar = node.declaration;
            this.print(declar, node), isStatement(declar) || this.semicolon();
          } else
            this.token("{"), node.specifiers.length && (this.space(), this.printList(node.specifiers, node), this.space()), this.token("}"), node.source && (this.space(), this.word("from"), this.space(), this.print(node.source, node)), this.semicolon();
        }
        function andSeparator() {
          this.space(), this.token("&"), this.space();
        }
        function orSeparator() {
          this.space(), this.token("|"), this.space();
        }
      }, "./node_modules/@babel/generator/lib/generators/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var _templateLiterals = __webpack_require__2("./node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(_templateLiterals).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _templateLiterals[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _templateLiterals[key];
          } }));
        });
        var _expressions = __webpack_require__2("./node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(_expressions).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _expressions[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _expressions[key];
          } }));
        });
        var _statements = __webpack_require__2("./node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(_statements).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _statements[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _statements[key];
          } }));
        });
        var _classes = __webpack_require__2("./node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(_classes).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _classes[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _classes[key];
          } }));
        });
        var _methods = __webpack_require__2("./node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(_methods).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _methods[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _methods[key];
          } }));
        });
        var _modules = __webpack_require__2("./node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(_modules).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _modules[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _modules[key];
          } }));
        });
        var _types = __webpack_require__2("./node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(_types).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _types[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _types[key];
          } }));
        });
        var _flow = __webpack_require__2("./node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(_flow).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _flow[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _flow[key];
          } }));
        });
        var _base = __webpack_require__2("./node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(_base).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _base[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _base[key];
          } }));
        });
        var _jsx = __webpack_require__2("./node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(_jsx).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _jsx[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _jsx[key];
          } }));
        });
        var _typescript = __webpack_require__2("./node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(_typescript).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (key in exports2 && exports2[key] === _typescript[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _typescript[key];
          } }));
        });
      }, "./node_modules/@babel/generator/lib/generators/jsx.js": (__unused_webpack_module, exports2) => {
        "use strict";
        function spaceSeparator() {
          this.space();
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.JSXAttribute = function(node) {
          this.print(node.name, node), node.value && (this.token("="), this.print(node.value, node));
        }, exports2.JSXClosingElement = function(node) {
          this.token("</"), this.print(node.name, node), this.token(">");
        }, exports2.JSXClosingFragment = function() {
          this.token("</"), this.token(">");
        }, exports2.JSXElement = function(node) {
          const open = node.openingElement;
          if (this.print(open, node), open.selfClosing)
            return;
          this.indent();
          for (const child of node.children)
            this.print(child, node);
          this.dedent(), this.print(node.closingElement, node);
        }, exports2.JSXEmptyExpression = function(node) {
          this.printInnerComments(node);
        }, exports2.JSXExpressionContainer = function(node) {
          this.token("{"), this.print(node.expression, node), this.token("}");
        }, exports2.JSXFragment = function(node) {
          this.print(node.openingFragment, node), this.indent();
          for (const child of node.children)
            this.print(child, node);
          this.dedent(), this.print(node.closingFragment, node);
        }, exports2.JSXIdentifier = function(node) {
          this.word(node.name);
        }, exports2.JSXMemberExpression = function(node) {
          this.print(node.object, node), this.token("."), this.print(node.property, node);
        }, exports2.JSXNamespacedName = function(node) {
          this.print(node.namespace, node), this.token(":"), this.print(node.name, node);
        }, exports2.JSXOpeningElement = function(node) {
          this.token("<"), this.print(node.name, node), this.print(node.typeParameters, node), node.attributes.length > 0 && (this.space(), this.printJoin(node.attributes, node, { separator: spaceSeparator }));
          node.selfClosing ? (this.space(), this.token("/>")) : this.token(">");
        }, exports2.JSXOpeningFragment = function() {
          this.token("<"), this.token(">");
        }, exports2.JSXSpreadAttribute = function(node) {
          this.token("{"), this.token("..."), this.print(node.argument, node), this.token("}");
        }, exports2.JSXSpreadChild = function(node) {
          this.token("{"), this.token("..."), this.print(node.expression, node), this.token("}");
        }, exports2.JSXText = function(node) {
          const raw = this.getPossibleRaw(node);
          raw != null ? this.token(raw) : this.token(node.value);
        };
      }, "./node_modules/@babel/generator/lib/generators/methods.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ArrowFunctionExpression = function(node) {
          node.async && (this.word("async"), this.space());
          const firstParam = node.params[0];
          this.format.retainLines || this.format.auxiliaryCommentBefore || this.format.auxiliaryCommentAfter || node.params.length !== 1 || !isIdentifier(firstParam) || function(node2, param) {
            var _param$leadingComment, _param$trailingCommen;
            return !!(node2.typeParameters || node2.returnType || node2.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
          }(node, firstParam) ? this._params(node) : this.print(firstParam, node);
          this._predicate(node), this.space(), this.token("=>"), this.space(), this.print(node.body, node);
        }, exports2.FunctionDeclaration = exports2.FunctionExpression = function(node) {
          this._functionHead(node), this.space(), this.print(node.body, node);
        }, exports2._functionHead = function(node) {
          node.async && (this.word("async"), this.space());
          this.word("function"), node.generator && this.token("*");
          this.printInnerComments(node), this.space(), node.id && this.print(node.id, node);
          this._params(node), this._predicate(node);
        }, exports2._methodHead = function(node) {
          const kind = node.kind, key = node.key;
          kind !== "get" && kind !== "set" || (this.word(kind), this.space());
          node.async && (this._catchUp("start", key.loc), this.word("async"), this.space());
          kind !== "method" && kind !== "init" || node.generator && this.token("*");
          node.computed ? (this.token("["), this.print(key, node), this.token("]")) : this.print(key, node);
          node.optional && this.token("?");
          this._params(node);
        }, exports2._param = function(parameter, parent) {
          this.printJoin(parameter.decorators, parameter), this.print(parameter, parent), parameter.optional && this.token("?");
          this.print(parameter.typeAnnotation, parameter);
        }, exports2._parameters = function(parameters, parent) {
          for (let i = 0; i < parameters.length; i++)
            this._param(parameters[i], parent), i < parameters.length - 1 && (this.token(","), this.space());
        }, exports2._params = function(node) {
          this.print(node.typeParameters, node), this.token("("), this._parameters(node.params, node), this.token(")"), this.print(node.returnType, node);
        }, exports2._predicate = function(node) {
          node.predicate && (node.returnType || this.token(":"), this.space(), this.print(node.predicate, node));
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isIdentifier } = _t;
      }, "./node_modules/@babel/generator/lib/generators/modules.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ExportAllDeclaration = function(node) {
          this.word("export"), this.space(), node.exportKind === "type" && (this.word("type"), this.space());
          this.token("*"), this.space(), this.word("from"), this.space(), this.print(node.source, node), this.printAssertions(node), this.semicolon();
        }, exports2.ExportDefaultDeclaration = function(node) {
          this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
          this.word("export"), this.space(), this.word("default"), this.space(), ExportDeclaration.apply(this, arguments);
        }, exports2.ExportDefaultSpecifier = function(node) {
          this.print(node.exported, node);
        }, exports2.ExportNamedDeclaration = function(node) {
          this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
          this.word("export"), this.space(), ExportDeclaration.apply(this, arguments);
        }, exports2.ExportNamespaceSpecifier = function(node) {
          this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.exported, node);
        }, exports2.ExportSpecifier = function(node) {
          node.exportKind === "type" && (this.word("type"), this.space());
          this.print(node.local, node), node.exported && node.local.name !== node.exported.name && (this.space(), this.word("as"), this.space(), this.print(node.exported, node));
        }, exports2.ImportAttribute = function(node) {
          this.print(node.key), this.token(":"), this.space(), this.print(node.value);
        }, exports2.ImportDeclaration = function(node) {
          this.word("import"), this.space(), (node.importKind === "type" || node.importKind === "typeof") && (this.word(node.importKind), this.space());
          const specifiers = node.specifiers.slice(0);
          if (specifiers != null && specifiers.length) {
            for (; ; ) {
              const first = specifiers[0];
              if (!isImportDefaultSpecifier(first) && !isImportNamespaceSpecifier(first))
                break;
              this.print(specifiers.shift(), node), specifiers.length && (this.token(","), this.space());
            }
            specifiers.length && (this.token("{"), this.space(), this.printList(specifiers, node), this.space(), this.token("}")), this.space(), this.word("from"), this.space();
          }
          var _node$attributes;
          this.print(node.source, node), this.printAssertions(node), (_node$attributes = node.attributes) != null && _node$attributes.length && (this.space(), this.word("with"), this.space(), this.printList(node.attributes, node));
          this.semicolon();
        }, exports2.ImportDefaultSpecifier = function(node) {
          this.print(node.local, node);
        }, exports2.ImportNamespaceSpecifier = function(node) {
          this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.local, node);
        }, exports2.ImportSpecifier = function(node) {
          node.importKind !== "type" && node.importKind !== "typeof" || (this.word(node.importKind), this.space());
          this.print(node.imported, node), node.local && node.local.name !== node.imported.name && (this.space(), this.word("as"), this.space(), this.print(node.local, node));
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isClassDeclaration, isExportDefaultSpecifier, isExportNamespaceSpecifier, isImportDefaultSpecifier, isImportNamespaceSpecifier, isStatement } = _t;
        function ExportDeclaration(node) {
          if (node.declaration) {
            const declar = node.declaration;
            this.print(declar, node), isStatement(declar) || this.semicolon();
          } else {
            node.exportKind === "type" && (this.word("type"), this.space());
            const specifiers = node.specifiers.slice(0);
            let hasSpecial = false;
            for (; ; ) {
              const first = specifiers[0];
              if (!isExportDefaultSpecifier(first) && !isExportNamespaceSpecifier(first))
                break;
              hasSpecial = true, this.print(specifiers.shift(), node), specifiers.length && (this.token(","), this.space());
            }
            (specifiers.length || !specifiers.length && !hasSpecial) && (this.token("{"), specifiers.length && (this.space(), this.printList(specifiers, node), this.space()), this.token("}")), node.source && (this.space(), this.word("from"), this.space(), this.print(node.source, node), this.printAssertions(node)), this.semicolon();
          }
        }
      }, "./node_modules/@babel/generator/lib/generators/statements.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.BreakStatement = void 0, exports2.CatchClause = function(node) {
          this.word("catch"), this.space(), node.param && (this.token("("), this.print(node.param, node), this.print(node.param.typeAnnotation, node), this.token(")"), this.space());
          this.print(node.body, node);
        }, exports2.ContinueStatement = void 0, exports2.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, exports2.DoWhileStatement = function(node) {
          this.word("do"), this.space(), this.print(node.body, node), this.space(), this.word("while"), this.space(), this.token("("), this.print(node.test, node), this.token(")"), this.semicolon();
        }, exports2.ForOfStatement = exports2.ForInStatement = void 0, exports2.ForStatement = function(node) {
          this.word("for"), this.space(), this.token("("), this.inForStatementInitCounter++, this.print(node.init, node), this.inForStatementInitCounter--, this.token(";"), node.test && (this.space(), this.print(node.test, node));
          this.token(";"), node.update && (this.space(), this.print(node.update, node));
          this.token(")"), this.printBlock(node);
        }, exports2.IfStatement = function(node) {
          this.word("if"), this.space(), this.token("("), this.print(node.test, node), this.token(")"), this.space();
          const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
          needsBlock && (this.token("{"), this.newline(), this.indent());
          this.printAndIndentOnComments(node.consequent, node), needsBlock && (this.dedent(), this.newline(), this.token("}"));
          node.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(node.alternate, node));
        }, exports2.LabeledStatement = function(node) {
          this.print(node.label, node), this.token(":"), this.space(), this.print(node.body, node);
        }, exports2.ReturnStatement = void 0, exports2.SwitchCase = function(node) {
          node.test ? (this.word("case"), this.space(), this.print(node.test, node), this.token(":")) : (this.word("default"), this.token(":"));
          node.consequent.length && (this.newline(), this.printSequence(node.consequent, node, { indent: true }));
        }, exports2.SwitchStatement = function(node) {
          this.word("switch"), this.space(), this.token("("), this.print(node.discriminant, node), this.token(")"), this.space(), this.token("{"), this.printSequence(node.cases, node, { indent: true, addNewlines(leading, cas) {
            if (!leading && node.cases[node.cases.length - 1] === cas)
              return -1;
          } }), this.token("}");
        }, exports2.ThrowStatement = void 0, exports2.TryStatement = function(node) {
          this.word("try"), this.space(), this.print(node.block, node), this.space(), node.handlers ? this.print(node.handlers[0], node) : this.print(node.handler, node);
          node.finalizer && (this.space(), this.word("finally"), this.space(), this.print(node.finalizer, node));
        }, exports2.VariableDeclaration = function(node, parent) {
          node.declare && (this.word("declare"), this.space());
          this.word(node.kind), this.space();
          let separator, hasInits = false;
          if (!isFor(parent))
            for (const declar of node.declarations)
              declar.init && (hasInits = true);
          hasInits && (separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent);
          if (this.printList(node.declarations, node, { separator }), isFor(parent)) {
            if (isForStatement(parent)) {
              if (parent.init === node)
                return;
            } else if (parent.left === node)
              return;
          }
          this.semicolon();
        }, exports2.VariableDeclarator = function(node) {
          this.print(node.id, node), node.definite && this.token("!");
          this.print(node.id.typeAnnotation, node), node.init && (this.space(), this.token("="), this.space(), this.print(node.init, node));
        }, exports2.WhileStatement = function(node) {
          this.word("while"), this.space(), this.token("("), this.print(node.test, node), this.token(")"), this.printBlock(node);
        }, exports2.WithStatement = function(node) {
          this.word("with"), this.space(), this.token("("), this.print(node.object, node), this.token(")"), this.printBlock(node);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isFor, isForStatement, isIfStatement, isStatement } = _t;
        function getLastStatement(statement) {
          return isStatement(statement.body) ? getLastStatement(statement.body) : statement;
        }
        const buildForXStatement = function(op) {
          return function(node) {
            this.word("for"), this.space(), op === "of" && node.await && (this.word("await"), this.space()), this.token("("), this.print(node.left, node), this.space(), this.word(op), this.space(), this.print(node.right, node), this.token(")"), this.printBlock(node);
          };
        }, ForInStatement = buildForXStatement("in");
        exports2.ForInStatement = ForInStatement;
        const ForOfStatement = buildForXStatement("of");
        function buildLabelStatement(prefix, key = "label") {
          return function(node) {
            this.word(prefix);
            const label = node[key];
            if (label) {
              this.space();
              const isLabel = key == "label", terminatorState = this.startTerminatorless(isLabel);
              this.print(label, node), this.endTerminatorless(terminatorState);
            }
            this.semicolon();
          };
        }
        exports2.ForOfStatement = ForOfStatement;
        const ContinueStatement = buildLabelStatement("continue");
        exports2.ContinueStatement = ContinueStatement;
        const ReturnStatement = buildLabelStatement("return", "argument");
        exports2.ReturnStatement = ReturnStatement;
        const BreakStatement = buildLabelStatement("break");
        exports2.BreakStatement = BreakStatement;
        const ThrowStatement = buildLabelStatement("throw", "argument");
        function variableDeclarationIndent() {
          if (this.token(","), this.newline(), this.endsWith(10))
            for (let i = 0; i < 4; i++)
              this.space(true);
        }
        function constDeclarationIndent() {
          if (this.token(","), this.newline(), this.endsWith(10))
            for (let i = 0; i < 6; i++)
              this.space(true);
        }
        exports2.ThrowStatement = ThrowStatement;
      }, "./node_modules/@babel/generator/lib/generators/template-literals.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.TaggedTemplateExpression = function(node) {
          this.print(node.tag, node), this.print(node.typeParameters, node), this.print(node.quasi, node);
        }, exports2.TemplateElement = function(node, parent) {
          const isFirst = parent.quasis[0] === node, isLast = parent.quasis[parent.quasis.length - 1] === node, value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
          this.token(value);
        }, exports2.TemplateLiteral = function(node) {
          const quasis = node.quasis;
          for (let i = 0; i < quasis.length; i++)
            this.print(quasis[i], node), i + 1 < quasis.length && this.print(node.expressions[i], node);
        };
      }, "./node_modules/@babel/generator/lib/generators/types.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ArgumentPlaceholder = function() {
          this.token("?");
        }, exports2.ArrayPattern = exports2.ArrayExpression = function(node) {
          const elems = node.elements, len = elems.length;
          this.token("["), this.printInnerComments(node);
          for (let i = 0; i < elems.length; i++) {
            const elem = elems[i];
            elem ? (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(",")) : this.token(",");
          }
          this.token("]");
        }, exports2.BigIntLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw != null)
            return void this.word(raw);
          this.word(node.value + "n");
        }, exports2.BooleanLiteral = function(node) {
          this.word(node.value ? "true" : "false");
        }, exports2.DecimalLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw != null)
            return void this.word(raw);
          this.word(node.value + "m");
        }, exports2.Identifier = function(node) {
          this.exactSource(node.loc, () => {
            this.word(node.name);
          });
        }, exports2.NullLiteral = function() {
          this.word("null");
        }, exports2.NumericLiteral = function(node) {
          const raw = this.getPossibleRaw(node), opts = this.format.jsescOption, value = node.value + "";
          opts.numbers ? this.number(_jsesc(node.value, opts)) : raw == null ? this.number(value) : this.format.minified ? this.number(raw.length < value.length ? raw : value) : this.number(raw);
        }, exports2.ObjectPattern = exports2.ObjectExpression = function(node) {
          const props = node.properties;
          this.token("{"), this.printInnerComments(node), props.length && (this.space(), this.printList(props, node, { indent: true, statement: true }), this.space());
          this.token("}");
        }, exports2.ObjectMethod = function(node) {
          this.printJoin(node.decorators, node), this._methodHead(node), this.space(), this.print(node.body, node);
        }, exports2.ObjectProperty = function(node) {
          if (this.printJoin(node.decorators, node), node.computed)
            this.token("["), this.print(node.key, node), this.token("]");
          else {
            if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name)
              return void this.print(node.value, node);
            if (this.print(node.key, node), node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name)
              return;
          }
          this.token(":"), this.space(), this.print(node.value, node);
        }, exports2.PipelineBareFunction = function(node) {
          this.print(node.callee, node);
        }, exports2.PipelinePrimaryTopicReference = function() {
          this.token("#");
        }, exports2.PipelineTopicExpression = function(node) {
          this.print(node.expression, node);
        }, exports2.RecordExpression = function(node) {
          const props = node.properties;
          let startToken, endToken;
          if (this.format.recordAndTupleSyntaxType === "bar")
            startToken = "{|", endToken = "|}";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash")
              throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            startToken = "#{", endToken = "}";
          }
          this.token(startToken), this.printInnerComments(node), props.length && (this.space(), this.printList(props, node, { indent: true, statement: true }), this.space());
          this.token(endToken);
        }, exports2.RegExpLiteral = function(node) {
          this.word(`/${node.pattern}/${node.flags}`);
        }, exports2.SpreadElement = exports2.RestElement = function(node) {
          this.token("..."), this.print(node.argument, node);
        }, exports2.StringLiteral = function(node) {
          const raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw != null)
            return void this.token(raw);
          const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && { json: true }));
          return this.token(val);
        }, exports2.TopicReference = function() {
          const { topicToken } = this.format;
          if (!validTopicTokenSet.has(topicToken)) {
            const givenTopicTokenJSON = JSON.stringify(topicToken), validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
            throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
          }
          this.token(topicToken);
        }, exports2.TupleExpression = function(node) {
          const elems = node.elements, len = elems.length;
          let startToken, endToken;
          if (this.format.recordAndTupleSyntaxType === "bar")
            startToken = "[|", endToken = "|]";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash")
              throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            startToken = "#[", endToken = "]";
          }
          this.token(startToken), this.printInnerComments(node);
          for (let i = 0; i < elems.length; i++) {
            const elem = elems[i];
            elem && (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(","));
          }
          this.token(endToken);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _jsesc = __webpack_require__2("./node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern, isIdentifier } = _t;
        const validTopicTokenSet = /* @__PURE__ */ new Set(["^", "%", "#"]);
      }, "./node_modules/@babel/generator/lib/generators/typescript.js": (__unused_webpack_module, exports2) => {
        "use strict";
        function tokenIfPlusMinus(self2, tok) {
          tok !== true && self2.token(tok);
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.TSAnyKeyword = function() {
          this.word("any");
        }, exports2.TSArrayType = function(node) {
          this.print(node.elementType, node), this.token("[]");
        }, exports2.TSAsExpression = function(node) {
          const { expression, typeAnnotation } = node;
          this.print(expression, node), this.space(), this.word("as"), this.space(), this.print(typeAnnotation, node);
        }, exports2.TSBigIntKeyword = function() {
          this.word("bigint");
        }, exports2.TSBooleanKeyword = function() {
          this.word("boolean");
        }, exports2.TSCallSignatureDeclaration = function(node) {
          this.tsPrintSignatureDeclarationBase(node), this.token(";");
        }, exports2.TSConditionalType = function(node) {
          this.print(node.checkType), this.space(), this.word("extends"), this.space(), this.print(node.extendsType), this.space(), this.token("?"), this.space(), this.print(node.trueType), this.space(), this.token(":"), this.space(), this.print(node.falseType);
        }, exports2.TSConstructSignatureDeclaration = function(node) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(node), this.token(";");
        }, exports2.TSConstructorType = function(node) {
          node.abstract && (this.word("abstract"), this.space());
          this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(node);
        }, exports2.TSDeclareFunction = function(node) {
          node.declare && (this.word("declare"), this.space());
          this._functionHead(node), this.token(";");
        }, exports2.TSDeclareMethod = function(node) {
          this._classMethodHead(node), this.token(";");
        }, exports2.TSEnumDeclaration = function(node) {
          const { declare, const: isConst, id, members } = node;
          declare && (this.word("declare"), this.space());
          isConst && (this.word("const"), this.space());
          this.word("enum"), this.space(), this.print(id, node), this.space(), this.tsPrintBraced(members, node);
        }, exports2.TSEnumMember = function(node) {
          const { id, initializer } = node;
          this.print(id, node), initializer && (this.space(), this.token("="), this.space(), this.print(initializer, node));
          this.token(",");
        }, exports2.TSExportAssignment = function(node) {
          this.word("export"), this.space(), this.token("="), this.space(), this.print(node.expression, node), this.token(";");
        }, exports2.TSExpressionWithTypeArguments = function(node) {
          this.print(node.expression, node), this.print(node.typeParameters, node);
        }, exports2.TSExternalModuleReference = function(node) {
          this.token("require("), this.print(node.expression, node), this.token(")");
        }, exports2.TSFunctionType = function(node) {
          this.tsPrintFunctionOrConstructorType(node);
        }, exports2.TSImportEqualsDeclaration = function(node) {
          const { isExport, id, moduleReference } = node;
          isExport && (this.word("export"), this.space());
          this.word("import"), this.space(), this.print(id, node), this.space(), this.token("="), this.space(), this.print(moduleReference, node), this.token(";");
        }, exports2.TSImportType = function(node) {
          const { argument, qualifier, typeParameters } = node;
          this.word("import"), this.token("("), this.print(argument, node), this.token(")"), qualifier && (this.token("."), this.print(qualifier, node));
          typeParameters && this.print(typeParameters, node);
        }, exports2.TSIndexSignature = function(node) {
          const { readonly, static: isStatic } = node;
          isStatic && (this.word("static"), this.space());
          readonly && (this.word("readonly"), this.space());
          this.token("["), this._parameters(node.parameters, node), this.token("]"), this.print(node.typeAnnotation, node), this.token(";");
        }, exports2.TSIndexedAccessType = function(node) {
          this.print(node.objectType, node), this.token("["), this.print(node.indexType, node), this.token("]");
        }, exports2.TSInferType = function(node) {
          this.token("infer"), this.space(), this.print(node.typeParameter);
        }, exports2.TSInterfaceBody = function(node) {
          this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
        }, exports2.TSInterfaceDeclaration = function(node) {
          const { declare, id, typeParameters, extends: extendz, body } = node;
          declare && (this.word("declare"), this.space());
          this.word("interface"), this.space(), this.print(id, node), this.print(typeParameters, node), extendz != null && extendz.length && (this.space(), this.word("extends"), this.space(), this.printList(extendz, node));
          this.space(), this.print(body, node);
        }, exports2.TSIntersectionType = function(node) {
          this.tsPrintUnionOrIntersectionType(node, "&");
        }, exports2.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, exports2.TSLiteralType = function(node) {
          this.print(node.literal, node);
        }, exports2.TSMappedType = function(node) {
          const { nameType, optional, readonly, typeParameter } = node;
          this.token("{"), this.space(), readonly && (tokenIfPlusMinus(this, readonly), this.word("readonly"), this.space());
          this.token("["), this.word(typeParameter.name), this.space(), this.word("in"), this.space(), this.print(typeParameter.constraint, typeParameter), nameType && (this.space(), this.word("as"), this.space(), this.print(nameType, node));
          this.token("]"), optional && (tokenIfPlusMinus(this, optional), this.token("?"));
          this.token(":"), this.space(), this.print(node.typeAnnotation, node), this.space(), this.token("}");
        }, exports2.TSMethodSignature = function(node) {
          const { kind } = node;
          kind !== "set" && kind !== "get" || (this.word(kind), this.space());
          this.tsPrintPropertyOrMethodName(node), this.tsPrintSignatureDeclarationBase(node), this.token(";");
        }, exports2.TSModuleBlock = function(node) {
          this.tsPrintBraced(node.body, node);
        }, exports2.TSModuleDeclaration = function(node) {
          const { declare, id } = node;
          declare && (this.word("declare"), this.space());
          node.global || (this.word(id.type === "Identifier" ? "namespace" : "module"), this.space());
          if (this.print(id, node), !node.body)
            return void this.token(";");
          let body = node.body;
          for (; body.type === "TSModuleDeclaration"; )
            this.token("."), this.print(body.id, body), body = body.body;
          this.space(), this.print(body, node);
        }, exports2.TSNamedTupleMember = function(node) {
          this.print(node.label, node), node.optional && this.token("?");
          this.token(":"), this.space(), this.print(node.elementType, node);
        }, exports2.TSNamespaceExportDeclaration = function(node) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(node.id, node);
        }, exports2.TSNeverKeyword = function() {
          this.word("never");
        }, exports2.TSNonNullExpression = function(node) {
          this.print(node.expression, node), this.token("!");
        }, exports2.TSNullKeyword = function() {
          this.word("null");
        }, exports2.TSNumberKeyword = function() {
          this.word("number");
        }, exports2.TSObjectKeyword = function() {
          this.word("object");
        }, exports2.TSOptionalType = function(node) {
          this.print(node.typeAnnotation, node), this.token("?");
        }, exports2.TSParameterProperty = function(node) {
          node.accessibility && (this.word(node.accessibility), this.space());
          node.readonly && (this.word("readonly"), this.space());
          this._param(node.parameter);
        }, exports2.TSParenthesizedType = function(node) {
          this.token("("), this.print(node.typeAnnotation, node), this.token(")");
        }, exports2.TSPropertySignature = function(node) {
          const { readonly, initializer } = node;
          readonly && (this.word("readonly"), this.space());
          this.tsPrintPropertyOrMethodName(node), this.print(node.typeAnnotation, node), initializer && (this.space(), this.token("="), this.space(), this.print(initializer, node));
          this.token(";");
        }, exports2.TSQualifiedName = function(node) {
          this.print(node.left, node), this.token("."), this.print(node.right, node);
        }, exports2.TSRestType = function(node) {
          this.token("..."), this.print(node.typeAnnotation, node);
        }, exports2.TSStringKeyword = function() {
          this.word("string");
        }, exports2.TSSymbolKeyword = function() {
          this.word("symbol");
        }, exports2.TSThisType = function() {
          this.word("this");
        }, exports2.TSTupleType = function(node) {
          this.token("["), this.printList(node.elementTypes, node), this.token("]");
        }, exports2.TSTypeAliasDeclaration = function(node) {
          const { declare, id, typeParameters, typeAnnotation } = node;
          declare && (this.word("declare"), this.space());
          this.word("type"), this.space(), this.print(id, node), this.print(typeParameters, node), this.space(), this.token("="), this.space(), this.print(typeAnnotation, node), this.token(";");
        }, exports2.TSTypeAnnotation = function(node) {
          this.token(":"), this.space(), node.optional && this.token("?");
          this.print(node.typeAnnotation, node);
        }, exports2.TSTypeAssertion = function(node) {
          const { typeAnnotation, expression } = node;
          this.token("<"), this.print(typeAnnotation, node), this.token(">"), this.space(), this.print(expression, node);
        }, exports2.TSTypeLiteral = function(node) {
          this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
        }, exports2.TSTypeOperator = function(node) {
          this.word(node.operator), this.space(), this.print(node.typeAnnotation, node);
        }, exports2.TSTypeParameter = function(node) {
          this.word(node.name), node.constraint && (this.space(), this.word("extends"), this.space(), this.print(node.constraint, node));
          node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
        }, exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = function(node, parent) {
          this.token("<"), this.printList(node.params, node, {}), parent.type === "ArrowFunctionExpression" && node.params.length === 1 && this.token(",");
          this.token(">");
        }, exports2.TSTypePredicate = function(node) {
          node.asserts && (this.word("asserts"), this.space());
          this.print(node.parameterName), node.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(node.typeAnnotation.typeAnnotation));
        }, exports2.TSTypeQuery = function(node) {
          this.word("typeof"), this.space(), this.print(node.exprName);
        }, exports2.TSTypeReference = function(node) {
          this.print(node.typeName, node), this.print(node.typeParameters, node);
        }, exports2.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, exports2.TSUnionType = function(node) {
          this.tsPrintUnionOrIntersectionType(node, "|");
        }, exports2.TSUnknownKeyword = function() {
          this.word("unknown");
        }, exports2.TSVoidKeyword = function() {
          this.word("void");
        }, exports2.tsPrintBraced = function(members, node) {
          if (this.token("{"), members.length) {
            this.indent(), this.newline();
            for (const member of members)
              this.print(member, node), this.newline();
            this.dedent(), this.rightBrace();
          } else
            this.token("}");
        }, exports2.tsPrintClassMemberModifiers = function(node, isField) {
          isField && node.declare && (this.word("declare"), this.space());
          node.accessibility && (this.word(node.accessibility), this.space());
          node.static && (this.word("static"), this.space());
          node.override && (this.word("override"), this.space());
          node.abstract && (this.word("abstract"), this.space());
          isField && node.readonly && (this.word("readonly"), this.space());
        }, exports2.tsPrintFunctionOrConstructorType = function(node) {
          const { typeParameters } = node, parameters = node.parameters;
          this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), this.token(")"), this.space(), this.token("=>"), this.space();
          const returnType = node.typeAnnotation;
          this.print(returnType.typeAnnotation, node);
        }, exports2.tsPrintPropertyOrMethodName = function(node) {
          node.computed && this.token("[");
          this.print(node.key, node), node.computed && this.token("]");
          node.optional && this.token("?");
        }, exports2.tsPrintSignatureDeclarationBase = function(node) {
          const { typeParameters } = node, parameters = node.parameters;
          this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), this.token(")");
          const returnType = node.typeAnnotation;
          this.print(returnType, node);
        }, exports2.tsPrintTypeLiteralOrInterfaceBody = function(members, node) {
          this.tsPrintBraced(members, node);
        }, exports2.tsPrintUnionOrIntersectionType = function(node, sep) {
          this.printJoin(node.types, node, { separator() {
            this.space(), this.token(sep), this.space();
          } });
        };
      }, "./node_modules/@babel/generator/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.CodeGenerator = void 0, exports2.default = function(ast, opts, code) {
          return new Generator(ast, opts, code).generate();
        };
        var _sourceMap = __webpack_require__2("./node_modules/@babel/generator/lib/source-map.js"), _printer = __webpack_require__2("./node_modules/@babel/generator/lib/printer.js");
        class Generator extends _printer.default {
          constructor(ast, opts = {}, code) {
            const format = function(code2, opts2) {
              const format2 = { auxiliaryCommentBefore: opts2.auxiliaryCommentBefore, auxiliaryCommentAfter: opts2.auxiliaryCommentAfter, shouldPrintComment: opts2.shouldPrintComment, retainLines: opts2.retainLines, retainFunctionParens: opts2.retainFunctionParens, comments: opts2.comments == null || opts2.comments, compact: opts2.compact, minified: opts2.minified, concise: opts2.concise, indent: { adjustMultilineComment: true, style: "  ", base: 0 }, decoratorsBeforeExport: !!opts2.decoratorsBeforeExport, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, opts2.jsescOption), recordAndTupleSyntaxType: opts2.recordAndTupleSyntaxType, topicToken: opts2.topicToken };
              format2.jsonCompatibleStrings = opts2.jsonCompatibleStrings, format2.minified ? (format2.compact = true, format2.shouldPrintComment = format2.shouldPrintComment || (() => format2.comments)) : format2.shouldPrintComment = format2.shouldPrintComment || ((value) => format2.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
              format2.compact === "auto" && (format2.compact = code2.length > 5e5, format2.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts2.filename} as it exceeds the max of 500KB.`));
              format2.compact && (format2.indent.adjustMultilineComment = false);
              return format2;
            }(code, opts);
            super(format, opts.sourceMaps ? new _sourceMap.default(opts, code) : null), this.ast = void 0, this.ast = ast;
          }
          generate() {
            return super.generate(this.ast);
          }
        }
        exports2.CodeGenerator = class {
          constructor(ast, opts, code) {
            this._generator = void 0, this._generator = new Generator(ast, opts, code);
          }
          generate() {
            return this._generator.generate();
          }
        };
      }, "./node_modules/@babel/generator/lib/node/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.needsParens = function(node, parent, printStack) {
          if (!parent)
            return false;
          if (isNewExpression(parent) && parent.callee === node && isOrHasCallExpression(node))
            return true;
          return find(expandedParens, node, parent, printStack);
        }, exports2.needsWhitespace = needsWhitespace, exports2.needsWhitespaceAfter = function(node, parent) {
          return needsWhitespace(node, parent, "after");
        }, exports2.needsWhitespaceBefore = function(node, parent) {
          return needsWhitespace(node, parent, "before");
        };
        var whitespace = __webpack_require__2("./node_modules/@babel/generator/lib/node/whitespace.js"), parens = __webpack_require__2("./node_modules/@babel/generator/lib/node/parentheses.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS, isCallExpression, isExpressionStatement, isMemberExpression, isNewExpression } = _t;
        function expandAliases(obj) {
          const newObj = {};
          function add(type, func) {
            const fn = newObj[type];
            newObj[type] = fn ? function(node, parent, stack) {
              const result = fn(node, parent, stack);
              return result == null ? func(node, parent, stack) : result;
            } : func;
          }
          for (const type of Object.keys(obj)) {
            const aliases = FLIPPED_ALIAS_KEYS[type];
            if (aliases)
              for (const alias of aliases)
                add(alias, obj[type]);
            else
              add(type, obj[type]);
          }
          return newObj;
        }
        const expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes), expandedWhitespaceList = expandAliases(whitespace.list);
        function find(obj, node, parent, printStack) {
          const fn = obj[node.type];
          return fn ? fn(node, parent, printStack) : null;
        }
        function isOrHasCallExpression(node) {
          return !!isCallExpression(node) || isMemberExpression(node) && isOrHasCallExpression(node.object);
        }
        function needsWhitespace(node, parent, type) {
          if (!node)
            return 0;
          isExpressionStatement(node) && (node = node.expression);
          let linesInfo = find(expandedWhitespaceNodes, node, parent);
          if (!linesInfo) {
            const items = find(expandedWhitespaceList, node, parent);
            if (items)
              for (let i = 0; i < items.length && (linesInfo = needsWhitespace(items[i], node, type), !linesInfo); i++)
                ;
          }
          return typeof linesInfo == "object" && linesInfo !== null && linesInfo[type] || 0;
        }
      }, "./node_modules/@babel/generator/lib/node/parentheses.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ArrowFunctionExpression = function(node, parent) {
          return isExportDeclaration(parent) || ConditionalExpression(node, parent);
        }, exports2.AssignmentExpression = function(node, parent) {
          return !!isObjectPattern(node.left) || ConditionalExpression(node, parent);
        }, exports2.Binary = function(node, parent) {
          if (node.operator === "**" && isBinaryExpression(parent, { operator: "**" }))
            return parent.left === node;
          if (isClassExtendsClause(node, parent))
            return true;
          if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent))
            return true;
          if (isBinary(parent)) {
            const parentOp = parent.operator, parentPos = PRECEDENCE[parentOp], nodeOp = node.operator, nodePos = PRECEDENCE[nodeOp];
            if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos)
              return true;
          }
        }, exports2.BinaryExpression = function(node, parent) {
          return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
        }, exports2.ClassExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, { expressionStatement: true, exportDefault: true });
        }, exports2.ConditionalExpression = ConditionalExpression, exports2.DoExpression = function(node, parent, printStack) {
          return !node.async && isFirstInContext(printStack, { expressionStatement: true });
        }, exports2.FunctionExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, { expressionStatement: true, exportDefault: true });
        }, exports2.FunctionTypeAnnotation = function(node, parent, printStack) {
          return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
        }, exports2.Identifier = function(node, parent, printStack) {
          if (node.name === "let") {
            const isFollowedByBracket = isMemberExpression(parent, { object: node, computed: true }) || isOptionalMemberExpression(parent, { object: node, computed: true, optional: false });
            return isFirstInContext(printStack, { expressionStatement: isFollowedByBracket, forHead: isFollowedByBracket, forInHead: isFollowedByBracket, forOfHead: true });
          }
          return node.name === "async" && isForOfStatement(parent) && node === parent.left;
        }, exports2.LogicalExpression = function(node, parent) {
          switch (node.operator) {
            case "||":
              return !!isLogicalExpression(parent) && (parent.operator === "??" || parent.operator === "&&");
            case "&&":
              return isLogicalExpression(parent, { operator: "??" });
            case "??":
              return isLogicalExpression(parent) && parent.operator !== "??";
          }
        }, exports2.NullableTypeAnnotation = function(node, parent) {
          return isArrayTypeAnnotation(parent);
        }, exports2.ObjectExpression = function(node, parent, printStack) {
          return isFirstInContext(printStack, { expressionStatement: true, arrowBody: true });
        }, exports2.OptionalIndexedAccessType = function(node, parent) {
          return isIndexedAccessType(parent, { objectType: node });
        }, exports2.OptionalCallExpression = exports2.OptionalMemberExpression = function(node, parent) {
          return isCallExpression(parent, { callee: node }) || isMemberExpression(parent, { object: node });
        }, exports2.SequenceExpression = function(node, parent) {
          if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node)
            return false;
          return true;
        }, exports2.TSAsExpression = function() {
          return true;
        }, exports2.TSInferType = function(node, parent) {
          return isTSArrayType(parent) || isTSOptionalType(parent);
        }, exports2.TSTypeAssertion = function() {
          return true;
        }, exports2.TSIntersectionType = exports2.TSUnionType = function(node, parent) {
          return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
        }, exports2.UnaryLike = UnaryLike, exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = function(node, parent) {
          return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
        }, exports2.UpdateExpression = function(node, parent) {
          return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
        }, exports2.AwaitExpression = exports2.YieldExpression = function(node, parent) {
          return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isArrayTypeAnnotation, isArrowFunctionExpression, isAssignmentExpression, isAwaitExpression, isBinary, isBinaryExpression, isCallExpression, isClassDeclaration, isClassExpression, isConditional, isConditionalExpression, isExportDeclaration, isExportDefaultDeclaration, isExpressionStatement, isFor, isForInStatement, isForOfStatement, isForStatement, isIfStatement, isIndexedAccessType, isIntersectionTypeAnnotation, isLogicalExpression, isMemberExpression, isNewExpression, isNullableTypeAnnotation, isObjectPattern, isOptionalCallExpression, isOptionalMemberExpression, isReturnStatement, isSequenceExpression, isSwitchStatement, isTSArrayType, isTSAsExpression, isTSIntersectionType, isTSNonNullExpression, isTSOptionalType, isTSRestType, isTSTypeAssertion, isTSUnionType, isTaggedTemplateExpression, isThrowStatement, isTypeAnnotation, isUnaryLike, isUnionTypeAnnotation, isVariableDeclarator, isWhileStatement, isYieldExpression } = _t, PRECEDENCE = { "||": 0, "??": 0, "&&": 1, "|": 2, "^": 3, "&": 4, "==": 5, "===": 5, "!=": 5, "!==": 5, "<": 6, ">": 6, "<=": 6, ">=": 6, in: 6, instanceof: 6, ">>": 7, "<<": 7, ">>>": 7, "+": 8, "-": 8, "*": 9, "/": 9, "%": 9, "**": 10 }, isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node, hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
        function UnaryLike(node, parent) {
          return hasPostfixPart(node, parent) || isBinaryExpression(parent, { operator: "**", left: node }) || isClassExtendsClause(node, parent);
        }
        function ConditionalExpression(node, parent) {
          return !!(isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, { test: node }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) || UnaryLike(node, parent);
        }
        function isFirstInContext(printStack, { expressionStatement = false, arrowBody = false, exportDefault = false, forHead = false, forInHead = false, forOfHead = false }) {
          let i = printStack.length - 1, node = printStack[i];
          i--;
          let parent = printStack[i];
          for (; i >= 0; ) {
            if (expressionStatement && isExpressionStatement(parent, { expression: node }) || exportDefault && isExportDefaultDeclaration(parent, { declaration: node }) || arrowBody && isArrowFunctionExpression(parent, { body: node }) || forHead && isForStatement(parent, { init: node }) || forInHead && isForInStatement(parent, { left: node }) || forOfHead && isForOfStatement(parent, { left: node }))
              return true;
            if (!(hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, { test: node }) || isBinary(parent, { left: node }) || isAssignmentExpression(parent, { left: node })))
              return false;
            node = parent, i--, parent = printStack[i];
          }
          return false;
        }
      }, "./node_modules/@babel/generator/lib/node/whitespace.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.nodes = exports2.list = void 0;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS, isArrayExpression, isAssignmentExpression, isBinary, isBlockStatement, isCallExpression, isFunction, isIdentifier, isLiteral, isMemberExpression, isObjectExpression, isOptionalCallExpression, isOptionalMemberExpression, isStringLiteral } = _t;
        function crawl(node, state = {}) {
          return isMemberExpression(node) || isOptionalMemberExpression(node) ? (crawl(node.object, state), node.computed && crawl(node.property, state)) : isBinary(node) || isAssignmentExpression(node) ? (crawl(node.left, state), crawl(node.right, state)) : isCallExpression(node) || isOptionalCallExpression(node) ? (state.hasCall = true, crawl(node.callee, state)) : isFunction(node) ? state.hasFunction = true : isIdentifier(node) && (state.hasHelper = state.hasHelper || isHelper(node.callee)), state;
        }
        function isHelper(node) {
          return isMemberExpression(node) ? isHelper(node.object) || isHelper(node.property) : isIdentifier(node) ? node.name === "require" || node.name[0] === "_" : isCallExpression(node) ? isHelper(node.callee) : !(!isBinary(node) && !isAssignmentExpression(node)) && (isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right));
        }
        function isType(node) {
          return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
        }
        const nodes = { AssignmentExpression(node) {
          const state = crawl(node.right);
          if (state.hasCall && state.hasHelper || state.hasFunction)
            return { before: state.hasFunction, after: true };
        }, SwitchCase: (node, parent) => ({ before: !!node.consequent.length || parent.cases[0] === node, after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node }), LogicalExpression(node) {
          if (isFunction(node.left) || isFunction(node.right))
            return { after: true };
        }, Literal(node) {
          if (isStringLiteral(node) && node.value === "use strict")
            return { after: true };
        }, CallExpression(node) {
          if (isFunction(node.callee) || isHelper(node))
            return { before: true, after: true };
        }, OptionalCallExpression(node) {
          if (isFunction(node.callee))
            return { before: true, after: true };
        }, VariableDeclaration(node) {
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType(declar.init);
            if (!enabled) {
              const state = crawl(declar.init);
              enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            if (enabled)
              return { before: true, after: true };
          }
        }, IfStatement(node) {
          if (isBlockStatement(node.consequent))
            return { before: true, after: true };
        } };
        exports2.nodes = nodes, nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
          if (parent.properties[0] === node)
            return { before: true };
        }, nodes.ObjectTypeCallProperty = function(node, parent) {
          var _parent$properties;
          if (parent.callProperties[0] === node && ((_parent$properties = parent.properties) == null || !_parent$properties.length))
            return { before: true };
        }, nodes.ObjectTypeIndexer = function(node, parent) {
          var _parent$properties2, _parent$callPropertie;
          if (!(parent.indexers[0] !== node || (_parent$properties2 = parent.properties) != null && _parent$properties2.length || (_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length))
            return { before: true };
        }, nodes.ObjectTypeInternalSlot = function(node, parent) {
          var _parent$properties3, _parent$callPropertie2, _parent$indexers;
          if (!(parent.internalSlots[0] !== node || (_parent$properties3 = parent.properties) != null && _parent$properties3.length || (_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length || (_parent$indexers = parent.indexers) != null && _parent$indexers.length))
            return { before: true };
        };
        const list = { VariableDeclaration: (node) => node.declarations.map((decl) => decl.init), ArrayExpression: (node) => node.elements, ObjectExpression: (node) => node.properties };
        exports2.list = list, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
          typeof amounts == "boolean" && (amounts = { after: amounts, before: amounts }), [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
            nodes[type2] = function() {
              return amounts;
            };
          });
        });
      }, "./node_modules/@babel/generator/lib/printer.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _buffer = __webpack_require__2("./node_modules/@babel/generator/lib/buffer.js"), n = __webpack_require__2("./node_modules/@babel/generator/lib/node/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), generatorFunctions = __webpack_require__2("./node_modules/@babel/generator/lib/generators/index.js");
        const { isProgram, isFile, isEmptyStatement } = _t, SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, NON_DECIMAL_LITERAL = /^0[box]/, PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/, { needsParens, needsWhitespaceAfter, needsWhitespaceBefore } = n;
        class Printer {
          constructor(format, map) {
            this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new WeakSet(), this._endsWithInteger = false, this._endsWithWord = false, this.format = format, this._buf = new _buffer.default(map);
          }
          generate(ast) {
            return this.print(ast), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            this.format.compact || this.format.concise || this._indent++;
          }
          dedent() {
            this.format.compact || this.format.concise || this._indent--;
          }
          semicolon(force = false) {
            this._maybeAddAuxComment(), this._append(";", !force);
          }
          rightBrace() {
            this.format.minified && this._buf.removeLastSemicolon(), this.token("}");
          }
          space(force = false) {
            if (!this.format.compact) {
              if (force)
                this._space();
              else if (this._buf.hasContent()) {
                const lastCp = this.getLastChar();
                lastCp !== 32 && lastCp !== 10 && this._space();
              }
            }
          }
          word(str) {
            (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) && this._space(), this._maybeAddAuxComment(), this._append(str), this._endsWithWord = true;
          }
          number(str) {
            this.word(str), this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
          }
          token(str) {
            const lastChar = this.getLastChar(), strFirst = str.charCodeAt(0);
            (str === "--" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(str);
          }
          newline(i = 1) {
            if (this.format.retainLines || this.format.compact)
              return;
            if (this.format.concise)
              return void this.space();
            const charBeforeNewline = this.endsWithCharAndNewline();
            if (charBeforeNewline !== 10 && (charBeforeNewline !== 123 && charBeforeNewline !== 58 || i--, !(i <= 0)))
              for (let j = 0; j < i; j++)
                this._newline();
          }
          endsWith(char) {
            return this.getLastChar() === char;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(loc, cb) {
            this._catchUp("start", loc), this._buf.exactSource(loc, cb);
          }
          source(prop, loc) {
            this._catchUp(prop, loc), this._buf.source(prop, loc);
          }
          withSource(prop, loc, cb) {
            this._catchUp(prop, loc), this._buf.withSource(prop, loc, cb);
          }
          _space() {
            this._append(" ", true);
          }
          _newline() {
            this._append("\n", true);
          }
          _append(str, queue = false) {
            this._maybeAddParen(str), this._maybeIndent(str), queue ? this._buf.queue(str) : this._buf.append(str), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _maybeIndent(str) {
            this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10 && this._buf.queue(this._getIndent());
          }
          _maybeAddParen(str) {
            const parenPushNewlineState = this._parenPushNewlineState;
            if (!parenPushNewlineState)
              return;
            let i;
            for (i = 0; i < str.length && str[i] === " "; i++)
              continue;
            if (i === str.length)
              return;
            const cha = str[i];
            if (cha !== "\n") {
              if (cha !== "/" || i + 1 === str.length)
                return void (this._parenPushNewlineState = null);
              const chaPost = str[i + 1];
              if (chaPost === "*") {
                if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2)))
                  return;
              } else if (chaPost !== "/")
                return void (this._parenPushNewlineState = null);
            }
            this.token("("), this.indent(), parenPushNewlineState.printed = true;
          }
          _catchUp(prop, loc) {
            if (!this.format.retainLines)
              return;
            const pos = loc ? loc[prop] : null;
            if ((pos == null ? void 0 : pos.line) != null) {
              const count = pos.line - this._buf.getCurrentLine();
              for (let i = 0; i < count; i++)
                this._newline();
            }
          }
          _getIndent() {
            return this.format.indent.style.repeat(this._indent);
          }
          startTerminatorless(isLabel = false) {
            return isLabel ? (this._noLineTerminator = true, null) : this._parenPushNewlineState = { printed: false };
          }
          endTerminatorless(state) {
            this._noLineTerminator = false, state != null && state.printed && (this.dedent(), this.newline(), this.token(")"));
          }
          print(node, parent) {
            if (!node)
              return;
            const oldConcise = this.format.concise;
            node._compact && (this.format.concise = true);
            const printMethod = this[node.type];
            if (!printMethod)
              throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);
            this._printStack.push(node);
            const oldInAux = this._insideAux;
            this._insideAux = !node.loc, this._maybeAddAuxComment(this._insideAux && !oldInAux);
            let shouldPrintParens = needsParens(node, parent, this._printStack);
            this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized && (shouldPrintParens = true), shouldPrintParens && this.token("("), this._printLeadingComments(node);
            const loc = isProgram(node) || isFile(node) ? null : node.loc;
            this.withSource("start", loc, () => {
              printMethod.call(this, node, parent);
            }), this._printTrailingComments(node), shouldPrintParens && this.token(")"), this._printStack.pop(), this.format.concise = oldConcise, this._insideAux = oldInAux;
          }
          _maybeAddAuxComment(enteredPositionlessNode) {
            enteredPositionlessNode && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = true;
            const comment = this.format.auxiliaryCommentBefore;
            comment && this._printComment({ type: "CommentBlock", value: comment });
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode)
              return;
            this._printAuxAfterOnNextUserNode = false;
            const comment = this.format.auxiliaryCommentAfter;
            comment && this._printComment({ type: "CommentBlock", value: comment });
          }
          getPossibleRaw(node) {
            const extra = node.extra;
            if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue)
              return extra.raw;
          }
          printJoin(nodes, parent, opts = {}) {
            if (nodes == null || !nodes.length)
              return;
            opts.indent && this.indent();
            const newlineOpts = { addNewlines: opts.addNewlines };
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              node && (opts.statement && this._printNewline(true, node, parent, newlineOpts), this.print(node, parent), opts.iterator && opts.iterator(node, i), opts.separator && i < nodes.length - 1 && opts.separator.call(this), opts.statement && this._printNewline(false, node, parent, newlineOpts));
            }
            opts.indent && this.dedent();
          }
          printAndIndentOnComments(node, parent) {
            const indent = node.leadingComments && node.leadingComments.length > 0;
            indent && this.indent(), this.print(node, parent), indent && this.dedent();
          }
          printBlock(parent) {
            const node = parent.body;
            isEmptyStatement(node) || this.space(), this.print(node, parent);
          }
          _printTrailingComments(node) {
            this._printComments(this._getComments(false, node));
          }
          _printLeadingComments(node) {
            this._printComments(this._getComments(true, node), true);
          }
          printInnerComments(node, indent = true) {
            var _node$innerComments;
            (_node$innerComments = node.innerComments) != null && _node$innerComments.length && (indent && this.indent(), this._printComments(node.innerComments), indent && this.dedent());
          }
          printSequence(nodes, parent, opts = {}) {
            return opts.statement = true, this.printJoin(nodes, parent, opts);
          }
          printList(items, parent, opts = {}) {
            return opts.separator == null && (opts.separator = commaSeparator), this.printJoin(items, parent, opts);
          }
          _printNewline(leading, node, parent, opts) {
            if (this.format.retainLines || this.format.compact)
              return;
            if (this.format.concise)
              return void this.space();
            let lines = 0;
            if (this._buf.hasContent()) {
              leading || lines++, opts.addNewlines && (lines += opts.addNewlines(leading, node) || 0);
              (leading ? needsWhitespaceBefore : needsWhitespaceAfter)(node, parent) && lines++;
            }
            this.newline(Math.min(2, lines));
          }
          _getComments(leading, node) {
            return node && (leading ? node.leadingComments : node.trailingComments) || [];
          }
          _printComment(comment, skipNewLines) {
            if (!this.format.shouldPrintComment(comment.value))
              return;
            if (comment.ignore)
              return;
            if (this._printedComments.has(comment))
              return;
            this._printedComments.add(comment);
            const isBlockComment = comment.type === "CommentBlock", printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
            printNewLines && this._buf.hasContent() && this.newline(1);
            const lastCharCode = this.getLastChar();
            lastCharCode !== 91 && lastCharCode !== 123 && this.space();
            let val = isBlockComment || this._noLineTerminator ? `/*${comment.value}*/` : `//${comment.value}
`;
            if (isBlockComment && this.format.indent.adjustMultilineComment) {
              var _comment$loc;
              const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
              if (offset) {
                const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
                val = val.replace(newlineRegex, "\n");
              }
              const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
            this.endsWith(47) && this._space(), this.withSource("start", comment.loc, () => {
              this._append(val);
            }), printNewLines && this.newline(1);
          }
          _printComments(comments, inlinePureAnnotation) {
            if (comments != null && comments.length)
              if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value))
                this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));
              else
                for (const comment of comments)
                  this._printComment(comment);
          }
          printAssertions(node) {
            var _node$assertions;
            (_node$assertions = node.assertions) != null && _node$assertions.length && (this.space(), this.word("assert"), this.space(), this.token("{"), this.space(), this.printList(node.assertions, node), this.space(), this.token("}"));
          }
        }
        Object.assign(Printer.prototype, generatorFunctions), Printer.prototype.Noop = function() {
        };
        var _default = Printer;
        function commaSeparator() {
          this.token(","), this.space();
        }
        exports2.default = _default;
      }, "./node_modules/@babel/generator/lib/source-map.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _sourceMap = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/source-map.js");
        exports2.default = class {
          constructor(opts, code) {
            this._cachedMap = void 0, this._code = void 0, this._opts = void 0, this._rawMappings = void 0, this._lastGenLine = void 0, this._lastSourceLine = void 0, this._lastSourceColumn = void 0, this._cachedMap = null, this._code = code, this._opts = opts, this._rawMappings = [];
          }
          get() {
            if (!this._cachedMap) {
              const map = this._cachedMap = new _sourceMap.SourceMapGenerator({ sourceRoot: this._opts.sourceRoot }), code = this._code;
              typeof code == "string" ? map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code) : typeof code == "object" && Object.keys(code).forEach((sourceFileName) => {
                map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
              }), this._rawMappings.forEach((mapping) => map.addMapping(mapping), map);
            }
            return this._cachedMap.toJSON();
          }
          getRawMappings() {
            return this._rawMappings.slice();
          }
          mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
            this._lastGenLine !== generatedLine && line === null || (force || this._lastGenLine !== generatedLine || this._lastSourceLine !== line || this._lastSourceColumn !== column) && (this._cachedMap = null, this._lastGenLine = generatedLine, this._lastSourceLine = line, this._lastSourceColumn = column, this._rawMappings.push({ name: identifierName || void 0, generated: { line: generatedLine, column: generatedColumn }, source: line == null ? void 0 : (filename || this._opts.sourceFileName).replace(/\\/g, "/"), original: line == null ? void 0 : { line, column } }));
          }
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map != "undefined";
        function ArraySet() {
          this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        }
        ArraySet.fromArray = function(aArray, aAllowDuplicates) {
          for (var set = new ArraySet(), i = 0, len = aArray.length; i < len; i++)
            set.add(aArray[i], aAllowDuplicates);
          return set;
        }, ArraySet.prototype.size = function() {
          return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
        }, ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
          var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
          isDuplicate && !aAllowDuplicates || this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
        }, ArraySet.prototype.has = function(aStr) {
          if (hasNativeMap)
            return this._set.has(aStr);
          var sStr = util.toSetString(aStr);
          return has.call(this._set, sStr);
        }, ArraySet.prototype.indexOf = function(aStr) {
          if (hasNativeMap) {
            var idx = this._set.get(aStr);
            if (idx >= 0)
              return idx;
          } else {
            var sStr = util.toSetString(aStr);
            if (has.call(this._set, sStr))
              return this._set[sStr];
          }
          throw new Error('"' + aStr + '" is not in the set.');
        }, ArraySet.prototype.at = function(aIdx) {
          if (aIdx >= 0 && aIdx < this._array.length)
            return this._array[aIdx];
          throw new Error("No element indexed by " + aIdx);
        }, ArraySet.prototype.toArray = function() {
          return this._array.slice();
        }, exports2.I = ArraySet;
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var base64 = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/base64.js");
        exports2.encode = function(aValue) {
          var digit, encoded = "", vlq = function(aValue2) {
            return aValue2 < 0 ? 1 + (-aValue2 << 1) : 0 + (aValue2 << 1);
          }(aValue);
          do {
            digit = 31 & vlq, (vlq >>>= 5) > 0 && (digit |= 32), encoded += base64.encode(digit);
          } while (vlq > 0);
          return encoded;
        }, exports2.decode = function(aStr, aIndex, aOutParam) {
          var continuation, digit, aValue, shifted, strLen = aStr.length, result = 0, shift = 0;
          do {
            if (aIndex >= strLen)
              throw new Error("Expected more digits in base 64 VLQ value.");
            if ((digit = base64.decode(aStr.charCodeAt(aIndex++))) === -1)
              throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
            continuation = !!(32 & digit), result += (digit &= 31) << shift, shift += 5;
          } while (continuation);
          aOutParam.value = (shifted = (aValue = result) >> 1, (1 & aValue) == 1 ? -shifted : shifted), aOutParam.rest = aIndex;
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/base64.js": (__unused_webpack_module, exports2) => {
        var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        exports2.encode = function(number) {
          if (0 <= number && number < intToCharMap.length)
            return intToCharMap[number];
          throw new TypeError("Must be between 0 and 63: " + number);
        }, exports2.decode = function(charCode) {
          return 65 <= charCode && charCode <= 90 ? charCode - 65 : 97 <= charCode && charCode <= 122 ? charCode - 97 + 26 : 48 <= charCode && charCode <= 57 ? charCode - 48 + 52 : charCode == 43 ? 62 : charCode == 47 ? 63 : -1;
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js": (__unused_webpack_module, exports2) => {
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
          var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], true);
          return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports2.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
        }
        exports2.GREATEST_LOWER_BOUND = 1, exports2.LEAST_UPPER_BOUND = 2, exports2.search = function(aNeedle, aHaystack, aCompare, aBias) {
          if (aHaystack.length === 0)
            return -1;
          var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
          if (index < 0)
            return -1;
          for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], true) === 0; )
            --index;
          return index;
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/util.js");
        function MappingList() {
          this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
        }
        MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
          this._array.forEach(aCallback, aThisArg);
        }, MappingList.prototype.add = function(aMapping) {
          var mappingA, mappingB, lineA, lineB, columnA, columnB;
          mappingA = this._last, mappingB = aMapping, lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn, lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0 ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = false, this._array.push(aMapping));
        }, MappingList.prototype.toArray = function() {
          return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
        }, exports2.H = MappingList;
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js": (__unused_webpack_module, exports2) => {
        function swap(ary, x, y) {
          var temp = ary[x];
          ary[x] = ary[y], ary[y] = temp;
        }
        function doQuickSort(ary, comparator, p, r) {
          if (p < r) {
            var i = p - 1;
            swap(ary, (low = p, high = r, Math.round(low + Math.random() * (high - low))), r);
            for (var pivot = ary[r], j = p; j < r; j++)
              comparator(ary[j], pivot) <= 0 && swap(ary, i += 1, j);
            swap(ary, i + 1, j);
            var q = i + 1;
            doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
          }
          var low, high;
        }
        exports2.U = function(ary, comparator) {
          doQuickSort(ary, comparator, 0, ary.length - 1);
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var util = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"), binarySearch = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/binary-search.js"), ArraySet = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I, base64VLQ = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"), quickSort = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/quick-sort.js").U;
        function SourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          return typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""))), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
        }
        function BasicSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
          var version3 = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
          if (version3 != this._version)
            throw new Error("Unsupported version: " + version3);
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          }), this._names = ArraySet.fromArray(names.map(String), true), this._sources = ArraySet.fromArray(sources, true), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this.file = file;
        }
        function Mapping() {
          this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
        }
        function IndexedSourceMapConsumer(aSourceMap) {
          var sourceMap = aSourceMap;
          typeof aSourceMap == "string" && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
          var version3 = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
          if (version3 != this._version)
            throw new Error("Unsupported version: " + version3);
          this._sources = new ArraySet(), this._names = new ArraySet();
          var lastOffset = { line: -1, column: 0 };
          this._sections = sections.map(function(s) {
            if (s.url)
              throw new Error("Support for url field in sections not implemented.");
            var offset = util.getArg(s, "offset"), offsetLine = util.getArg(offset, "line"), offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
              throw new Error("Section offsets must be ordered and non-overlapping.");
            return lastOffset = offset, { generatedOffset: { generatedLine: offsetLine + 1, generatedColumn: offsetColumn + 1 }, consumer: new SourceMapConsumer(util.getArg(s, "map")) };
          });
        }
        SourceMapConsumer.fromSourceMap = function(aSourceMap) {
          return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
        }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", { get: function() {
          return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
        } }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", { get: function() {
          return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
        } }), SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
          var c = aStr.charAt(index);
          return c === ";" || c === ",";
        }, SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          throw new Error("Subclasses must implement _parseMappings");
        }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
          var mappings, context = aContext || null;
          switch (aOrder || SourceMapConsumer.GENERATED_ORDER) {
            case SourceMapConsumer.GENERATED_ORDER:
              mappings = this._generatedMappings;
              break;
            case SourceMapConsumer.ORIGINAL_ORDER:
              mappings = this._originalMappings;
              break;
            default:
              throw new Error("Unknown order of iteration.");
          }
          var sourceRoot = this.sourceRoot;
          mappings.map(function(mapping) {
            var source = mapping.source === null ? null : this._sources.at(mapping.source);
            return source != null && sourceRoot != null && (source = util.join(sourceRoot, source)), { source, generatedLine: mapping.generatedLine, generatedColumn: mapping.generatedColumn, originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name: mapping.name === null ? null : this._names.at(mapping.name) };
          }, this).forEach(aCallback, context);
        }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
          var line = util.getArg(aArgs, "line"), needle = { source: util.getArg(aArgs, "source"), originalLine: line, originalColumn: util.getArg(aArgs, "column", 0) };
          if (this.sourceRoot != null && (needle.source = util.relative(this.sourceRoot, needle.source)), !this._sources.has(needle.source))
            return [];
          needle.source = this._sources.indexOf(needle.source);
          var mappings = [], index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (aArgs.column === void 0)
              for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) }), mapping = this._originalMappings[++index];
            else
              for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
                mappings.push({ line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) }), mapping = this._originalMappings[++index];
          }
          return mappings;
        }, exports2.SourceMapConsumer = SourceMapConsumer, BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.fromSourceMap = function(aSourceMap) {
          var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot), smc.file = aSourceMap._file;
          for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
            var srcMapping = generatedMappings[i], destMapping = new Mapping();
            destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
          }
          return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
        }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
          return this._sources.toArray().map(function(s) {
            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
          }, this);
        } }), BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          for (var mapping, str, segment, end, value, generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = []; index < length; )
            if (aStr.charAt(index) === ";")
              generatedLine++, index++, previousGeneratedColumn = 0;
            else if (aStr.charAt(index) === ",")
              index++;
            else {
              for ((mapping = new Mapping()).generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
                ;
              if (segment = cachedSegments[str = aStr.slice(index, end)])
                index += str.length;
              else {
                for (segment = []; index < end; )
                  base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
                if (segment.length === 2)
                  throw new Error("Found a source, but no line and column");
                if (segment.length === 3)
                  throw new Error("Found a source and line, but no column");
                cachedSegments[str] = segment;
              }
              mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
            }
          quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
        }, BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
          if (aNeedle[aLineName] <= 0)
            throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
          if (aNeedle[aColumnName] < 0)
            throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
          return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
          for (var index = 0; index < this._generatedMappings.length; ++index) {
            var mapping = this._generatedMappings[index];
            if (index + 1 < this._generatedMappings.length) {
              var nextMapping = this._generatedMappings[index + 1];
              if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
              }
            }
            mapping.lastGeneratedColumn = 1 / 0;
          }
        }, BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") }, index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._generatedMappings[index];
            if (mapping.generatedLine === needle.generatedLine) {
              var source = util.getArg(mapping, "source", null);
              source !== null && (source = this._sources.at(source), this.sourceRoot != null && (source = util.join(this.sourceRoot, source)));
              var name = util.getArg(mapping, "name", null);
              return name !== null && (name = this._names.at(name)), { source, line: util.getArg(mapping, "originalLine", null), column: util.getArg(mapping, "originalColumn", null), name };
            }
          }
          return { source: null, line: null, column: null, name: null };
        }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
          return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
            return sc == null;
          }));
        }, BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
          if (!this.sourcesContent)
            return null;
          if (this.sourceRoot != null && (aSource = util.relative(this.sourceRoot, aSource)), this._sources.has(aSource))
            return this.sourcesContent[this._sources.indexOf(aSource)];
          var url;
          if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file" && this._sources.has(fileUriAbsPath))
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
            if ((!url.path || url.path == "/") && this._sources.has("/" + aSource))
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
          }
          if (nullOnMissing)
            return null;
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
          var source = util.getArg(aArgs, "source");
          if (this.sourceRoot != null && (source = util.relative(this.sourceRoot, source)), !this._sources.has(source))
            return { line: null, column: null, lastColumn: null };
          var needle = { source: source = this._sources.indexOf(source), originalLine: util.getArg(aArgs, "line"), originalColumn: util.getArg(aArgs, "column") }, index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
          if (index >= 0) {
            var mapping = this._originalMappings[index];
            if (mapping.source === needle.source)
              return { line: util.getArg(mapping, "generatedLine", null), column: util.getArg(mapping, "generatedColumn", null), lastColumn: util.getArg(mapping, "lastGeneratedColumn", null) };
          }
          return { line: null, column: null, lastColumn: null };
        }, IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
          for (var sources = [], i = 0; i < this._sections.length; i++)
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++)
              sources.push(this._sections[i].consumer.sources[j]);
          return sources;
        } }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
          var needle = { generatedLine: util.getArg(aArgs, "line"), generatedColumn: util.getArg(aArgs, "column") }, sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }), section = this._sections[sectionIndex];
          return section ? section.consumer.originalPositionFor({ line: needle.generatedLine - (section.generatedOffset.generatedLine - 1), column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), bias: aArgs.bias }) : { source: null, line: null, column: null, name: null };
        }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
          return this._sections.every(function(s) {
            return s.consumer.hasContentsOfAllSources();
          });
        }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
          for (var i = 0; i < this._sections.length; i++) {
            var content = this._sections[i].consumer.sourceContentFor(aSource, true);
            if (content)
              return content;
          }
          if (nullOnMissing)
            return null;
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
          for (var i = 0; i < this._sections.length; i++) {
            var section = this._sections[i];
            if (section.consumer.sources.indexOf(util.getArg(aArgs, "source")) !== -1) {
              var generatedPosition = section.consumer.generatedPositionFor(aArgs);
              if (generatedPosition)
                return { line: generatedPosition.line + (section.generatedOffset.generatedLine - 1), column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0) };
            }
          }
          return { line: null, column: null };
        }, IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
          this.__generatedMappings = [], this.__originalMappings = [];
          for (var i = 0; i < this._sections.length; i++)
            for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
              var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
              section.consumer.sourceRoot !== null && (source = util.join(section.consumer.sourceRoot, source)), this._sources.add(source), source = this._sources.indexOf(source);
              var name = section.consumer._names.at(mapping.name);
              this._names.add(name), name = this._names.indexOf(name);
              var adjustedMapping = { source, generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1), generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0), originalLine: mapping.originalLine, originalColumn: mapping.originalColumn, name };
              this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
            }
          quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var base64VLQ = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/base64-vlq.js"), util = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"), ArraySet = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/array-set.js").I, MappingList = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/mapping-list.js").H;
        function SourceMapGenerator(aArgs) {
          aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", false), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
        }
        SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({ file: aSourceMapConsumer.file, sourceRoot });
          return aSourceMapConsumer.eachMapping(function(mapping) {
            var newMapping = { generated: { line: mapping.generatedLine, column: mapping.generatedColumn } };
            mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = { line: mapping.originalLine, column: mapping.originalColumn }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
          }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            content != null && generator.setSourceContent(sourceFile, content);
          }), generator;
        }, SourceMapGenerator.prototype.addMapping = function(aArgs) {
          var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
          this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({ generatedLine: generated.line, generatedColumn: generated.column, originalLine: original != null && original.line, originalColumn: original != null && original.column, source, name });
        }, SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
        }, SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
          var sourceFile = aSourceFile;
          if (aSourceFile == null) {
            if (aSourceMapConsumer.file == null)
              throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
            sourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
          var newSources = new ArraySet(), newNames = new ArraySet();
          this._mappings.unsortedForEach(function(mapping) {
            if (mapping.source === sourceFile && mapping.originalLine != null) {
              var original = aSourceMapConsumer.originalPositionFor({ line: mapping.originalLine, column: mapping.originalColumn });
              original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
            }
            var source = mapping.source;
            source == null || newSources.has(source) || newSources.add(source);
            var name = mapping.name;
            name == null || newNames.has(name) || newNames.add(name);
          }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
            content != null && (aSourceMapPath != null && (sourceFile2 = util.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
          }, this);
        }, SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
          if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
            throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
          if ((!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0) || aOriginal || aSource || aName) && !(aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource))
            throw new Error("Invalid mapping: " + JSON.stringify({ generated: aGenerated, source: aSource, original: aOriginal, name: aName }));
        }, SourceMapGenerator.prototype._serializeMappings = function() {
          for (var next, mapping, nameIdx, sourceIdx, previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
            if (next = "", (mapping = mappings[i]).generatedLine !== previousGeneratedLine)
              for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
                next += ";", previousGeneratedLine++;
            else if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1]))
                continue;
              next += ",";
            }
            next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
          }
          return result;
        }, SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
          return aSources.map(function(source) {
            if (!this._sourcesContents)
              return null;
            aSourceRoot != null && (source = util.relative(aSourceRoot, source));
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
          }, this);
        }, SourceMapGenerator.prototype.toJSON = function() {
          var map = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
          return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
        }, SourceMapGenerator.prototype.toString = function() {
          return JSON.stringify(this.toJSON());
        }, exports2.SourceMapGenerator = SourceMapGenerator;
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        var SourceMapGenerator = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator, util = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/util.js"), REGEX_NEWLINE = /(\r?\n)/, isSourceNode = "$$$isSourceNode$$$";
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
          this.children = [], this.sourceContents = {}, this.line = aLine == null ? null : aLine, this.column = aColumn == null ? null : aColumn, this.source = aSource == null ? null : aSource, this.name = aName == null ? null : aName, this[isSourceNode] = true, aChunks != null && this.add(aChunks);
        }
        SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
          var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
            return getNextLine() + (getNextLine() || "");
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
            }
          }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
          return aSourceMapConsumer.eachMapping(function(mapping) {
            if (lastMapping !== null) {
              if (!(lastGeneratedLine < mapping.generatedLine)) {
                var code = (nextLine = remainingLines[remainingLinesIndex]).substr(0, mapping.generatedColumn - lastGeneratedColumn);
                return remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), void (lastMapping = mapping);
              }
              addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
            }
            for (; lastGeneratedLine < mapping.generatedLine; )
              node.add(shiftNextLine()), lastGeneratedLine++;
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[remainingLinesIndex];
              node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
            }
            lastMapping = mapping;
          }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
          }), node;
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === void 0)
              node.add(code);
            else {
              var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
              node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
            }
          }
        }, SourceNode.prototype.add = function(aChunk) {
          if (Array.isArray(aChunk))
            aChunk.forEach(function(chunk) {
              this.add(chunk);
            }, this);
          else {
            if (!aChunk[isSourceNode] && typeof aChunk != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            aChunk && this.children.push(aChunk);
          }
          return this;
        }, SourceNode.prototype.prepend = function(aChunk) {
          if (Array.isArray(aChunk))
            for (var i = aChunk.length - 1; i >= 0; i--)
              this.prepend(aChunk[i]);
          else {
            if (!aChunk[isSourceNode] && typeof aChunk != "string")
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            this.children.unshift(aChunk);
          }
          return this;
        }, SourceNode.prototype.walk = function(aFn) {
          for (var chunk, i = 0, len = this.children.length; i < len; i++)
            (chunk = this.children[i])[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, { source: this.source, line: this.line, column: this.column, name: this.name });
        }, SourceNode.prototype.join = function(aSep) {
          var newChildren, i, len = this.children.length;
          if (len > 0) {
            for (newChildren = [], i = 0; i < len - 1; i++)
              newChildren.push(this.children[i]), newChildren.push(aSep);
            newChildren.push(this.children[i]), this.children = newChildren;
          }
          return this;
        }, SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
          var lastChild = this.children[this.children.length - 1];
          return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
        }, SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        }, SourceNode.prototype.walkSourceContents = function(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++)
            this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
          var sources = Object.keys(this.sourceContents);
          for (i = 0, len = sources.length; i < len; i++)
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }, SourceNode.prototype.toString = function() {
          var str = "";
          return this.walk(function(chunk) {
            str += chunk;
          }), str;
        }, SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
          var generated = { code: "", line: 1, column: 0 }, map = new SourceMapGenerator(aArgs), sourceMappingActive = false, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
          return this.walk(function(chunk, original) {
            generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? (lastOriginalSource === original.source && lastOriginalLine === original.line && lastOriginalColumn === original.column && lastOriginalName === original.name || map.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = true) : sourceMappingActive && (map.addMapping({ generated: { line: generated.line, column: generated.column } }), lastOriginalSource = null, sourceMappingActive = false);
            for (var idx = 0, length = chunk.length; idx < length; idx++)
              chunk.charCodeAt(idx) === 10 ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = false) : sourceMappingActive && map.addMapping({ source: original.source, original: { line: original.line, column: original.column }, generated: { line: generated.line, column: generated.column }, name: original.name })) : generated.column++;
          }), this.walkSourceContents(function(sourceFile, sourceContent) {
            map.setSourceContent(sourceFile, sourceContent);
          }), { code: generated.code, map };
        }, exports2.SourceNode = SourceNode;
      }, "./node_modules/@babel/generator/node_modules/source-map/lib/util.js": (__unused_webpack_module, exports2) => {
        exports2.getArg = function(aArgs, aName, aDefaultValue) {
          if (aName in aArgs)
            return aArgs[aName];
          if (arguments.length === 3)
            return aDefaultValue;
          throw new Error('"' + aName + '" is a required argument.');
        };
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/, dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
          var match = aUrl.match(urlRegexp);
          return match ? { scheme: match[1], auth: match[2], host: match[3], port: match[4], path: match[5] } : null;
        }
        function urlGenerate(aParsedUrl) {
          var url = "";
          return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
        }
        function normalize(aPath) {
          var path = aPath, url = urlParse(aPath);
          if (url) {
            if (!url.path)
              return aPath;
            path = url.path;
          }
          for (var part, isAbsolute2 = exports2.isAbsolute(path), parts = path.split(/\/+/), up = 0, i = parts.length - 1; i >= 0; i--)
            (part = parts[i]) === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
          return (path = parts.join("/")) === "" && (path = isAbsolute2 ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
        }
        exports2.urlParse = urlParse, exports2.urlGenerate = urlGenerate, exports2.normalize = normalize, exports2.join = function(aRoot, aPath) {
          aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
          var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
          if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
            return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
          if (aPathUrl || aPath.match(dataUrlRegexp))
            return aPath;
          if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
            return aRootUrl.host = aPath, urlGenerate(aRootUrl);
          var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
          return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
        }, exports2.isAbsolute = function(aPath) {
          return aPath.charAt(0) === "/" || !!aPath.match(urlRegexp);
        }, exports2.relative = function(aRoot, aPath) {
          aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
          for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
            var index = aRoot.lastIndexOf("/");
            if (index < 0)
              return aPath;
            if ((aRoot = aRoot.slice(0, index)).match(/^([^\/]+:\/)?\/*$/))
              return aPath;
            ++level;
          }
          return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        };
        var supportsNullProto = !("__proto__" in /* @__PURE__ */ Object.create(null));
        function identity(s) {
          return s;
        }
        function isProtoString(s) {
          if (!s)
            return false;
          var length = s.length;
          if (length < 9)
            return false;
          if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95)
            return false;
          for (var i = length - 10; i >= 0; i--)
            if (s.charCodeAt(i) !== 36)
              return false;
          return true;
        }
        function strcmp(aStr1, aStr2) {
          return aStr1 === aStr2 ? 0 : aStr1 > aStr2 ? 1 : -1;
        }
        exports2.toSetString = supportsNullProto ? identity : function(aStr) {
          return isProtoString(aStr) ? "$" + aStr : aStr;
        }, exports2.fromSetString = supportsNullProto ? identity : function(aStr) {
          return isProtoString(aStr) ? aStr.slice(1) : aStr;
        }, exports2.compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
          var cmp = mappingA.source - mappingB.source;
          return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 || onlyCompareOriginal || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || (cmp = mappingA.generatedLine - mappingB.generatedLine) !== 0 ? cmp : mappingA.name - mappingB.name;
        }, exports2.compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || onlyCompareGenerated || (cmp = mappingA.source - mappingB.source) !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 ? cmp : mappingA.name - mappingB.name;
        }, exports2.compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
          var cmp = mappingA.generatedLine - mappingB.generatedLine;
          return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn) !== 0 || (cmp = strcmp(mappingA.source, mappingB.source)) !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine) !== 0 || (cmp = mappingA.originalColumn - mappingB.originalColumn) !== 0 ? cmp : strcmp(mappingA.name, mappingB.name);
        };
      }, "./node_modules/@babel/generator/node_modules/source-map/source-map.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        exports2.SourceMapGenerator = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator, exports2.SourceMapConsumer = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer, exports2.SourceNode = __webpack_require__2("./node_modules/@babel/generator/node_modules/source-map/lib/source-node.js").SourceNode;
      }, "./node_modules/@babel/helper-annotate-as-pure/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(pathOrNode) {
          const node = pathOrNode.node || pathOrNode;
          if ((({ leadingComments }) => !!leadingComments && leadingComments.some((comment) => /[@#]__PURE__/.test(comment.value)))(node))
            return;
          addComment(node, "leading", "#__PURE__");
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { addComment } = _t;
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.buildDecoratedClass = function(ref, path, elements, file) {
          const { node, scope } = path, initializeId = scope.generateUidIdentifier("initialize"), isDeclaration = node.id && path.isDeclaration(), isStrict = path.isInStrictMode(), { superClass } = node;
          node.type = "ClassDeclaration", node.id || (node.id = _core.types.cloneNode(ref));
          let superId;
          superClass && (superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super"), node.superClass = superId);
          const classDecorators = takeDecorators(node), definitions = _core.types.arrayExpression(elements.filter((element) => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId))), wrapperCall = _core.template.expression.ast`
    ${function(file2) {
            try {
              return file2.addHelper("decorate");
            } catch (err) {
              throw err.code === "BABEL_HELPER_UNKNOWN" && (err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."), err;
            }
          }(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
          isStrict || wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
          let replacement = wrapperCall, classPathDesc = "arguments.1.body.body.0";
          isDeclaration && (replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`, classPathDesc = "declarations.0.init." + classPathDesc);
          return { instanceNodes: [_core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)`], wrapClass: (path2) => (path2.replaceWith(replacement), path2.get(classPathDesc)) };
        }, exports2.hasDecorators = function(node) {
          return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
        }, exports2.hasOwnDecorators = hasOwnDecorators;
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _helperReplaceSupers = __webpack_require__2("./node_modules/@babel/helper-replace-supers/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/@babel/helper-function-name/lib/index.js");
        function hasOwnDecorators(node) {
          return !(!node.decorators || !node.decorators.length);
        }
        function prop(key, value) {
          return value ? _core.types.objectProperty(_core.types.identifier(key), value) : null;
        }
        function takeDecorators(node) {
          let result;
          return node.decorators && node.decorators.length > 0 && (result = _core.types.arrayExpression(node.decorators.map((decorator) => decorator.expression))), node.decorators = void 0, result;
        }
        function getKey(node) {
          return node.computed ? node.key : _core.types.isIdentifier(node.key) ? _core.types.stringLiteral(node.key.name) : _core.types.stringLiteral(String(node.key.value));
        }
        function extractElementDescriptor(classRef, superRef, path) {
          const { node, scope } = path, isMethod = path.isClassMethod();
          if (path.isPrivate())
            throw path.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
          new _helperReplaceSupers.default({ methodPath: path, objectRef: classRef, superRef, file: this, refToPreserve: classRef }).replace();
          const properties = [prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core.types.booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);
          if (_core.types.isClassMethod(node)) {
            const id = node.computed ? null : node.key;
            _core.types.toExpression(node), properties.push(prop("value", (0, _helperFunctionName.default)({ node, id, scope }) || node));
          } else
            _core.types.isClassProperty(node) && node.value ? properties.push((key = "value", body = _core.template.statements.ast`return ${node.value}`, _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body)))) : properties.push(prop("value", scope.buildUndefinedNode()));
          var key, body;
          return path.remove(), _core.types.objectExpression(properties);
        }
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/features.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.FEATURES = void 0, exports2.enableFeature = function(file, feature, loose) {
          hasFeature(file, feature) && !canIgnoreLoose(file, feature) || (file.set(featuresKey, file.get(featuresKey) | feature), loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (setLoose(file, feature, true), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (setLoose(file, feature, false), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : setLoose(file, feature, loose));
          let resolvedLoose, higherPriorityPluginName;
          for (const [mask, name] of featuresSameLoose) {
            if (!hasFeature(file, mask))
              continue;
            const loose2 = isLoose(file, mask);
            if (!canIgnoreLoose(file, mask)) {
              if (resolvedLoose === !loose2)
                throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");
              resolvedLoose = loose2, higherPriorityPluginName = name;
            }
          }
          if (resolvedLoose !== void 0)
            for (const [mask, name] of featuresSameLoose)
              hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose && (setLoose(file, mask, resolvedLoose), console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.
The "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${name}", { "loose": ${resolvedLoose} }]
to the "plugins" section of your Babel config.`));
        }, exports2.isLoose = isLoose, exports2.shouldTransform = function(path, file) {
          let decoratorPath = null, publicFieldPath = null, privateFieldPath = null, privateMethodPath = null, staticBlockPath = null;
          (0, _decorators.hasOwnDecorators)(path.node) && (decoratorPath = path.get("decorators.0"));
          for (const el of path.get("body.body"))
            !decoratorPath && (0, _decorators.hasOwnDecorators)(el.node) && (decoratorPath = el.get("decorators.0")), !publicFieldPath && el.isClassProperty() && (publicFieldPath = el), !privateFieldPath && el.isClassPrivateProperty() && (privateFieldPath = el), !privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod() && (privateMethodPath = el), !staticBlockPath && el.isStaticBlock != null && el.isStaticBlock() && (staticBlockPath = el);
          if (decoratorPath && privateFieldPath)
            throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (decoratorPath && privateMethodPath)
            throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (decoratorPath && !hasFeature(file, FEATURES.decorators))
            throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "legacy": true }]\n	["@babel/plugin-proposal-class-properties", { "loose": true }]');
          if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods))
            throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-proposal-private-method` to your configuration.");
          if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods))
            throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-proposal-class-properties` to your configuration.");
          if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks))
            throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
          if (decoratorPath || privateMethodPath || staticBlockPath)
            return true;
          if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields))
            return true;
          return false;
        };
        var _decorators = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");
        const FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 });
        exports2.FEATURES = FEATURES;
        const featuresSameLoose = /* @__PURE__ */ new Map([[FEATURES.fields, "@babel/plugin-proposal-class-properties"], [FEATURES.privateMethods, "@babel/plugin-proposal-private-methods"], [FEATURES.privateIn, "@babel/plugin-proposal-private-property-in-object"]]), featuresKey = "@babel/plugin-class-features/featuresKey", looseKey = "@babel/plugin-class-features/looseKey", looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
        function hasFeature(file, feature) {
          return !!(file.get(featuresKey) & feature);
        }
        function isLoose(file, feature) {
          return !!(file.get(looseKey) & feature);
        }
        function setLoose(file, feature, loose) {
          loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature), file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
        }
        function canIgnoreLoose(file, feature) {
          return !!(file.get(looseLowPriorityKey) & feature);
        }
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.buildFieldsInitNodes = function(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
          let injectSuperRef, needsClassRef = false;
          const staticNodes = [], instanceNodes = [], pureStaticNodes = [], getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => (injectSuperRef != null || (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef)), injectSuperRef);
          for (const prop of props) {
            prop.isClassProperty() && ts.assertFieldTransformed(prop);
            const isStatic = prop.node.static, isInstance = !isStatic, isPrivate = prop.isPrivate(), isPublic = !isPrivate, isField = prop.isProperty(), isMethod = !isField, isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();
            if (isStatic || isMethod && isPrivate || isStaticBlock) {
              const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
              needsClassRef = needsClassRef || replaced;
            }
            switch (true) {
              case isStaticBlock:
                staticNodes.push(_core.template.statement.ast`(() => ${_core.types.blockStatement(prop.node.body)})()`);
                break;
              case (isStatic && isPrivate && isField && privateFieldsAsProperties):
                needsClassRef = true, staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
                break;
              case (isStatic && isPrivate && isField && !privateFieldsAsProperties):
                needsClassRef = true, staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
                break;
              case (isStatic && isPublic && isField && setPublicClassFields):
                needsClassRef = true, staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
                break;
              case (isStatic && isPublic && isField && !setPublicClassFields):
                needsClassRef = true, staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));
                break;
              case (isInstance && isPrivate && isField && privateFieldsAsProperties):
                instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
                break;
              case (isInstance && isPrivate && isField && !privateFieldsAsProperties):
                instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));
                break;
              case (isInstance && isPrivate && isMethod && privateFieldsAsProperties):
                instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isInstance && isPrivate && isMethod && !privateFieldsAsProperties):
                instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isStatic && isPrivate && isMethod && !privateFieldsAsProperties):
                needsClassRef = true, staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isStatic && isPrivate && isMethod && privateFieldsAsProperties):
                needsClassRef = true, staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap)), pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
                break;
              case (isInstance && isPublic && isField && setPublicClassFields):
                instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
                break;
              case (isInstance && isPublic && isField && !setPublicClassFields):
                instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          return { staticNodes: staticNodes.filter(Boolean), instanceNodes: instanceNodes.filter(Boolean), pureStaticNodes: pureStaticNodes.filter(Boolean), wrapClass(path) {
            for (const prop of props)
              prop.remove();
            return injectSuperRef && (path.scope.push({ id: _core.types.cloneNode(injectSuperRef) }), path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass))), needsClassRef ? (path.isClassExpression() ? (path.scope.push({ id: ref }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node))) : path.node.id || (path.node.id = ref), path) : path;
          } };
        }, exports2.buildPrivateNamesMap = function(props) {
          const privateNamesMap = /* @__PURE__ */ new Map();
          for (const prop of props)
            if (prop.isPrivate()) {
              const { name } = prop.node.key.id, update = privateNamesMap.has(name) ? privateNamesMap.get(name) : { id: prop.scope.generateUidIdentifier(name), static: prop.node.static, method: !prop.isProperty() };
              prop.isClassPrivateMethod() && (prop.node.kind === "get" ? update.getId = prop.scope.generateUidIdentifier(`get_${name}`) : prop.node.kind === "set" ? update.setId = prop.scope.generateUidIdentifier(`set_${name}`) : prop.node.kind === "method" && (update.methodId = prop.scope.generateUidIdentifier(name))), privateNamesMap.set(name, update);
            }
          return privateNamesMap;
        }, exports2.buildPrivateNamesNodes = function(privateNamesMap, privateFieldsAsProperties, state) {
          const initNodes = [];
          for (const [name, value] of privateNamesMap) {
            const { static: isStatic, method: isMethod, getId, setId } = value, isAccessor = getId || setId, id = _core.types.cloneNode(value.id);
            let init;
            privateFieldsAsProperties ? init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [_core.types.stringLiteral(name)]) : isStatic || (init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), [])), init && ((0, _helperAnnotateAsPure.default)(init), initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));
          }
          return initNodes;
        }, exports2.transformPrivateNamesUsage = function(ref, path, privateNamesMap, { privateFieldsAsProperties, noDocumentAll, innerBinding }, state) {
          if (!privateNamesMap.size)
            return;
          const body = path.get("body"), handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
          (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({ privateNamesMap, classRef: ref, file: state }, handler, { noDocumentAll, innerBinding })), body.traverse(privateInVisitor, { privateNamesMap, classRef: ref, file: state, privateFieldsAsProperties, innerBinding });
        };
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _helperReplaceSupers = __webpack_require__2("./node_modules/@babel/helper-replace-supers/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/@babel/helper-environment-visitor/lib/index.js"), _helperMemberExpressionToFunctions = __webpack_require__2("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), _helperOptimiseCallExpression = __webpack_require__2("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"), _helperAnnotateAsPure = __webpack_require__2("./node_modules/@babel/helper-annotate-as-pure/lib/index.js"), ts = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        function privateNameVisitorFactory(visitor) {
          const privateNameVisitor2 = Object.assign({}, visitor, { Class(path) {
            const { privateNamesMap } = this, body = path.get("body.body"), visiblePrivateNames = new Map(privateNamesMap), redeclared = [];
            for (const prop of body) {
              if (!prop.isPrivate())
                continue;
              const { name } = prop.node.key.id;
              visiblePrivateNames.delete(name), redeclared.push(name);
            }
            redeclared.length && (path.get("body").traverse(nestedVisitor, Object.assign({}, this, { redeclared })), path.traverse(privateNameVisitor2, Object.assign({}, this, { privateNamesMap: visiblePrivateNames })), path.skipKey("body"));
          } }), nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]);
          return privateNameVisitor2;
        }
        const privateNameVisitor = privateNameVisitorFactory({ PrivateName(path, { noDocumentAll }) {
          const { privateNamesMap, redeclared } = this, { node, parentPath } = path;
          if (!parentPath.isMemberExpression({ property: node }) && !parentPath.isOptionalMemberExpression({ property: node }))
            return;
          const { name } = node.id;
          privateNamesMap.has(name) && (redeclared && redeclared.includes(name) || this.handle(parentPath, noDocumentAll));
        } });
        function unshadow(name, scope, innerBinding) {
          for (; (_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding); ) {
            var _scope;
            scope.rename(name), scope = scope.parent;
          }
        }
        const privateInVisitor = privateNameVisitorFactory({ BinaryExpression(path) {
          const { operator, left, right } = path.node;
          if (operator !== "in")
            return;
          if (!_core.types.isPrivateName(left))
            return;
          const { privateFieldsAsProperties, privateNamesMap, redeclared } = this, { name } = left.id;
          if (!privateNamesMap.has(name))
            return;
          if (redeclared && redeclared.includes(name))
            return;
          if (unshadow(this.classRef.name, path.scope, this.innerBinding), privateFieldsAsProperties) {
            const { id: id2 } = privateNamesMap.get(name);
            return void path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id2)})
      `);
          }
          const { id, static: isStatic } = privateNamesMap.get(name);
          isStatic ? path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`) : path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);
        } }), privateNameHandlerSpec = { memoise(member, count) {
          const { scope } = member, { object } = member.node, memo = scope.maybeGenerateMemoised(object);
          memo && this.memoiser.set(object, memo, count);
        }, receiver(member) {
          const { object } = member.node;
          return this.memoiser.has(object) ? _core.types.cloneNode(this.memoiser.get(object)) : _core.types.cloneNode(object);
        }, get(member) {
          const { classRef, privateNamesMap, file, innerBinding } = this, { name } = member.node.property.id, { id, static: isStatic, method: isMethod, methodId, getId, setId } = privateNamesMap.get(name), isAccessor = getId || setId;
          if (isStatic) {
            const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
            return unshadow(classRef.name, member.scope, innerBinding), _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);
          }
          if (isMethod) {
            if (isAccessor) {
              if (!getId && setId) {
                if (file.availableHelper("writeOnlyError"))
                  return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper("writeOnlyError"), [_core.types.stringLiteral(`#${name}`)])]);
                console.warn("@babel/helpers is outdated, update it to silence this warning.");
              }
              return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
            }
            return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);
          }
          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), _core.types.cloneNode(id)]);
        }, boundGet(member) {
          return this.memoise(member, 1), _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [this.receiver(member)]);
        }, set(member, value) {
          const { classRef, privateNamesMap, file } = this, { name } = member.node.property.id, { id, static: isStatic, method: isMethod, setId, getId } = privateNamesMap.get(name);
          if (isStatic) {
            const helperName = isMethod && !(getId || setId) ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
            return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);
          }
          return isMethod ? setId ? _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value]) : _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper("readOnlyError"), [_core.types.stringLiteral(`#${name}`)])]) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), _core.types.cloneNode(id), value]);
        }, destructureSet(member) {
          const { classRef, privateNamesMap, file } = this, { name } = member.node.property.id, { id, static: isStatic } = privateNamesMap.get(name);
          if (isStatic) {
            try {
              var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
            } catch (_unused) {
              throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
            }
            return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier("value"));
          }
          return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier("value"));
        }, call(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);
        }, optionalCall(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);
        } }, privateNameHandlerLoose = { get(member) {
          const { privateNamesMap, file } = this, { object } = member.node, { name } = member.node.property.id;
          return _core.template.expression`BASE(REF, PROP)[PROP]`({ BASE: file.addHelper("classPrivateFieldLooseBase"), REF: _core.types.cloneNode(object), PROP: _core.types.cloneNode(privateNamesMap.get(name).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(member) {
          return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [_core.types.cloneNode(member.node.object)]);
        }, simpleSet(member) {
          return this.get(member);
        }, destructureSet(member) {
          return this.get(member);
        }, call(member, args) {
          return _core.types.callExpression(this.get(member), args);
        }, optionalCall(member, args) {
          return _core.types.optionalCallExpression(this.get(member), args, true);
        } };
        function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
          const { id } = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
          return _core.template.statement.ast`
    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    });
  `;
        }
        function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
          const { id } = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
          if (!state.availableHelper("classPrivateFieldInitSpec"))
            return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${value},
      })`;
          const helper = state.addHelper("classPrivateFieldInitSpec");
          return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      writable: true,
      value: ${value}
    },
  )`;
        }
        function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, getId, setId, initAdded } = privateName, isAccessor = getId || setId;
          if (!prop.isProperty() && (initAdded || !isAccessor))
            return;
          if (isAccessor)
            return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), _core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      }
    `;
          const value = prop.node.value || prop.scope.buildUndefinedNode();
          return _core.template.statement.ast`
    var ${_core.types.cloneNode(id)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    };
  `;
        }
        function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { methodId, id, getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          if (methodId)
            return _core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `;
          return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      });
    `) : void 0;
        }
        function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          return getId || setId ? function(ref2, prop2, privateNamesMap2, state2) {
            const privateName2 = privateNamesMap2.get(prop2.node.key.id.name), { id, getId: getId2, setId: setId2 } = privateName2;
            if (privateNamesMap2.set(prop2.node.key.id.name, Object.assign({}, privateName2, { initAdded: true })), !state2.availableHelper("classPrivateFieldInitSpec"))
              return _core.template.statement.ast`
      ${id}.set(${ref2}, {
        get: ${getId2 ? getId2.name : prop2.scope.buildUndefinedNode()},
        set: ${setId2 ? setId2.name : prop2.scope.buildUndefinedNode()}
      });
    `;
            const helper = state2.addHelper("classPrivateFieldInitSpec");
            return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      get: ${getId2 ? getId2.name : prop2.scope.buildUndefinedNode()},
      set: ${setId2 ? setId2.name : prop2.scope.buildUndefinedNode()}
    },
  )`;
          }(ref, prop, privateNamesMap, state) : function(ref2, prop2, privateNamesMap2, state2) {
            const privateName2 = privateNamesMap2.get(prop2.node.key.id.name), { id } = privateName2;
            if (!state2.availableHelper("classPrivateMethodInitSpec"))
              return _core.template.statement.ast`${id}.add(${ref2})`;
            const helper = state2.addHelper("classPrivateMethodInitSpec");
            return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)}
  )`;
          }(ref, prop, privateNamesMap, state);
        }
        function buildPublicFieldInitLoose(ref, prop) {
          const { key, computed } = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
          return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));
        }
        function buildPublicFieldInitSpec(ref, prop, state) {
          const { key, computed } = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
          return _core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));
        }
        function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, methodId, getId, setId, initAdded } = privateName;
          if (initAdded)
            return;
          return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      })
    `) : _core.template.statement.ast`
    Object.defineProperty(${ref}, ${id}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${methodId.name}
    });
  `;
        }
        function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), { id, methodId, getId, setId, getterDeclared, setterDeclared, static: isStatic } = privateName, { params, body, generator, async } = prop.node, isGetter = getId && !getterDeclared && params.length === 0, isSetter = setId && !setterDeclared && params.length > 0;
          let declId = methodId;
          return isGetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { getterDeclared: true })), declId = getId) : isSetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { setterDeclared: true })), declId = setId) : isStatic && !privateFieldsAsProperties && (declId = id), _core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async);
        }
        const thisContextVisitor = _core.traverse.visitors.merge([{ ThisExpression(path, state) {
          state.needsClassRef = true, path.replaceWith(_core.types.cloneNode(state.classRef));
        }, MetaProperty(path) {
          const meta = path.get("meta"), property = path.get("property"), { scope } = path;
          meta.isIdentifier({ name: "new" }) && property.isIdentifier({ name: "target" }) && path.replaceWith(scope.buildUndefinedNode());
        } }, _helperEnvironmentVisitor.default]), innerReferencesVisitor = { ReferencedIdentifier(path, state) {
          path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding) && (state.needsClassRef = true, path.node.name = state.classRef.name);
        } };
        function replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
          var _state$classRef;
          const state = { classRef: ref, needsClassRef: false, innerBinding: innerBindingRef };
          return new _helperReplaceSupers.default({ methodPath: path, constantSuper, file, refToPreserve: ref, getSuperRef, getObjectRef: () => (state.needsClassRef = true, isStaticBlock || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier("prototype"))) }).replace(), (isStaticBlock || path.isProperty()) && path.traverse(thisContextVisitor, state), (_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name) && path.traverse(innerReferencesVisitor, state), state.needsClassRef;
        }
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "FEATURES", { enumerable: true, get: function() {
          return _features.FEATURES;
        } }), exports2.createClassFeaturePlugin = function({ name, feature, loose, manipulateOptions, api = { assumption: () => {
        } } }) {
          const setPublicClassFields = api.assumption("setPublicClassFields"), privateFieldsAsProperties = api.assumption("privateFieldsAsProperties"), constantSuper = api.assumption("constantSuper"), noDocumentAll = api.assumption("noDocumentAll");
          if (loose === true) {
            const explicit = [];
            setPublicClassFields !== void 0 && explicit.push('"setPublicClassFields"'), privateFieldsAsProperties !== void 0 && explicit.push('"privateFieldsAsProperties"'), explicit.length !== 0 && console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsProperties": true
	}`);
          }
          return { name, manipulateOptions, pre() {
            (0, _features.enableFeature)(this.file, feature, loose), (!this.file.get(versionKey) || this.file.get(versionKey) < version3) && this.file.set(versionKey, version3);
          }, visitor: { Class(path, state) {
            if (this.file.get(versionKey) !== version3)
              return;
            if (!(0, _features.shouldTransform)(path, this.file))
              return;
            path.isClassDeclaration() && (0, _typescript.assertFieldTransformed)(path);
            const loose2 = (0, _features.isLoose)(this.file, feature);
            let constructor;
            const isDecorated = (0, _decorators.hasDecorators)(path.node), props = [], elements = [], computedPaths = [], privateNames = /* @__PURE__ */ new Set(), body = path.get("body");
            for (const path2 of body.get("body")) {
              if ((path2.isClassProperty() || path2.isClassMethod()) && path2.node.computed && computedPaths.push(path2), path2.isPrivate()) {
                const { name: name2 } = path2.node.key.id, getName = `get ${name2}`, setName = `set ${name2}`;
                if (path2.isClassPrivateMethod()) {
                  if (path2.node.kind === "get") {
                    if (privateNames.has(getName) || privateNames.has(name2) && !privateNames.has(setName))
                      throw path2.buildCodeFrameError("Duplicate private field");
                    privateNames.add(getName).add(name2);
                  } else if (path2.node.kind === "set") {
                    if (privateNames.has(setName) || privateNames.has(name2) && !privateNames.has(getName))
                      throw path2.buildCodeFrameError("Duplicate private field");
                    privateNames.add(setName).add(name2);
                  }
                } else {
                  if (privateNames.has(name2) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name2) && (privateNames.has(getName) || privateNames.has(setName)))
                    throw path2.buildCodeFrameError("Duplicate private field");
                  privateNames.add(name2);
                }
              }
              path2.isClassMethod({ kind: "constructor" }) ? constructor = path2 : (elements.push(path2), (path2.isProperty() || path2.isPrivate() || path2.isStaticBlock != null && path2.isStaticBlock()) && props.push(path2));
            }
            if (!props.length && !isDecorated)
              return;
            const innerBinding = path.node.id;
            let ref;
            !innerBinding || path.isClassExpression() ? ((0, _helperFunctionName.default)(path), ref = path.scope.generateUidIdentifier("class")) : ref = _core.types.cloneNode(path.node.id);
            const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props), privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose2, state);
            let keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;
            (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, { privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose2, noDocumentAll, innerBinding }, state), isDecorated ? (staticNodes = pureStaticNodes = keysNodes = [], { instanceNodes, wrapClass } = (0, _decorators.buildDecoratedClass)(ref, path, elements, this.file)) : (keysNodes = (0, _misc.extractComputedKeys)(ref, path, computedPaths, this.file), { staticNodes, pureStaticNodes, instanceNodes, wrapClass } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, setPublicClassFields != null ? setPublicClassFields : loose2, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose2, constantSuper != null ? constantSuper : loose2, innerBinding)), instanceNodes.length > 0 && (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state2) => {
              if (!isDecorated)
                for (const prop of props)
                  prop.node.static || prop.traverse(referenceVisitor, state2);
            });
            const wrappedPath = wrapClass(path);
            wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]), staticNodes.length > 0 && wrappedPath.insertAfter(staticNodes), pureStaticNodes.length > 0 && wrappedPath.find((parent) => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);
          }, ExportDefaultDeclaration(path) {
            if (this.file.get(versionKey) !== version3)
              return;
            const decl = path.get("declaration");
            decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node) && (decl.node.id ? (0, _helperSplitExportDeclaration.default)(path) : decl.node.type = "ClassExpression");
          } } };
        }, Object.defineProperty(exports2, "enableFeature", { enumerable: true, get: function() {
          return _features.enableFeature;
        } }), Object.defineProperty(exports2, "injectInitialization", { enumerable: true, get: function() {
          return _misc.injectInitialization;
        } });
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/@babel/helper-function-name/lib/index.js"), _helperSplitExportDeclaration = __webpack_require__2("./node_modules/@babel/helper-split-export-declaration/lib/index.js"), _fields = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), _decorators = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), _misc = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), _features = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), _typescript = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const version3 = "7.16.10".split(".").reduce((v, x) => 1e5 * v + +x, 0), versionKey = "@babel/plugin-class-features/version";
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.extractComputedKeys = function(ref, path, computedPaths, file) {
          const declarations = [], state = { classBinding: path.node.id && path.scope.getBinding(path.node.id.name), file };
          for (const computedPath of computedPaths) {
            const computedKey = computedPath.get("key");
            computedKey.isReferencedIdentifier() ? handleClassTDZ(computedKey, state) : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
            const computedNode = computedPath.node;
            if (!computedKey.isConstantExpression()) {
              const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
              path.scope.push({ id: ident, kind: "let" }), declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(ident), computedNode.key))), computedNode.key = _core.types.cloneNode(ident);
            }
          }
          return declarations;
        }, exports2.injectInitialization = function(path, constructor, nodes, renamer) {
          if (!nodes.length)
            return;
          const isDerived = !!path.node.superClass;
          if (!constructor) {
            const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
            isDerived && (newConstructor.params = [_core.types.restElement(_core.types.identifier("args"))], newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)), [constructor] = path.get("body").unshiftContainer("body", newConstructor);
          }
          renamer && renamer(referenceVisitor, { scope: constructor.scope });
          if (isDerived) {
            const bareSupers = [];
            constructor.traverse(findBareSupers, bareSupers);
            let isFirst = true;
            for (const bareSuper of bareSupers)
              isFirst ? (bareSuper.insertAfter(nodes), isFirst = false) : bareSuper.insertAfter(nodes.map((n) => _core.types.cloneNode(n)));
          } else
            constructor.get("body").unshiftContainer("body", nodes);
        };
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/@babel/helper-environment-visitor/lib/index.js");
        const findBareSupers = _core.traverse.visitors.merge([{ Super(path) {
          const { node, parentPath } = path;
          parentPath.isCallExpression({ callee: node }) && this.push(parentPath);
        } }, _helperEnvironmentVisitor.default]), referenceVisitor = { "TSTypeAnnotation|TypeAnnotation"(path) {
          path.skip();
        }, ReferencedIdentifier(path) {
          this.scope.hasOwnBinding(path.node.name) && (this.scope.rename(path.node.name), path.skip());
        } };
        function handleClassTDZ(path, state) {
          if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
            const classNameTDZError = state.file.addHelper("classNameTDZError"), throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);
            path.replaceWith(_core.types.sequenceExpression([throwNode, path.node])), path.skip();
          }
        }
        const classFieldDefinitionEvaluationTDZVisitor = { ReferencedIdentifier: handleClassTDZ };
      }, "./node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.assertFieldTransformed = function(path) {
          if (path.node.declare)
            throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators");
        };
      }, "./node_modules/@babel/helper-environment-visitor/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0, exports2.skipAllButComputedKey = skipAllButComputedKey;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS, staticBlock } = _t;
        function skipAllButComputedKey(path) {
          if (!path.node.computed)
            return void path.skip();
          const keys = VISITOR_KEYS[path.type];
          for (const key of keys)
            key !== "key" && path.skipKey(key);
        }
        var _default = { [(staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation|FunctionDeclaration|FunctionExpression"]: (path) => path.skip(), "Method|ClassProperty"(path) {
          skipAllButComputedKey(path);
        } };
        exports2.default = _default;
      }, "./node_modules/@babel/helper-function-name/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function({ node, parent, scope, id }, localBinding = false, supportUnicodeId = false) {
          if (node.id)
            return;
          if (!isObjectProperty(parent) && !isObjectMethod(parent, { kind: "method" }) || parent.computed && !isLiteral(parent.key)) {
            if (isVariableDeclarator(parent)) {
              if (id = parent.id, isIdentifier(id) && !localBinding) {
                const binding = scope.parent.getBinding(id.name);
                if (binding && binding.constant && scope.getBinding(id.name) === binding)
                  return node.id = cloneNode(id), void (node.id[NOT_LOCAL_BINDING] = true);
              }
            } else if (isAssignmentExpression(parent, { operator: "=" }))
              id = parent.left;
            else if (!id)
              return;
          } else
            id = parent.key;
          let name;
          id && isLiteral(id) ? name = function(id2) {
            if (isNullLiteral(id2))
              return "null";
            if (isRegExpLiteral(id2))
              return `_${id2.pattern}_${id2.flags}`;
            if (isTemplateLiteral(id2))
              return id2.quasis.map((quasi) => quasi.value.raw).join("");
            if (id2.value !== void 0)
              return id2.value + "";
            return "";
          }(id) : id && isIdentifier(id) && (name = id.name);
          if (name === void 0)
            return;
          if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name))
            return;
          name = toBindingIdentifierName(name), (id = identifier(name))[NOT_LOCAL_BINDING] = true;
          return function(state, method, id2, scope2) {
            if (state.selfReference) {
              if (!scope2.hasBinding(id2.name) || scope2.hasGlobal(id2.name)) {
                if (!isFunction(method))
                  return;
                let build = buildPropertyMethodAssignmentWrapper;
                method.generator && (build = buildGeneratorPropertyMethodAssignmentWrapper);
                const template = build({ FUNCTION: method, FUNCTION_ID: id2, FUNCTION_KEY: scope2.generateUidIdentifier(id2.name) }).expression, params = template.callee.body.body[0].params;
                for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++)
                  params.push(scope2.generateUidIdentifier("x"));
                return template;
              }
              scope2.rename(id2.name);
            }
            method.id = id2, scope2.getProgramParent().references[id2.name] = true;
          }(function(node2, name2, scope2) {
            const state = { selfAssignment: false, selfReference: false, outerDeclar: scope2.getBindingIdentifier(name2), references: [], name: name2 }, binding = scope2.getOwnBinding(name2);
            binding ? binding.kind === "param" && (state.selfReference = true) : (state.outerDeclar || scope2.hasGlobal(name2)) && scope2.traverse(node2, visitor, state);
            return state;
          }(node, name, scope), node, id, scope) || node;
        };
        var _helperGetFunctionArity = __webpack_require__2("./node_modules/@babel/helper-get-function-arity/lib/index.js"), _template = __webpack_require__2("./node_modules/@babel/template/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { NOT_LOCAL_BINDING, cloneNode, identifier, isAssignmentExpression, isFunction, isIdentifier, isLiteral, isNullLiteral, isObjectMethod, isObjectProperty, isRegExpLiteral, isTemplateLiteral, isVariableDeclarator, toBindingIdentifierName } = _t, buildPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), visitor = { "ReferencedIdentifier|BindingIdentifier"(path, state) {
          if (path.node.name !== state.name)
            return;
          path.scope.getBindingIdentifier(state.name) === state.outerDeclar && (state.selfReference = true, path.stop());
        } };
      }, "./node_modules/@babel/helper-get-function-arity/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          const params = node.params;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            if (isAssignmentPattern(param) || isRestElement(param))
              return i;
          }
          return params.length;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isAssignmentPattern, isRestElement } = _t;
      }, "./node_modules/@babel/helper-hoist-variables/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path, emit, kind = "var") {
          path.traverse(visitor, { kind, emit });
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { assignmentExpression, expressionStatement, identifier } = _t, visitor = { Scope(path, state) {
          state.kind === "let" && path.skip();
        }, FunctionParent(path) {
          path.skip();
        }, VariableDeclaration(path, state) {
          if (state.kind && path.node.kind !== state.kind)
            return;
          const nodes = [], declarations = path.get("declarations");
          let firstId;
          for (const declar of declarations) {
            firstId = declar.node.id, declar.node.init && nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
            for (const name of Object.keys(declar.getBindingIdentifiers()))
              state.emit(identifier(name), name, declar.node.init !== null);
          }
          path.parentPath.isFor({ left: path.node }) ? path.replaceWith(firstId) : path.replaceWithMultiple(nodes);
        } };
      }, "./node_modules/@babel/helper-member-expression-to-functions/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function _interopNamespace(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var n = /* @__PURE__ */ Object.create(null);
          return e2 && Object.keys(e2).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e2, k);
              Object.defineProperty(n, k, d.get ? d : { enumerable: true, get: function() {
                return e2[k];
              } });
            }
          }), n.default = e2, Object.freeze(n);
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
        var _t__namespace = _interopNamespace(__webpack_require__2("./node_modules/@babel/types/lib/index.js"));
        function willPathCastToBoolean(path) {
          const maybeWrapped = path, { node, parentPath } = maybeWrapped;
          if (parentPath.isLogicalExpression()) {
            const { operator, right } = parentPath.node;
            if (operator === "&&" || operator === "||" || operator === "??" && node === right)
              return willPathCastToBoolean(parentPath);
          }
          if (parentPath.isSequenceExpression()) {
            const { expressions } = parentPath.node;
            return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
          }
          return parentPath.isConditional({ test: node }) || parentPath.isUnaryExpression({ operator: "!" }) || parentPath.isLoop({ test: node });
        }
        const { LOGICAL_OPERATORS, arrowFunctionExpression, assignmentExpression, binaryExpression, booleanLiteral, callExpression, cloneNode, conditionalExpression, identifier, isMemberExpression, isOptionalCallExpression, isOptionalMemberExpression, isUpdateExpression, logicalExpression, memberExpression, nullLiteral, numericLiteral, optionalCallExpression, optionalMemberExpression, sequenceExpression, unaryExpression } = _t__namespace;
        class AssignmentMemoiser {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(key) {
            return this._map.has(key);
          }
          get(key) {
            if (!this.has(key))
              return;
            const record = this._map.get(key), { value } = record;
            return record.count--, record.count === 0 ? assignmentExpression("=", value, key) : value;
          }
          set(key, value, count) {
            return this._map.set(key, { count, value });
          }
        }
        function toNonOptional(path, base) {
          const { node } = path;
          if (isOptionalMemberExpression(node))
            return memberExpression(base, node.property, node.computed);
          if (path.isOptionalCallExpression()) {
            const callee = path.get("callee");
            if (path.node.optional && callee.isOptionalMemberExpression()) {
              const { object } = callee.node, context = path.scope.maybeGenerateMemoised(object) || object;
              return callee.get("object").replaceWith(assignmentExpression("=", context, object)), callExpression(memberExpression(base, identifier("call")), [context, ...path.node.arguments]);
            }
            return callExpression(base, path.node.arguments);
          }
          return path.node;
        }
        const handle = { memoise() {
        }, handle(member, noDocumentAll) {
          const { node, parent, parentPath, scope } = member;
          if (member.isOptionalMemberExpression()) {
            if (function(path) {
              for (; path && !path.isProgram(); ) {
                const { parentPath: parentPath2, container, listKey } = path, parentNode = parentPath2.node;
                if (listKey) {
                  if (container !== parentNode[listKey])
                    return true;
                } else if (container !== parentNode)
                  return true;
                path = parentPath2;
              }
              return false;
            }(member))
              return;
            const endPath = member.find(({ node: node2, parent: parent2 }) => isOptionalMemberExpression(parent2) ? parent2.optional || parent2.object !== node2 : !isOptionalCallExpression(parent2) || (node2 !== member.node && parent2.optional || parent2.callee !== node2));
            if (scope.path.isPattern())
              return void endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
            const willEndPathCastToBoolean = willPathCastToBoolean(endPath), rootParentPath = endPath.parentPath;
            if (rootParentPath.isUpdateExpression({ argument: node }) || rootParentPath.isAssignmentExpression({ left: node }))
              throw member.buildCodeFrameError("can't handle assignment");
            const isDeleteOperation = rootParentPath.isUnaryExpression({ operator: "delete" });
            if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName())
              throw member.buildCodeFrameError("can't delete a private class element");
            let startingOptional = member;
            for (; ; )
              if (startingOptional.isOptionalMemberExpression()) {
                if (startingOptional.node.optional)
                  break;
                startingOptional = startingOptional.get("object");
              } else {
                if (!startingOptional.isOptionalCallExpression())
                  throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
                if (startingOptional.node.optional)
                  break;
                startingOptional = startingOptional.get("callee");
              }
            const startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee", startingNode = startingOptional.node[startingProp], baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode), baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode, parentIsOptionalCall = parentPath.isOptionalCallExpression({ callee: node }), isOptionalCall = (parent2) => parentIsOptionalCall, parentIsCall = parentPath.isCallExpression({ callee: node });
            startingOptional.replaceWith(toNonOptional(startingOptional, baseRef)), isOptionalCall() ? parent.optional ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.replaceWith(this.call(member, parent.arguments)) : parentIsCall ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member));
            let context, regular = member.node;
            for (let current = member; current !== endPath; ) {
              const parentPath2 = current.parentPath;
              if (parentPath2 === endPath && isOptionalCall() && parent.optional) {
                regular = parentPath2.node;
                break;
              }
              regular = toNonOptional(parentPath2, regular), current = parentPath2;
            }
            const endParentPath = endPath.parentPath;
            if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({ callee: endPath.node, optional: true })) {
              const { object } = regular;
              context = member.scope.maybeGenerateMemoised(object), context && (regular.object = assignmentExpression("=", context, object));
            }
            let replacementPath = endPath;
            isDeleteOperation && (replacementPath = endParentPath, regular = endParentPath.node);
            const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
            if (willEndPathCastToBoolean) {
              let nonNullishCheck;
              nonNullishCheck = noDocumentAll ? binaryExpression("!=", baseMemoised, nullLiteral()) : logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
            } else {
              let nullishCheck;
              nullishCheck = noDocumentAll ? binaryExpression("==", baseMemoised, nullLiteral()) : logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode())), replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
            }
            if (context) {
              const endParent = endParentPath.node;
              endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context), ...endParent.arguments], false));
            }
          } else if (isUpdateExpression(parent, { argument: node })) {
            if (this.simpleSet)
              return void member.replaceWith(this.simpleSet(member));
            const { operator, prefix } = parent;
            this.memoise(member, 2);
            const value = binaryExpression(operator[0], unaryExpression("+", this.get(member)), numericLiteral(1));
            if (prefix)
              parentPath.replaceWith(this.set(member, value));
            else {
              const { scope: scope2 } = member, ref = scope2.generateUidIdentifierBasedOnNode(node);
              scope2.push({ id: ref }), value.left = assignmentExpression("=", cloneNode(ref), value.left), parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref)]));
            }
          } else if (parentPath.isAssignmentExpression({ left: node })) {
            if (this.simpleSet)
              return void member.replaceWith(this.simpleSet(member));
            const { operator, right: value } = parentPath.node;
            if (operator === "=")
              parentPath.replaceWith(this.set(member, value));
            else {
              const operatorTrunc = operator.slice(0, -1);
              LOGICAL_OPERATORS.includes(operatorTrunc) ? (this.memoise(member, 1), parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value)))) : (this.memoise(member, 2), parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), value))));
            }
          } else {
            if (!parentPath.isCallExpression({ callee: node }))
              return parentPath.isOptionalCallExpression({ callee: node }) ? scope.path.isPattern() ? void parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), [])) : void parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments)) : void (parentPath.isForXStatement({ left: node }) || parentPath.isObjectProperty({ value: node }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({ left: node }) && parentPath.parentPath.isObjectProperty({ value: parent }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({ left: node }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement() ? member.replaceWith(this.destructureSet(member)) : parentPath.isTaggedTemplateExpression() ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member)));
            parentPath.replaceWith(this.call(member, parentPath.node.arguments));
          }
        } };
        exports2.default = function(path, visitor, state) {
          path.traverse(visitor, Object.assign({}, handle, state, { memoiser: new AssignmentMemoiser() }));
        };
      }, "./node_modules/@babel/helper-module-imports/lib/import-builder.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { callExpression, cloneNode, expressionStatement, identifier, importDeclaration, importDefaultSpecifier, importNamespaceSpecifier, importSpecifier, memberExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;
        exports2.default = class {
          constructor(importedSource, scope, hub) {
            this._statements = [], this._resultName = null, this._scope = null, this._hub = null, this._importedSource = void 0, this._scope = scope, this._hub = hub, this._importedSource = importedSource;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(importDeclaration([], stringLiteral(this._importedSource))), this;
          }
          require() {
            return this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)]))), this;
          }
          namespace(name = "namespace") {
            const local = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
            return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importNamespaceSpecifier(local)], this._resultName = cloneNode(local), this;
          }
          default(name) {
            name = this._scope.generateUidIdentifier(name);
            const statement = this._statements[this._statements.length - 1];
            return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importDefaultSpecifier(name)], this._resultName = cloneNode(name), this;
          }
          named(name, importName) {
            if (importName === "default")
              return this.default(name);
            name = this._scope.generateUidIdentifier(name);
            const statement = this._statements[this._statements.length - 1];
            return _assert(statement.type === "ImportDeclaration"), _assert(statement.specifiers.length === 0), statement.specifiers = [importSpecifier(name, identifier(importName))], this._resultName = cloneNode(name), this;
          }
          var(name) {
            name = this._scope.generateUidIdentifier(name);
            let statement = this._statements[this._statements.length - 1];
            return statement.type !== "ExpressionStatement" && (_assert(this._resultName), statement = expressionStatement(this._resultName), this._statements.push(statement)), this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(name, statement.expression)]), this._resultName = cloneNode(name), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop(callee) {
            const statement = this._statements[this._statements.length - 1];
            return statement.type === "ExpressionStatement" ? statement.expression = callExpression(callee, [statement.expression]) : statement.type === "VariableDeclaration" ? (_assert(statement.declarations.length === 1), statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init])) : _assert.fail("Unexpected type."), this;
          }
          prop(name) {
            const statement = this._statements[this._statements.length - 1];
            return statement.type === "ExpressionStatement" ? statement.expression = memberExpression(statement.expression, identifier(name)) : statement.type === "VariableDeclaration" ? (_assert(statement.declarations.length === 1), statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name))) : _assert.fail("Unexpected type:" + statement.type), this;
          }
          read(name) {
            this._resultName = memberExpression(this._resultName, identifier(name));
          }
        };
      }, "./node_modules/@babel/helper-module-imports/lib/import-injector.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _importBuilder = __webpack_require__2("./node_modules/@babel/helper-module-imports/lib/import-builder.js"), _isModule = __webpack_require__2("./node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { numericLiteral, sequenceExpression } = _t;
        exports2.default = class {
          constructor(path, importedSource, opts) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
            const programPath = path.find((p) => p.isProgram());
            this._programPath = programPath, this._programScope = programPath.scope, this._hub = programPath.hub, this._defaultOpts = this._applyDefaults(importedSource, opts, true);
          }
          addDefault(importedSourceIn, opts) {
            return this.addNamed("default", importedSourceIn, opts);
          }
          addNamed(importName, importedSourceIn, opts) {
            return _assert(typeof importName == "string"), this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
          }
          addNamespace(importedSourceIn, opts) {
            return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
          }
          addSideEffect(importedSourceIn, opts) {
            return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
          }
          _applyDefaults(importedSource, opts, isInit = false) {
            const optsList = [];
            typeof importedSource == "string" ? (optsList.push({ importedSource }), optsList.push(opts)) : (_assert(!opts, "Unexpected secondary arguments."), optsList.push(importedSource));
            const newOpts = Object.assign({}, this._defaultOpts);
            for (const opts2 of optsList)
              opts2 && (Object.keys(newOpts).forEach((key) => {
                opts2[key] !== void 0 && (newOpts[key] = opts2[key]);
              }), isInit || (opts2.nameHint !== void 0 && (newOpts.nameHint = opts2.nameHint), opts2.blockHoist !== void 0 && (newOpts.blockHoist = opts2.blockHoist)));
            return newOpts;
          }
          _generateImport(opts, importName) {
            const isDefault = importName === "default", isNamed = !!importName && !isDefault, isNamespace = importName === null, { importedSource, importedType, importedInterop, importingInterop, ensureLiveReference, ensureNoContext, nameHint, importPosition, blockHoist } = opts;
            let name = nameHint || importName;
            const isMod = (0, _isModule.default)(this._programPath), isModuleForNode = isMod && importingInterop === "node", isModuleForBabel = isMod && importingInterop === "babel";
            if (importPosition === "after" && !isMod)
              throw new Error('"importPosition": "after" is only supported in modules');
            const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
            if (importedType === "es6") {
              if (!isModuleForNode && !isModuleForBabel)
                throw new Error("Cannot import an ES6 module from CommonJS");
              builder.import(), isNamespace ? builder.namespace(nameHint || importedSource) : (isDefault || isNamed) && builder.named(name, importName);
            } else {
              if (importedType !== "commonjs")
                throw new Error(`Unexpected interopType "${importedType}"`);
              if (importedInterop === "babel")
                if (isModuleForNode) {
                  name = name !== "default" ? name : importedSource;
                  const es6Default = `${importedSource}$es6Default`;
                  builder.import(), isNamespace ? builder.default(es6Default).var(name || importedSource).wildcardInterop() : isDefault ? ensureLiveReference ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default") : builder.default(es6Default).var(name).defaultInterop().prop(importName) : isNamed && builder.default(es6Default).read(importName);
                } else
                  isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource).wildcardInterop() : (isDefault || isNamed) && ensureLiveReference ? isDefault ? (name = name !== "default" ? name : importedSource, builder.var(name).read(importName), builder.defaultInterop()) : builder.var(importedSource).read(importName) : isDefault ? builder.var(name).defaultInterop().prop(importName) : isNamed && builder.var(name).prop(importName));
              else if (importedInterop === "compiled")
                isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : (isDefault || isNamed) && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : (isDefault || isNamed) && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName).var(name)));
              else {
                if (importedInterop !== "uncompiled")
                  throw new Error(`Unknown importedInterop "${importedInterop}".`);
                if (isDefault && ensureLiveReference)
                  throw new Error("No live reference for commonjs default");
                isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.named(name, importName)) : (builder.require(), isNamespace ? builder.var(name || importedSource) : isDefault ? builder.var(name) : isNamed && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName)));
              }
            }
            const { statements, resultName } = builder.done();
            return this._insertStatements(statements, importPosition, blockHoist), (isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier" ? sequenceExpression([numericLiteral(0), resultName]) : resultName;
          }
          _insertStatements(statements, importPosition = "before", blockHoist = 3) {
            const body = this._programPath.get("body");
            if (importPosition === "after") {
              for (let i = body.length - 1; i >= 0; i--)
                if (body[i].isImportDeclaration())
                  return void body[i].insertAfter(statements);
            } else {
              statements.forEach((node) => {
                node._blockHoist = blockHoist;
              });
              const targetPath = body.find((p) => {
                const val = p.node._blockHoist;
                return Number.isFinite(val) && val < 4;
              });
              if (targetPath)
                return void targetPath.insertBefore(statements);
            }
            this._programPath.unshiftContainer("body", statements);
          }
        };
      }, "./node_modules/@babel/helper-module-imports/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "ImportInjector", { enumerable: true, get: function() {
          return _importInjector.default;
        } }), exports2.addDefault = function(path, importedSource, opts) {
          return new _importInjector.default(path).addDefault(importedSource, opts);
        }, exports2.addNamed = function(path, name, importedSource, opts) {
          return new _importInjector.default(path).addNamed(name, importedSource, opts);
        }, exports2.addNamespace = function(path, importedSource, opts) {
          return new _importInjector.default(path).addNamespace(importedSource, opts);
        }, exports2.addSideEffect = function(path, importedSource, opts) {
          return new _importInjector.default(path).addSideEffect(importedSource, opts);
        }, Object.defineProperty(exports2, "isModule", { enumerable: true, get: function() {
          return _isModule.default;
        } });
        var _importInjector = __webpack_require__2("./node_modules/@babel/helper-module-imports/lib/import-injector.js"), _isModule = __webpack_require__2("./node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/@babel/helper-module-imports/lib/is-module.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path) {
          const { sourceType } = path.node;
          if (sourceType !== "module" && sourceType !== "script")
            throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);
          return path.node.sourceType === "module";
        };
      }, "./node_modules/@babel/helper-module-transforms/lib/get-module-name.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = getModuleName;
        {
          const originalGetModuleName = getModuleName;
          exports2.default = getModuleName = function(rootOpts, pluginOpts) {
            var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
            return originalGetModuleName(rootOpts, { moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId, moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds, getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId, moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot });
          };
        }
        function getModuleName(rootOpts, pluginOpts) {
          const { filename, filenameRelative = filename, sourceRoot = pluginOpts.moduleRoot } = rootOpts, { moduleId, moduleIds = !!moduleId, getModuleId, moduleRoot = sourceRoot } = pluginOpts;
          if (!moduleIds)
            return null;
          if (moduleId != null && !getModuleId)
            return moduleId;
          let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
          if (filenameRelative) {
            const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
            moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
          }
          return moduleName = moduleName.replace(/\\/g, "/"), getModuleId && getModuleId(moduleName) || moduleName;
        }
      }, "./node_modules/@babel/helper-module-transforms/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.buildNamespaceInitStatements = function(metadata, sourceMetadata, constantReexports = false) {
          const statements = [];
          let srcNamespace = identifier(sourceMetadata.name);
          sourceMetadata.lazy && (srcNamespace = callExpression(srcNamespace, []));
          for (const localName of sourceMetadata.importsNamespace)
            localName !== sourceMetadata.name && statements.push(_template.default.statement`var NAME = SOURCE;`({ NAME: localName, SOURCE: cloneNode(srcNamespace) }));
          constantReexports && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));
          for (const exportName of sourceMetadata.reexportNamespace)
            statements.push((sourceMetadata.lazy ? _template.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({ EXPORTS: metadata.exportName, NAME: exportName, NAMESPACE: cloneNode(srcNamespace) }));
          if (sourceMetadata.reexportAll) {
            const statement = function(metadata2, namespace, constantReexports2) {
              return (constantReexports2 ? _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: namespace, EXPORTS: metadata2.exportName, VERIFY_NAME_LIST: metadata2.exportNameListName ? _template.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: metadata2.exportNameListName }) : null });
            }(metadata, cloneNode(srcNamespace), constantReexports);
            statement.loc = sourceMetadata.reexportAll.loc, statements.push(statement);
          }
          return statements;
        }, exports2.ensureStatementsHoisted = function(statements) {
          statements.forEach((header) => {
            header._blockHoist = 3;
          });
        }, Object.defineProperty(exports2, "getModuleName", { enumerable: true, get: function() {
          return _getModuleName.default;
        } }), Object.defineProperty(exports2, "hasExports", { enumerable: true, get: function() {
          return _normalizeAndLoadMetadata.hasExports;
        } }), Object.defineProperty(exports2, "isModule", { enumerable: true, get: function() {
          return _helperModuleImports.isModule;
        } }), Object.defineProperty(exports2, "isSideEffectImport", { enumerable: true, get: function() {
          return _normalizeAndLoadMetadata.isSideEffectImport;
        } }), exports2.rewriteModuleStatementsAndPrepareHeader = function(path, { loose, exportName, strict, allowTopLevelThis, strictMode, noInterop, importInterop = noInterop ? "none" : "babel", lazy, esNamespaceOnly, constantReexports = loose, enumerableModuleMeta = loose, noIncompleteNsImportDetection }) {
          (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop), _assert((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script"), path.node.sourceType = "script";
          const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, { importInterop, initializeReexports: constantReexports, lazy, esNamespaceOnly });
          allowTopLevelThis || (0, _rewriteThis.default)(path);
          if ((0, _rewriteLiveReferences.default)(path, meta), strictMode !== false) {
            const hasStrict = path.node.directives.some((directive2) => directive2.value.value === "use strict");
            hasStrict || path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
          }
          const headers = [];
          (0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict && headers.push(function(metadata, enumerableModuleMeta2 = false) {
            return (enumerableModuleMeta2 ? _template.default.statement`
        EXPORTS.__esModule = true;
      ` : _template.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: metadata.exportName });
          }(meta, enumerableModuleMeta));
          const nameList = function(programPath, metadata) {
            const exportedVars = /* @__PURE__ */ Object.create(null);
            for (const data of metadata.local.values())
              for (const name2 of data.names)
                exportedVars[name2] = true;
            let hasReexport = false;
            for (const data of metadata.source.values()) {
              for (const exportName2 of data.reexports.keys())
                exportedVars[exportName2] = true;
              for (const exportName2 of data.reexportNamespace)
                exportedVars[exportName2] = true;
              hasReexport = hasReexport || !!data.reexportAll;
            }
            if (!hasReexport || Object.keys(exportedVars).length === 0)
              return null;
            const name = programPath.scope.generateUidIdentifier("exportNames");
            return delete exportedVars.default, { name: name.name, statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))]) };
          }(path, meta);
          nameList && (meta.exportNameListName = nameList.name, headers.push(nameList.statement));
          return headers.push(...function(programPath, metadata, constantReexports2 = false, noIncompleteNsImportDetection2 = false) {
            const initStatements = [];
            for (const [localName, data] of metadata.local)
              if (data.kind === "import")
                ;
              else if (data.kind === "hoisted")
                initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);
              else if (!noIncompleteNsImportDetection2)
                for (const exportName2 of data.names)
                  initStatements.push([exportName2, null]);
            for (const data of metadata.source.values()) {
              if (!constantReexports2) {
                const reexportsStatements = buildReexportsFromMeta(metadata, data, false), reexports = [...data.reexports.keys()];
                for (let i = 0; i < reexportsStatements.length; i++)
                  initStatements.push([reexports[i], reexportsStatements[i]]);
              }
              if (!noIncompleteNsImportDetection2)
                for (const exportName2 of data.reexportNamespace)
                  initStatements.push([exportName2, null]);
            }
            initStatements.sort((a, b) => a[0] > b[0] ? 1 : -1);
            const results = [];
            if (noIncompleteNsImportDetection2)
              for (const [, initStatement] of initStatements)
                results.push(initStatement);
            else {
              const chunkSize = 100;
              for (let i = 0, uninitializedExportNames = []; i < initStatements.length; i += chunkSize) {
                for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
                  const [exportName2, initStatement] = initStatements[i + j];
                  initStatement !== null ? (uninitializedExportNames.length > 0 && (results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode())), uninitializedExportNames = []), results.push(initStatement)) : uninitializedExportNames.push(exportName2);
                }
                uninitializedExportNames.length > 0 && results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
              }
            }
            return results;
          }(path, meta, constantReexports, noIncompleteNsImportDetection)), { meta, headers };
        }, Object.defineProperty(exports2, "rewriteThis", { enumerable: true, get: function() {
          return _rewriteThis.default;
        } }), exports2.wrapInterop = function(programPath, expr, type) {
          if (type === "none")
            return null;
          if (type === "node-namespace")
            return callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral(true)]);
          if (type === "node-default")
            return null;
          let helper;
          if (type === "default")
            helper = "interopRequireDefault";
          else {
            if (type !== "namespace")
              throw new Error(`Unknown interop: ${type}`);
            helper = "interopRequireWildcard";
          }
          return callExpression(programPath.hub.addHelper(helper), [expr]);
        };
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _template = __webpack_require__2("./node_modules/@babel/template/lib/index.js"), _helperModuleImports = __webpack_require__2("./node_modules/@babel/helper-module-imports/lib/index.js"), _rewriteThis = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), _rewriteLiveReferences = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), _normalizeAndLoadMetadata = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), _getModuleName = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        const { booleanLiteral, callExpression, cloneNode, directive, directiveLiteral, expressionStatement, identifier, isIdentifier, memberExpression, stringLiteral, valueToNode, variableDeclaration, variableDeclarator } = _t;
        const ReexportTemplate = { constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: _template.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: _template.default.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` }, buildReexportsFromMeta = (meta, metadata, constantReexports) => {
          const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name), { stringSpecifiers } = meta;
          return Array.from(metadata.reexports, ([exportName, importName]) => {
            let NAMESPACE_IMPORT = cloneNode(namespace);
            importName === "default" && metadata.interop === "node-default" || (NAMESPACE_IMPORT = stringSpecifiers.has(importName) ? memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true) : memberExpression(NAMESPACE_IMPORT, identifier(importName)));
            const astNodes = { EXPORTS: meta.exportName, EXPORT_NAME: exportName, NAMESPACE_IMPORT };
            return constantReexports || isIdentifier(NAMESPACE_IMPORT) ? stringSpecifiers.has(exportName) ? ReexportTemplate.constantComputed(astNodes) : ReexportTemplate.constant(astNodes) : ReexportTemplate.spec(astNodes);
          });
        };
        const InitTemplate = { computed: _template.default.expression`EXPORTS["NAME"] = VALUE`, default: _template.default.expression`EXPORTS.NAME = VALUE` };
        function buildInitStatement(metadata, exportNames, initExpr) {
          const { stringSpecifiers, exportName: EXPORTS } = metadata;
          return expressionStatement(exportNames.reduce((acc, exportName) => {
            const params = { EXPORTS, NAME: exportName, VALUE: acc };
            return stringSpecifiers.has(exportName) ? InitTemplate.computed(params) : InitTemplate.default(params);
          }, initExpr));
        }
      }, "./node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(programPath, exportName, { importInterop, initializeReexports = false, lazy = false, esNamespaceOnly = false }) {
          exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);
          const stringSpecifiers = /* @__PURE__ */ new Set();
          !function(programPath2) {
            programPath2.get("body").forEach((child) => {
              child.isExportDefaultDeclaration() && (0, _helperSplitExportDeclaration.default)(child);
            });
          }(programPath);
          const { local, source, hasExports } = function(programPath2, { lazy: lazy2, initializeReexports: initializeReexports2 }, stringSpecifiers2) {
            const localData = function(programPath3, initializeReexports3, stringSpecifiers3) {
              const bindingKindLookup = /* @__PURE__ */ new Map();
              programPath3.get("body").forEach((child) => {
                let kind;
                if (child.isImportDeclaration())
                  kind = "import";
                else {
                  if (child.isExportDefaultDeclaration() && (child = child.get("declaration")), child.isExportNamedDeclaration()) {
                    if (child.node.declaration)
                      child = child.get("declaration");
                    else if (initializeReexports3 && child.node.source && child.get("source").isStringLiteral())
                      return void child.get("specifiers").forEach((spec) => {
                        assertExportSpecifier(spec), bindingKindLookup.set(spec.get("local").node.name, "block");
                      });
                  }
                  if (child.isFunctionDeclaration())
                    kind = "hoisted";
                  else if (child.isClassDeclaration())
                    kind = "block";
                  else if (child.isVariableDeclaration({ kind: "var" }))
                    kind = "var";
                  else {
                    if (!child.isVariableDeclaration())
                      return;
                    kind = "block";
                  }
                }
                Object.keys(child.getOuterBindingIdentifiers()).forEach((name) => {
                  bindingKindLookup.set(name, kind);
                });
              });
              const localMetadata = /* @__PURE__ */ new Map(), getLocalMetadata = (idPath) => {
                const localName = idPath.node.name;
                let metadata = localMetadata.get(localName);
                if (!metadata) {
                  const kind = bindingKindLookup.get(localName);
                  if (kind === void 0)
                    throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
                  metadata = { names: [], kind }, localMetadata.set(localName, metadata);
                }
                return metadata;
              };
              return programPath3.get("body").forEach((child) => {
                if (!child.isExportNamedDeclaration() || !initializeReexports3 && child.node.source) {
                  if (child.isExportDefaultDeclaration()) {
                    const declaration = child.get("declaration");
                    if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
                      throw declaration.buildCodeFrameError("Unexpected default expression export.");
                    getLocalMetadata(declaration.get("id")).names.push("default");
                  }
                } else if (child.node.declaration) {
                  const declaration = child.get("declaration"), ids = declaration.getOuterBindingIdentifierPaths();
                  Object.keys(ids).forEach((name) => {
                    if (name === "__esModule")
                      throw declaration.buildCodeFrameError('Illegal export "__esModule".');
                    getLocalMetadata(ids[name]).names.push(name);
                  });
                } else
                  child.get("specifiers").forEach((spec) => {
                    const local2 = spec.get("local"), exported = spec.get("exported"), localMetadata2 = getLocalMetadata(local2), exportName2 = getExportSpecifierName(exported, stringSpecifiers3);
                    if (exportName2 === "__esModule")
                      throw exported.buildCodeFrameError('Illegal export "__esModule".');
                    localMetadata2.names.push(exportName2);
                  });
              }), localMetadata;
            }(programPath2, initializeReexports2, stringSpecifiers2), sourceData = /* @__PURE__ */ new Map(), getData = (sourceNode) => {
              const source2 = sourceNode.value;
              let data = sourceData.get(source2);
              return data || (data = { name: programPath2.scope.generateUidIdentifier((0, _path.basename)(source2, (0, _path.extname)(source2))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, lazy: false, source: source2 }, sourceData.set(source2, data)), data;
            };
            let hasExports2 = false;
            programPath2.get("body").forEach((child) => {
              if (child.isImportDeclaration()) {
                const data = getData(child.node.source);
                data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
                  if (spec.isImportDefaultSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data.imports.set(localName, "default");
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data.reexports.set(name, "default");
                    }));
                  } else if (spec.isImportNamespaceSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data.importsNamespace.add(localName);
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data.reexportNamespace.add(name);
                    }));
                  } else if (spec.isImportSpecifier()) {
                    const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers2), localName = spec.get("local").node.name;
                    data.imports.set(localName, importName);
                    const reexport = localData.get(localName);
                    reexport && (localData.delete(localName), reexport.names.forEach((name) => {
                      data.reexports.set(name, importName);
                    }));
                  }
                });
              } else if (child.isExportAllDeclaration()) {
                hasExports2 = true;
                const data = getData(child.node.source);
                data.loc || (data.loc = child.node.loc), data.reexportAll = { loc: child.node.loc };
              } else if (child.isExportNamedDeclaration() && child.node.source) {
                hasExports2 = true;
                const data = getData(child.node.source);
                data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec) => {
                  assertExportSpecifier(spec);
                  const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers2), exportName2 = getExportSpecifierName(spec.get("exported"), stringSpecifiers2);
                  if (data.reexports.set(exportName2, importName), exportName2 === "__esModule")
                    throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else
                (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) && (hasExports2 = true);
            });
            for (const metadata of sourceData.values()) {
              let needsDefault = false, needsNamed = false;
              metadata.importsNamespace.size > 0 && (needsDefault = true, needsNamed = true), metadata.reexportAll && (needsNamed = true);
              for (const importName of metadata.imports.values())
                importName === "default" ? needsDefault = true : needsNamed = true;
              for (const importName of metadata.reexports.values())
                importName === "default" ? needsDefault = true : needsNamed = true;
              needsDefault && needsNamed ? metadata.interop = "namespace" : needsDefault && (metadata.interop = "default");
            }
            for (const [source2, metadata] of sourceData)
              if (lazy2 !== false && !isSideEffectImport(metadata) && !metadata.reexportAll)
                if (lazy2 === true)
                  metadata.lazy = !/\./.test(source2);
                else if (Array.isArray(lazy2))
                  metadata.lazy = lazy2.indexOf(source2) !== -1;
                else {
                  if (typeof lazy2 != "function")
                    throw new Error(".lazy must be a boolean, string array, or function");
                  metadata.lazy = lazy2(source2);
                }
            return { hasExports: hasExports2, local: localData, source: sourceData };
          }(programPath, { initializeReexports, lazy }, stringSpecifiers);
          !function(programPath2) {
            programPath2.get("body").forEach((child) => {
              if (child.isImportDeclaration())
                child.remove();
              else if (child.isExportNamedDeclaration())
                child.node.declaration ? (child.node.declaration._blockHoist = child.node._blockHoist, child.replaceWith(child.node.declaration)) : child.remove();
              else if (child.isExportDefaultDeclaration()) {
                const declaration = child.get("declaration");
                if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
                  throw declaration.buildCodeFrameError("Unexpected default expression export.");
                declaration._blockHoist = child.node._blockHoist, child.replaceWith(declaration);
              } else
                child.isExportAllDeclaration() && child.remove();
            });
          }(programPath);
          for (const [, metadata] of source) {
            metadata.importsNamespace.size > 0 && (metadata.name = metadata.importsNamespace.values().next().value);
            const resolvedInterop = resolveImportInterop(importInterop, metadata.source);
            resolvedInterop === "none" ? metadata.interop = "none" : resolvedInterop === "node" && metadata.interop === "namespace" ? metadata.interop = "node-namespace" : resolvedInterop === "node" && metadata.interop === "default" ? metadata.interop = "node-default" : esNamespaceOnly && metadata.interop === "namespace" && (metadata.interop = "default");
          }
          return { exportName, exportNameListName: null, hasExports, local, source, stringSpecifiers };
        }, exports2.hasExports = function(metadata) {
          return metadata.hasExports;
        }, exports2.isSideEffectImport = isSideEffectImport, exports2.validateImportInteropOption = validateImportInteropOption;
        var _path = __webpack_require__2("path"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/index.js"), _helperSplitExportDeclaration = __webpack_require__2("./node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function isSideEffectImport(source) {
          return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
        }
        function validateImportInteropOption(importInterop) {
          if (typeof importInterop != "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node")
            throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
          return importInterop;
        }
        function resolveImportInterop(importInterop, source) {
          return typeof importInterop == "function" ? validateImportInteropOption(importInterop(source)) : importInterop;
        }
        function getExportSpecifierName(path, stringSpecifiers) {
          if (path.isIdentifier())
            return path.node.name;
          if (path.isStringLiteral()) {
            const stringValue = path.node.value;
            return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue) || stringSpecifiers.add(stringValue), stringValue;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
        }
        function assertExportSpecifier(path) {
          if (!path.isExportSpecifier())
            throw path.isExportNamespaceSpecifier() ? path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.") : path.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(programPath, metadata) {
          const imported = /* @__PURE__ */ new Map(), exported = /* @__PURE__ */ new Map(), requeueInParent = (path) => {
            programPath.requeue(path);
          };
          for (const [source, data] of metadata.source) {
            for (const [localName, importName] of data.imports)
              imported.set(localName, [source, importName, null]);
            for (const localName of data.importsNamespace)
              imported.set(localName, [source, null, localName]);
          }
          for (const [local, data] of metadata.local) {
            let exportMeta = exported.get(local);
            exportMeta || (exportMeta = [], exported.set(local, exportMeta)), exportMeta.push(...data.names);
          }
          const rewriteBindingInitVisitorState = { metadata, requeueInParent, scope: programPath.scope, exported };
          programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState), (0, _helperSimpleAccess.default)(programPath, /* @__PURE__ */ new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));
          const rewriteReferencesVisitorState = { seen: /* @__PURE__ */ new WeakSet(), metadata, requeueInParent, scope: programPath.scope, imported, exported, buildImportReference: ([source, importName, localName], identNode) => {
            const meta = metadata.source.get(source);
            if (localName)
              return meta.lazy && (identNode = callExpression(identNode, [])), identNode;
            let namespace = identifier(meta.name);
            if (meta.lazy && (namespace = callExpression(namespace, [])), importName === "default" && meta.interop === "node-default")
              return namespace;
            const computed = metadata.stringSpecifiers.has(importName);
            return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
          } };
          programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
        };
        var _assert = __webpack_require__2("assert"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _template = __webpack_require__2("./node_modules/@babel/template/lib/index.js"), _helperSimpleAccess = __webpack_require__2("./node_modules/@babel/helper-simple-access/lib/index.js");
        const { assignmentExpression, callExpression, cloneNode, expressionStatement, getOuterBindingIdentifiers, identifier, isMemberExpression, isVariableDeclaration, jsxIdentifier, jsxMemberExpression, memberExpression, numericLiteral, sequenceExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;
        const rewriteBindingInitVisitor = { Scope(path) {
          path.skip();
        }, ClassDeclaration(path) {
          const { requeueInParent, exported, metadata } = this, { id } = path.node;
          if (!id)
            throw new Error("Expected class to have a name");
          const localName = id.name, exportNames = exported.get(localName) || [];
          if (exportNames.length > 0) {
            const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
            statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
          }
        }, VariableDeclaration(path) {
          const { requeueInParent, exported, metadata } = this;
          Object.keys(path.getOuterBindingIdentifiers()).forEach((localName) => {
            const exportNames = exported.get(localName) || [];
            if (exportNames.length > 0) {
              const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
              statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
            }
          });
        } }, buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => (exportNames || []).reduce((expr, exportName) => {
          const { stringSpecifiers } = metadata, computed = stringSpecifiers.has(exportName);
          return assignmentExpression("=", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
        }, localExpr), buildImportThrow = (localName) => _template.default.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `, rewriteReferencesVisitor = { ReferencedIdentifier(path) {
          const { seen, buildImportReference, scope, imported, requeueInParent } = this;
          if (seen.has(path.node))
            return;
          seen.add(path.node);
          const localName = path.node.name, importData = imported.get(localName);
          if (importData) {
            if (function(path2) {
              do {
                switch (path2.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return true;
                  case "ExportSpecifier":
                    return path2.parentPath.parent.exportKind === "type";
                  default:
                    if (path2.parentPath.isStatement() || path2.parentPath.isExpression())
                      return false;
                }
              } while (path2 = path2.parentPath);
            }(path))
              throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const localBinding = path.scope.getBinding(localName);
            if (scope.getBinding(localName) !== localBinding)
              return;
            const ref = buildImportReference(importData, path.node);
            if (ref.loc = path.node.loc, (path.parentPath.isCallExpression({ callee: path.node }) || path.parentPath.isOptionalCallExpression({ callee: path.node }) || path.parentPath.isTaggedTemplateExpression({ tag: path.node })) && isMemberExpression(ref))
              path.replaceWith(sequenceExpression([numericLiteral(0), ref]));
            else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
              const { object, property } = ref;
              path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
            } else
              path.replaceWith(ref);
            requeueInParent(path), path.skip();
          }
        }, AssignmentExpression: { exit(path) {
          const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
          if (seen.has(path.node))
            return;
          seen.add(path.node);
          const left = path.get("left");
          if (!left.isMemberExpression())
            if (left.isIdentifier()) {
              const localName = left.node.name;
              if (scope.getBinding(localName) !== path.scope.getBinding(localName))
                return;
              const exportedNames = exported.get(localName), importData = imported.get(localName);
              if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
                _assert(path.node.operator === "=", "Path was not simplified");
                const assignment = path.node;
                importData && (assignment.left = buildImportReference(importData, assignment.left), assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)])), path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment)), requeueInParent(path);
              }
            } else {
              const ids = left.getOuterBindingIdentifiers(), programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path.scope.getBinding(localName)), id = programScopeIds.find((localName) => imported.has(localName));
              id && (path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]));
              const items = [];
              if (programScopeIds.forEach((localName) => {
                const exportedNames = exported.get(localName) || [];
                exportedNames.length > 0 && items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));
              }), items.length > 0) {
                let node = sequenceExpression(items);
                path.parentPath.isExpressionStatement() && (node = expressionStatement(node), node._blockHoist = path.parentPath.node._blockHoist);
                requeueInParent(path.insertAfter(node)[0]);
              }
            }
        } }, "ForOfStatement|ForInStatement"(path) {
          const { scope, node } = path, { left } = node, { exported, imported, scope: programScope } = this;
          if (!isVariableDeclaration(left)) {
            let importConstViolationName, didTransformExport = false;
            const loopBodyScope = path.get("body").scope;
            for (const name of Object.keys(getOuterBindingIdentifiers(left)))
              programScope.getBinding(name) === scope.getBinding(name) && (exported.has(name) && (didTransformExport = true, loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name)), imported.has(name) && !importConstViolationName && (importConstViolationName = name));
            if (!didTransformExport && !importConstViolationName)
              return;
            path.ensureBlock();
            const bodyPath = path.get("body"), newLoopId = scope.generateUidIdentifierBasedOnNode(left);
            path.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))])), scope.registerDeclaration(path.get("left")), didTransformExport && bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId))), importConstViolationName && bodyPath.unshiftContainer("body", expressionStatement(buildImportThrow(importConstViolationName)));
          }
        } };
      }, "./node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(programPath) {
          (0, _traverse.default)(programPath.node, Object.assign({}, rewriteThisVisitor, { noScope: true }));
        };
        var _helperEnvironmentVisitor = __webpack_require__2("./node_modules/@babel/helper-environment-visitor/lib/index.js"), _traverse = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { numericLiteral, unaryExpression } = _t;
        const rewriteThisVisitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { ThisExpression(path) {
          path.replaceWith(unaryExpression("void", numericLiteral(0), true));
        } }]);
      }, "./node_modules/@babel/helper-optimise-call-expression/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(callee, thisNode, args, optional) {
          return args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, { name: "arguments" }) ? optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false) : callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]) : optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode, ...args], false) : callExpression(memberExpression(callee, identifier("call")), [thisNode, ...args]);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { callExpression, identifier, isIdentifier, isSpreadElement, memberExpression, optionalCallExpression, optionalMemberExpression } = _t;
      }, "./node_modules/@babel/helper-plugin-utils/lib/index.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.declare = function(builder) {
          return (api, options, dirname3) => {
            var _clonedApi2;
            let clonedApi;
            for (const name of Object.keys(apiPolyfills)) {
              var _clonedApi;
              api[name] || (clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api), clonedApi[name] = apiPolyfills[name](clonedApi));
            }
            return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname3);
          };
        };
        const apiPolyfills = { assertVersion: (api) => (range) => {
          !function(range2, version3) {
            if (typeof range2 == "number") {
              if (!Number.isInteger(range2))
                throw new Error("Expected string or integer value.");
              range2 = `^${range2}.0.0-0`;
            }
            if (typeof range2 != "string")
              throw new Error("Expected string or integer value.");
            const limit = Error.stackTraceLimit;
            typeof limit == "number" && limit < 25 && (Error.stackTraceLimit = 25);
            let err;
            err = version3.slice(0, 2) === "7." ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version3}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${range2}", but was loaded with "${version3}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
            typeof limit == "number" && (Error.stackTraceLimit = limit);
            throw Object.assign(err, { code: "BABEL_VERSION_UNSUPPORTED", version: version3, range: range2 });
          }(range, api.version);
        }, targets: () => () => ({}), assumption: () => () => {
        } };
        function copyApiObject(api) {
          let proto = null;
          return typeof api.version == "string" && /^7\./.test(api.version) && (proto = Object.getPrototypeOf(api), !proto || has(proto, "version") && has(proto, "transform") && has(proto, "template") && has(proto, "types") || (proto = null)), Object.assign({}, proto, api);
        }
        function has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
      }, "./node_modules/@babel/helper-replace-supers/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0, Object.defineProperty(exports2, "environmentVisitor", { enumerable: true, get: function() {
          return _helperEnvironmentVisitor.default;
        } }), Object.defineProperty(exports2, "skipAllButComputedKey", { enumerable: true, get: function() {
          return _helperEnvironmentVisitor.skipAllButComputedKey;
        } });
        var _traverse = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _helperMemberExpressionToFunctions = __webpack_require__2("./node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), _helperOptimiseCallExpression = __webpack_require__2("./node_modules/@babel/helper-optimise-call-expression/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/@babel/helper-environment-visitor/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { assignmentExpression, booleanLiteral, callExpression, cloneNode, identifier, memberExpression, sequenceExpression, stringLiteral, thisExpression } = _t;
        function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
          objectRef = cloneNode(objectRef);
          const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
          return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
        }
        const visitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { Super(path, state) {
          const { node, parentPath } = path;
          parentPath.isMemberExpression({ object: node }) && state.handle(parentPath);
        } }]), unshadowSuperBindingVisitor = _traverse.default.visitors.merge([_helperEnvironmentVisitor.default, { Scopable(path, { refName }) {
          const binding = path.scope.getOwnBinding(refName);
          binding && binding.identifier.name === refName && path.scope.rename(refName);
        } }]), specHandlers = { memoise(superMember, count) {
          const { scope, node } = superMember, { computed, property } = node;
          if (!computed)
            return;
          const memo = scope.maybeGenerateMemoised(property);
          memo && this.memoiser.set(property, memo, count);
        }, prop(superMember) {
          const { computed, property } = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : computed ? cloneNode(property) : stringLiteral(property.name);
        }, get(superMember) {
          return this._get(superMember, this._getThisRefs());
        }, _get(superMember, thisRefs) {
          const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);
        }, _getThisRefs() {
          if (!this.isDerivedConstructor)
            return { this: thisExpression() };
          const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
          return { memo: assignmentExpression("=", thisRef, thisExpression()), this: cloneNode(thisRef) };
        }, set(superMember, value) {
          const thisRefs = this._getThisRefs(), proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode())]);
        }, destructureSet(superMember) {
          throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);
        }, optionalCall(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);
        } }, looseHandlers = Object.assign({}, specHandlers, { prop(superMember) {
          const { property } = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : cloneNode(property);
        }, get(superMember) {
          const { isStatic, getSuperRef } = this, { computed } = superMember.node, prop = this.prop(superMember);
          let object;
          var _getSuperRef, _getSuperRef2;
          isStatic ? object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype")) : object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
          return memberExpression(object, prop, computed);
        }, set(superMember, value) {
          const { computed } = superMember.node, prop = this.prop(superMember);
          return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
        }, destructureSet(superMember) {
          const { computed } = superMember.node, prop = this.prop(superMember);
          return memberExpression(thisExpression(), prop, computed);
        }, call(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);
        }, optionalCall(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);
        } });
        exports2.default = class {
          constructor(opts) {
            var _opts$constantSuper;
            const path = opts.methodPath;
            this.methodPath = path, this.isDerivedConstructor = path.isClassMethod({ kind: "constructor" }) && !!opts.superRef, this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock()), this.isPrivateMethod = path.isPrivate() && path.isMethod(), this.file = opts.file, this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose, this.opts = opts;
          }
          getObjectRef() {
            return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? cloneNode(this.opts.superRef) : this.opts.getSuperRef ? cloneNode(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            this.opts.refToPreserve && this.methodPath.traverse(unshadowSuperBindingVisitor, { refName: this.opts.refToPreserve.name });
            const handler = this.constantSuper ? looseHandlers : specHandlers;
            (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: handler.get }, handler));
          }
        };
      }, "./node_modules/@babel/helper-simple-access/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path, bindingNames) {
          path.traverse(simpleAssignmentVisitor, { scope: path.scope, bindingNames, seen: /* @__PURE__ */ new WeakSet() });
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { LOGICAL_OPERATORS, assignmentExpression, binaryExpression, cloneNode, identifier, logicalExpression, numericLiteral, sequenceExpression, unaryExpression } = _t;
        const simpleAssignmentVisitor = { UpdateExpression: { exit(path) {
          const { scope, bindingNames } = this, arg = path.get("argument");
          if (!arg.isIdentifier())
            return;
          const localName = arg.node.name;
          if (bindingNames.has(localName) && scope.getBinding(localName) === path.scope.getBinding(localName))
            if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
              const operator = path.node.operator == "++" ? "+=" : "-=";
              path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
            } else if (path.node.prefix)
              path.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
            else {
              const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old"), varName = old.name;
              path.scope.push({ id: old });
              const binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));
              path.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
            }
        } }, AssignmentExpression: { exit(path) {
          const { scope, seen, bindingNames } = this;
          if (path.node.operator === "=")
            return;
          if (seen.has(path.node))
            return;
          seen.add(path.node);
          const left = path.get("left");
          if (!left.isIdentifier())
            return;
          const localName = left.node.name;
          if (!bindingNames.has(localName))
            return;
          if (scope.getBinding(localName) !== path.scope.getBinding(localName))
            return;
          const operator = path.node.operator.slice(0, -1);
          LOGICAL_OPERATORS.includes(operator) ? path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression("=", cloneNode(path.node.left), path.node.right))) : (path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right), path.node.operator = "=");
        } } };
      }, "./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.isTransparentExprWrapper = isTransparentExprWrapper, exports2.skipTransparentExprWrapperNodes = function(node) {
          for (; isTransparentExprWrapper(node); )
            node = node.expression;
          return node;
        }, exports2.skipTransparentExprWrappers = function(path) {
          for (; isTransparentExprWrapper(path.node); )
            path = path.get("expression");
          return path;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression, isTSAsExpression, isTSNonNullExpression, isTSTypeAssertion, isTypeCastExpression } = _t;
        function isTransparentExprWrapper(node) {
          return isTSAsExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
        }
      }, "./node_modules/@babel/helper-split-export-declaration/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(exportDeclaration) {
          if (!exportDeclaration.isExportDeclaration())
            throw new Error("Only export declarations can be split.");
          const isDefault = exportDeclaration.isExportDefaultDeclaration(), declaration = exportDeclaration.get("declaration"), isClassDeclaration = declaration.isClassDeclaration();
          if (isDefault) {
            const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration, scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
            let id = declaration.node.id, needBindingRegistration = false;
            id || (needBindingRegistration = true, id = scope.generateUidIdentifier("default"), (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) && (declaration.node.id = cloneNode(id)));
            const updatedDeclaration = standaloneDeclaration ? declaration : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]), updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
            return exportDeclaration.insertAfter(updatedExportDeclaration), exportDeclaration.replaceWith(updatedDeclaration), needBindingRegistration && scope.registerDeclaration(exportDeclaration), exportDeclaration;
          }
          if (exportDeclaration.get("specifiers").length > 0)
            throw new Error("It doesn't make sense to split exported specifiers.");
          const bindingIdentifiers = declaration.getOuterBindingIdentifiers(), specifiers = Object.keys(bindingIdentifiers).map((name) => exportSpecifier(identifier(name), identifier(name))), aliasDeclar = exportNamedDeclaration(null, specifiers);
          return exportDeclaration.insertAfter(aliasDeclar), exportDeclaration.replaceWith(declaration.node), exportDeclaration;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { cloneNode, exportNamedDeclaration, exportSpecifier, identifier, variableDeclaration, variableDeclarator } = _t;
      }, "./node_modules/@babel/helper-validator-identifier/lib/identifier.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.isIdentifierChar = isIdentifierChar, exports2.isIdentifierName = function(name) {
          let isFirst = true;
          for (let i = 0; i < name.length; i++) {
            let cp = name.charCodeAt(i);
            if ((64512 & cp) == 55296 && i + 1 < name.length) {
              const trail = name.charCodeAt(++i);
              (64512 & trail) == 56320 && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
            }
            if (isFirst) {
              if (isFirst = false, !isIdentifierStart(cp))
                return false;
            } else if (!isIdentifierChar(cp))
              return false;
          }
          return !isFirst;
        }, exports2.isIdentifierStart = isIdentifierStart;
        let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(code, set) {
          let pos = 65536;
          for (let i = 0, length = set.length; i < length; i += 2) {
            if (pos += set[i], pos > code)
              return false;
            if (pos += set[i + 1], pos >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart(code) {
          return code < 65 ? code === 36 : code <= 90 || (code < 97 ? code === 95 : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
        }
        function isIdentifierChar(code) {
          return code < 48 ? code === 36 : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? code === 95 : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
        }
      }, "./node_modules/@babel/helper-validator-identifier/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "isIdentifierChar", { enumerable: true, get: function() {
          return _identifier.isIdentifierChar;
        } }), Object.defineProperty(exports2, "isIdentifierName", { enumerable: true, get: function() {
          return _identifier.isIdentifierName;
        } }), Object.defineProperty(exports2, "isIdentifierStart", { enumerable: true, get: function() {
          return _identifier.isIdentifierStart;
        } }), Object.defineProperty(exports2, "isKeyword", { enumerable: true, get: function() {
          return _keyword.isKeyword;
        } }), Object.defineProperty(exports2, "isReservedWord", { enumerable: true, get: function() {
          return _keyword.isReservedWord;
        } }), Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(exports2, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictBindReservedWord;
        } }), Object.defineProperty(exports2, "isStrictReservedWord", { enumerable: true, get: function() {
          return _keyword.isStrictReservedWord;
        } });
        var _identifier = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/identifier.js"), _keyword = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/@babel/helper-validator-identifier/lib/keyword.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.isKeyword = function(word) {
          return keywords.has(word);
        }, exports2.isReservedWord = isReservedWord, exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, exports2.isStrictBindReservedWord = function(word, inModule) {
          return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }, exports2.isStrictReservedWord = isStrictReservedWord;
        const reservedWords_strict = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], reservedWords_strictBind = ["eval", "arguments"], keywords = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
        function isReservedWord(word, inModule) {
          return inModule && word === "await" || word === "enum";
        }
        function isStrictReservedWord(word, inModule) {
          return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
          return reservedWordsStrictBindSet.has(word);
        }
      }, "./node_modules/@babel/helpers/lib/helpers-generated.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _template = __webpack_require__2("./node_modules/@babel/template/lib/index.js");
        function helper(minVersion, source) {
          return Object.freeze({ minVersion, ast: () => _template.default.program.ast(source) });
        }
        var _default = Object.freeze({ asyncIterator: helper("7.15.9", 'export default function _asyncIterator(iterable){var method,async,sync,retry=2;for("undefined"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async="@@asyncIterator",sync="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var done=r.done;return Promise.resolve(r.value).then((function(value){return{value:value,done:done}}))}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments))},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments))}},new AsyncFromSyncIterator(s)}'), jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(type,props,key,children){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var defaultProps=type&&type.defaultProps,childrenLength=arguments.length-3;if(props||0===childrenLength||(props={children:void 0}),1===childrenLength)props.children=children;else if(childrenLength>1){for(var childArray=new Array(childrenLength),i=0;i<childrenLength;i++)childArray[i]=arguments[i+3];props.children=childArray}if(props&&defaultProps)for(var propName in defaultProps)void 0===props[propName]&&(props[propName]=defaultProps[propName]);else props||(props=defaultProps||{});return{$$typeof:REACT_ELEMENT_TYPE,type:type,key:void 0===key?null:""+key,ref:null,props:props,_owner:null}}'), objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}export default function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}'), typeof: helper("7.0.0-beta.0", 'export default function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}'), wrapRegExp: helper("7.2.6", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(re,groups){return new BabelRegExp(re,void 0,groups)};var _super=RegExp.prototype,_groups=new WeakMap;function BabelRegExp(re,flags,groups){var _this=new RegExp(re,flags);return _groups.set(_this,groups||_groups.get(re)),setPrototypeOf(_this,BabelRegExp.prototype)}function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce((function(groups,name){return groups[name]=result[g[name]],groups}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);return result&&(result.groups=buildGroups(result,this)),result},BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if("string"==typeof substitution){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\\$<([^>]+)>/g,(function(_,name){return"$"+groups[name]})))}if("function"==typeof substitution){var _this=this;return _super[Symbol.replace].call(this,str,(function(){var args=arguments;return"object"!=typeof args[args.length-1]&&(args=[].slice.call(args)).push(buildGroups(args,_this)),substitution.apply(this,args)}))}return _super[Symbol.replace].call(this,str,substitution)},_wrapRegExp.apply(this,arguments)}') });
        exports2.default = _default;
      }, "./node_modules/@babel/helpers/lib/helpers.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _template = __webpack_require__2("./node_modules/@babel/template/lib/index.js"), _helpersGenerated = __webpack_require__2("./node_modules/@babel/helpers/lib/helpers-generated.js");
        const helpers = Object.assign({ __proto__: null }, _helpersGenerated.default);
        var _default = helpers;
        exports2.default = _default;
        const helper = (minVersion) => (tpl) => ({ minVersion, ast: () => _template.default.program.ast(tpl) });
        helpers.AwaitValue = helper("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`, helpers.AsyncGenerator = helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null,
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg)
        var value = result.value;
        var wrappedAwait = value instanceof AwaitValue;

        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function (arg) {
            if (wrappedAwait) {
              resume(key === "return" ? "return" : "next", arg);
              return
            }

            settle(result.done ? "return" : "normal", arg);
          },
          function (err) { resume("throw", err); });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({ value: value, done: true });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({ value: value, done: false });
          break;
      }

      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    // Hide "return" method if generator return is not supported
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
`, helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function _awaitAsyncGenerator(value) {
    return new AwaitValue(value);
  }
`, helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")`
  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {}, waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) { resolve(inner[key](value)); });
      return { done: false, value: awaitWrap(value) };
    };

    iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; };

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }
      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }
        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }
        return pump("return", value);
      };
    }

    return iter;
  }
`, helpers.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, helpers.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, helpers.createClass = helper("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`, helpers.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`, helpers.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, helpers.defineProperty = helper("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, helpers.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, helpers.objectSpread = helper("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`, helpers.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, helpers.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, helpers.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, helpers.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`, helpers.isNativeReflectConstruct = helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`, helpers.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`, helpers.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`, helpers.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, helpers.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, helpers.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, helpers.interopRequireWildcard = helper("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`, helpers.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`, helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, helpers.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, helpers.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, helpers.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`, helpers.createSuper = helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `, helpers.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, helpers.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`, helpers.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }
`, helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, helpers.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, helpers.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, helpers.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, helpers.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, helpers.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, helpers.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, helpers.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, helpers.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, helpers.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, helpers.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, helpers.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, helpers.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, helpers.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, helpers.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, helpers.iterableToArrayLimit = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliance is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step

    var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`, helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`, helpers.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, helpers.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, helpers.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, helpers.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, helpers.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, helpers.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, helpers.toPrimitive = helper("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`, helpers.toPropertyKey = helper("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`, helpers.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, helpers.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, helpers.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, helpers.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, helpers.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, helpers.classExtractFieldDescriptor = helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, helpers.classStaticPrivateMethodGet = helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, helpers.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, helpers.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, helpers.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, helpers.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, helpers.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, helpers.classCheckPrivateStaticAccess = helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, helpers.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, helpers.decorate = helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, helpers.classPrivateMethodGet = helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, helpers.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`, helpers.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`, helpers.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`, helpers.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
      }, "./node_modules/@babel/helpers/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0, exports2.ensure = function(name, newFileClass) {
          fileClass || (fileClass = newFileClass);
          loadHelper(name);
        }, exports2.get = get, exports2.getDependencies = function(name) {
          return Array.from(loadHelper(name).dependencies.values());
        }, exports2.list = void 0, exports2.minVersion = function(name) {
          return loadHelper(name).minVersion();
        };
        var _traverse = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _helpers = __webpack_require__2("./node_modules/@babel/helpers/lib/helpers.js");
        const { assignmentExpression, cloneNode, expressionStatement, file: t_file, identifier, variableDeclaration, variableDeclarator } = _t;
        function makePath(path) {
          const parts = [];
          for (; path.parentPath; path = path.parentPath)
            parts.push(path.key), path.inList && parts.push(path.listKey);
          return parts.reverse().join(".");
        }
        let fileClass;
        const helperData = /* @__PURE__ */ Object.create(null);
        function loadHelper(name) {
          if (!helperData[name]) {
            const helper = _helpers.default[name];
            if (!helper)
              throw Object.assign(new ReferenceError(`Unknown helper ${name}`), { code: "BABEL_HELPER_UNKNOWN", helper: name });
            const fn = () => {
              const file = { ast: t_file(helper.ast()) };
              return fileClass ? new fileClass({ filename: `babel-helper://${name}` }, file) : file;
            }, metadata = function(file) {
              const globals = /* @__PURE__ */ new Set(), localBindingNames = /* @__PURE__ */ new Set(), dependencies = /* @__PURE__ */ new Map();
              let exportName, exportPath;
              const exportBindingAssignments = [], importPaths = [], importBindingsReferences = [], dependencyVisitor = { ImportDeclaration(child) {
                const name2 = child.node.source.value;
                if (!_helpers.default[name2])
                  throw child.buildCodeFrameError(`Unknown helper ${name2}`);
                if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier())
                  throw child.buildCodeFrameError("Helpers can only import a default value");
                const bindingIdentifier = child.node.specifiers[0].local;
                dependencies.set(bindingIdentifier, name2), importPaths.push(makePath(child));
              }, ExportDefaultDeclaration(child) {
                const decl = child.get("declaration");
                if (decl.isFunctionDeclaration()) {
                  if (!decl.node.id)
                    throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
                  exportName = decl.node.id.name;
                }
                exportPath = makePath(child);
              }, ExportAllDeclaration(child) {
                throw child.buildCodeFrameError("Helpers can only export default");
              }, ExportNamedDeclaration(child) {
                throw child.buildCodeFrameError("Helpers can only export default");
              }, Statement(child) {
                child.isModuleDeclaration() || child.skip();
              } }, referenceVisitor = { Program(path) {
                const bindings = path.scope.getAllBindings();
                Object.keys(bindings).forEach((name2) => {
                  name2 !== exportName && (dependencies.has(bindings[name2].identifier) || localBindingNames.add(name2));
                });
              }, ReferencedIdentifier(child) {
                const name2 = child.node.name, binding = child.scope.getBinding(name2);
                binding ? dependencies.has(binding.identifier) && importBindingsReferences.push(makePath(child)) : globals.add(name2);
              }, AssignmentExpression(child) {
                const left = child.get("left");
                if (!(exportName in left.getBindingIdentifiers()))
                  return;
                if (!left.isIdentifier())
                  throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
                const binding = child.scope.getBinding(exportName);
                binding != null && binding.scope.path.isProgram() && exportBindingAssignments.push(makePath(child));
              } };
              if ((0, _traverse.default)(file.ast, dependencyVisitor, file.scope), (0, _traverse.default)(file.ast, referenceVisitor, file.scope), !exportPath)
                throw new Error("Helpers must default-export something.");
              return exportBindingAssignments.reverse(), { globals: Array.from(globals), localBindingNames: Array.from(localBindingNames), dependencies, exportBindingAssignments, exportPath, exportName, importBindingsReferences, importPaths };
            }(fn());
            helperData[name] = { build(getDependency, id, localBindings) {
              const file = fn();
              return function(file2, metadata2, id2, localBindings2, getDependency2) {
                if (localBindings2 && !id2)
                  throw new Error("Unexpected local bindings for module-based helpers.");
                if (!id2)
                  return;
                const { localBindingNames, dependencies, exportBindingAssignments, exportPath, exportName, importBindingsReferences, importPaths } = metadata2, dependenciesRefs = {};
                dependencies.forEach((name2, id3) => {
                  dependenciesRefs[id3.name] = typeof getDependency2 == "function" && getDependency2(name2) || id3;
                });
                const toRename = {}, bindings = new Set(localBindings2 || []);
                localBindingNames.forEach((name2) => {
                  let newName = name2;
                  for (; bindings.has(newName); )
                    newName = "_" + newName;
                  newName !== name2 && (toRename[name2] = newName);
                }), id2.type === "Identifier" && exportName !== id2.name && (toRename[exportName] = id2.name);
                const visitor = { Program(path) {
                  const exp = path.get(exportPath), imps = importPaths.map((p) => path.get(p)), impsBindingRefs = importBindingsReferences.map((p) => path.get(p)), decl = exp.get("declaration");
                  if (id2.type === "Identifier")
                    decl.isFunctionDeclaration() ? exp.replaceWith(decl) : exp.replaceWith(variableDeclaration("var", [variableDeclarator(id2, decl.node)]));
                  else {
                    if (id2.type !== "MemberExpression")
                      throw new Error("Unexpected helper format.");
                    decl.isFunctionDeclaration() ? (exportBindingAssignments.forEach((assignPath) => {
                      const assign = path.get(assignPath);
                      assign.replaceWith(assignmentExpression("=", id2, assign.node));
                    }), exp.replaceWith(decl), path.pushContainer("body", expressionStatement(assignmentExpression("=", id2, identifier(exportName))))) : exp.replaceWith(expressionStatement(assignmentExpression("=", id2, decl.node)));
                  }
                  Object.keys(toRename).forEach((name2) => {
                    path.scope.rename(name2, toRename[name2]);
                  });
                  for (const path2 of imps)
                    path2.remove();
                  for (const path2 of impsBindingRefs) {
                    const node = cloneNode(dependenciesRefs[path2.node.name]);
                    path2.replaceWith(node);
                  }
                  path.stop();
                } };
                (0, _traverse.default)(file2.ast, visitor, file2.scope);
              }(file, metadata, id, localBindings, getDependency), { nodes: file.ast.program.body, globals: metadata.globals };
            }, minVersion: () => helper.minVersion, dependencies: metadata.dependencies };
          }
          return helperData[name];
        }
        function get(name, getDependency, id, localBindings) {
          return loadHelper(name).build(getDependency, id, localBindings);
        }
        const list = Object.keys(_helpers.default).map((name) => name.replace(/^_/, ""));
        exports2.list = list;
        var _default = get;
        exports2.default = _default;
      }, "./node_modules/@babel/parser/lib/index.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        class Position {
          constructor(line, col, index) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = line, this.column = col, indexes.set(this, index);
          }
        }
        class SourceLocation {
          constructor(start, end) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = start, this.end = end;
          }
        }
        const indexes = /* @__PURE__ */ new WeakMap();
        function createPositionWithColumnOffset(position, columnOffset) {
          const { line, column } = position;
          return new Position(line, column + columnOffset, indexes.get(position) + columnOffset);
        }
        function setTrailingComments(node, comments) {
          node.trailingComments === void 0 ? node.trailingComments = comments : node.trailingComments.unshift(...comments);
        }
        function setInnerComments(node, comments) {
          node.innerComments === void 0 ? node.innerComments = comments : node.innerComments.unshift(...comments);
        }
        function adjustInnerComments(node, elements, commentWS) {
          let lastElement = null, i = elements.length;
          for (; lastElement === null && i > 0; )
            lastElement = elements[--i];
          lastElement === null || lastElement.start > commentWS.start ? setInnerComments(node, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
        }
        const ErrorCodes = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), ErrorMessages = makeErrorTemplates({ AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, ErrorCodes.SyntaxError), SourceTypeModuleErrorMessages = makeErrorTemplates({ ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'` }, ErrorCodes.SourceTypeModuleError);
        function keepReasonCodeCompat(reasonCode, syntaxPlugin) {
          return syntaxPlugin === "flow" && reasonCode === "PatternIsOptional" ? "OptionalBindingPattern" : reasonCode;
        }
        function makeErrorTemplates(messages, code, syntaxPlugin) {
          const templates = {};
          return Object.keys(messages).forEach((reasonCode) => {
            templates[reasonCode] = Object.freeze({ code, reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin), template: messages[reasonCode] });
          }), Object.freeze(templates);
        }
        class TokContext {
          constructor(token, preserveSpace) {
            this.token = void 0, this.preserveSpace = void 0, this.token = token, this.preserveSpace = !!preserveSpace;
          }
        }
        const types = { brace: new TokContext("{"), j_oTag: new TokContext("<tag"), j_cTag: new TokContext("</tag"), j_expr: new TokContext("<tag>...</tag>", true) };
        types.template = new TokContext("`", true);
        class ExportedTokenType {
          constructor(label, conf = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.rightAssociative = !!conf.rightAssociative, this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, this.binop = conf.binop != null ? conf.binop : null, this.updateContext = null;
          }
        }
        const keywords$1 = /* @__PURE__ */ new Map();
        function createKeyword(name, options = {}) {
          options.keyword = name;
          const token = createToken(name, options);
          return keywords$1.set(name, token), token;
        }
        function createBinop(name, binop) {
          return createToken(name, { beforeExpr: true, binop });
        }
        let tokenTypeCounter = -1;
        const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
        function createToken(name, options = {}) {
          var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
          return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1), tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null && _options$beforeExpr), tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null && _options$startsExpr), tokenPrefixes.push((_options$prefix = options.prefix) != null && _options$prefix), tokenTypes.push(new ExportedTokenType(name, options)), tokenTypeCounter;
        }
        function createKeywordLike(name, options = {}) {
          var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
          return ++tokenTypeCounter, keywords$1.set(name, tokenTypeCounter), tokenLabels.push(name), tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1), tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null && _options$beforeExpr2), tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null && _options$startsExpr2), tokenPrefixes.push((_options$prefix2 = options.prefix) != null && _options$prefix2), tokenTypes.push(new ExportedTokenType("name", options)), tokenTypeCounter;
        }
        const tt = { bracketL: createToken("[", { beforeExpr: true, startsExpr: true }), bracketHashL: createToken("#[", { beforeExpr: true, startsExpr: true }), bracketBarL: createToken("[|", { beforeExpr: true, startsExpr: true }), bracketR: createToken("]"), bracketBarR: createToken("|]"), braceL: createToken("{", { beforeExpr: true, startsExpr: true }), braceBarL: createToken("{|", { beforeExpr: true, startsExpr: true }), braceHashL: createToken("#{", { beforeExpr: true, startsExpr: true }), braceR: createToken("}", { beforeExpr: true }), braceBarR: createToken("|}"), parenL: createToken("(", { beforeExpr: true, startsExpr: true }), parenR: createToken(")"), comma: createToken(",", { beforeExpr: true }), semi: createToken(";", { beforeExpr: true }), colon: createToken(":", { beforeExpr: true }), doubleColon: createToken("::", { beforeExpr: true }), dot: createToken("."), question: createToken("?", { beforeExpr: true }), questionDot: createToken("?."), arrow: createToken("=>", { beforeExpr: true }), template: createToken("template"), ellipsis: createToken("...", { beforeExpr: true }), backQuote: createToken("`", { startsExpr: true }), dollarBraceL: createToken("${", { beforeExpr: true, startsExpr: true }), templateTail: createToken("...`", { startsExpr: true }), templateNonTail: createToken("...${", { beforeExpr: true, startsExpr: true }), at: createToken("@"), hash: createToken("#", { startsExpr: true }), interpreterDirective: createToken("#!..."), eq: createToken("=", { beforeExpr: true, isAssign: true }), assign: createToken("_=", { beforeExpr: true, isAssign: true }), slashAssign: createToken("_=", { beforeExpr: true, isAssign: true }), xorAssign: createToken("_=", { beforeExpr: true, isAssign: true }), moduloAssign: createToken("_=", { beforeExpr: true, isAssign: true }), incDec: createToken("++/--", { prefix: true, postfix: true, startsExpr: true }), bang: createToken("!", { beforeExpr: true, prefix: true, startsExpr: true }), tilde: createToken("~", { beforeExpr: true, prefix: true, startsExpr: true }), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), lt: createBinop("</>/<=/>=", 7), gt: createBinop("</>/<=/>=", 7), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), plusMin: createToken("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: createToken("%", { binop: 10, startsExpr: true }), star: createToken("*", { binop: 10 }), slash: createBinop("/", 10), exponent: createToken("**", { beforeExpr: true, binop: 11, rightAssociative: true }), _in: createKeyword("in", { beforeExpr: true, binop: 7 }), _instanceof: createKeyword("instanceof", { beforeExpr: true, binop: 7 }), _break: createKeyword("break"), _case: createKeyword("case", { beforeExpr: true }), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", { beforeExpr: true }), _else: createKeyword("else", { beforeExpr: true }), _finally: createKeyword("finally"), _function: createKeyword("function", { startsExpr: true }), _if: createKeyword("if"), _return: createKeyword("return", { beforeExpr: true }), _switch: createKeyword("switch"), _throw: createKeyword("throw", { beforeExpr: true, prefix: true, startsExpr: true }), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _with: createKeyword("with"), _new: createKeyword("new", { beforeExpr: true, startsExpr: true }), _this: createKeyword("this", { startsExpr: true }), _super: createKeyword("super", { startsExpr: true }), _class: createKeyword("class", { startsExpr: true }), _extends: createKeyword("extends", { beforeExpr: true }), _export: createKeyword("export"), _import: createKeyword("import", { startsExpr: true }), _null: createKeyword("null", { startsExpr: true }), _true: createKeyword("true", { startsExpr: true }), _false: createKeyword("false", { startsExpr: true }), _typeof: createKeyword("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: createKeyword("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: createKeyword("delete", { beforeExpr: true, prefix: true, startsExpr: true }), _do: createKeyword("do", { isLoop: true, beforeExpr: true }), _for: createKeyword("for", { isLoop: true }), _while: createKeyword("while", { isLoop: true }), _as: createKeywordLike("as", { startsExpr: true }), _assert: createKeywordLike("assert", { startsExpr: true }), _async: createKeywordLike("async", { startsExpr: true }), _await: createKeywordLike("await", { startsExpr: true }), _from: createKeywordLike("from", { startsExpr: true }), _get: createKeywordLike("get", { startsExpr: true }), _let: createKeywordLike("let", { startsExpr: true }), _meta: createKeywordLike("meta", { startsExpr: true }), _of: createKeywordLike("of", { startsExpr: true }), _sent: createKeywordLike("sent", { startsExpr: true }), _set: createKeywordLike("set", { startsExpr: true }), _static: createKeywordLike("static", { startsExpr: true }), _yield: createKeywordLike("yield", { startsExpr: true }), _asserts: createKeywordLike("asserts", { startsExpr: true }), _checks: createKeywordLike("checks", { startsExpr: true }), _exports: createKeywordLike("exports", { startsExpr: true }), _global: createKeywordLike("global", { startsExpr: true }), _implements: createKeywordLike("implements", { startsExpr: true }), _intrinsic: createKeywordLike("intrinsic", { startsExpr: true }), _infer: createKeywordLike("infer", { startsExpr: true }), _is: createKeywordLike("is", { startsExpr: true }), _mixins: createKeywordLike("mixins", { startsExpr: true }), _proto: createKeywordLike("proto", { startsExpr: true }), _require: createKeywordLike("require", { startsExpr: true }), _keyof: createKeywordLike("keyof", { startsExpr: true }), _readonly: createKeywordLike("readonly", { startsExpr: true }), _unique: createKeywordLike("unique", { startsExpr: true }), _abstract: createKeywordLike("abstract", { startsExpr: true }), _declare: createKeywordLike("declare", { startsExpr: true }), _enum: createKeywordLike("enum", { startsExpr: true }), _module: createKeywordLike("module", { startsExpr: true }), _namespace: createKeywordLike("namespace", { startsExpr: true }), _interface: createKeywordLike("interface", { startsExpr: true }), _type: createKeywordLike("type", { startsExpr: true }), _opaque: createKeywordLike("opaque", { startsExpr: true }), name: createToken("name", { startsExpr: true }), string: createToken("string", { startsExpr: true }), num: createToken("num", { startsExpr: true }), bigint: createToken("bigint", { startsExpr: true }), decimal: createToken("decimal", { startsExpr: true }), regexp: createToken("regexp", { startsExpr: true }), privateName: createToken("#name", { startsExpr: true }), eof: createToken("eof"), jsxName: createToken("jsxName"), jsxText: createToken("jsxText", { beforeExpr: true }), jsxTagStart: createToken("jsxTagStart", { startsExpr: true }), jsxTagEnd: createToken("jsxTagEnd"), placeholder: createToken("%%", { startsExpr: true }) };
        function tokenIsIdentifier(token) {
          return token >= 89 && token <= 124;
        }
        function tokenIsKeywordOrIdentifier(token) {
          return token >= 54 && token <= 124;
        }
        function tokenIsLiteralPropertyName(token) {
          return token >= 54 && token <= 128;
        }
        function tokenCanStartExpression(token) {
          return tokenStartsExprs[token];
        }
        function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
          return token >= 121 && token <= 123;
        }
        function tokenIsKeyword(token) {
          return token >= 54 && token <= 88;
        }
        function tokenLabelName(token) {
          return tokenLabels[token];
        }
        function tokenOperatorPrecedence(token) {
          return tokenBinops[token];
        }
        function tokenIsTemplate(token) {
          return token >= 24 && token <= 25;
        }
        function getExportedToken(token) {
          return tokenTypes[token];
        }
        tokenTypes[8].updateContext = (context) => {
          context.pop();
        }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
          context.push(types.brace);
        }, tokenTypes[22].updateContext = (context) => {
          context[context.length - 1] === types.template ? context.pop() : context.push(types.template);
        }, tokenTypes[134].updateContext = (context) => {
          context.push(types.j_expr, types.j_oTag);
        };
        let nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
        const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
        const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(code, set) {
          let pos = 65536;
          for (let i = 0, length = set.length; i < length; i += 2) {
            if (pos += set[i], pos > code)
              return false;
            if (pos += set[i + 1], pos >= code)
              return true;
          }
          return false;
        }
        function isIdentifierStart(code) {
          return code < 65 ? code === 36 : code <= 90 || (code < 97 ? code === 95 : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
        }
        function isIdentifierChar(code) {
          return code < 48 ? code === 36 : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? code === 95 : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
        }
        const reservedWords_strict = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], reservedWords_strictBind = ["eval", "arguments"], keywords = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
        function isReservedWord(word, inModule) {
          return inModule && word === "await" || word === "enum";
        }
        function isStrictReservedWord(word, inModule) {
          return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
        }
        function isStrictBindOnlyReservedWord(word) {
          return reservedWordsStrictBindSet.has(word);
        }
        function isStrictBindReservedWord(word, inModule) {
          return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
        }
        const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Scope {
          constructor(flags) {
            this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = flags;
          }
        }
        class ScopeHandler {
          constructor(raise, inModule) {
            this.scopeStack = [], this.undefinedExports = /* @__PURE__ */ new Map(), this.raise = raise, this.inModule = inModule;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const flags = this.currentThisScopeFlags();
            return (64 & flags) > 0 && (2 & flags) == 0;
          }
          get inStaticBlock() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (128 & flags)
                return true;
              if (323 & flags)
                return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(flags) {
            return new Scope(flags);
          }
          enter(flags) {
            this.scopeStack.push(this.createScope(flags));
          }
          exit() {
            this.scopeStack.pop();
          }
          treatFunctionsAsVarInScope(scope) {
            return !!(2 & scope.flags || !this.inModule && 1 & scope.flags);
          }
          declareName(name, bindingType, loc) {
            let scope = this.currentScope();
            if (8 & bindingType || 16 & bindingType)
              this.checkRedeclarationInScope(scope, name, bindingType, loc), 16 & bindingType ? scope.functions.add(name) : scope.lexical.add(name), 8 & bindingType && this.maybeExportDefined(scope, name);
            else if (4 & bindingType)
              for (let i = this.scopeStack.length - 1; i >= 0 && (scope = this.scopeStack[i], this.checkRedeclarationInScope(scope, name, bindingType, loc), scope.var.add(name), this.maybeExportDefined(scope, name), !(259 & scope.flags)); --i)
                ;
            this.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
          }
          maybeExportDefined(scope, name) {
            this.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
          }
          checkRedeclarationInScope(scope, name, bindingType, loc) {
            this.isRedeclaredInScope(scope, name, bindingType) && this.raise(ErrorMessages.VarRedeclaration, { at: loc }, name);
          }
          isRedeclaredInScope(scope, name, bindingType) {
            return !!(1 & bindingType) && (8 & bindingType ? scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name) : 16 & bindingType ? scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name) : scope.lexical.has(name) && !(8 & scope.flags && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name));
          }
          checkLocalExport(id) {
            const { name } = id, topLevelScope = this.scopeStack[0];
            topLevelScope.lexical.has(name) || topLevelScope.var.has(name) || topLevelScope.functions.has(name) || this.undefinedExports.set(name, id.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (259 & flags)
                return flags;
            }
          }
          currentThisScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags } = this.scopeStack[i];
              if (323 & flags && !(4 & flags))
                return flags;
            }
          }
        }
        class FlowScope extends Scope {
          constructor(...args) {
            super(...args), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class FlowScopeHandler extends ScopeHandler {
          createScope(flags) {
            return new FlowScope(flags);
          }
          declareName(name, bindingType, loc) {
            const scope = this.currentScope();
            if (2048 & bindingType)
              return this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name), void scope.declareFunctions.add(name);
            super.declareName(...arguments);
          }
          isRedeclaredInScope(scope, name, bindingType) {
            return !!super.isRedeclaredInScope(...arguments) || !!(2048 & bindingType) && (!scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name)));
          }
          checkLocalExport(id) {
            this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
          }
        }
        const lineBreak = /\r\n?|[\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
        function isNewLine(code) {
          switch (code) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceToLineBreak = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function isWhitespace(code) {
          switch (code) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class State {
          constructor() {
            this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 131, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [types.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          init({ strictMode, sourceType, startLine, startColumn }) {
            this.strict = strictMode !== false && (strictMode === true || sourceType === "module"), this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
          }
          curPosition() {
            return new Position(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone(skipArrays) {
            const state = new State(), keys = Object.keys(this);
            for (let i = 0, length = keys.length; i < length; i++) {
              const key = keys[i];
              let val = this[key];
              !skipArrays && Array.isArray(val) && (val = val.slice()), state[key] = val;
            }
            return state;
          }
        }
        var _isDigit = function(code) {
          return code >= 48 && code <= 57;
        };
        const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100]), forbiddenNumericSeparatorSiblings = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] }, allowedNumericSeparatorSiblings = { bin: [48, 49] };
        allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55], allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57], allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
        class Token {
          constructor(state) {
            this.type = state.type, this.value = state.value, this.start = state.start, this.end = state.end, this.loc = new SourceLocation(state.startLoc, state.endLoc);
          }
        }
        class ClassScope {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class ClassScopeHandler {
          constructor(raise) {
            this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.raise = raise;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new ClassScope());
          }
          exit() {
            const oldClassScope = this.stack.pop(), current = this.current();
            for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames))
              current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, loc) : this.raise(ErrorMessages.InvalidPrivateFieldResolution, { at: loc }, name);
          }
          declarePrivateName(name, elementType, loc) {
            const { privateNames, loneAccessors, undefinedPrivateNames } = this.current();
            let redefined = privateNames.has(name);
            if (3 & elementType) {
              const accessor = redefined && loneAccessors.get(name);
              if (accessor) {
                const oldStatic = 4 & accessor, newStatic = 4 & elementType;
                redefined = (3 & accessor) === (3 & elementType) || oldStatic !== newStatic, redefined || loneAccessors.delete(name);
              } else
                redefined || loneAccessors.set(name, elementType);
            }
            redefined && this.raise(ErrorMessages.PrivateNameRedeclaration, { at: loc }, name), privateNames.add(name), undefinedPrivateNames.delete(name);
          }
          usePrivateName(name, loc) {
            let classScope;
            for (classScope of this.stack)
              if (classScope.privateNames.has(name))
                return;
            classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.raise(ErrorMessages.InvalidPrivateFieldResolution, { at: loc }, name);
          }
        }
        class ExpressionScope {
          constructor(type = 0) {
            this.type = void 0, this.type = type;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
        class ArrowHeadParsingScope extends ExpressionScope {
          constructor(type) {
            super(type), this.errors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(message, loc) {
            this.errors.set(indexes.get(loc), { message, loc });
          }
          clearDeclarationError(loc) {
            this.errors.delete(indexes.get(loc));
          }
          iterateErrors(iterator) {
            this.errors.forEach(iterator);
          }
        }
        class ExpressionScopeHandler {
          constructor(raise) {
            this.stack = [new ExpressionScope()], this.raise = raise;
          }
          enter(scope) {
            this.stack.push(scope);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(loc, template) {
            const { stack } = this;
            let i = stack.length - 1, scope = stack[i];
            for (; !scope.isCertainlyParameterDeclaration(); ) {
              if (!scope.canBeArrowParameterDeclaration())
                return;
              scope.recordDeclarationError(template, loc), scope = stack[--i];
            }
            this.raise(template, { at: loc });
          }
          recordParenthesizedIdentifierError(template, loc) {
            const { stack } = this, scope = stack[stack.length - 1];
            if (scope.isCertainlyParameterDeclaration())
              this.raise(template, { at: loc });
            else {
              if (!scope.canBeArrowParameterDeclaration())
                return;
              scope.recordDeclarationError(template, loc);
            }
          }
          recordAsyncArrowParametersError(template, loc) {
            const { stack } = this;
            let i = stack.length - 1, scope = stack[i];
            for (; scope.canBeArrowParameterDeclaration(); )
              scope.type === 2 && scope.recordDeclarationError(template, loc), scope = stack[--i];
          }
          validateAsPattern() {
            const { stack } = this, currentScope = stack[stack.length - 1];
            currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors(({ message, loc }) => {
              this.raise(message, { at: loc });
              let i = stack.length - 2, scope = stack[i];
              for (; scope.canBeArrowParameterDeclaration(); )
                scope.clearDeclarationError(loc), scope = stack[--i];
            });
          }
        }
        function newExpressionScope() {
          return new ExpressionScope();
        }
        class ProductionParameterHandler {
          constructor() {
            this.stacks = [];
          }
          enter(flags) {
            this.stacks.push(flags);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function functionFlags(isAsync, isGenerator) {
          return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
        }
        class ExpressionErrors {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.optionalParametersLoc = null;
          }
        }
        class Node2 {
          constructor(parser, pos, loc) {
            this.type = "", this.start = pos, this.end = 0, this.loc = new SourceLocation(loc), parser != null && parser.options.ranges && (this.range = [pos, 0]), parser != null && parser.filename && (this.loc.filename = parser.filename);
          }
        }
        const NodePrototype = Node2.prototype;
        function cloneIdentifier(node) {
          const { type, start, end, loc, range, extra, name } = node, cloned = Object.create(NodePrototype);
          return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, cloned.extra = extra, cloned.name = name, type === "Placeholder" && (cloned.expectedNode = node.expectedNode), cloned;
        }
        function cloneStringLiteral(node) {
          const { type, start, end, loc, range, extra } = node;
          if (type === "Placeholder")
            return function(node2) {
              return cloneIdentifier(node2);
            }(node);
          const cloned = Object.create(NodePrototype);
          return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, cloned.range = range, node.raw !== void 0 ? cloned.raw = node.raw : cloned.extra = extra, cloned.value = node.value, cloned;
        }
        NodePrototype.__clone = function() {
          const newNode = new Node2(), keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments" && (newNode[key] = this[key]);
          }
          return newNode;
        };
        const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = makeErrorTemplates({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." }, ErrorCodes.SyntaxError, "flow");
        function hasTypeImportKind(node) {
          return node.importKind === "type" || node.importKind === "typeof";
        }
        function isMaybeDefaultImport(type) {
          return tokenIsKeywordOrIdentifier(type) && type !== 93;
        }
        const exportSuggestions = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
        const entities = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, HEX_NUMBER = /^[\da-fA-F]+$/, DECIMAL_NUMBER = /^\d+$/, JsxErrors = makeErrorTemplates({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }, ErrorCodes.SyntaxError, "jsx");
        function isFragment(object) {
          return !!object && (object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment");
        }
        function getQualifiedJSXName(object) {
          if (object.type === "JSXIdentifier")
            return object.name;
          if (object.type === "JSXNamespacedName")
            return object.namespace.name + ":" + object.name.name;
          if (object.type === "JSXMemberExpression")
            return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
          throw new Error("Node had unexpected type: " + object.type);
        }
        class TypeScriptScope extends Scope {
          constructor(...args) {
            super(...args), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
          }
        }
        class TypeScriptScopeHandler extends ScopeHandler {
          createScope(flags) {
            return new TypeScriptScope(flags);
          }
          declareName(name, bindingType, loc) {
            const scope = this.currentScope();
            if (1024 & bindingType)
              return this.maybeExportDefined(scope, name), void scope.exportOnlyBindings.add(name);
            super.declareName(...arguments), 2 & bindingType && (1 & bindingType || (this.checkRedeclarationInScope(scope, name, bindingType, loc), this.maybeExportDefined(scope, name)), scope.types.add(name)), 256 & bindingType && scope.enums.add(name), 512 & bindingType && scope.constEnums.add(name), 128 & bindingType && scope.classes.add(name);
          }
          isRedeclaredInScope(scope, name, bindingType) {
            if (scope.enums.has(name)) {
              if (256 & bindingType) {
                return !!(512 & bindingType) !== scope.constEnums.has(name);
              }
              return true;
            }
            return 128 & bindingType && scope.classes.has(name) ? !!scope.lexical.has(name) && !!(1 & bindingType) : !!(2 & bindingType && scope.types.has(name)) || super.isRedeclaredInScope(...arguments);
          }
          checkLocalExport(id) {
            const topLevelScope = this.scopeStack[0], { name } = id;
            topLevelScope.types.has(name) || topLevelScope.exportOnlyBindings.has(name) || super.checkLocalExport(id);
          }
        }
        function assert(x) {
          if (!x)
            throw new Error("Assert fail");
        }
        const TSErrors = makeErrorTemplates({ AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0." }, ErrorCodes.SyntaxError, "typescript");
        function tsIsAccessModifier(modifier) {
          return modifier === "private" || modifier === "public" || modifier === "protected";
        }
        const PlaceholderErrors = makeErrorTemplates({ ClassNameIsRequired: "A class name is required." }, ErrorCodes.SyntaxError, "placeholders");
        function hasPlugin(plugins, expectedConfig) {
          const [expectedName, expectedOptions] = typeof expectedConfig == "string" ? [expectedConfig, {}] : expectedConfig, expectedKeys = Object.keys(expectedOptions), expectedOptionsIsEmpty = expectedKeys.length === 0;
          return plugins.some((p) => {
            if (typeof p == "string")
              return expectedOptionsIsEmpty && p === expectedName;
            {
              const [pluginName, pluginOptions] = p;
              if (pluginName !== expectedName)
                return false;
              for (const key of expectedKeys)
                if (pluginOptions[key] !== expectedOptions[key])
                  return false;
              return true;
            }
          });
        }
        function getPluginOption(plugins, name, option) {
          const plugin = plugins.find((plugin2) => Array.isArray(plugin2) ? plugin2[0] === name : plugin2 === name);
          return plugin && Array.isArray(plugin) ? plugin[1][option] : null;
        }
        const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^", "%", "#"], RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
        const mixinPlugins = { estree: (superClass) => class extends superClass {
          parseRegExpLiteral({ pattern, flags }) {
            let regex = null;
            try {
              regex = new RegExp(pattern, flags);
            } catch (e2) {
            }
            const node = this.estreeParseLiteral(regex);
            return node.regex = { pattern, flags }, node;
          }
          parseBigIntLiteral(value) {
            let bigInt;
            try {
              bigInt = BigInt(value);
            } catch (_unused) {
              bigInt = null;
            }
            const node = this.estreeParseLiteral(bigInt);
            return node.bigint = String(node.value || value), node;
          }
          parseDecimalLiteral(value) {
            const node = this.estreeParseLiteral(null);
            return node.decimal = String(node.value || value), node;
          }
          estreeParseLiteral(value) {
            return this.parseLiteral(value, "Literal");
          }
          parseStringLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          parseNumericLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          directiveToStmt(directive) {
            const directiveLiteral = directive.value, stmt = this.startNodeAt(directive.start, directive.loc.start), expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
            return expression.value = directiveLiteral.extra.expressionValue, expression.raw = directiveLiteral.extra.raw, stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end), stmt.directive = directiveLiteral.extra.raw.slice(1, -1), this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
          }
          initFunction(node, isAsync) {
            super.initFunction(node, isAsync), node.expression = false;
          }
          checkDeclaration(node) {
            node != null && this.isObjectProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
          }
          getObjectOrClassMethodParams(method) {
            return method.value.params;
          }
          isValidDirective(stmt) {
            var _stmt$expression$extr;
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value == "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
          }
          parseBlockBody(node, ...args) {
            super.parseBlockBody(node, ...args);
            const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
            node.body = directiveStatements.concat(node.body), delete node.directives;
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true), method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), classBody.body.push(method);
          }
          parsePrivateName() {
            const node = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node) : node;
          }
          convertPrivateNameToPrivateIdentifier(node) {
            const name = super.getPrivateNameSV(node);
            return delete (node = node).id, node.name = name, node.type = "PrivateIdentifier", node;
          }
          isPrivateName(node) {
            return this.getPluginOption("estree", "classFeatures") ? node.type === "PrivateIdentifier" : super.isPrivateName(node);
          }
          getPrivateNameSV(node) {
            return this.getPluginOption("estree", "classFeatures") ? node.name : super.getPrivateNameSV(node);
          }
          parseLiteral(value, type) {
            const node = super.parseLiteral(value, type);
            return node.raw = node.extra.raw, delete node.extra, node;
          }
          parseFunctionBody(node, allowExpression, isMethod = false) {
            super.parseFunctionBody(node, allowExpression, isMethod), node.expression = node.body.type !== "BlockStatement";
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
            let funcNode = this.startNode();
            return funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope), funcNode.type = "FunctionExpression", delete funcNode.kind, node.value = funcNode, type === "ClassPrivateMethod" && (node.computed = false), type = "MethodDefinition", this.finishNode(node, type);
          }
          parseClassProperty(...args) {
            const propertyNode = super.parseClassProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", propertyNode) : propertyNode;
          }
          parseClassPrivateProperty(...args) {
            const propertyNode = super.parseClassPrivateProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", propertyNode.computed = false, propertyNode) : propertyNode;
          }
          parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
            return node && (node.type = "Property", node.kind === "method" && (node.kind = "init"), node.shorthand = false), node;
          }
          parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
            const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
            return node && (node.kind = "init", node.type = "Property"), node;
          }
          isAssignable(node, isBinding) {
            return node != null && this.isObjectProperty(node) ? this.isAssignable(node.value, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = false) {
            return node != null && this.isObjectProperty(node) ? (this.toAssignable(node.value, isLHS), node) : super.toAssignable(node, isLHS);
          }
          toAssignableObjectExpressionProp(prop, ...args) {
            prop.kind === "get" || prop.kind === "set" ? this.raise(ErrorMessages.PatternHasAccessor, { node: prop.key }) : prop.method ? this.raise(ErrorMessages.PatternHasMethod, { node: prop.key }) : super.toAssignableObjectExpressionProp(prop, ...args);
          }
          finishCallExpression(node, optional) {
            if (super.finishCallExpression(node, optional), node.callee.type === "Import") {
              var _node$arguments$;
              if (node.type = "ImportExpression", node.source = node.arguments[0], this.hasPlugin("importAssertions"))
                node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
              delete node.arguments, delete node.callee;
            }
            return node;
          }
          toReferencedArguments(node) {
            node.type !== "ImportExpression" && super.toReferencedArguments(node);
          }
          parseExport(node) {
            switch (super.parseExport(node), node.type) {
              case "ExportAllDeclaration":
                node.exported = null;
                break;
              case "ExportNamedDeclaration":
                node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier" && (node.type = "ExportAllDeclaration", node.exported = node.specifiers[0].exported, delete node.specifiers);
            }
            return node;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
            if (state.optionalChainMember) {
              if (node.type !== "OptionalMemberExpression" && node.type !== "OptionalCallExpression" || (node.type = node.type.substring(8)), state.stop) {
                const chain = this.startNodeAtNode(node);
                return chain.expression = node, this.finishNode(chain, "ChainExpression");
              }
            } else
              node.type !== "MemberExpression" && node.type !== "CallExpression" || (node.optional = false);
            return node;
          }
          hasPropertyAsPrivateName(node) {
            return node.type === "ChainExpression" && (node = node.expression), super.hasPropertyAsPrivateName(node);
          }
          isOptionalChain(node) {
            return node.type === "ChainExpression";
          }
          isObjectProperty(node) {
            return node.type === "Property" && node.kind === "init" && !node.method;
          }
          isObjectMethod(node) {
            return node.method || node.kind === "get" || node.kind === "set";
          }
        }, jsx: (superClass) => class extends superClass {
          jsxReadToken() {
            let out = "", chunkStart = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(JsxErrors.UnterminatedJsxContent, { at: this.state.startLoc });
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? ch === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(134)) : super.getTokenFromCode(ch) : (out += this.input.slice(chunkStart, this.state.pos), this.finishToken(133, out));
                case 38:
                  out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos;
                  break;
                default:
                  isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(true), chunkStart = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            return ++this.state.pos, ch === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, out = normalizeCRLF ? "\n" : "\r\n") : out = String.fromCharCode(ch), ++this.state.curLine, this.state.lineStart = this.state.pos, out;
          }
          jsxReadString(quote) {
            let out = "", chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(ErrorMessages.UnterminatedString, { at: this.state.startLoc });
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              ch === 38 ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(false), chunkStart = this.state.pos) : ++this.state.pos;
            }
            return out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(125, out);
          }
          jsxReadEntity() {
            let entity, str = "", count = 0, ch = this.input[this.state.pos];
            const startPos = ++this.state.pos;
            for (; this.state.pos < this.length && count++ < 10; ) {
              if (ch = this.input[this.state.pos++], ch === ";") {
                str[0] === "#" ? str[1] === "x" ? (str = str.substr(2), HEX_NUMBER.test(str) && (entity = String.fromCodePoint(parseInt(str, 16)))) : (str = str.substr(1), DECIMAL_NUMBER.test(str) && (entity = String.fromCodePoint(parseInt(str, 10)))) : entity = entities[str];
                break;
              }
              str += ch;
            }
            return entity || (this.state.pos = startPos, "&");
          }
          jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do {
              ch = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar(ch) || ch === 45);
            return this.finishToken(132, this.input.slice(start, this.state.pos));
          }
          jsxParseIdentifier() {
            const node = this.startNode();
            return this.match(132) ? node.name = this.state.value : tokenIsKeyword(this.state.type) ? node.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(node, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const startPos = this.state.start, startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
            if (!this.eat(14))
              return name;
            const node = this.startNodeAt(startPos, startLoc);
            return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let node = this.jsxParseNamespacedName();
            if (node.type === "JSXNamespacedName")
              return node;
            for (; this.eat(16); ) {
              const newNode = this.startNodeAt(startPos, startLoc);
              newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
          }
          jsxParseAttributeValue() {
            let node;
            switch (this.state.type) {
              case 5:
                return node = this.startNode(), this.setContext(types.brace), this.next(), node = this.jsxParseExpressionContainer(node, types.j_oTag), node.expression.type === "JSXEmptyExpression" && this.raise(JsxErrors.AttributeIsEmpty, { node }), node;
              case 134:
              case 125:
                return this.parseExprAtom();
              default:
                throw this.raise(JsxErrors.UnsupportedJsxValue, { at: this.state.startLoc });
            }
          }
          jsxParseEmptyExpression() {
            const node = this.startNodeAt(indexes.get(this.state.lastTokEndLoc), this.state.lastTokEndLoc);
            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(node) {
            return this.next(), node.expression = this.parseExpression(), this.setContext(types.j_oTag), this.expect(8), this.finishNode(node, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(node, previousContext) {
            if (this.match(8))
              node.expression = this.jsxParseEmptyExpression();
            else {
              const expression = this.parseExpression();
              node.expression = expression;
            }
            return this.setContext(previousContext), this.expect(8), this.finishNode(node, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const node = this.startNode();
            return this.match(5) ? (this.setContext(types.brace), this.next(), this.expect(21), node.argument = this.parseMaybeAssignAllowIn(), this.setContext(types.j_oTag), this.expect(8), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), node.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            return this.match(135) ? (this.expect(135), this.finishNode(node, "JSXOpeningFragment")) : (node.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(node));
          }
          jsxParseOpeningElementAfterName(node) {
            const attributes = [];
            for (; !this.match(52) && !this.match(135); )
              attributes.push(this.jsxParseAttribute());
            return node.attributes = attributes, node.selfClosing = this.eat(52), this.expect(135), this.finishNode(node, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            return this.match(135) ? (this.expect(135), this.finishNode(node, "JSXClosingFragment")) : (node.name = this.jsxParseElementName(), this.expect(135), this.finishNode(node, "JSXClosingElement"));
          }
          jsxParseElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
              contents:
                for (; ; )
                  switch (this.state.type) {
                    case 134:
                      if (startPos = this.state.start, startLoc = this.state.startLoc, this.next(), this.eat(52)) {
                        closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                        break contents;
                      }
                      children.push(this.jsxParseElementAt(startPos, startLoc));
                      break;
                    case 133:
                      children.push(this.parseExprAtom());
                      break;
                    case 5: {
                      const node2 = this.startNode();
                      this.setContext(types.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node2)) : children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
              isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null ? this.raise(JsxErrors.MissingClosingTagFragment, { node: closingElement }) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, { node: closingElement }, getQualifiedJSXName(openingElement.name)) : isFragment(openingElement) || isFragment(closingElement) || getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, { node: closingElement }, getQualifiedJSXName(openingElement.name));
            }
            if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, node.closingElement = closingElement), node.children = children, this.match(45))
              throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
          }
          jsxParseElement() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(startPos, startLoc);
          }
          setContext(newContext) {
            const { context } = this.state;
            context[context.length - 1] = newContext;
          }
          parseExprAtom(refExpressionErrors) {
            return this.match(133) ? this.parseLiteral(this.state.value, "JSXText") : this.match(134) ? this.jsxParseElement() : this.match(45) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(134), this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(code) {
            const context = this.curContext();
            if (context === types.j_expr)
              return this.jsxReadToken();
            if (context === types.j_oTag || context === types.j_cTag) {
              if (isIdentifierStart(code))
                return this.jsxReadWord();
              if (code === 62)
                return ++this.state.pos, this.finishToken(135);
              if ((code === 34 || code === 39) && context === types.j_oTag)
                return this.jsxReadString(code);
            }
            return code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(134)) : super.getTokenFromCode(code);
          }
          updateContext(prevType) {
            const { context, type } = this.state;
            if (type === 52 && prevType === 134)
              context.splice(-2, 2, types.j_cTag), this.state.canStartJSXElement = false;
            else if (type === 134)
              context.push(types.j_oTag);
            else if (type === 135) {
              const out = context[context.length - 1];
              out === types.j_oTag && prevType === 52 || out === types.j_cTag ? (context.pop(), this.state.canStartJSXElement = context[context.length - 1] === types.j_expr) : (this.setContext(types.j_expr), this.state.canStartJSXElement = true);
            } else
              this.state.canStartJSXElement = tokenBeforeExprs[type];
          }
        }, flow: (superClass) => class extends superClass {
          constructor(...args) {
            super(...args), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(type, val) {
            return type !== 125 && type !== 13 && type !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(type, val);
          }
          addComment(comment) {
            if (this.flowPragma === void 0) {
              const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
              if (matches)
                if (matches[1] === "flow")
                  this.flowPragma = "flow";
                else {
                  if (matches[1] !== "noflow")
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
              else
                ;
            }
            return super.addComment(comment);
          }
          flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = true, this.expect(tok || 14);
            const type = this.flowParseType();
            return this.state.inType = oldInType, type;
          }
          flowParsePredicate() {
            const node = this.startNode(), moduloLoc = this.state.startLoc;
            return this.next(), this.expectContextual(103), this.state.lastTokStart > indexes.get(moduloLoc) + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, { at: moduloLoc }), this.eat(10) ? (node.value = this.parseExpression(), this.expect(11), this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = true, this.expect(14);
            let type = null, predicate = null;
            return this.match(50) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type = this.flowParseType(), this.state.inType = oldInType, this.match(50) && (predicate = this.flowParsePredicate())), [type, predicate];
          }
          flowParseDeclareClass(node) {
            return this.next(), this.flowParseInterfaceish(node, true), this.finishNode(node, "DeclareClass");
          }
          flowParseDeclareFunction(node) {
            this.next();
            const id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
            this.match(45) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, this.expect(10);
            const tmp = this.flowParseFunctionTypeParams();
            return typeNode.params = tmp.params, typeNode.rest = tmp.rest, typeNode.this = tmp._this, this.expect(11), [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), this.semicolon(), this.scope.declareName(node.id.name, 2048, node.id.loc.start), this.finishNode(node, "DeclareFunction");
          }
          flowParseDeclare(node, insideModule) {
            if (this.match(76))
              return this.flowParseDeclareClass(node);
            if (this.match(64))
              return this.flowParseDeclareFunction(node);
            if (this.match(70))
              return this.flowParseDeclareVariable(node);
            if (this.eatContextual(119))
              return this.match(16) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(node));
            if (this.isContextual(122))
              return this.flowParseDeclareTypeAlias(node);
            if (this.isContextual(123))
              return this.flowParseDeclareOpaqueType(node);
            if (this.isContextual(121))
              return this.flowParseDeclareInterface(node);
            if (this.match(78))
              return this.flowParseDeclareExportDeclaration(node, insideModule);
            throw this.unexpected();
          }
          flowParseDeclareVariable(node) {
            return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(node.id.name, 5, node.id.loc.start), this.semicolon(), this.finishNode(node, "DeclareVariable");
          }
          flowParseDeclareModule(node) {
            this.scope.enter(0), this.match(125) ? node.id = this.parseExprAtom() : node.id = this.parseIdentifier();
            const bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
            for (this.expect(5); !this.match(8); ) {
              let bodyNode2 = this.startNode();
              this.match(79) ? (this.next(), this.isContextual(122) || this.match(83) || this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), this.parseImport(bodyNode2)) : (this.expectContextual(117, FlowErrors.UnsupportedStatementInDeclareModule), bodyNode2 = this.flowParseDeclare(bodyNode2, true)), body.push(bodyNode2);
            }
            this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
            let kind = null, hasModuleExport = false;
            return body.forEach((bodyElement) => {
              !function(bodyElement2) {
                return bodyElement2.type === "DeclareExportAllDeclaration" || bodyElement2.type === "DeclareExportDeclaration" && (!bodyElement2.declaration || bodyElement2.declaration.type !== "TypeAlias" && bodyElement2.declaration.type !== "InterfaceDeclaration");
              }(bodyElement) ? bodyElement.type === "DeclareModuleExports" && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, { node: bodyElement }), kind === "ES" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, { node: bodyElement }), kind = "CommonJS", hasModuleExport = true) : (kind === "CommonJS" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, { node: bodyElement }), kind = "ES");
            }), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(node, insideModule) {
            if (this.expect(78), this.eat(61))
              return this.match(64) || this.match(76) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), this.semicolon()), node.default = true, this.finishNode(node, "DeclareExportDeclaration");
            if (this.match(71) || this.isLet() || (this.isContextual(122) || this.isContextual(121)) && !insideModule) {
              const label = this.state.value, suggestion = exportSuggestions[label];
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, { at: this.state.startLoc }, label, suggestion);
            }
            if (this.match(70) || this.match(64) || this.match(76) || this.isContextual(123))
              return node.declaration = this.flowParseDeclare(this.startNode()), node.default = false, this.finishNode(node, "DeclareExportDeclaration");
            if (this.match(51) || this.match(5) || this.isContextual(121) || this.isContextual(122) || this.isContextual(123))
              return (node = this.parseExport(node)).type === "ExportNamedDeclaration" && (node.type = "ExportDeclaration", node.default = false, delete node.exportKind), node.type = "Declare" + node.type, node;
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(node) {
            return this.next(), this.expectContextual(104), node.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(node, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(node) {
            return this.next(), this.flowParseTypeAlias(node), node.type = "DeclareTypeAlias", node;
          }
          flowParseDeclareOpaqueType(node) {
            return this.next(), this.flowParseOpaqueType(node, true), node.type = "DeclareOpaqueType", node;
          }
          flowParseDeclareInterface(node) {
            return this.next(), this.flowParseInterfaceish(node), this.finishNode(node, "DeclareInterface");
          }
          flowParseInterfaceish(node, isClass = false) {
            if (node.id = this.flowParseRestrictedIdentifier(!isClass, true), this.scope.declareName(node.id.name, isClass ? 17 : 9, node.id.loc.start), this.match(45) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.extends = [], node.implements = [], node.mixins = [], this.eat(77))
              do {
                node.extends.push(this.flowParseInterfaceExtends());
              } while (!isClass && this.eat(12));
            if (this.isContextual(110)) {
              this.next();
              do {
                node.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            if (this.isContextual(106)) {
              this.next();
              do {
                node.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            node.body = this.flowParseObjectType({ allowStatic: isClass, allowExact: false, allowSpread: false, allowProto: isClass, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const node = this.startNode();
            return node.id = this.flowParseQualifiedTypeIdentifier(), this.match(45) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, this.finishNode(node, "InterfaceExtends");
          }
          flowParseInterface(node) {
            return this.flowParseInterfaceish(node), this.finishNode(node, "InterfaceDeclaration");
          }
          checkNotUnderscore(word) {
            word === "_" && this.raise(FlowErrors.UnexpectedReservedUnderscore, { at: this.state.startLoc });
          }
          checkReservedType(word, startLoc, declaration) {
            reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, { at: startLoc }, word);
          }
          flowParseRestrictedIdentifier(liberal, declaration) {
            return this.checkReservedType(this.state.value, this.state.startLoc, declaration), this.parseIdentifier(liberal);
          }
          flowParseTypeAlias(node) {
            return node.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(node.id.name, 9, node.id.loc.start), this.match(45) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node, "TypeAlias");
          }
          flowParseOpaqueType(node, declare) {
            return this.expectContextual(122), node.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(node.id.name, 9, node.id.loc.start), this.match(45) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, node.supertype = null, this.match(14) && (node.supertype = this.flowParseTypeInitialiser(14)), node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(node, "OpaqueType");
          }
          flowParseTypeParameter(requireDefault = false) {
            const nodeStartLoc = this.state.startLoc, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
            return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, this.match(29) ? (this.eat(29), node.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc }), this.finishNode(node, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType, node = this.startNode();
            node.params = [], this.state.inType = true, this.match(45) || this.match(134) ? this.next() : this.unexpected();
            let defaultRequired = false;
            do {
              const typeParameter = this.flowParseTypeParameter(defaultRequired);
              node.params.push(typeParameter), typeParameter.default && (defaultRequired = true), this.match(46) || this.expect(12);
            } while (!this.match(46));
            return this.expect(46), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const node = this.startNode(), oldInType = this.state.inType;
            node.params = [], this.state.inType = true, this.expect(45);
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(46); )
              node.params.push(this.flowParseType()), this.match(46) || this.expect(12);
            return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expect(46), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const node = this.startNode(), oldInType = this.state.inType;
            for (node.params = [], this.state.inType = true, this.expect(45); !this.match(46); )
              node.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(46) || this.expect(12);
            return this.expect(46), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const node = this.startNode();
            if (this.expectContextual(121), node.extends = [], this.eat(77))
              do {
                node.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            return node.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(node, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(126) || this.match(125) ? this.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(node, isStatic, variance) {
            return node.static = isStatic, this.lookahead().type === 14 ? (node.id = this.flowParseObjectPropertyKey(), node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), this.expect(3), node.value = this.flowParseTypeInitialiser(), node.variance = variance, this.finishNode(node, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(node, isStatic) {
            return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(45) || this.match(10) ? (node.method = true, node.optional = false, node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start))) : (node.method = false, this.eat(17) && (node.optional = true), node.value = this.flowParseTypeInitialiser()), this.finishNode(node, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(node) {
            for (node.params = [], node.rest = null, node.typeParameters = null, node.this = null, this.match(45) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(74) && (node.this = this.flowParseFunctionTypeParam(true), node.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              node.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (node.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(node, isStatic) {
            const valueNode = this.startNode();
            return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), this.finishNode(node, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const nodeStart = this.startNode();
            let endDelim, exact;
            nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], nodeStart.internalSlots = [];
            let inexact = false;
            for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = true) : (this.expect(5), endDelim = 8, exact = false), nodeStart.exact = exact; !this.match(endDelim); ) {
              let isStatic = false, protoStartLoc = null, inexactStartLoc = null;
              const node = this.startNode();
              if (allowProto && this.isContextual(111)) {
                const lookahead = this.lookahead();
                lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), protoStartLoc = this.state.startLoc, allowStatic = false);
              }
              if (allowStatic && this.isContextual(100)) {
                const lookahead = this.lookahead();
                lookahead.type !== 14 && lookahead.type !== 17 && (this.next(), isStatic = true);
              }
              const variance = this.flowParseVariance();
              if (this.eat(0))
                protoStartLoc != null && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
              else if (this.match(10) || this.match(45))
                protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
              else {
                let kind = "init";
                if (this.isContextual(94) || this.isContextual(99)) {
                  tokenIsLiteralPropertyName(this.lookahead().type) && (kind = this.state.value, this.next());
                }
                const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
                propOrInexact === null ? (inexact = true, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
              }
              this.flowObjectTypeSemicolon(), !inexactStartLoc || this.match(8) || this.match(9) || this.raise(FlowErrors.UnexpectedExplicitInexactInObject, { at: inexactStartLoc });
            }
            this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            return this.state.inType = oldInType, out;
          }
          flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
            if (this.eat(21)) {
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(FlowErrors.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), variance && this.raise(FlowErrors.InexactVariance, { node: variance }), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, { node: variance }), node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
            }
            {
              node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = protoStartLoc != null, node.kind = kind;
              let optional = false;
              return this.match(45) || this.match(10) ? (node.method = true, protoStartLoc != null && this.unexpected(protoStartLoc), variance && this.unexpected(variance.loc.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start)), kind !== "get" && kind !== "set" || this.flowCheckGetterSetterParams(node), !allowSpread && node.key.name === "constructor" && node.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, { node: node.value.this })) : (kind !== "init" && this.unexpected(), node.method = false, this.eat(17) && (optional = true), node.value = this.flowParseTypeInitialiser(), node.variance = variance), node.optional = optional, this.finishNode(node, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(property) {
            const paramCount = property.kind === "get" ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
            property.value.this && this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, { node: property.value.this }), length !== paramCount && this.raise(property.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, { node: property }), property.kind === "set" && property.value.rest && this.raise(ErrorMessages.BadSetterRestParameter, { node: property });
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
            startPos = startPos || this.state.start, startLoc = startLoc || this.state.startLoc;
            let node = id || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(true), node = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            return node;
          }
          flowParseGenericType(startPos, startLoc, id) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id), this.match(45) && (node.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(node, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const node = this.startNode();
            return this.expect(83), node.argument = this.flowParsePrimaryType(), this.finishNode(node, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const node = this.startNode();
            for (node.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(node, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(first) {
            let name = null, optional = false, typeAnnotation = null;
            const node = this.startNode(), lh = this.lookahead(), isThis = this.state.type === 74;
            return lh.type === 14 || lh.type === 17 ? (isThis && !first && this.raise(FlowErrors.ThisParamMustBeFirst, { node }), name = this.parseIdentifier(isThis), this.eat(17) && (optional = true, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, { node })), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, this.finishNode(node, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(type) {
            const node = this.startNodeAt(type.start, type.loc.start);
            return node.name = null, node.optional = false, node.typeAnnotation = type, this.finishNode(node, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(params = []) {
            let rest = null, _this = null;
            for (this.match(74) && (_this = this.flowParseFunctionTypeParam(true), _this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (rest = this.flowParseFunctionTypeParam(false)), { params, rest, _this };
          }
          flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
            switch (id.name) {
              case "any":
                return this.finishNode(node, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(node, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(node, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(node, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(node, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(node, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(node, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(id.name), this.flowParseGenericType(startPos, startLoc, id);
            }
          }
          flowParsePrimaryType() {
            const startPos = this.state.start, startLoc = this.state.startLoc, node = this.startNode();
            let tmp, type, isGroupedType = false;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, type = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, type;
              case 45:
                return node.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), tmp = this.flowParseFunctionTypeParams(), node.params = tmp.params, node.rest = tmp.rest, node.this = tmp._this, this.expect(11), this.expect(19), node.returnType = this.flowParseType(), this.finishNode(node, "FunctionTypeAnnotation");
              case 10:
                if (this.next(), !this.match(11) && !this.match(21))
                  if (tokenIsIdentifier(this.state.type) || this.match(74)) {
                    const token = this.lookahead().type;
                    isGroupedType = token !== 17 && token !== 14;
                  } else
                    isGroupedType = true;
                if (isGroupedType) {
                  if (this.state.noAnonFunctionType = false, type = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                    return this.expect(11), type;
                  this.eat(12);
                }
                return tmp = type ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]) : this.flowParseFunctionTypeParams(), node.params = tmp.params, node.rest = tmp.rest, node.this = tmp._this, this.expect(11), this.expect(19), node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
              case 125:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 81:
              case 82:
                return node.value = this.match(81), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");
              case 49:
                if (this.state.value === "-") {
                  if (this.next(), this.match(126))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                  if (this.match(127))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                  throw this.raise(FlowErrors.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                }
                throw this.unexpected();
              case 126:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 127:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(node, "VoidTypeAnnotation");
              case 80:
                return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");
              case 74:
                return this.next(), this.finishNode(node, "ThisTypeAnnotation");
              case 51:
                return this.next(), this.finishNode(node, "ExistsTypeAnnotation");
              case 83:
                return this.flowParseTypeofType();
              default:
                if (tokenIsKeyword(this.state.type)) {
                  const label = tokenLabelName(this.state.type);
                  return this.next(), super.createIdentifier(node, label);
                }
                if (tokenIsIdentifier(this.state.type))
                  return this.isContextual(121) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let type = this.flowParsePrimaryType(), seenOptionalIndexedAccess = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const node = this.startNodeAt(startPos, startLoc), optional = this.eat(18);
              seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), !optional && this.match(3) ? (node.elementType = type, this.next(), type = this.finishNode(node, "ArrayTypeAnnotation")) : (node.objectType = type, node.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node.optional = optional, type = this.finishNode(node, "OptionalIndexedAccessType")) : type = this.finishNode(node, "IndexedAccessType"));
            }
            return type;
          }
          flowParsePrefixType() {
            const node = this.startNode();
            return this.eat(17) ? (node.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const node = this.startNodeAt(param.start, param.loc.start);
              return node.params = [this.reinterpretTypeAsFunctionTypeParam(param)], node.rest = null, node.this = null, node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
            }
            return param;
          }
          flowParseIntersectionType() {
            const node = this.startNode();
            this.eat(43);
            const type = this.flowParseAnonFunctionWithoutParens();
            for (node.types = [type]; this.eat(43); )
              node.types.push(this.flowParseAnonFunctionWithoutParens());
            return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const node = this.startNode();
            this.eat(41);
            const type = this.flowParseIntersectionType();
            for (node.types = [type]; this.eat(41); )
              node.types.push(this.flowParseIntersectionType());
            return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
          }
          flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = true;
            const type = this.flowParseUnionType();
            return this.state.inType = oldInType, type;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 124 && this.state.value === "_") {
              const startPos = this.state.start, startLoc = this.state.startLoc, node = this.parseIdentifier();
              return this.flowParseGenericType(startPos, startLoc, node);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const node = this.startNode();
            return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(ident)), ident;
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
          }
          flowParseVariance() {
            let variance = null;
            return this.match(49) && (variance = this.startNode(), this.state.value === "+" ? variance.kind = "plus" : variance.kind = "minus", this.next(), this.finishNode(variance, "Variance")), variance;
          }
          parseFunctionBody(node, allowExpressionBody, isMethod = false) {
            return allowExpressionBody ? this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod)) : super.parseFunctionBody(node, false, isMethod);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            if (this.match(14)) {
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(node, type, isMethod);
          }
          parseStatement(context, topLevel) {
            if (this.state.strict && this.isContextual(121)) {
              if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
                const node = this.startNode();
                return this.next(), this.flowParseInterface(node);
              }
            } else if (this.shouldParseEnums() && this.isContextual(118)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            const stmt = super.parseStatement(context, topLevel);
            return this.flowPragma !== void 0 || this.isValidDirective(stmt) || (this.flowPragma = null), stmt;
          }
          parseExpressionStatement(node, expr) {
            if (expr.type === "Identifier") {
              if (expr.name === "declare") {
                if (this.match(76) || tokenIsIdentifier(this.state.type) || this.match(64) || this.match(70) || this.match(78))
                  return this.flowParseDeclare(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                if (expr.name === "interface")
                  return this.flowParseInterface(node);
                if (expr.name === "type")
                  return this.flowParseTypeAlias(node);
                if (expr.name === "opaque")
                  return this.flowParseOpaqueType(node, false);
              }
            }
            return super.parseExpressionStatement(node, expr);
          }
          shouldParseExportDeclaration() {
            const { type } = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 118 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type } = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 118 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(118)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(expr, startPos, startLoc, refExpressionErrors) {
            if (!this.match(17))
              return expr;
            if (this.state.maybeInArrowParameters) {
              const nextCh = this.lookaheadCharCode();
              if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41)
                return this.setOptionalParametersError(refExpressionErrors), expr;
            }
            this.expect(17);
            const state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startPos, startLoc);
            let { consequent, failed } = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
              const noArrowAt = [...originalNoArrowAt];
              if (invalid.length > 0) {
                this.state = state, this.state.noArrowAt = noArrowAt;
                for (let i = 0; i < invalid.length; i++)
                  noArrowAt.push(invalid[i].start);
                ({ consequent, failed } = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
              }
              failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, { at: state.startLoc }), failed && valid.length === 1 && (this.state = state, noArrowAt.push(valid[0].start), this.state.noArrowAt = noArrowAt, { consequent, failed } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(consequent, true), this.state.noArrowAt = originalNoArrowAt, this.expect(14), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(node, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent, failed };
          }
          getArrowLikeExpressions(node, disallowInvalid) {
            const stack = [node], arrows = [];
            for (; stack.length !== 0; ) {
              const node2 = stack.pop();
              node2.type === "ArrowFunctionExpression" ? (node2.typeParameters || !node2.returnType ? this.finishArrowValidation(node2) : arrows.push(node2), stack.push(node2.body)) : node2.type === "ConditionalExpression" && (stack.push(node2.consequent), stack.push(node2.alternate));
            }
            return disallowInvalid ? (arrows.forEach((node2) => this.finishArrowValidation(node2)), [arrows, []]) : function(list, test) {
              const list1 = [], list2 = [];
              for (let i = 0; i < list.length; i++)
                (test(list[i], i, list) ? list1 : list2).push(list[i]);
              return [list1, list2];
            }(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
          }
          finishArrowValidation(node) {
            var _node$extra;
            this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(node, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(node, parse2) {
            let result;
            return this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), result = parse2(), this.state.noArrowParamsConversionAt.pop()) : result = parse2(), result;
          }
          parseParenItem(node, startPos, startLoc) {
            if (node = super.parseParenItem(node, startPos, startLoc), this.eat(17) && (node.optional = true, this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node;
          }
          assertModuleNodeAllowed(node) {
            node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type" || super.assertModuleNodeAllowed(node);
          }
          parseExport(node) {
            const decl = super.parseExport(node);
            return decl.type !== "ExportNamedDeclaration" && decl.type !== "ExportAllDeclaration" || (decl.exportKind = decl.exportKind || "value"), decl;
          }
          parseExportDeclaration(node) {
            if (this.isContextual(122)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.match(5) ? (node.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
            }
            if (this.isContextual(123)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseOpaqueType(declarationNode, false);
            }
            if (this.isContextual(121)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseInterface(declarationNode);
            }
            if (this.shouldParseEnums() && this.isContextual(118)) {
              node.exportKind = "value";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(declarationNode);
            }
            return super.parseExportDeclaration(node);
          }
          eatExportStar(node) {
            return !!super.eatExportStar(...arguments) || !(!this.isContextual(122) || this.lookahead().type !== 51) && (node.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(node) {
            const { startLoc } = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
            return hasNamespace && node.exportKind === "type" && this.unexpected(startLoc), hasNamespace;
          }
          parseClassId(node, isStatement, optionalId) {
            super.parseClassId(node, isStatement, optionalId), this.match(45) && (node.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(classBody, member, state) {
            const { startLoc } = this.state;
            if (this.isContextual(117)) {
              if (this.parseClassMemberFromModifier(classBody, member))
                return;
              member.declare = true;
            }
            super.parseClassMember(classBody, member, state), member.declare && (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition" ? this.raise(FlowErrors.DeclareClassElement, { at: startLoc }) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, { node: member.value }));
          }
          isIterator(word) {
            return word === "iterator" || word === "asyncIterator";
          }
          readIterator() {
            const word = super.readWord1(), fullWord = "@@" + word;
            this.isIterator(word) && this.state.inType || this.raise(ErrorMessages.InvalidIdentifier, { at: this.state.curPosition() }, fullWord), this.finishToken(124, fullWord);
          }
          getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            return code === 123 && next === 124 ? this.finishOp(6, 2) : !this.state.inType || code !== 62 && code !== 60 ? this.state.inType && code === 63 ? next === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(current, next2) {
              return current === 64 && next2 === 64;
            }(code, next) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(code) : this.finishOp(code === 62 ? 46 : 45, 1);
          }
          isAssignable(node, isBinding) {
            return node.type === "TypeCastExpression" ? this.isAssignable(node.expression, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = false) {
            return node.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(node), isLHS) : super.toAssignable(node, isLHS);
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              (expr == null ? void 0 : expr.type) === "TypeCastExpression" && (exprList[i] = this.typeCastToParameter(expr));
            }
            return super.toAssignableList(exprList, trailingCommaLoc, isLHS);
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            for (let i = 0; i < exprList.length; i++) {
              var _expr$extra;
              const expr = exprList[i];
              !expr || expr.type !== "TypeCastExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized || !(exprList.length > 1) && isParenthesizedExpr || this.raise(FlowErrors.TypeCastInPattern, { node: expr.typeAnnotation });
            }
            return exprList;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            return canBePattern && !this.state.maybeInArrowParameters && this.toReferencedList(node.elements), node;
          }
          checkLVal(expr, ...args) {
            if (expr.type !== "TypeCastExpression")
              return super.checkLVal(expr, ...args);
          }
          parseClassProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(node);
          }
          isClassMethod() {
            return this.match(45) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(method) {
            return !this.match(14) && super.isNonstaticConstructor(method);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(45) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), method.params && isConstructor) {
              const params = method.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, { node: method });
            } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
              const params = method.value.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, { node: method });
            }
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            method.variance && this.unexpected(method.variance.loc.start), delete method.variance, this.match(45) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          parseClassSuper(node) {
            if (super.parseClassSuper(node), node.superClass && this.match(45) && (node.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(106)) {
              this.next();
              const implemented = node.implements = [];
              do {
                const node2 = this.startNode();
                node2.id = this.flowParseRestrictedIdentifier(true), this.match(45) ? node2.typeParameters = this.flowParseTypeParameterInstantiation() : node2.typeParameters = null, implemented.push(this.finishNode(node2, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(method) {
            super.checkGetterSetterParams(method);
            const params = this.getObjectOrClassMethodParams(method);
            if (params.length > 0) {
              const param = params[0];
              this.isThisParam(param) && method.kind === "get" ? this.raise(FlowErrors.GetterMayNotHaveThisParam, { node: param }) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, { node: param });
            }
          }
          parsePropertyNamePrefixOperator(node) {
            node.variance = this.flowParseVariance();
          }
          parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            let typeParameters;
            prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance, this.match(45) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors), typeParameters && ((prop.value || prop).typeParameters = typeParameters);
          }
          parseAssignableListItemTypes(param) {
            return this.eat(17) && (param.type !== "Identifier" && this.raise(FlowErrors.PatternIsOptional, { node: param }), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, { node: param }), param.optional = true), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, { node: param }), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, { node: param }), this.resetEndLocation(param), param;
          }
          parseMaybeDefault(startPos, startLoc, left) {
            const node = super.parseMaybeDefault(startPos, startLoc, left);
            return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, { node: node.typeAnnotation }), node;
          }
          shouldParseDefaultImport(node) {
            return hasTypeImportKind(node) ? isMaybeDefaultImport(this.state.type) : super.shouldParseDefaultImport(node);
          }
          parseImportSpecifierLocal(node, specifier, type, contextDescription) {
            specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(specifier.local, contextDescription, 9), node.specifiers.push(this.finishNode(specifier, type));
          }
          maybeParseDefaultImportSpecifier(node) {
            node.importKind = "value";
            let kind = null;
            if (this.match(83) ? kind = "typeof" : this.isContextual(122) && (kind = "type"), kind) {
              const lh = this.lookahead(), { type } = lh;
              kind === "type" && type === 51 && this.unexpected(null, lh.type), (isMaybeDefaultImport(type) || type === 5 || type === 51) && (this.next(), node.importKind = kind);
            }
            return super.maybeParseDefaultImportSpecifier(node);
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            const firstIdent = specifier.imported;
            let specifierTypeKind = null;
            firstIdent.type === "Identifier" && (firstIdent.name === "type" ? specifierTypeKind = "type" : firstIdent.name === "typeof" && (specifierTypeKind = "typeof"));
            let isBinding = false;
            if (this.isContextual(89) && !this.isLookaheadContextual("as")) {
              const as_ident = this.parseIdentifier(true);
              specifierTypeKind === null || tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = firstIdent, specifier.importKind = null, specifier.local = this.parseIdentifier()) : (specifier.imported = as_ident, specifier.importKind = specifierTypeKind, specifier.local = cloneIdentifier(as_ident));
            } else {
              if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type))
                specifier.imported = this.parseIdentifier(true), specifier.importKind = specifierTypeKind;
              else {
                if (importedIsString)
                  throw this.raise(ErrorMessages.ImportBindingIsString, { node: specifier }, firstIdent.value);
                specifier.imported = firstIdent, specifier.importKind = null;
              }
              this.eatContextual(89) ? specifier.local = this.parseIdentifier() : (isBinding = true, specifier.local = cloneIdentifier(specifier.imported));
            }
            const specifierIsTypeImport = hasTypeImportKind(specifier);
            return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, { node: specifier }), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, true), !isBinding || isInTypeOnlyImport || specifierIsTypeImport || this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true), this.checkLVal(specifier.local, "import specifier", 9), this.finishNode(specifier, "ImportSpecifier");
          }
          parseBindingAtom() {
            return this.state.type === 74 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(node, allowModifiers) {
            const kind = node.kind;
            kind !== "get" && kind !== "set" && this.match(45) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(node, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            if (this.match(14)) {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, node.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node, call);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx;
            let jsx, state = null;
            if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
              if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state), !jsx.error)
                return jsx.node;
              const { context } = this.state, currentContext = context[context.length - 1];
              currentContext !== types.j_oTag && currentContext !== types.j_expr || context.pop();
            }
            if ((_jsx = jsx) != null && _jsx.error || this.match(45)) {
              var _jsx2, _jsx3;
              let typeParameters;
              state = state || this.state.clone();
              const arrow = this.tryParse((abort) => {
                var _arrowExpression$extr;
                typeParameters = this.flowParseTypeParameterDeclaration();
                const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
                  const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                  return this.resetStartLocationFromNode(result, typeParameters), result;
                });
                (_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized && abort();
                const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
                return expr.type !== "ArrowFunctionExpression" && abort(), expr.typeParameters = typeParameters, this.resetStartLocationFromNode(expr, typeParameters), arrowExpression2;
              }, state);
              let arrowExpression = null;
              if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
                if (!arrow.error && !arrow.aborted)
                  return arrow.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, { node: typeParameters }), arrow.node;
                arrowExpression = arrow.node;
              }
              if ((_jsx2 = jsx) != null && _jsx2.node)
                return this.state = jsx.failState, jsx.node;
              if (arrowExpression)
                return this.state = arrow.failState, arrowExpression;
              if ((_jsx3 = jsx) != null && _jsx3.thrown)
                throw jsx.error;
              if (arrow.thrown)
                throw arrow.error;
              throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, { node: typeParameters });
            }
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse(() => {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const typeNode = this.startNode();
                return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), typeNode;
              });
              if (result.thrown)
                return null;
              result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node);
          }
          shouldParseArrow(params) {
            return this.match(14) || super.shouldParseArrow(params);
          }
          setArrowFunctionParameters(node, params) {
            this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1 ? node.params = params : super.setArrowFunctionParameters(node, params);
          }
          checkParams(node, allowDuplicates, isArrowFunction) {
            if (!isArrowFunction || this.state.noArrowParamsConversionAt.indexOf(node.start) === -1) {
              for (let i = 0; i < node.params.length; i++)
                this.isThisParam(node.params[i]) && i > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, { node: node.params[i] });
              return super.checkParams(...arguments);
            }
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(base, startPos, startLoc, noCalls) {
            if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
              this.next();
              const node = this.startNodeAt(startPos, startLoc);
              node.callee = base, node.arguments = this.parseCallExpressionArguments(11, false), base = this.finishNode(node, "CallExpression");
            } else if (base.type === "Identifier" && base.name === "async" && this.match(45)) {
              const state = this.state.clone(), arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
              if (!arrow.error && !arrow.aborted)
                return arrow.node;
              const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
              if (result.node && !result.error)
                return result.node;
              if (arrow.node)
                return this.state = arrow.failState, arrow.node;
              if (result.node)
                return this.state = result.failState, result.node;
              throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startPos, startLoc, noCalls);
          }
          parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (subscriptState.optionalChainMember = true, noCalls)
                return subscriptState.stop = true, base;
              this.next();
              const node = this.startNodeAt(startPos, startLoc);
              return node.callee = base, node.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), node.arguments = this.parseCallExpressionArguments(11, false), node.optional = true, this.finishCallExpression(node, true);
            }
            if (!noCalls && this.shouldParseTypes() && this.match(45)) {
              const node = this.startNodeAt(startPos, startLoc);
              node.callee = base;
              const result = this.tryParse(() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), node.arguments = this.parseCallExpressionArguments(11, false), subscriptState.optionalChainMember && (node.optional = false), this.finishCallExpression(node, subscriptState.optionalChainMember)));
              if (result.node)
                return result.error && (this.state = result.failState), result.node;
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
          }
          parseNewArguments(node) {
            let targs = null;
            this.shouldParseTypes() && this.match(45) && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), node.typeArguments = targs, super.parseNewArguments(node);
          }
          parseAsyncArrowWithTypeParameters(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            if (this.parseFunctionParams(node), this.parseArrow(node))
              return this.parseArrowExpression(node, void 0, true);
          }
          readToken_mult_modulo(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (code === 42 && next === 47 && this.state.hasFlowComment)
              return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(code);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            code !== 124 || next !== 125 ? super.readToken_pipe_amp(code) : this.finishOp(9, 2);
          }
          parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, { at: this.state.curPosition() }), fileNode;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment)
                throw this.raise(FlowErrors.NestedFlowComment, { at: this.state.startLoc });
              return this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
            }
            if (!this.state.hasFlowComment)
              return super.skipBlockComment();
            {
              const end = this.input.indexOf("*-/", this.state.pos + 2);
              if (end === -1)
                throw this.raise(ErrorMessages.UnterminatedComment, { at: this.state.curPosition() });
              this.state.pos = end + 2 + 3;
            }
          }
          skipFlowComment() {
            const { pos } = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            for (; [32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)); )
              shiftToFirstNonWhiteSpace++;
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            return ch2 === 58 && ch3 === 58 ? shiftToFirstNonWhiteSpace + 2 : this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include" ? shiftToFirstNonWhiteSpace + 12 : ch2 === 58 && ch3 !== 58 && shiftToFirstNonWhiteSpace;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(ErrorMessages.UnterminatedComment, { at: this.state.curPosition() });
          }
          flowEnumErrorBooleanMemberNotInitialized(loc, { enumName, memberName }) {
            this.raise(FlowErrors.EnumBooleanMemberNotInitialized, { at: loc }, memberName, enumName);
          }
          flowEnumErrorInvalidExplicitType(loc, { enumName, suppliedType }) {
            return this.raise(suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, { at: loc }, enumName, suppliedType);
          }
          flowEnumErrorInvalidMemberInitializer(loc, { enumName, explicitType, memberName }) {
            return this.raise(explicitType === "boolean" || explicitType === "number" || explicitType === "string" ? FlowErrors.EnumInvalidMemberInitializerPrimaryType : explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerUnknownType, { at: loc }, enumName, memberName, explicitType);
          }
          flowEnumErrorNumberMemberNotInitialized(loc, { enumName, memberName }) {
            this.raise(FlowErrors.EnumNumberMemberNotInitialized, { at: loc }, enumName, memberName);
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(node, { enumName }) {
            this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, { node }, enumName);
          }
          flowEnumMemberInit() {
            const startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 126: {
                const literal = this.parseNumericLiteral(this.state.value);
                return endOfInit() ? { type: "number", loc: literal.loc.start, value: literal } : { type: "invalid", loc: startLoc };
              }
              case 125: {
                const literal = this.parseStringLiteral(this.state.value);
                return endOfInit() ? { type: "string", loc: literal.loc.start, value: literal } : { type: "invalid", loc: startLoc };
              }
              case 81:
              case 82: {
                const literal = this.parseBooleanLiteral(this.match(81));
                return endOfInit() ? { type: "boolean", loc: literal.loc.start, value: literal } : { type: "invalid", loc: startLoc };
              }
              default:
                return { type: "invalid", loc: startLoc };
            }
          }
          flowEnumMemberRaw() {
            const loc = this.state.startLoc;
            return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc } };
          }
          flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
            const { explicitType } = context;
            explicitType !== null && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
          flowEnumMembers({ enumName, explicitType }) {
            const seenNames = /* @__PURE__ */ new Set(), members = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let hasUnknownMembers = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                hasUnknownMembers = true;
                break;
              }
              const memberNode = this.startNode(), { id, init } = this.flowEnumMemberRaw(), memberName = id.name;
              if (memberName === "")
                continue;
              /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, { node: id }, memberName, memberName[0].toUpperCase() + memberName.slice(1), enumName), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, { node: id }, memberName, enumName), seenNames.add(memberName);
              const context = { enumName, explicitType, memberName };
              switch (memberNode.id = id, init.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
                case "none":
                  switch (explicitType) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                      break;
                    default:
                      members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members, hasUnknownMembers };
          }
          flowEnumStringMembers(initializedMembers, defaultedMembers, { enumName }) {
            if (initializedMembers.length === 0)
              return defaultedMembers;
            if (defaultedMembers.length === 0)
              return initializedMembers;
            if (defaultedMembers.length > initializedMembers.length) {
              for (const member of initializedMembers)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(member, { enumName });
              return defaultedMembers;
            }
            for (const member of defaultedMembers)
              this.flowEnumErrorStringMemberInconsistentlyInitailized(member, { enumName });
            return initializedMembers;
          }
          flowEnumParseExplicitType({ enumName }) {
            if (this.eatContextual(97)) {
              if (!tokenIsIdentifier(this.state.type))
                throw this.flowEnumErrorInvalidExplicitType(this.state.startLoc, { enumName, suppliedType: null });
              const { value } = this.state;
              return this.next(), value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.startLoc, { enumName, suppliedType: value }), value;
            }
            return null;
          }
          flowEnumBody(node, id) {
            const enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({ enumName });
            this.expect(5);
            const { members, hasUnknownMembers } = this.flowEnumMembers({ enumName, explicitType });
            switch (node.hasUnknownMembers = hasUnknownMembers, explicitType) {
              case "boolean":
                return node.explicitType = true, node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
              case "number":
                return node.explicitType = true, node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
              case "string":
                return node.explicitType = true, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName }), this.expect(8), this.finishNode(node, "EnumStringBody");
              case "symbol":
                return node.members = members.defaultedMembers, this.expect(8), this.finishNode(node, "EnumSymbolBody");
              default: {
                const empty = () => (node.members = [], this.expect(8), this.finishNode(node, "EnumStringBody"));
                node.explicitType = false;
                const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
                if (boolsLen || numsLen || strsLen || defaultedLen) {
                  if (boolsLen || numsLen) {
                    if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, { enumName, memberName: member.id.name });
                      return node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
                    }
                    if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, { enumName, memberName: member.id.name });
                      return node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
                    }
                    return this.raise(FlowErrors.EnumInconsistentMemberValues, { at: nameLoc }, enumName), empty();
                  }
                  return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, { enumName }), this.expect(8), this.finishNode(node, "EnumStringBody");
                }
                return empty();
              }
            }
          }
          flowParseEnumDeclaration(node) {
            const id = this.parseIdentifier();
            return node.id = id, node.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (this.input.charCodeAt(next) === 60) {
              const afterNext = this.input.charCodeAt(next + 1);
              return afterNext !== 60 && afterNext !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(node) {
            return node.type === "TypeCastExpression" ? node.expression : node;
          }
        }, typescript: (superClass) => class extends superClass {
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(51) || this.match(21) || this.match(130) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
            if (!tokenIsIdentifier(this.state.type))
              return;
            const modifier = this.state.value;
            if (allowedModifiers.indexOf(modifier) !== -1) {
              if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return modifier;
            }
          }
          tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
            const enforceOrder = (loc, modifier, before, after) => {
              modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, { at: loc }, before, after);
            }, incompatible = (loc, modifier, mod1, mod2) => {
              (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, { at: loc }, mod1, mod2);
            };
            for (; ; ) {
              const { startLoc } = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
              if (!modifier)
                break;
              tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, { at: startLoc }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : (Object.hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, { at: startLoc }, modifier) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), modified[modifier] = true), disallowedModifiers != null && disallowedModifiers.includes(modifier) && this.raise(errorTemplate, { at: startLoc }, modifier);
            }
          }
          tsIsListTerminator(kind) {
            switch (kind) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(46);
            }
            throw new Error("Unreachable");
          }
          tsParseList(kind, parseElement) {
            const result = [];
            for (; !this.tsIsListTerminator(kind); )
              result.push(parseElement());
            return result;
          }
          tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
            return function(x) {
              if (x == null)
                throw new Error(`Unexpected ${x} value.`);
              return x;
            }(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
          }
          tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
            const result = [];
            let trailingCommaPos = -1;
            for (; !this.tsIsListTerminator(kind); ) {
              trailingCommaPos = -1;
              const element = parseElement();
              if (element == null)
                return;
              if (result.push(element), !this.eat(12)) {
                if (this.tsIsListTerminator(kind))
                  break;
                return void (expectSuccess && this.expect(12));
              }
              trailingCommaPos = this.state.lastTokStart;
            }
            return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
          }
          tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
            skipFirstToken || (bracket ? this.expect(0) : this.expect(45));
            const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
            return bracket ? this.expect(3) : this.expect(46), result;
          }
          tsParseImportType() {
            const node = this.startNode();
            return this.expect(79), this.expect(10), this.match(125) || this.raise(TSErrors.UnsupportedImportTypeArgument, { at: this.state.startLoc }), node.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (node.qualifier = this.tsParseEntityName(true)), this.match(45) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
          }
          tsParseEntityName(allowReservedWords) {
            let entity = this.parseIdentifier();
            for (; this.eat(16); ) {
              const node = this.startNodeAtNode(entity);
              node.left = entity, node.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node, "TSQualifiedName");
            }
            return entity;
          }
          tsParseTypeReference() {
            const node = this.startNode();
            return node.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.match(45) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSTypeReference");
          }
          tsParseThisTypePredicate(lhs) {
            this.next();
            const node = this.startNodeAtNode(lhs);
            return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(false), node.asserts = false, this.finishNode(node, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const node = this.startNode();
            return this.next(), this.finishNode(node, "TSThisType");
          }
          tsParseTypeQuery() {
            const node = this.startNode();
            return this.expect(83), this.match(79) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(true), this.finishNode(node, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const node = this.startNode();
            return node.name = this.tsParseTypeParameterName(), node.constraint = this.tsEatThenParseType(77), node.default = this.tsEatThenParseType(29), this.finishNode(node, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.match(45))
              return this.tsParseTypeParameters();
          }
          tsParseTypeParameters() {
            const node = this.startNode();
            this.match(45) || this.match(134) ? this.next() : this.unexpected();
            const refTrailingCommaPos = { value: -1 };
            return node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos), node.params.length === 0 && this.raise(TSErrors.EmptyTypeParameters, { node }), refTrailingCommaPos.value !== -1 && this.addExtra(node, "trailingComma", refTrailingCommaPos.value), this.finishNode(node, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            return this.lookahead().type === 71 ? (this.next(), this.tsParseTypeReference()) : null;
          }
          tsFillSignature(returnToken, signature) {
            const returnTokenRequired = returnToken === 19;
            signature.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), signature.parameters = this.tsParseBindingListForSignature(), (returnTokenRequired || this.match(returnToken)) && (signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(11, 41).map((pattern) => (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern" && this.raise(TSErrors.UnsupportedSignatureParameterKind, { node: pattern }, pattern.type), pattern));
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(kind, node) {
            return this.tsFillSignature(14, node), this.tsParseTypeMemberSemicolon(), this.finishNode(node, kind);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!tokenIsIdentifier(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(node) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(0);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), node.parameters = [id];
            const type = this.tsTryParseTypeAnnotation();
            return type && (node.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(node, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(node, readonly) {
            this.eat(17) && (node.optional = true);
            const nodeAny = node;
            if (this.match(10) || this.match(45)) {
              readonly && this.raise(TSErrors.ReadonlyForMethodSignature, { node });
              const method = nodeAny;
              method.kind && this.match(45) && this.raise(TSErrors.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
              const paramsKey = "parameters", returnTypeKey = "typeAnnotation";
              if (method.kind === "get")
                method[paramsKey].length > 0 && (this.raise(ErrorMessages.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
              else if (method.kind === "set") {
                if (method[paramsKey].length !== 1)
                  this.raise(ErrorMessages.BadSetterArity, { at: this.state.curPosition() });
                else {
                  const firstParameter = method[paramsKey][0];
                  this.isThisParam(firstParameter) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), firstParameter.type === "Identifier" && firstParameter.optional && this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), firstParameter.type === "RestElement" && this.raise(TSErrors.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                }
                method[returnTypeKey] && this.raise(TSErrors.SetAccesorCannotHaveReturnType, { node: method[returnTypeKey] });
              } else
                method.kind = "method";
              return this.finishNode(method, "TSMethodSignature");
            }
            {
              const property = nodeAny;
              readonly && (property.readonly = true);
              const type = this.tsTryParseTypeAnnotation();
              return type && (property.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), this.finishNode(property, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const node = this.startNode();
            if (this.match(10) || this.match(45))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
            if (this.match(73)) {
              const id = this.startNode();
              return this.next(), this.match(10) || this.match(45) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), this.tsParsePropertyOrMethodSignature(node, false));
            }
            this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
            const idx = this.tsTryParseIndexSignature(node);
            return idx || (this.parsePropertyName(node), node.computed || node.key.type !== "Identifier" || node.key.name !== "get" && node.key.name !== "set" || !this.tsTokenCanFollowModifier() || (node.kind = node.key.name, this.parsePropertyName(node)), this.tsParsePropertyOrMethodSignature(node, !!node.readonly));
          }
          tsParseTypeLiteral() {
            const node = this.startNode();
            return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), members;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(49) ? this.isContextual(114) : (this.isContextual(114) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(54))));
          }
          tsParseMappedTypeParameter() {
            const node = this.startNode();
            return node.name = this.tsParseTypeParameterName(), node.constraint = this.tsExpectThenParseType(54), this.finishNode(node, "TSTypeParameter");
          }
          tsParseMappedType() {
            const node = this.startNode();
            return this.expect(5), this.match(49) ? (node.readonly = this.state.value, this.next(), this.expectContextual(114)) : this.eatContextual(114) && (node.readonly = true), this.expect(0), node.typeParameter = this.tsParseMappedTypeParameter(), node.nameType = this.eatContextual(89) ? this.tsParseType() : null, this.expect(3), this.match(49) ? (node.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (node.optional = true), node.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(node, "TSMappedType");
          }
          tsParseTupleType() {
            const node = this.startNode();
            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let seenOptionalElement = false, labeledElements = null;
            return node.elementTypes.forEach((elementNode) => {
              var _labeledElements;
              let { type } = elementNode;
              !seenOptionalElement || type === "TSRestType" || type === "TSOptionalType" || type === "TSNamedTupleMember" && elementNode.optional || this.raise(TSErrors.OptionalTypeBeforeRequired, { node: elementNode }), seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType", type === "TSRestType" && (type = (elementNode = elementNode.typeAnnotation).type);
              const isLabeled = type === "TSNamedTupleMember";
              labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled, labeledElements !== isLabeled && this.raise(TSErrors.MixedLabeledAndUnlabeledElements, { node: elementNode });
            }), this.finishNode(node, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { start: startPos, startLoc } = this.state, rest = this.eat(21);
            let type = this.tsParseType();
            const optional = this.eat(17);
            if (this.eat(14)) {
              const labeledNode = this.startNodeAtNode(type);
              labeledNode.optional = optional, type.type !== "TSTypeReference" || type.typeParameters || type.typeName.type !== "Identifier" ? (this.raise(TSErrors.InvalidTupleMemberLabel, { node: type }), labeledNode.label = type) : labeledNode.label = type.typeName, labeledNode.elementType = this.tsParseType(), type = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
              const optionalTypeNode = this.startNodeAtNode(type);
              optionalTypeNode.typeAnnotation = type, type = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
              const restNode = this.startNodeAt(startPos, startLoc);
              restNode.typeAnnotation = type, type = this.finishNode(restNode, "TSRestType");
            }
            return type;
          }
          tsParseParenthesizedType() {
            const node = this.startNode();
            return this.expect(10), node.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(node, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(type, abstract) {
            const node = this.startNode();
            return type === "TSConstructorType" && (node.abstract = !!abstract, abstract && this.next(), this.next()), this.tsFillSignature(19, node), this.finishNode(node, type);
          }
          tsParseLiteralTypeNode() {
            const node = this.startNode();
            return node.literal = (() => {
              switch (this.state.type) {
                case 126:
                case 127:
                case 125:
                case 81:
                case 82:
                  return this.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })(), this.finishNode(node, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const node = this.startNode();
            return node.literal = this.parseTemplate(false), this.finishNode(node, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            return this.isContextual(109) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 125:
              case 126:
              case 127:
              case 81:
              case 82:
                return this.tsParseLiteralTypeNode();
              case 49:
                if (this.state.value === "-") {
                  const node = this.startNode(), nextToken = this.lookahead();
                  if (nextToken.type !== 126 && nextToken.type !== 127)
                    throw this.unexpected();
                  return node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
                }
                break;
              case 74:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 83:
                return this.tsParseTypeQuery();
              case 79:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type } = this.state;
                if (tokenIsIdentifier(type) || type === 84 || type === 80) {
                  const nodeType = type === 84 ? "TSVoidKeyword" : type === 80 ? "TSNullKeyword" : function(value) {
                    switch (value) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                    const node = this.startNode();
                    return this.next(), this.finishNode(node, nodeType);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let type = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                const node = this.startNodeAtNode(type);
                node.elementType = type, this.expect(3), type = this.finishNode(node, "TSArrayType");
              } else {
                const node = this.startNodeAtNode(type);
                node.objectType = type, node.indexType = this.tsParseType(), this.expect(3), type = this.finishNode(node, "TSIndexedAccessType");
              }
            return type;
          }
          tsParseTypeOperator() {
            const node = this.startNode(), operator = this.state.value;
            return this.next(), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), operator === "readonly" && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(node) {
            switch (node.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(TSErrors.UnexpectedReadonly, { node });
            }
          }
          tsParseInferType() {
            const node = this.startNode();
            this.expectContextual(108);
            const typeParameter = this.startNode();
            return typeParameter.name = this.tsParseTypeParameterName(), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), this.finishNode(node, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            var token;
            return (token = this.state.type) >= 113 && token <= 115 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(108) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
            const node = this.startNode(), hasLeadingOperator = this.eat(operator), types2 = [];
            do {
              types2.push(parseConstituentType());
            } while (this.eat(operator));
            return types2.length !== 1 || hasLeadingOperator ? (node.types = types2, this.finishNode(node, kind)) : types2[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 43);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 41);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(45) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(74))
              return this.next(), true;
            if (this.match(5)) {
              let braceStackCounter = 1;
              for (this.next(); braceStackCounter > 0; )
                this.match(5) ? ++braceStackCounter : this.match(8) && --braceStackCounter, this.next();
              return true;
            }
            if (this.match(0)) {
              let braceStackCounter = 1;
              for (this.next(); braceStackCounter > 0; )
                this.match(0) ? ++braceStackCounter : this.match(3) && --braceStackCounter, this.next();
              return true;
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21))
              return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(29))
                return true;
              if (this.match(11) && (this.next(), this.match(19)))
                return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(returnToken) {
            return this.tsInType(() => {
              const t = this.startNode();
              this.expect(returnToken);
              const node = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (asserts && this.match(74)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                return thisTypePredicate.type === "TSThisType" ? (node.parameterName = thisTypePredicate, node.asserts = true, node.typeAnnotation = null, thisTypePredicate = this.finishNode(node, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node), thisTypePredicate.asserts = true), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
              }
              const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!typePredicateVariable)
                return asserts ? (node.parameterName = this.parseIdentifier(), node.asserts = asserts, node.typeAnnotation = null, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t);
              const type = this.tsParseTypeAnnotation(false);
              return node.parameterName = typePredicateVariable, node.typeAnnotation = type, node.asserts = asserts, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual(109) && !this.hasPrecedingLineBreak())
              return this.next(), id;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 102)
              return false;
            const containsEsc = this.state.containsEsc;
            return this.next(), !(!tokenIsIdentifier(this.state.type) && !this.match(74)) && (containsEsc && this.raise(ErrorMessages.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc }, "asserts"), true);
          }
          tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
            return this.tsInType(() => {
              eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
            }), this.finishNode(t, "TSTypeAnnotation");
          }
          tsParseType() {
            assert(this.state.inType);
            const type = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(77))
              return type;
            const node = this.startNodeAtNode(type);
            return node.checkType = type, node.extendsType = this.tsParseNonConditionalType(), this.expect(17), node.trueType = this.tsParseType(), this.expect(14), node.falseType = this.tsParseType(), this.finishNode(node, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(116) && this.lookahead().type === 73;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(73) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });
            const node = this.startNode(), _const = this.tsTryNextParseConstantContext();
            return node.typeAnnotation = _const || this.tsNextThenParseType(), this.expect(46), node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
          }
          tsParseHeritageClause(descriptor) {
            const originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, { at: originalStartLoc }, descriptor), delimitedList;
          }
          tsParseExpressionWithTypeArguments() {
            const node = this.startNode();
            return node.expression = this.tsParseEntityName(false), this.match(45) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(node) {
            tokenIsIdentifier(this.state.type) ? (node.id = this.parseIdentifier(), this.checkLVal(node.id, "typescript interface declaration", 130)) : (node.id = null, this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc })), node.typeParameters = this.tsTryParseTypeParameters(), this.eat(77) && (node.extends = this.tsParseHeritageClause("extends"));
            const body = this.startNode();
            return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), this.finishNode(node, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(node) {
            return node.id = this.parseIdentifier(), this.checkLVal(node.id, "typescript type alias", 2), node.typeParameters = this.tsTryParseTypeParameters(), node.typeAnnotation = this.tsInType(() => {
              if (this.expect(29), this.isContextual(107) && this.lookahead().type !== 16) {
                const node2 = this.startNode();
                return this.next(), this.finishNode(node2, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
          }
          tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [oldContext[0]];
            try {
              return cb();
            } finally {
              this.state.context = oldContext;
            }
          }
          tsInType(cb) {
            const oldInType = this.state.inType;
            this.state.inType = true;
            try {
              return cb();
            } finally {
              this.state.inType = oldInType;
            }
          }
          tsEatThenParseType(token) {
            return this.match(token) ? this.tsNextThenParseType() : void 0;
          }
          tsExpectThenParseType(token) {
            return this.tsDoThenParseType(() => this.expect(token));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType(() => this.next());
          }
          tsDoThenParseType(cb) {
            return this.tsInType(() => (cb(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const node = this.startNode();
            return node.id = this.match(125) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (node.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(node, "TSEnumMember");
          }
          tsParseEnumDeclaration(node, isConst) {
            return isConst && (node.const = true), node.id = this.parseIdentifier(), this.checkLVal(node.id, "typescript enum declaration", isConst ? 779 : 267), this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(node, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const node = this.startNode();
            return this.scope.enter(0), this.expect(5), this.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(node, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(node, nested = false) {
            if (node.id = this.parseIdentifier(), nested || this.checkLVal(node.id, "module or namespace declaration", 1024), this.eat(16)) {
              const inner = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(inner, true), node.body = inner;
            } else
              this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(node) {
            return this.isContextual(105) ? (node.global = true, node.id = this.parseIdentifier()) : this.match(125) ? node.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(node, isExport) {
            node.isExport = isExport || false, node.id = this.parseIdentifier(), this.checkLVal(node.id, "import equals declaration", 9), this.expect(29);
            const moduleReference = this.tsParseModuleReference();
            return node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference" && this.raise(TSErrors.ImportAliasHasImportType, { node: moduleReference }), node.moduleReference = moduleReference, this.semicolon(), this.finishNode(node, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(112) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const node = this.startNode();
            if (this.expectContextual(112), this.expect(10), !this.match(125))
              throw this.unexpected();
            return node.expression = this.parseExprAtom(), this.expect(11), this.finishNode(node, "TSExternalModuleReference");
          }
          tsLookAhead(f) {
            const state = this.state.clone(), res = f();
            return this.state = state, res;
          }
          tsTryParseAndCatch(f) {
            const result = this.tryParse((abort) => f() || abort());
            if (!result.aborted && result.node)
              return result.error && (this.state = result.failState), result.node;
          }
          tsTryParse(f) {
            const state = this.state.clone(), result = f();
            return result !== void 0 && result !== false ? result : void (this.state = state);
          }
          tsTryParseDeclare(nany) {
            if (this.isLineTerminator())
              return;
            let kind, starttype = this.state.type;
            return this.isContextual(95) && (starttype = 70, kind = "let"), this.tsInAmbientContext(() => {
              switch (starttype) {
                case 64:
                  return nany.declare = true, this.parseFunctionStatement(nany, false, true);
                case 76:
                  return nany.declare = true, this.parseClass(nany, true, false);
                case 71:
                  if (this.match(71) && this.isLookaheadContextual("enum"))
                    return this.expect(71), this.expectContextual(118), this.tsParseEnumDeclaration(nany, true);
                case 70:
                  return kind = kind || this.state.value, this.parseVarStatement(nany, kind);
                case 105:
                  return this.tsParseAmbientExternalModuleDeclaration(nany);
                default:
                  if (tokenIsIdentifier(starttype))
                    return this.tsParseDeclaration(nany, this.state.value, true);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
          }
          tsParseExpressionStatement(node, expr) {
            switch (expr.name) {
              case "declare": {
                const declaration = this.tsTryParseDeclare(node);
                if (declaration)
                  return declaration.declare = true, declaration;
                break;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const mod = node;
                  return mod.global = true, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(node, expr.name, false);
            }
          }
          tsParseDeclaration(node, value, next) {
            switch (value) {
              case "abstract":
                if (this.tsCheckLineTerminator(next) && (this.match(76) || tokenIsIdentifier(this.state.type)))
                  return this.tsParseAbstractDeclaration(node);
                break;
              case "enum":
                if (next || tokenIsIdentifier(this.state.type))
                  return next && this.next(), this.tsParseEnumDeclaration(node, false);
                break;
              case "interface":
                if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
                  return this.tsParseInterfaceDeclaration(node);
                break;
              case "module":
                if (this.tsCheckLineTerminator(next)) {
                  if (this.match(125))
                    return this.tsParseAmbientExternalModuleDeclaration(node);
                  if (tokenIsIdentifier(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(node);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(node);
                break;
              case "type":
                if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type))
                  return this.tsParseTypeAliasDeclaration(node);
            }
          }
          tsCheckLineTerminator(next) {
            return next ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
            if (!this.match(45))
              return;
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const res = this.tsTryParseAndCatch(() => {
              const node = this.startNodeAt(startPos, startLoc);
              return node.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(node), node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), node;
            });
            return this.state.maybeInArrowParameters = oldMaybeInArrowParameters, res ? this.parseArrowExpression(res, null, true) : void 0;
          }
          tsParseTypeArguments() {
            const node = this.startNode();
            return node.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(45), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), node.params.length === 0 && this.raise(TSErrors.EmptyTypeArguments, { node }), this.expect(46), this.finishNode(node, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (token = this.state.type) >= 116 && token <= 122;
            var token;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(allowModifiers, decorators) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let accessibility, readonly = false, override = false;
            if (allowModifiers !== void 0) {
              const modified = {};
              this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]), accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly, allowModifiers === false && (accessibility || readonly || override) && this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });
            }
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            if (accessibility || readonly || override) {
              const pp = this.startNodeAt(startPos, startLoc);
              return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), readonly && (pp.readonly = readonly), override && (pp.override = override), elt.type !== "Identifier" && elt.type !== "AssignmentPattern" && this.raise(TSErrors.UnsupportedParameterPropertyKind, { node: pp }), pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
            }
            return decorators.length && (left.decorators = decorators), elt;
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            this.match(14) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : bodilessType === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, { node }), node.declare) ? super.parseFunctionBodyAndFinish(node, bodilessType, isMethod) : super.parseFunctionBodyAndFinish(node, type, isMethod);
          }
          registerFunctionStatementId(node) {
            !node.body && node.id ? this.checkLVal(node.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
          }
          tsCheckForInvalidTypeCasts(items) {
            items.forEach((node) => {
              (node == null ? void 0 : node.type) === "TSTypeCastExpression" && this.raise(TSErrors.UnexpectedTypeAnnotation, { node: node.typeAnnotation });
            });
          }
          toReferencedList(exprList, isInParens) {
            return this.tsCheckForInvalidTypeCasts(exprList), exprList;
          }
          parseArrayLike(...args) {
            const node = super.parseArrayLike(...args);
            return node.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(node.elements), node;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              const nonNullExpression = this.startNodeAt(startPos, startLoc);
              return nonNullExpression.expression = base, this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            let isOptionalCall = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (noCalls)
                return state.stop = true, base;
              state.optionalChainMember = isOptionalCall = true, this.next();
            }
            if (this.match(45)) {
              let missingParenErrorLoc;
              const result = this.tsTryParseAndCatch(() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                  const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                  if (asyncArrowFn)
                    return asyncArrowFn;
                }
                const node = this.startNodeAt(startPos, startLoc);
                node.callee = base;
                const typeArguments = this.tsParseTypeArguments();
                if (typeArguments) {
                  if (isOptionalCall && !this.match(10) && (missingParenErrorLoc = this.state.curPosition(), this.unexpected()), !noCalls && this.eat(10))
                    return node.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(node.arguments), node.typeParameters = typeArguments, state.optionalChainMember && (node.optional = isOptionalCall), this.finishCallExpression(node, state.optionalChainMember);
                  if (tokenIsTemplate(this.state.type)) {
                    const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                    return result2.typeParameters = typeArguments, result2;
                  }
                }
                this.unexpected();
              });
              if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result)
                return result;
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, state);
          }
          parseNewArguments(node) {
            if (this.match(45)) {
              const typeParameters = this.tsTryParseAndCatch(() => {
                const args = this.tsParseTypeArguments();
                return this.match(10) || this.unexpected(), args;
              });
              typeParameters && (node.typeParameters = typeParameters);
            }
            super.parseNewArguments(node);
          }
          parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            if (tokenOperatorPrecedence(54) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(89)) {
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.expression = left;
              const _const = this.tsTryNextParseConstantContext();
              return node.typeAnnotation = _const || this.tsNextThenParseType(), this.finishNode(node, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          }
          checkDuplicateExports() {
          }
          parseImport(node) {
            if (node.importKind = "value", tokenIsIdentifier(this.state.type) || this.match(51) || this.match(5)) {
              let ahead = this.lookahead();
              if (this.isContextual(122) && ahead.type !== 12 && ahead.type !== 93 && ahead.type !== 29 && (node.importKind = "type", this.next(), ahead = this.lookahead()), tokenIsIdentifier(this.state.type) && ahead.type === 29)
                return this.tsParseImportEqualsDeclaration(node);
            }
            const importNode = super.parseImport(node);
            return importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, { node: importNode }), importNode;
          }
          parseExport(node) {
            if (this.match(79))
              return this.next(), this.isContextual(122) && this.lookaheadCharCode() !== 61 ? (node.importKind = "type", this.next()) : node.importKind = "value", this.tsParseImportEqualsDeclaration(node, true);
            if (this.eat(29)) {
              const assign = node;
              return assign.expression = this.parseExpression(), this.semicolon(), this.finishNode(assign, "TSExportAssignment");
            }
            if (this.eatContextual(89)) {
              const decl = node;
              return this.expectContextual(120), decl.id = this.parseIdentifier(), this.semicolon(), this.finishNode(decl, "TSNamespaceExportDeclaration");
            }
            return this.isContextual(122) && this.lookahead().type === 5 ? (this.next(), node.exportKind = "type") : node.exportKind = "value", super.parseExport(node);
          }
          isAbstractClass() {
            return this.isContextual(116) && this.lookahead().type === 76;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const cls = this.startNode();
              return this.next(), cls.abstract = true, this.parseClass(cls, true, true), cls;
            }
            if (this.match(121)) {
              const interfaceNode = this.startNode();
              this.next();
              const result = this.tsParseInterfaceDeclaration(interfaceNode);
              if (result)
                return result;
            }
            return super.parseExportDefaultExpression();
          }
          parseStatementContent(context, topLevel) {
            if (this.state.type === 71) {
              if (this.lookahead().type === 118) {
                const node = this.startNode();
                return this.next(), this.expectContextual(118), this.tsParseEnumDeclaration(node, true);
              }
            }
            return super.parseStatementContent(context, topLevel);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier) => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(100) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(classBody, member, state) {
            const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers(member, modifiers, void 0, void 0, true);
            const callParseClassMemberWithIsStatic = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), this.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            };
            member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const idx = this.tsTryParseIndexSignature(member);
            if (idx)
              return classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, { node: member }), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, { node: member }, member.accessibility), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, { node: member }), void (member.override && this.raise(TSErrors.IndexSignatureHasOverride, { node: member }));
            !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, { node: member }), member.override && (state.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, { node: member })), super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parsePostMemberNameModifiers(methodOrProp) {
            this.eat(17) && (methodOrProp.optional = true), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, { node: methodOrProp }), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, { node: methodOrProp });
          }
          parseExpressionStatement(node, expr) {
            return (expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0) || super.parseExpressionStatement(node, expr);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(expr, startPos, startLoc, refExpressionErrors) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
            const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
            return result.node ? (result.error && (this.state = result.failState), result.node) : (result.error && super.setOptionalParametersError(refExpressionErrors, result.error), expr);
          }
          parseParenItem(node, startPos, startLoc) {
            if (node = super.parseParenItem(node, startPos, startLoc), this.eat(17) && (node.optional = true, this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node;
          }
          parseExportDeclaration(node) {
            const startPos = this.state.start, startLoc = this.state.startLoc, isDeclare = this.eatContextual(117);
            if (isDeclare && (this.isContextual(117) || !this.shouldParseExportDeclaration()))
              throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
            let declaration;
            return tokenIsIdentifier(this.state.type) && (declaration = this.tsTryParseExportDeclaration()), declaration || (declaration = super.parseExportDeclaration(node)), declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) && (node.exportKind = "type"), declaration && isDeclare && (this.resetStartLocation(declaration, startPos, startLoc), declaration.declare = true), declaration;
          }
          parseClassId(node, isStatement, optionalId) {
            if ((!isStatement || optionalId) && this.isContextual(106))
              return;
            super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 139);
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (node.typeParameters = typeParameters);
          }
          parseClassPropertyAnnotation(node) {
            !node.optional && this.eat(35) && (node.definite = true);
            const type = this.tsTryParseTypeAnnotation();
            type && (node.typeAnnotation = type);
          }
          parseClassProperty(node) {
            if (this.parseClassPropertyAnnotation(node), this.state.isAmbientContext && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), node.abstract && this.match(29)) {
              const { key } = node;
              this.raise(TSErrors.AbstractPropertyHasInitializer, { at: this.state.startLoc }, key.type !== "Identifier" || node.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name);
            }
            return super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return node.abstract && this.raise(TSErrors.PrivateElementHasAbstract, { node }), node.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, { node }, node.accessibility), this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, { node: typeParameters }), !method.declare || method.kind !== "get" && method.kind !== "set" || this.raise(TSErrors.DeclareAccessor, { node: method }, method.kind), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          declareClassPrivateMethodInScope(node, kind) {
            node.type !== "TSDeclareMethod" && (node.type !== "MethodDefinition" || node.value.body) && super.declareClassPrivateMethodInScope(node, kind);
          }
          parseClassSuper(node) {
            super.parseClassSuper(node), node.superClass && this.match(45) && (node.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual(106) && (node.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(prop, ...args) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, ...args);
          }
          parseFunctionParams(node, allowModifiers) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = true);
            const type = this.tsTryParseTypeAnnotation();
            type && (decl.id.typeAnnotation = type, this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            return this.match(14) && (node.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node, call);
          }
          parseMaybeAssign(...args) {
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
            let state, jsx, typeCast, typeParameters;
            if (this.hasPlugin("jsx") && (this.match(134) || this.match(45))) {
              if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(...args), state), !jsx.error)
                return jsx.node;
              const { context } = this.state, currentContext = context[context.length - 1];
              currentContext !== types.j_oTag && currentContext !== types.j_expr || context.pop();
            }
            if (!((_jsx = jsx) != null && _jsx.error || this.match(45)))
              return super.parseMaybeAssign(...args);
            state = state || this.state.clone();
            const arrow = this.tryParse((abort) => {
              var _expr$extra, _typeParameters;
              typeParameters = this.tsParseTypeParameters();
              const expr = super.parseMaybeAssign(...args);
              return (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && abort(), ((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0 && this.resetStartLocationFromNode(expr, typeParameters), expr.typeParameters = typeParameters, expr;
            }, state);
            if (!arrow.error && !arrow.aborted)
              return typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
            if (!jsx && (assert(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state), !typeCast.error))
              return typeCast.node;
            if ((_jsx2 = jsx) != null && _jsx2.node)
              return this.state = jsx.failState, jsx.node;
            if (arrow.node)
              return this.state = arrow.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), arrow.node;
            if ((_typeCast = typeCast) != null && _typeCast.node)
              return this.state = typeCast.failState, typeCast.node;
            if ((_jsx3 = jsx) != null && _jsx3.thrown)
              throw jsx.error;
            if (arrow.thrown)
              throw arrow.error;
            if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
              throw typeCast.error;
            throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
          }
          reportReservedArrowTypeParam(node) {
            var _node$extra;
            node.params.length !== 1 || (_node$extra = node.extra) != null && _node$extra.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(TSErrors.ReservedArrowTypeParam, { node });
          }
          parseMaybeUnary(refExpressionErrors) {
            return !this.hasPlugin("jsx") && this.match(45) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse((abort) => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || abort(), returnType;
              });
              if (result.aborted)
                return;
              result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
            }
            return super.parseArrow(node);
          }
          parseAssignableListItemTypes(param) {
            this.eat(17) && (param.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(TSErrors.PatternIsOptional, { node: param }), param.optional = true);
            const type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type), this.resetEndLocation(param), param;
          }
          isAssignable(node, isBinding) {
            switch (node.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(node.expression, isBinding);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(node, isBinding);
            }
          }
          toAssignable(node, isLHS = false) {
            switch (node.type) {
              case "TSTypeCastExpression":
                return super.toAssignable(this.typeCastToParameter(node), isLHS);
              case "TSParameterProperty":
              default:
                return super.toAssignable(node, isLHS);
              case "ParenthesizedExpression":
                return this.toAssignableParenthesizedExpression(node, isLHS);
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                return node.expression = this.toAssignable(node.expression, isLHS), node;
            }
          }
          toAssignableParenthesizedExpression(node, isLHS) {
            switch (node.expression.type) {
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                return node.expression = this.toAssignable(node.expression, isLHS), node;
              default:
                return super.toAssignable(node, isLHS);
            }
          }
          checkLVal(expr, contextDescription, ...args) {
            var _expr$extra2;
            switch (expr.type) {
              case "TSTypeCastExpression":
                return;
              case "TSParameterProperty":
                return void this.checkLVal(expr.parameter, "parameter property", ...args);
              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!(args[0] || contextDescription === "parenthesized expression" || (_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
                  this.raise(ErrorMessages.InvalidLhs, { node: expr }, contextDescription);
                  break;
                }
                return void this.checkLVal(expr.expression, "parenthesized expression", ...args);
              case "TSNonNullExpression":
                return void this.checkLVal(expr.expression, contextDescription, ...args);
              default:
                return void super.checkLVal(expr, contextDescription, ...args);
            }
          }
          parseBindingAtom() {
            return this.state.type === 74 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(expr) {
            if (this.match(45)) {
              const typeArguments = this.tsParseTypeArguments();
              if (this.match(10)) {
                const call = super.parseMaybeDecoratorArguments(expr);
                return call.typeParameters = typeArguments, call;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(expr);
          }
          checkCommaAfterRest(close) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), false) : super.checkCommaAfterRest(close);
          }
          isClassMethod() {
            return this.match(45) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(...args) {
            const node = super.parseMaybeDefault(...args);
            return node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, { node: node.typeAnnotation }), node;
          }
          getTokenFromCode(code) {
            if (this.state.inType) {
              if (code === 62)
                return this.finishOp(46, 1);
              if (code === 60)
                return this.finishOp(45, 1);
            }
            return super.getTokenFromCode(code);
          }
          reScan_lt_gt() {
            const { type } = this.state;
            type === 45 ? (this.state.pos -= 1, this.readToken_lt()) : type === 46 && (this.state.pos -= 1, this.readToken_gt());
          }
          toAssignableList(exprList) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              if (expr)
                switch (expr.type) {
                  case "TSTypeCastExpression":
                    exprList[i] = this.typeCastToParameter(expr);
                    break;
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    this.state.maybeInArrowParameters ? this.raise(TSErrors.UnexpectedTypeCastInParameter, { node: expr }) : exprList[i] = this.typeCastToParameter(expr);
                }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), node.expression;
          }
          shouldParseArrow(params) {
            return this.match(14) ? params.every((expr) => this.isAssignable(expr, true)) : super.shouldParseArrow(params);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(node) {
            if (this.match(45)) {
              const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
              typeArguments && (node.typeParameters = typeArguments);
            }
            return super.jsxParseOpeningElementAfterName(node);
          }
          getGetterSetterExpectedParamCount(method) {
            const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
            return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
          }
          parseCatchClauseParam() {
            const param = super.parseCatchClauseParam(), type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type, this.resetEndLocation(param)), param;
          }
          tsInAmbientContext(cb) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return cb();
            } finally {
              this.state.isAmbientContext = oldIsAmbientContext;
            }
          }
          parseClass(node, ...args) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node.abstract;
            try {
              return super.parseClass(node, ...args);
            } finally {
              this.state.inAbstractClass = oldInAbstractClass;
            }
          }
          tsParseAbstractDeclaration(node) {
            if (this.match(76))
              return node.abstract = true, this.parseClass(node, true, false);
            if (this.isContextual(121)) {
              if (!this.hasFollowingLineBreak())
                return node.abstract = true, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, { node }), this.next(), this.tsParseInterfaceDeclaration(node);
            } else
              this.unexpected(null, 76);
          }
          parseMethod(...args) {
            const method = super.parseMethod(...args);
            if (method.abstract) {
              if (this.hasPlugin("estree") ? !!method.value.body : !!method.body) {
                const { key } = method;
                this.raise(TSErrors.AbstractMethodHasImplementation, { node: method }, key.type !== "Identifier" || method.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name);
              }
            }
            return method;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport), this.finishNode(node, "ExportSpecifier")) : (node.exportKind = "value", super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport), this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly));
          }
          parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
            const leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported";
            let rightOfAs, leftOfAs = node[leftOfAsKey], hasTypeSpecifier = false, canParseAsKeyword = true;
            const loc = leftOfAs.loc.start;
            if (this.isContextual(89)) {
              const firstAs = this.parseIdentifier();
              if (this.isContextual(89)) {
                const secondAs = this.parseIdentifier();
                tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = true, leftOfAs = firstAs, rightOfAs = this.parseIdentifier(), canParseAsKeyword = false) : (rightOfAs = secondAs, canParseAsKeyword = false);
              } else
                tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = false, rightOfAs = this.parseIdentifier()) : (hasTypeSpecifier = true, leftOfAs = firstAs);
            } else
              tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = true, leftOfAs = this.parseIdentifier());
            hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, { at: loc }), node[leftOfAsKey] = leftOfAs, node[rightOfAsKey] = rightOfAs;
            node[isImport ? "importKind" : "exportKind"] = hasTypeSpecifier ? "type" : "value", canParseAsKeyword && this.eatContextual(89) && (node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), node[rightOfAsKey] || (node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey])), isImport && this.checkLVal(node[rightOfAsKey], "import specifier", 9);
          }
        }, v8intrinsic: (superClass) => class extends superClass {
          parseV8Intrinsic() {
            if (this.match(50)) {
              const v8IntrinsicStartLoc = this.state.startLoc, node = this.startNode();
              if (this.next(), tokenIsIdentifier(this.state.type)) {
                const name = this.parseIdentifierName(this.state.start), identifier = this.createIdentifier(node, name);
                if (identifier.type = "V8IntrinsicIdentifier", this.match(10))
                  return identifier;
              }
              this.unexpected(v8IntrinsicStartLoc);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        }, placeholders: (superClass) => class extends superClass {
          parsePlaceholder(expectedNode) {
            if (this.match(136)) {
              const node = this.startNode();
              return this.next(), this.assertNoSpace("Unexpected space in placeholder."), node.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(136), this.finishPlaceholder(node, expectedNode);
            }
          }
          finishPlaceholder(node, expectedNode) {
            const isFinished = !(!node.expectedNode || node.type !== "Placeholder");
            return node.expectedNode = expectedNode, isFinished ? node : this.finishNode(node, "Placeholder");
          }
          getTokenFromCode(code) {
            return code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(136, 2) : super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(word) {
            word !== void 0 && super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          checkLVal(expr) {
            expr.type !== "Placeholder" && super.checkLVal(...arguments);
          }
          toAssignable(node) {
            return node && node.type === "Placeholder" && node.expectedNode === "Expression" ? (node.expectedNode = "Pattern", node) : super.toAssignable(...arguments);
          }
          isLet(context) {
            if (super.isLet(context))
              return true;
            if (!this.isContextual(95))
              return false;
            if (context)
              return false;
            return this.lookahead().type === 136;
          }
          verifyBreakContinue(node) {
            node.label && node.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(node, expr) {
            if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized)
              return super.parseExpressionStatement(...arguments);
            if (this.match(14)) {
              const stmt = node;
              return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = this.parseStatement("label"), this.finishNode(stmt, "LabeledStatement");
            }
            return this.semicolon(), node.name = expr.name, this.finishPlaceholder(node, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(node, isStatement, optionalId) {
            const type = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(node);
            const oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
              if (!(this.match(77) || this.match(136) || this.match(5))) {
                if (optionalId || !isStatement)
                  return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), this.finishNode(node, type);
                throw this.raise(PlaceholderErrors.ClassNameIsRequired, { at: this.state.startLoc });
              }
              node.id = placeholder;
            } else
              this.parseClassId(node, isStatement, optionalId);
            return this.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, type);
          }
          parseExport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseExport(...arguments);
            if (!this.isContextual(93) && !this.match(12))
              return node.specifiers = [], node.source = null, node.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            return specifier.exported = placeholder, node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], super.parseExport(node);
          }
          isExportDefaultSpecifier() {
            if (this.match(61)) {
              const next = this.nextTokenStart();
              if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(136), this.nextTokenStartSince(next + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(node) {
            return !!(node.specifiers && node.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(node) {
            const { specifiers } = node;
            specifiers != null && specifiers.length && (node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder")), super.checkExport(node), node.specifiers = specifiers;
          }
          parseImport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder)
              return super.parseImport(...arguments);
            if (node.specifiers = [], !this.isContextual(93) && !this.match(12))
              return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), this.semicolon(), this.finishNode(node, "ImportDeclaration");
            const specifier = this.startNodeAtNode(placeholder);
            if (specifier.local = placeholder, this.finishNode(specifier, "ImportDefaultSpecifier"), node.specifiers.push(specifier), this.eat(12)) {
              this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node);
            }
            return this.expectContextual(93), node.source = this.parseImportSource(), this.semicolon(), this.finishNode(node, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
        } }, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
        const unwrapParenthesizedExpression = (node) => node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
        const invalidHackPipeBodies = /* @__PURE__ */ new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
        const loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" }, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
        class Parser extends class extends class extends class extends class extends class extends class extends class extends class extends class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(pluginConfig) {
            if (typeof pluginConfig == "string")
              return this.plugins.has(pluginConfig);
            {
              const [pluginName, pluginOptions] = pluginConfig;
              if (!this.hasPlugin(pluginName))
                return false;
              const actualOptions = this.plugins.get(pluginName);
              for (const key of Object.keys(pluginOptions))
                if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key])
                  return false;
              return true;
            }
          }
          getPluginOption(plugin, name) {
            var _this$plugins$get;
            return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
          }
        } {
          addComment(comment) {
            this.filename && (comment.loc.filename = this.filename), this.state.comments.push(comment);
          }
          processComment(node) {
            const { commentStack } = this.state, commentStackLength = commentStack.length;
            if (commentStackLength === 0)
              return;
            let i = commentStackLength - 1;
            const lastCommentWS = commentStack[i];
            lastCommentWS.start === node.end && (lastCommentWS.leadingNode = node, i--);
            const { start: nodeStart } = node;
            for (; i >= 0; i--) {
              const commentWS = commentStack[i], commentEnd = commentWS.end;
              if (!(commentEnd > nodeStart)) {
                commentEnd === nodeStart && (commentWS.trailingNode = node);
                break;
              }
              commentWS.containingNode = node, this.finalizeComment(commentWS), commentStack.splice(i, 1);
            }
          }
          finalizeComment(commentWS) {
            const { comments } = commentWS;
            if (commentWS.leadingNode !== null || commentWS.trailingNode !== null)
              commentWS.leadingNode !== null && setTrailingComments(commentWS.leadingNode, comments), commentWS.trailingNode !== null && function(node, comments2) {
                node.leadingComments === void 0 ? node.leadingComments = comments2 : node.leadingComments.unshift(...comments2);
              }(commentWS.trailingNode, comments);
            else {
              const { containingNode: node, start: commentStart } = commentWS;
              if (this.input.charCodeAt(commentStart - 1) === 44)
                switch (node.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    adjustInnerComments(node, node.properties, commentWS);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    adjustInnerComments(node, node.arguments, commentWS);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    adjustInnerComments(node, node.params, commentWS);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    adjustInnerComments(node, node.elements, commentWS);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    adjustInnerComments(node, node.specifiers, commentWS);
                    break;
                  default:
                    setInnerComments(node, comments);
                }
              else
                setInnerComments(node, comments);
            }
          }
          finalizeRemainingComments() {
            const { commentStack } = this.state;
            for (let i = commentStack.length - 1; i >= 0; i--)
              this.finalizeComment(commentStack[i]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(node) {
            const { commentStack } = this.state, { length } = commentStack;
            if (length === 0)
              return;
            const commentWS = commentStack[length - 1];
            commentWS.leadingNode === node && (commentWS.leadingNode = null);
          }
          takeSurroundingComments(node, start, end) {
            const { commentStack } = this.state, commentStackLength = commentStack.length;
            if (commentStackLength === 0)
              return;
            let i = commentStackLength - 1;
            for (; i >= 0; i--) {
              const commentWS = commentStack[i], commentEnd = commentWS.end;
              if (commentWS.start === end)
                commentWS.leadingNode = node;
              else if (commentEnd === start)
                commentWS.trailingNode = node;
              else if (commentEnd < start)
                break;
            }
          }
        } {
          raise({ code, reasonCode, template }, origin, ...params) {
            return this.raiseWithData(origin.node ? origin.node.loc.start : origin.at, { code, reasonCode }, template, ...params);
          }
          raiseOverwrite(loc, { code, template }, ...params) {
            const pos = indexes.get(loc), message = template.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
            if (this.options.errorRecovery) {
              const errors = this.state.errors;
              for (let i = errors.length - 1; i >= 0; i--) {
                const error = errors[i];
                if (error.pos === pos)
                  return Object.assign(error, { message });
                if (error.pos < pos)
                  break;
              }
            }
            return this._raise({ code, loc, pos }, message);
          }
          raiseWithData(loc, data, errorTemplate, ...params) {
            const pos = indexes.get(loc), message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
            return this._raise(Object.assign({ loc, pos }, data), message);
          }
          _raise(errorContext, message) {
            const err = new SyntaxError(message);
            if (Object.assign(err, errorContext), this.options.errorRecovery)
              return this.isLookahead || this.state.errors.push(err), err;
            throw err;
          }
        } {
          constructor(options, input) {
            super(), this.isLookahead = void 0, this.tokens = [], this.state = new State(), this.state.init(options), this.input = input, this.length = input.length, this.isLookahead = false;
          }
          pushToken(token) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(token), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(type) {
            return !!this.match(type) && (this.next(), true);
          }
          match(type) {
            return this.state.type === type;
          }
          createLookaheadState(state) {
            return { pos: state.pos, value: null, type: state.type, start: state.start, end: state.end, context: [this.curContext()], inType: state.inType, startLoc: state.startLoc, lastTokEndLoc: state.lastTokEndLoc, curLine: state.curLine, lineStart: state.lineStart, curPosition: state.curPosition };
          }
          lookahead() {
            const old = this.state;
            this.state = this.createLookaheadState(old), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const curr = this.state;
            return this.state = old, curr;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(pos) {
            return skipWhiteSpace.lastIndex = pos, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          codePointAtPos(pos) {
            let cp = this.input.charCodeAt(pos);
            if ((64512 & cp) == 55296 && ++pos < this.input.length) {
              const trail = this.input.charCodeAt(pos);
              (64512 & trail) == 56320 && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
            }
            return cp;
          }
          setStrict(strict) {
            this.state.strict = strict, strict && (this.state.strictErrors.forEach(({ message, loc }) => this.raise(message, { at: loc })), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(131) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment() {
            let startLoc;
            this.isLookahead || (startLoc = this.state.curPosition());
            const start = this.state.pos, end = this.input.indexOf("*/", start + 2);
            if (end === -1)
              throw this.raise(ErrorMessages.UnterminatedComment, { at: this.state.curPosition() });
            for (this.state.pos = end + 2, lineBreakG.lastIndex = start + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= end; )
              ++this.state.curLine, this.state.lineStart = lineBreakG.lastIndex;
            if (this.isLookahead)
              return;
            const comment = { type: "CommentBlock", value: this.input.slice(start + 2, end), start, end: end + 2, loc: new SourceLocation(startLoc, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(comment), comment;
          }
          skipLineComment(startSkip) {
            const start = this.state.pos;
            let startLoc;
            this.isLookahead || (startLoc = this.state.curPosition());
            let ch = this.input.charCodeAt(this.state.pos += startSkip);
            if (this.state.pos < this.length)
              for (; !isNewLine(ch) && ++this.state.pos < this.length; )
                ch = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            const end = this.state.pos, comment = { type: "CommentLine", value: this.input.slice(start + startSkip, end), start, end, loc: new SourceLocation(startLoc, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(comment), comment;
          }
          skipSpace() {
            const spaceStart = this.state.pos, comments = [];
            loop:
              for (; this.state.pos < this.length; ) {
                const ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        const comment = this.skipBlockComment();
                        comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        break;
                      }
                      case 47: {
                        const comment = this.skipLineComment(2);
                        comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        break;
                      }
                      default:
                        break loop;
                    }
                    break;
                  default:
                    if (isWhitespace(ch))
                      ++this.state.pos;
                    else if (ch !== 45 || this.inModule) {
                      if (ch !== 60 || this.inModule)
                        break loop;
                      {
                        const pos = this.state.pos;
                        if (this.input.charCodeAt(pos + 1) !== 33 || this.input.charCodeAt(pos + 2) !== 45 || this.input.charCodeAt(pos + 3) !== 45)
                          break loop;
                        {
                          const comment = this.skipLineComment(4);
                          comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                        }
                      }
                    } else {
                      const pos = this.state.pos;
                      if (this.input.charCodeAt(pos + 1) !== 45 || this.input.charCodeAt(pos + 2) !== 62 || !(spaceStart === 0 || this.state.lineStart > spaceStart))
                        break loop;
                      {
                        const comment = this.skipLineComment(3);
                        comment !== void 0 && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                      }
                    }
                }
              }
            if (comments.length > 0) {
              const CommentWhitespace = { start: spaceStart, end: this.state.pos, comments, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(CommentWhitespace);
            }
          }
          finishToken(type, val) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const prevType = this.state.type;
            this.state.type = type, this.state.value = val, this.isLookahead || this.updateContext(prevType);
          }
          replaceToken(type) {
            this.state.type = type, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            const nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
            if (next >= 48 && next <= 57)
              throw this.raise(ErrorMessages.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
            if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
                throw this.raise(next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
              this.state.pos += 2, next === 123 ? this.finishToken(7) : this.finishToken(1);
            } else
              isIdentifierStart(next) ? (++this.state.pos, this.finishToken(130, this.readWord1(next))) : next === 92 ? (++this.state.pos, this.finishToken(130, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const next = this.input.charCodeAt(this.state.pos + 1);
            next >= 48 && next <= 57 ? this.readNumber(true) : next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(52, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let ch = this.input.charCodeAt(this.state.pos + 1);
            if (ch !== 33)
              return false;
            const start = this.state.pos;
            for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; )
              ch = this.input.charCodeAt(this.state.pos);
            const value = this.input.slice(start + 2, this.state.pos);
            return this.finishToken(28, value), true;
          }
          readToken_mult_modulo(code) {
            let type = code === 42 ? 51 : 50, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
            code === 42 && next === 42 && (width++, next = this.input.charCodeAt(this.state.pos + 2), type = 53), next !== 61 || this.state.inType || (width++, type = code === 37 ? 33 : 30), this.finishOp(type, width);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next !== code) {
              if (code === 124) {
                if (next === 62)
                  return void this.finishOp(37, 2);
                if (this.hasPlugin("recordAndTuple") && next === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && next === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              next !== 61 ? this.finishOp(code === 124 ? 41 : 43, 1) : this.finishOp(30, 2);
            } else
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(code === 124 ? 39 : 40, 2);
          }
          readToken_caret() {
            this.input.charCodeAt(this.state.pos + 1) !== 61 || this.state.inType ? this.finishOp(42, 1) : this.finishOp(32, 2);
          }
          readToken_plus_min(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            next !== code ? next === 61 ? this.finishOp(30, 2) : this.finishOp(49, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos } = this.state, next = this.input.charCodeAt(pos + 1);
            if (next === 60)
              return this.input.charCodeAt(pos + 2) === 61 ? void this.finishOp(30, 3) : void this.finishOp(48, 2);
            next !== 61 ? this.finishOp(45, 1) : this.finishOp(47, 2);
          }
          readToken_gt() {
            const { pos } = this.state, next = this.input.charCodeAt(pos + 1);
            if (next === 62) {
              const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
              return this.input.charCodeAt(pos + size) === 61 ? void this.finishOp(30, size + 1) : void this.finishOp(48, size);
            }
            next !== 61 ? this.finishOp(46, 1) : this.finishOp(47, 2);
          }
          readToken_eq_excl(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next !== 61)
              return code === 61 && next === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(code === 61 ? 29 : 35, 1);
            this.finishOp(44, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
            next === 63 ? next2 === 61 ? this.finishOp(30, 3) : this.finishOp(38, 2) : next !== 46 || next2 >= 48 && next2 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(code) {
            switch (code) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const next = this.input.charCodeAt(this.state.pos + 1);
                if (next === 120 || next === 88)
                  return void this.readRadixNumber(16);
                if (next === 111 || next === 79)
                  return void this.readRadixNumber(8);
                if (next === 98 || next === 66)
                  return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(code);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(code);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(code);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(code);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(code);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return ++this.state.pos, void this.finishToken(26);
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (isIdentifierStart(code))
                  return void this.readWord(code);
            }
            throw this.raise(ErrorMessages.InvalidOrUnexpectedToken, { at: this.state.curPosition() }, String.fromCodePoint(code));
          }
          finishOp(type, size) {
            const str = this.input.slice(this.state.pos, this.state.pos + size);
            this.state.pos += size, this.finishToken(type, str);
          }
          readRegexp() {
            const startLoc = this.state.startLoc, start = this.state.start + 1;
            let escaped, inClass, { pos } = this.state;
            for (; ; ++pos) {
              if (pos >= this.length)
                throw this.raise(ErrorMessages.UnterminatedRegExp, { at: createPositionWithColumnOffset(startLoc, 1) });
              const ch = this.input.charCodeAt(pos);
              if (isNewLine(ch))
                throw this.raise(ErrorMessages.UnterminatedRegExp, { at: createPositionWithColumnOffset(startLoc, 1) });
              if (escaped)
                escaped = false;
              else {
                if (ch === 91)
                  inClass = true;
                else if (ch === 93 && inClass)
                  inClass = false;
                else if (ch === 47 && !inClass)
                  break;
                escaped = ch === 92;
              }
            }
            const content = this.input.slice(start, pos);
            ++pos;
            let mods = "";
            for (; pos < this.length; ) {
              const cp = this.codePointAtPos(pos), char = String.fromCharCode(cp);
              if (VALID_REGEX_FLAGS.has(cp))
                mods.includes(char) && this.raise(ErrorMessages.DuplicateRegExpFlags, { at: createPositionWithColumnOffset(startLoc, pos + 2 - start) });
              else {
                if (!isIdentifierChar(cp) && cp !== 92)
                  break;
                this.raise(ErrorMessages.MalformedRegExpFlags, { at: createPositionWithColumnOffset(startLoc, pos + 2 - start) });
              }
              ++pos, mods += char;
            }
            this.state.pos = pos, this.finishToken(129, { pattern: content, flags: mods });
          }
          readInt(radix, len, forceLen, allowNumSeparator = true) {
            const start = this.state.pos, forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
            let invalid = false, total = 0;
            for (let i = 0, e2 = len == null ? 1 / 0 : len; i < e2; ++i) {
              const code = this.input.charCodeAt(this.state.pos);
              let val;
              if (code !== 95) {
                if (val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : _isDigit(code) ? code - 48 : 1 / 0, val >= radix)
                  if (this.options.errorRecovery && val <= 9)
                    val = 0, this.raise(ErrorMessages.InvalidDigit, { at: this.state.curPosition() }, radix);
                  else {
                    if (!forceLen)
                      break;
                    val = 0, invalid = true;
                  }
                ++this.state.pos, total = total * radix + val;
              } else {
                const prev = this.input.charCodeAt(this.state.pos - 1), next = this.input.charCodeAt(this.state.pos + 1);
                (allowedSiblings.indexOf(next) === -1 || forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) && this.raise(ErrorMessages.UnexpectedNumericSeparator, { at: this.state.curPosition() }), allowNumSeparator || this.raise(ErrorMessages.NumericSeparatorInEscapeSequence, { at: this.state.curPosition() }), ++this.state.pos;
              }
            }
            return this.state.pos === start || len != null && this.state.pos - start !== len || invalid ? null : total;
          }
          readRadixNumber(radix) {
            const startLoc = this.state.curPosition();
            let isBigInt = false;
            this.state.pos += 2;
            const val = this.readInt(radix);
            val == null && this.raise(ErrorMessages.InvalidDigit, { at: createPositionWithColumnOffset(startLoc, 2) }, radix);
            const next = this.input.charCodeAt(this.state.pos);
            if (next === 110)
              ++this.state.pos, isBigInt = true;
            else if (next === 109)
              throw this.raise(ErrorMessages.InvalidDecimal, { at: startLoc });
            if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
              throw this.raise(ErrorMessages.NumberIdentifier, { at: this.state.curPosition() });
            if (isBigInt) {
              const str = this.input.slice(indexes.get(startLoc), this.state.pos).replace(/[_n]/g, "");
              this.finishToken(127, str);
            } else
              this.finishToken(126, val);
          }
          readNumber(startsWithDot) {
            const start = this.state.pos, startLoc = this.state.curPosition();
            let isFloat = false, isBigInt = false, isDecimal = false, hasExponent = false, isOctal = false;
            startsWithDot || this.readInt(10) !== null || this.raise(ErrorMessages.InvalidNumber, { at: this.state.curPosition() });
            const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
            if (hasLeadingZero) {
              const integer = this.input.slice(start, this.state.pos);
              if (this.recordStrictModeErrors(ErrorMessages.StrictOctalLiteral, startLoc), !this.state.strict) {
                const underscorePos = integer.indexOf("_");
                underscorePos > 0 && this.raise(ErrorMessages.ZeroDigitNumericSeparator, { at: createPositionWithColumnOffset(startLoc, underscorePos) });
              }
              isOctal = hasLeadingZero && !/[89]/.test(integer);
            }
            let next = this.input.charCodeAt(this.state.pos);
            if (next !== 46 || isOctal || (++this.state.pos, this.readInt(10), isFloat = true, next = this.input.charCodeAt(this.state.pos)), next !== 69 && next !== 101 || isOctal || (next = this.input.charCodeAt(++this.state.pos), next !== 43 && next !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(ErrorMessages.InvalidOrMissingExponent, { at: startLoc }), isFloat = true, hasExponent = true, next = this.input.charCodeAt(this.state.pos)), next === 110 && ((isFloat || hasLeadingZero) && this.raise(ErrorMessages.InvalidBigIntLiteral, { at: startLoc }), ++this.state.pos, isBigInt = true), next === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (hasExponent || hasLeadingZero) && this.raise(ErrorMessages.InvalidDecimal, { at: startLoc }), ++this.state.pos, isDecimal = true), isIdentifierStart(this.codePointAtPos(this.state.pos)))
              throw this.raise(ErrorMessages.NumberIdentifier, { at: this.state.curPosition() });
            const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
            if (isBigInt)
              return void this.finishToken(127, str);
            if (isDecimal)
              return void this.finishToken(128, str);
            const val = isOctal ? parseInt(str, 8) : parseFloat(str);
            this.finishToken(126, val);
          }
          readCodePoint(throwOnInvalid) {
            let code;
            if (this.input.charCodeAt(this.state.pos) === 123) {
              if (++this.state.pos, code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid), ++this.state.pos, code !== null && code > 1114111) {
                if (!throwOnInvalid)
                  return null;
                this.raise(ErrorMessages.InvalidCodePoint, { at: this.state.curPosition() });
              }
            } else
              code = this.readHexChar(4, false, throwOnInvalid);
            return code;
          }
          readString(quote) {
            let out = "", chunkStart = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(ErrorMessages.UnterminatedString, { at: this.state.startLoc });
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote)
                break;
              if (ch === 92)
                out += this.input.slice(chunkStart, this.state.pos), out += this.readEscapedChar(false), chunkStart = this.state.pos;
              else if (ch === 8232 || ch === 8233)
                ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              else {
                if (isNewLine(ch))
                  throw this.raise(ErrorMessages.UnterminatedString, { at: this.state.startLoc });
                ++this.state.pos;
              }
            }
            out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(125, out);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            let out = "", chunkStart = this.state.pos, containsInvalid = false;
            for (++this.state.pos; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(ErrorMessages.UnterminatedTemplate, { at: createPositionWithColumnOffset(this.state.startLoc, 1) });
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === 96)
                return ++this.state.pos, out += this.input.slice(chunkStart, this.state.pos), void this.finishToken(24, containsInvalid ? null : out);
              if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
                return this.state.pos += 2, out += this.input.slice(chunkStart, this.state.pos), void this.finishToken(25, containsInvalid ? null : out);
              if (ch === 92) {
                out += this.input.slice(chunkStart, this.state.pos);
                const escaped = this.readEscapedChar(true);
                escaped === null ? containsInvalid = true : out += escaped, chunkStart = this.state.pos;
              } else if (isNewLine(ch)) {
                switch (out += this.input.slice(chunkStart, this.state.pos), ++this.state.pos, ch) {
                  case 13:
                    this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                  case 10:
                    out += "\n";
                    break;
                  default:
                    out += String.fromCharCode(ch);
                }
                ++this.state.curLine, this.state.lineStart = this.state.pos, chunkStart = this.state.pos;
              } else
                ++this.state.pos;
            }
          }
          recordStrictModeErrors(message, loc) {
            const index = indexes.get(loc);
            this.state.strict && !this.state.strictErrors.has(index) ? this.raise(message, { at: loc }) : this.state.strictErrors.set(index, { loc, message });
          }
          readEscapedChar(inTemplate) {
            const throwOnInvalid = !inTemplate, ch = this.input.charCodeAt(++this.state.pos);
            switch (++this.state.pos, ch) {
              case 110:
                return "\n";
              case 114:
                return "\r";
              case 120: {
                const code = this.readHexChar(2, false, throwOnInvalid);
                return code === null ? null : String.fromCharCode(code);
              }
              case 117: {
                const code = this.readCodePoint(throwOnInvalid);
                return code === null ? null : String.fromCodePoint(code);
              }
              case 116:
                return "	";
              case 98:
                return "\b";
              case 118:
                return "\v";
              case 102:
                return "\f";
              case 13:
                this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
              case 10:
                this.state.lineStart = this.state.pos, ++this.state.curLine;
              case 8232:
              case 8233:
                return "";
              case 56:
              case 57:
                if (inTemplate)
                  return null;
                this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, createPositionWithColumnOffset(this.state.curPosition(), -1));
              default:
                if (ch >= 48 && ch <= 55) {
                  const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);
                  let octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
                  octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), this.state.pos += octalStr.length - 1;
                  const next = this.input.charCodeAt(this.state.pos);
                  if (octalStr !== "0" || next === 56 || next === 57) {
                    if (inTemplate)
                      return null;
                    this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, codePos);
                  }
                  return String.fromCharCode(octal);
                }
                return String.fromCharCode(ch);
            }
          }
          readHexChar(len, forceLen, throwOnInvalid) {
            const codeLoc = this.state.curPosition(), n = this.readInt(16, len, forceLen, false);
            return n === null && (throwOnInvalid ? this.raise(ErrorMessages.InvalidEscapeSequence, { at: codeLoc }) : this.state.pos = indexes.get(codeLoc) - 1), n;
          }
          readWord1(firstCode) {
            this.state.containsEsc = false;
            let word = "";
            const start = this.state.pos;
            let chunkStart = this.state.pos;
            for (firstCode !== void 0 && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const ch = this.codePointAtPos(this.state.pos);
              if (isIdentifierChar(ch))
                this.state.pos += ch <= 65535 ? 1 : 2;
              else {
                if (ch !== 92)
                  break;
                {
                  this.state.containsEsc = true, word += this.input.slice(chunkStart, this.state.pos);
                  const escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(ErrorMessages.MissingUnicodeEscape, { at: this.state.curPosition() }), chunkStart = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const esc = this.readCodePoint(true);
                  esc !== null && (identifierCheck(esc) || this.raise(ErrorMessages.EscapedCharNotAnIdentifier, { at: escStart }), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
                }
              }
            }
            return word + this.input.slice(chunkStart, this.state.pos);
          }
          readWord(firstCode) {
            const word = this.readWord1(firstCode), type = keywords$1.get(word);
            type !== void 0 ? this.finishToken(type, tokenLabelName(type)) : this.finishToken(124, word);
          }
          checkKeywordEscapes() {
            const { type } = this.state;
            tokenIsKeyword(type) && this.state.containsEsc && this.raise(ErrorMessages.InvalidEscapedReservedWord, { at: this.state.startLoc }, tokenLabelName(type));
          }
          updateContext(prevType) {
          }
        } {
          addExtra(node, key, value, enumerable = true) {
            if (!node)
              return;
            const extra = node.extra = node.extra || {};
            enumerable ? extra[key] = value : Object.defineProperty(extra, key, { enumerable, value });
          }
          isContextual(token) {
            return this.state.type === token && !this.state.containsEsc;
          }
          isUnparsedContextual(nameStart, name) {
            const nameEnd = nameStart + name.length;
            if (this.input.slice(nameStart, nameEnd) === name) {
              const nextCh = this.input.charCodeAt(nameEnd);
              return !(isIdentifierChar(nextCh) || (64512 & nextCh) == 55296);
            }
            return false;
          }
          isLookaheadContextual(name) {
            const next = this.nextTokenStart();
            return this.isUnparsedContextual(next, name);
          }
          eatContextual(token) {
            return !!this.isContextual(token) && (this.next(), true);
          }
          expectContextual(token, template) {
            if (!this.eatContextual(token)) {
              if (template != null)
                throw this.raise(template, { at: this.state.startLoc });
              throw this.unexpected(null, token);
            }
          }
          canInsertSemicolon() {
            return this.match(131) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return lineBreak.test(this.input.slice(indexes.get(this.state.lastTokEndLoc), this.state.start));
          }
          hasFollowingLineBreak() {
            return skipWhiteSpaceToLineBreak.lastIndex = this.state.end, skipWhiteSpaceToLineBreak.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(allowAsi = true) {
            (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(ErrorMessages.MissingSemicolon, { at: this.state.lastTokEndLoc });
          }
          expect(type, loc) {
            this.eat(type) || this.unexpected(loc, type);
          }
          assertNoSpace(message = "Unexpected space.") {
            this.state.start > indexes.get(this.state.lastTokEndLoc) && this.raise({ code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedSpace", template: message }, { at: this.state.lastTokEndLoc });
          }
          unexpected(loc, type) {
            throw this.raise({ code: ErrorCodes.SyntaxError, reasonCode: "UnexpectedToken", template: type != null ? `Unexpected token, expected "${tokenLabelName(type)}"` : "Unexpected token" }, { at: loc != null ? loc : this.state.startLoc });
          }
          getPluginNamesFromConfigs(pluginConfigs) {
            return pluginConfigs.map((c) => typeof c == "string" ? c : c[0]);
          }
          expectPlugin(pluginConfig, loc) {
            if (!this.hasPlugin(pluginConfig))
              throw this.raiseWithData(loc != null ? loc : this.state.startLoc, { missingPlugin: this.getPluginNamesFromConfigs([pluginConfig]) }, `This experimental syntax requires enabling the parser plugin: ${JSON.stringify(pluginConfig)}.`);
            return true;
          }
          expectOnePlugin(pluginConfigs) {
            if (!pluginConfigs.some((c) => this.hasPlugin(c)))
              throw this.raiseWithData(this.state.startLoc, { missingPlugin: this.getPluginNamesFromConfigs(pluginConfigs) }, `This experimental syntax requires enabling one of the following parser plugin(s): ${pluginConfigs.map((c) => JSON.stringify(c)).join(", ")}.`);
          }
          tryParse(fn, oldState = this.state.clone()) {
            const abortSignal = { node: null };
            try {
              const node = fn((node2 = null) => {
                throw abortSignal.node = node2, abortSignal;
              });
              if (this.state.errors.length > oldState.errors.length) {
                const failState = this.state;
                return this.state = oldState, this.state.tokensLength = failState.tokensLength, { node, error: failState.errors[oldState.errors.length], thrown: false, aborted: false, failState };
              }
              return { node, error: null, thrown: false, aborted: false, failState: null };
            } catch (error) {
              const failState = this.state;
              if (this.state = oldState, error instanceof SyntaxError)
                return { node: null, error, thrown: true, aborted: false, failState };
              if (error === abortSignal)
                return { node: abortSignal.node, error: null, thrown: false, aborted: true, failState };
              throw error;
            }
          }
          checkExpressionErrors(refExpressionErrors, andThrow) {
            if (!refExpressionErrors)
              return false;
            const { shorthandAssignLoc, doubleProtoLoc, optionalParametersLoc } = refExpressionErrors;
            if (!andThrow)
              return !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc;
            shorthandAssignLoc != null && this.raise(ErrorMessages.InvalidCoverInitializedName, { at: shorthandAssignLoc }), doubleProtoLoc != null && this.raise(ErrorMessages.DuplicateProto, { at: doubleProtoLoc }), optionalParametersLoc != null && this.unexpected(optionalParametersLoc);
          }
          isLiteralPropertyName() {
            return tokenIsLiteralPropertyName(this.state.type);
          }
          isPrivateName(node) {
            return node.type === "PrivateName";
          }
          getPrivateNameSV(node) {
            return node.id.name;
          }
          hasPropertyAsPrivateName(node) {
            return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
          }
          isOptionalChain(node) {
            return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
          }
          isObjectProperty(node) {
            return node.type === "ObjectProperty";
          }
          isObjectMethod(node) {
            return node.type === "ObjectMethod";
          }
          initializeScopes(inModule = this.options.sourceType === "module") {
            const oldLabels = this.state.labels;
            this.state.labels = [];
            const oldExportedIdentifiers = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const oldInModule = this.inModule;
            this.inModule = inModule;
            const oldScope = this.scope, ScopeHandler2 = this.getScopeHandler();
            this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
            const oldProdParam = this.prodParam;
            this.prodParam = new ProductionParameterHandler();
            const oldClassScope = this.classScope;
            this.classScope = new ClassScopeHandler(this.raise.bind(this));
            const oldExpressionScope = this.expressionScope;
            return this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this)), () => {
              this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
            };
          }
          enterInitialScopes() {
            let paramFlags = 0;
            this.inModule && (paramFlags |= 2), this.scope.enter(1), this.prodParam.enter(paramFlags);
          }
        } {
          startNode() {
            return new Node2(this, this.state.start, this.state.startLoc);
          }
          startNodeAt(pos, loc) {
            return new Node2(this, pos, loc);
          }
          startNodeAtNode(type) {
            return this.startNodeAt(type.start, type.loc.start);
          }
          finishNode(node, type) {
            return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
          }
          finishNodeAt(node, type, endLoc) {
            return node.type = type, node.end = indexes.get(endLoc), node.loc.end = endLoc, this.options.ranges && (node.range[1] = node.end), this.options.attachComment && this.processComment(node), node;
          }
          resetStartLocation(node, start, startLoc) {
            node.start = start, node.loc.start = startLoc, this.options.ranges && (node.range[0] = start);
          }
          resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
            node.end = indexes.get(endLoc), node.loc.end = endLoc, this.options.ranges && (node.range[1] = node.end);
          }
          resetStartLocationFromNode(node, locationNode) {
            this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
          }
        } {
          toAssignable(node, isLHS = false) {
            var _node$extra, _node$extra3;
            let parenthesized;
            switch ((node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node), isLHS ? parenthesized.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start) : parenthesized.type !== "MemberExpression" && this.raise(ErrorMessages.InvalidParenthesizedAssignment, { node }) : this.raise(ErrorMessages.InvalidParenthesizedAssignment, { node })), node.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                node.type = "ObjectPattern";
                for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
                  var _node$extra2;
                  const prop = node.properties[i], isLast = i === last;
                  this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc && this.raise(ErrorMessages.RestTrailingComma, { at: node.extra.trailingCommaLoc });
                }
                break;
              case "ObjectProperty":
                this.toAssignable(node.value, isLHS);
                break;
              case "SpreadElement": {
                this.checkToRestConversion(node), node.type = "RestElement";
                const arg = node.argument;
                this.toAssignable(arg, isLHS);
                break;
              }
              case "ArrayExpression":
                node.type = "ArrayPattern", this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
                break;
              case "AssignmentExpression":
                node.operator !== "=" && this.raise(ErrorMessages.MissingEqInAssignment, { at: node.left.loc.end }), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isLHS);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(parenthesized, isLHS);
            }
            return node;
          }
          toAssignableObjectExpressionProp(prop, isLast, isLHS) {
            prop.type === "ObjectMethod" ? this.raise(prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod, { node: prop.key }) : prop.type !== "SpreadElement" || isLast ? this.toAssignable(prop, isLHS) : this.raise(ErrorMessages.RestTrailingComma, { node: prop });
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            let end = exprList.length;
            if (end) {
              const last = exprList[end - 1];
              if ((last == null ? void 0 : last.type) === "RestElement")
                --end;
              else if ((last == null ? void 0 : last.type) === "SpreadElement") {
                last.type = "RestElement";
                let arg = last.argument;
                this.toAssignable(arg, isLHS), arg = unwrapParenthesizedExpression(arg), arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern" && this.unexpected(arg.start), trailingCommaLoc && this.raise(ErrorMessages.RestTrailingComma, { at: trailingCommaLoc }), --end;
              }
            }
            for (let i = 0; i < end; i++) {
              const elt = exprList[i];
              elt && (this.toAssignable(elt, isLHS), elt.type === "RestElement" && this.raise(ErrorMessages.RestTrailingComma, { node: elt }));
            }
            return exprList;
          }
          isAssignable(node, isBinding) {
            switch (node.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                const last = node.properties.length - 1;
                return node.properties.every((prop, i) => prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop));
              }
              case "ObjectProperty":
                return this.isAssignable(node.value);
              case "SpreadElement":
                return this.isAssignable(node.argument);
              case "ArrayExpression":
                return node.elements.every((element) => element === null || this.isAssignable(element));
              case "AssignmentExpression":
                return node.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(node.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !isBinding;
              default:
                return false;
            }
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            return exprList;
          }
          toReferencedListDeep(exprList, isParenthesizedExpr) {
            this.toReferencedList(exprList, isParenthesizedExpr);
            for (const expr of exprList)
              (expr == null ? void 0 : expr.type) === "ArrayExpression" && this.toReferencedListDeep(expr.elements);
          }
          parseSpread(refExpressionErrors, refNeedsArrowPos) {
            const node = this.startNode();
            return this.next(), node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos), this.finishNode(node, "SpreadElement");
          }
          parseRestBinding() {
            const node = this.startNode();
            return this.next(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const node = this.startNode();
                return this.next(), node.elements = this.parseBindingList(3, 93, true), this.finishNode(node, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
            const elts = [];
            let first = true;
            for (; !this.eat(close); )
              if (first ? first = false : this.expect(12), allowEmpty && this.match(12))
                elts.push(null);
              else {
                if (this.eat(close))
                  break;
                if (this.match(21)) {
                  if (elts.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(closeCharCode)) {
                    this.expect(close);
                    break;
                  }
                } else {
                  const decorators = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(ErrorMessages.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                    decorators.push(this.parseDecorator());
                  elts.push(this.parseAssignableListItem(allowModifiers, decorators));
                }
              }
            return elts;
          }
          parseBindingRestProperty(prop) {
            return this.next(), prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement");
          }
          parseBindingProperty() {
            const prop = this.startNode(), { type, start: startPos, startLoc } = this.state;
            return type === 21 ? this.parseBindingRestProperty(prop) : (this.parsePropertyName(prop), prop.method = false, this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false), prop);
          }
          parseAssignableListItem(allowModifiers, decorators) {
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            return decorators.length && (left.decorators = decorators), elt;
          }
          parseAssignableListItemTypes(param) {
            return param;
          }
          parseMaybeDefault(startPos, startLoc, left) {
            var _startLoc, _startPos, _left;
            if (startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc, startPos = (_startPos = startPos) != null ? _startPos : this.state.start, left = (_left = left) != null ? _left : this.parseBindingAtom(), !this.eat(29))
              return left;
            const node = this.startNodeAt(startPos, startLoc);
            return node.left = left, node.right = this.parseMaybeAssignAllowIn(), this.finishNode(node, "AssignmentPattern");
          }
          checkLVal(expr, contextDescription, bindingType = 64, checkClashes, disallowLetBinding, strictModeChanged = false) {
            switch (expr.type) {
              case "Identifier": {
                const { name } = expr;
                this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name)) && this.raise(bindingType === 64 ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, { node: expr }, name), checkClashes && (checkClashes.has(name) ? this.raise(ErrorMessages.ParamDupe, { node: expr }) : checkClashes.add(name)), disallowLetBinding && name === "let" && this.raise(ErrorMessages.LetInLexicalBinding, { node: expr }), 64 & bindingType || this.scope.declareName(name, bindingType, expr.loc.start);
                break;
              }
              case "MemberExpression":
                bindingType !== 64 && this.raise(ErrorMessages.InvalidPropertyBindingPattern, { node: expr });
                break;
              case "ObjectPattern":
                for (let prop of expr.properties) {
                  if (this.isObjectProperty(prop))
                    prop = prop.value;
                  else if (this.isObjectMethod(prop))
                    continue;
                  this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                }
                break;
              case "ArrayPattern":
                for (const elem of expr.elements)
                  elem && this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
                break;
              case "AssignmentPattern":
                this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
                break;
              case "RestElement":
                this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
                break;
              case "ParenthesizedExpression":
                this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
                break;
              default:
                this.raise(bindingType === 64 ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, { node: expr }, contextDescription);
            }
          }
          checkToRestConversion(node) {
            node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression" && this.raise(ErrorMessages.InvalidRestAssignmentPattern, { node: node.argument });
          }
          checkCommaAfterRest(close) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === close ? ErrorMessages.RestTrailingComma : ErrorMessages.ElementAfterRest, { at: this.state.startLoc }), true);
          }
        } {
          checkProto(prop, isRecord, protoRef, refExpressionErrors) {
            if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand)
              return;
            const key = prop.key;
            if ((key.type === "Identifier" ? key.name : key.value) === "__proto__") {
              if (isRecord)
                return void this.raise(ErrorMessages.RecordNoProto, { node: key });
              protoRef.used && (refExpressionErrors ? refExpressionErrors.doubleProtoLoc === null && (refExpressionErrors.doubleProtoLoc = key.loc.start) : this.raise(ErrorMessages.DuplicateProto, { node: key })), protoRef.used = true;
            }
          }
          shouldExitDescending(expr, potentialArrowAt) {
            return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const expr = this.parseExpression();
            return this.match(131) || this.unexpected(), this.finalizeRemainingComments(), expr.comments = this.state.comments, expr.errors = this.state.errors, this.options.tokens && (expr.tokens = this.tokens), expr;
          }
          parseExpression(disallowIn, refExpressionErrors) {
            return disallowIn ? this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors)) : this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
          }
          parseExpressionBase(refExpressionErrors) {
            const startPos = this.state.start, startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
            if (this.match(12)) {
              const node = this.startNodeAt(startPos, startLoc);
              for (node.expressions = [expr]; this.eat(12); )
                node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
              return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
            }
            return expr;
          }
          parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
            return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
          }
          parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
            return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
          }
          setOptionalParametersError(refExpressionErrors, resultError) {
            var _resultError$loc;
            refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            if (this.isContextual(101) && this.prodParam.hasYield) {
              let left2 = this.parseYield();
              return afterLeftParse && (left2 = afterLeftParse.call(this, left2, startPos, startLoc)), left2;
            }
            let ownExpressionErrors;
            refExpressionErrors ? ownExpressionErrors = false : (refExpressionErrors = new ExpressionErrors(), ownExpressionErrors = true);
            const { type } = this.state;
            (type === 10 || tokenIsIdentifier(type)) && (this.state.potentialArrowAt = this.state.start);
            let left = this.parseMaybeConditional(refExpressionErrors);
            if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), (token = this.state.type) >= 29 && token <= 33) {
              const node = this.startNodeAt(startPos, startLoc), operator = this.state.value;
              return node.operator = operator, this.match(29) ? (node.left = this.toAssignable(left, true), refExpressionErrors.doubleProtoLoc != null && indexes.get(refExpressionErrors.doubleProtoLoc) >= startPos && (refExpressionErrors.doubleProtoLoc = null), refExpressionErrors.shorthandAssignLoc != null && indexes.get(refExpressionErrors.shorthandAssignLoc) >= startPos && (refExpressionErrors.shorthandAssignLoc = null)) : node.left = left, this.checkLVal(left, "assignment expression"), this.next(), node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentExpression");
            }
            var token;
            return ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, true), left;
          }
          parseMaybeConditional(refExpressionErrors) {
            const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
          }
          parseConditional(expr, startPos, startLoc, refExpressionErrors) {
            if (this.eat(17)) {
              const node = this.startNodeAt(startPos, startLoc);
              return node.test = expr, node.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), node.alternate = this.parseMaybeAssign(), this.finishNode(node, "ConditionalExpression");
            }
            return expr;
          }
          parseMaybeUnaryOrPrivate(refExpressionErrors) {
            return this.match(130) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
          }
          parseExprOps(refExpressionErrors) {
            const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startPos, startLoc, -1);
          }
          parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            if (this.isPrivateName(left)) {
              const value = this.getPrivateNameSV(left);
              (minPrec >= tokenOperatorPrecedence(54) || !this.prodParam.hasIn || !this.match(54)) && this.raise(ErrorMessages.PrivateInExpectedIn, { node: left }, value), this.classScope.usePrivateName(value, left.loc.start);
            }
            const op = this.state.type;
            if ((token = op) >= 37 && token <= 55 && (this.prodParam.hasIn || !this.match(54))) {
              let prec = tokenOperatorPrecedence(op);
              if (prec > minPrec) {
                if (op === 37) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return left;
                  this.checkPipelineAtInfixOperator(left, leftStartLoc);
                }
                const node = this.startNodeAt(leftStartPos, leftStartLoc);
                node.left = left, node.operator = this.state.value;
                const logical = op === 39 || op === 40, coalesce = op === 38;
                if (coalesce && (prec = tokenOperatorPrecedence(40)), this.next(), op === 37 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 92 && this.prodParam.hasAwait)
                  throw this.raise(ErrorMessages.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                node.right = this.parseExprOpRightExpr(op, prec), this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
                const nextOp = this.state.type;
                if (coalesce && (nextOp === 39 || nextOp === 40) || logical && nextOp === 38)
                  throw this.raise(ErrorMessages.MixingCoalesceWithLogical, { at: this.state.startLoc });
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
              }
            }
            var token;
            return left;
          }
          parseExprOpRightExpr(op, prec) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            if (op === 37)
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case "smart":
                  return this.withTopicBindingContext(() => {
                    if (this.prodParam.hasYield && this.isContextual(101))
                      throw this.raise(ErrorMessages.PipeBodyIsTighter, { at: this.state.startLoc }, this.state.value);
                    return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec));
              }
            return this.parseExprOpBaseRightExpr(op, prec);
          }
          parseExprOpBaseRightExpr(op, prec) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, op === 53 ? prec - 1 : prec);
          }
          parseHackPipeBody() {
            var _body$extra;
            const { startLoc } = this.state, body = this.parseMaybeAssign();
            return !invalidHackPipeBodies.has(body.type) || (_body$extra = body.extra) != null && _body$extra.parenthesized || this.raise(ErrorMessages.PipeUnparenthesizedBody, { at: startLoc }, invalidHackPipeBodies.get(body.type)), this.topicReferenceWasUsedInCurrentContext() || this.raise(ErrorMessages.PipeTopicUnused, { at: startLoc }), body;
          }
          checkExponentialAfterUnary(node) {
            this.match(53) && this.raise(ErrorMessages.UnexpectedTokenUnaryExponentiation, { node: node.argument });
          }
          parseMaybeUnary(refExpressionErrors, sawUnary) {
            const startPos = this.state.start, startLoc = this.state.startLoc, isAwait = this.isContextual(92);
            if (isAwait && this.isAwaitAllowed()) {
              this.next();
              const expr2 = this.parseAwait(startPos, startLoc);
              return sawUnary || this.checkExponentialAfterUnary(expr2), expr2;
            }
            const update = this.match(34), node = this.startNode();
            if (token = this.state.type, tokenPrefixes[token]) {
              node.operator = this.state.value, node.prefix = true, this.match(68) && this.expectPlugin("throwExpressions");
              const isDelete = this.match(85);
              if (this.next(), node.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(refExpressionErrors, true), this.state.strict && isDelete) {
                const arg = node.argument;
                arg.type === "Identifier" ? this.raise(ErrorMessages.StrictDelete, { node }) : this.hasPropertyAsPrivateName(arg) && this.raise(ErrorMessages.DeletePrivateField, { node });
              }
              if (!update)
                return sawUnary || this.checkExponentialAfterUnary(node), this.finishNode(node, "UnaryExpression");
            }
            var token;
            const expr = this.parseUpdate(node, update, refExpressionErrors);
            if (isAwait) {
              const { type } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(50)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(startLoc, ErrorMessages.AwaitNotInAsyncContext), this.parseAwait(startPos, startLoc);
            }
            return expr;
          }
          parseUpdate(node, update, refExpressionErrors) {
            if (update)
              return this.checkLVal(node.argument, "prefix operation"), this.finishNode(node, "UpdateExpression");
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let expr = this.parseExprSubscripts(refExpressionErrors);
            if (this.checkExpressionErrors(refExpressionErrors, false))
              return expr;
            for (; this.state.type === 34 && !this.canInsertSemicolon(); ) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.operator = this.state.value, node2.prefix = false, node2.argument = expr, this.checkLVal(expr, "postfix operation"), this.next(), expr = this.finishNode(node2, "UpdateExpression");
            }
            return expr;
          }
          parseExprSubscripts(refExpressionErrors) {
            const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
            return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startPos, startLoc);
          }
          parseSubscripts(base, startPos, startLoc, noCalls) {
            const state = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(base), stop: false };
            do {
              base = this.parseSubscript(base, startPos, startLoc, noCalls, state), state.maybeAsyncArrow = false;
            } while (!state.stop);
            return base;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            const { type } = this.state;
            if (!noCalls && type === 15)
              return this.parseBind(base, startPos, startLoc, noCalls, state);
            if (tokenIsTemplate(type))
              return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
            let optional = false;
            if (type === 18) {
              if (noCalls && this.lookaheadCharCode() === 40)
                return state.stop = true, base;
              state.optionalChainMember = optional = true, this.next();
            }
            if (!noCalls && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
            {
              const computed = this.eat(0);
              return computed || optional || this.eat(16) ? this.parseMember(base, startPos, startLoc, state, computed, optional) : (state.stop = true, base);
            }
          }
          parseMember(base, startPos, startLoc, state, computed, optional) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.object = base, node.computed = computed, computed ? (node.property = this.parseExpression(), this.expect(3)) : this.match(130) ? (base.type === "Super" && this.raise(ErrorMessages.SuperPrivateField, { at: startLoc }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node.property = this.parsePrivateName()) : node.property = this.parseIdentifier(true), state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
          }
          parseBind(base, startPos, startLoc, noCalls, state) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.object = base, this.next(), node.callee = this.parseNoCallExpr(), state.stop = true, this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
          }
          parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            let refExpressionErrors = null;
            this.state.maybeInArrowParameters = true, this.next();
            let node = this.startNodeAt(startPos, startLoc);
            return node.callee = base, state.maybeAsyncArrow && (this.expressionScope.enter(new ArrowHeadParsingScope(2)), refExpressionErrors = new ExpressionErrors()), state.optionalChainMember && (node.optional = optional), node.arguments = optional ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors), this.finishCallExpression(node, state.optionalChainMember), state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node)) : (state.maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, true), this.expressionScope.exit()), this.toReferencedArguments(node)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
          }
          toReferencedArguments(node, isParenthesizedExpr) {
            this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
          }
          parseTaggedTemplateExpression(base, startPos, startLoc, state) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.tag = base, node.quasi = this.parseTemplate(true), state.optionalChainMember && this.raise(ErrorMessages.OptionalChainingNoTemplate, { at: startLoc }), this.finishNode(node, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(base) {
            return base.type === "Identifier" && base.name === "async" && indexes.get(this.state.lastTokEndLoc) === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && base.start === this.state.potentialArrowAt;
          }
          finishCallExpression(node, optional) {
            if (node.callee.type === "Import")
              if (node.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), node.arguments.length === 0 || node.arguments.length > 2)
                this.raise(ErrorMessages.ImportCallArity, { node }, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
              else
                for (const arg of node.arguments)
                  arg.type === "SpreadElement" && this.raise(ErrorMessages.ImportCallSpreadArgument, { node: arg });
            return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
            const elts = [];
            let first = true;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                !dynamicImport || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(ErrorMessages.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
                break;
              }
              elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
            }
            return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(node, call) {
            var _call$extra;
            return this.resetPreviousNodeTrailingComments(call), this.expect(19), this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc), call.innerComments && setInnerComments(node, call.innerComments), call.callee.trailingComments && setInnerComments(node, call.callee.trailingComments), node;
          }
          parseNoCallExpr() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
          }
          parseExprAtom(refExpressionErrors) {
            let node;
            const { type } = this.state;
            switch (type) {
              case 75:
                return this.parseSuper();
              case 79:
                return node = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(node) : (this.match(10) || this.raise(ErrorMessages.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(node, "Import"));
              case 74:
                return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");
              case 86:
                return this.parseDo(this.startNode(), false);
              case 52:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 126:
                return this.parseNumericLiteral(this.state.value);
              case 127:
                return this.parseBigIntLiteral(this.state.value);
              case 128:
                return this.parseDecimalLiteral(this.state.value);
              case 125:
                return this.parseStringLiteral(this.state.value);
              case 80:
                return this.parseNullLiteral();
              case 81:
                return this.parseBooleanLiteral(true);
              case 82:
                return this.parseBooleanLiteral(false);
              case 10: {
                const canBeArrow = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(canBeArrow);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, refExpressionErrors);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, refExpressionErrors);
              case 64:
                return this.parseFunctionOrFunctionSent();
              case 26:
                this.parseDecorators();
              case 76:
                return node = this.startNode(), this.takeDecorators(node), this.parseClass(node, false);
              case 73:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                node = this.startNode(), this.next(), node.object = null;
                const callee = node.callee = this.parseNoCallExpr();
                if (callee.type === "MemberExpression")
                  return this.finishNode(node, "BindExpression");
                throw this.raise(ErrorMessages.UnsupportedBind, { node: callee });
              }
              case 130:
                return this.raise(ErrorMessages.PrivateInExpectedIn, { at: this.state.startLoc }, this.state.value), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(50, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(42, "^");
              case 42:
              case 50:
              case 27: {
                const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
                if (pipeProposal)
                  return this.parseTopicReference(pipeProposal);
                throw this.unexpected();
              }
              case 45: {
                const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
                if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                  break;
                }
                throw this.unexpected();
              }
              default:
                if (tokenIsIdentifier(type)) {
                  if (this.isContextual(119) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                    return this.parseModuleExpression();
                  const canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
                  if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                    const { type: type2 } = this.state;
                    if (type2 === 64)
                      return this.resetPreviousNodeTrailingComments(id), this.next(), this.parseFunction(this.startNodeAtNode(id), void 0, true);
                    if (tokenIsIdentifier(type2))
                      return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
                    if (type2 === 86)
                      return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), true);
                  }
                  return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(id), [id], false)) : id;
                }
                throw this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal)
              return this.state.type = topicTokenType, this.state.value = topicTokenValue, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(pipeProposal);
            throw this.unexpected();
          }
          parseTopicReference(pipeProposal) {
            const node = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
            return this.next(), this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
          }
          finishTopicReference(node, startLoc, pipeProposal, tokenType) {
            if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
              const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(pipeProposal === "smart" ? ErrorMessages.PrimaryTopicNotAllowed : ErrorMessages.PipeTopicUnbound, { at: startLoc }), this.registerTopicReference(), this.finishNode(node, nodeType);
            }
            throw this.raise(ErrorMessages.PipeTopicUnconfiguredToken, { at: startLoc }, tokenLabelName(tokenType));
          }
          testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
            switch (pipeProposal) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: tokenLabelName(tokenType) }]);
              case "smart":
                return tokenType === 27;
              default:
                throw this.raise(ErrorMessages.PipeTopicRequiresHackPipes, { at: startLoc });
            }
          }
          parseAsyncArrowUnaryFunction(node) {
            this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
            const params = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(ErrorMessages.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(node, params, true), node;
          }
          parseDo(node, isAsync) {
            this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), node.async = isAsync, this.next();
            const oldLabels = this.state.labels;
            return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node.body = this.parseBlock(), this.prodParam.exit()) : node.body = this.parseBlock(), this.state.labels = oldLabels, this.finishNode(node, "DoExpression");
          }
          parseSuper() {
            const node = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(ErrorMessages.UnexpectedSuper, { node }) : this.raise(ErrorMessages.SuperNotAllowed, { node }), this.match(10) || this.match(0) || this.match(16) || this.raise(ErrorMessages.UnsupportedSuper, { node }), this.finishNode(node, "Super");
          }
          parsePrivateName() {
            const node = this.startNode(), id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), name = this.state.value;
            return this.next(), node.id = this.createIdentifier(id, name), this.finishNode(node, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const node = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
              return this.next(), this.match(98) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(node, meta, "sent");
            }
            return this.parseFunction(node);
          }
          parseMetaProperty(node, meta, propertyName) {
            node.meta = meta;
            const containsEsc = this.state.containsEsc;
            return node.property = this.parseIdentifier(true), (node.property.name !== propertyName || containsEsc) && this.raise(ErrorMessages.UnsupportedMetaProperty, { node: node.property }, meta.name, propertyName), this.finishNode(node, "MetaProperty");
          }
          parseImportMetaProperty(node) {
            const id = this.createIdentifier(this.startNodeAtNode(node), "import");
            return this.next(), this.isContextual(96) && (this.inModule || this.raise(SourceTypeModuleErrorMessages.ImportMetaOutsideModule, { node: id }), this.sawUnambiguousESM = true), this.parseMetaProperty(node, id, "meta");
          }
          parseLiteralAtNode(value, type, node) {
            return this.addExtra(node, "rawValue", value), this.addExtra(node, "raw", this.input.slice(node.start, this.state.end)), node.value = value, this.next(), this.finishNode(node, type);
          }
          parseLiteral(value, type) {
            const node = this.startNode();
            return this.parseLiteralAtNode(value, type, node);
          }
          parseStringLiteral(value) {
            return this.parseLiteral(value, "StringLiteral");
          }
          parseNumericLiteral(value) {
            return this.parseLiteral(value, "NumericLiteral");
          }
          parseBigIntLiteral(value) {
            return this.parseLiteral(value, "BigIntLiteral");
          }
          parseDecimalLiteral(value) {
            return this.parseLiteral(value, "DecimalLiteral");
          }
          parseRegExpLiteral(value) {
            const node = this.parseLiteral(value.value, "RegExpLiteral");
            return node.pattern = value.pattern, node.flags = value.flags, node;
          }
          parseBooleanLiteral(value) {
            const node = this.startNode();
            return node.value = value, this.next(), this.finishNode(node, "BooleanLiteral");
          }
          parseNullLiteral() {
            const node = this.startNode();
            return this.next(), this.finishNode(node, "NullLiteral");
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let val;
            this.next(), this.expressionScope.enter(new ArrowHeadParsingScope(1));
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const innerStartPos = this.state.start, innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors();
            let spreadStartLoc, optionalCommaStartLoc, first = true;
            for (; !this.match(11); ) {
              if (first)
                first = false;
              else if (this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc), this.match(11)) {
                optionalCommaStartLoc = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
                if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc)), !this.checkCommaAfterRest(41))
                  break;
              } else
                exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
            }
            const innerEndLoc = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let arrowNode = this.startNodeAt(startPos, startLoc);
            if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)))
              return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, false), arrowNode;
            if (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), this.checkExpressionErrors(refExpressionErrors, true), this.toReferencedListDeep(exprList, true), exprList.length > 1 ? (val = this.startNodeAt(innerStartPos, innerStartLoc), val.expressions = exprList, this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], !this.options.createParenthesizedExpressions)
              return this.addExtra(val, "parenthesized", true), this.addExtra(val, "parenStart", startPos), this.takeSurroundingComments(val, startPos, indexes.get(this.state.lastTokEndLoc)), val;
            const parenExpression = this.startNodeAt(startPos, startLoc);
            return parenExpression.expression = val, this.finishNode(parenExpression, "ParenthesizedExpression"), parenExpression;
          }
          shouldParseArrow(params) {
            return !this.canInsertSemicolon();
          }
          parseArrow(node) {
            if (this.eat(19))
              return node;
          }
          parseParenItem(node, startPos, startLoc) {
            return node;
          }
          parseNewOrNewTarget() {
            const node = this.startNode();
            if (this.next(), this.match(16)) {
              const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
              this.next();
              const metaProp = this.parseMetaProperty(node, meta, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(ErrorMessages.UnexpectedNewTarget, { node: metaProp }), metaProp;
            }
            return this.parseNew(node);
          }
          parseNew(node) {
            return node.callee = this.parseNoCallExpr(), node.callee.type === "Import" ? this.raise(ErrorMessages.ImportCallNotNewExpression, { node: node.callee }) : this.isOptionalChain(node.callee) ? this.raise(ErrorMessages.OptionalChainingNoNew, { at: this.state.lastTokEndLoc }) : this.eat(18) && this.raise(ErrorMessages.OptionalChainingNoNew, { at: this.state.startLoc }), this.parseNewArguments(node), this.finishNode(node, "NewExpression");
          }
          parseNewArguments(node) {
            if (this.eat(10)) {
              const args = this.parseExprList(11);
              this.toReferencedList(args), node.arguments = args;
            } else
              node.arguments = [];
          }
          parseTemplateElement(isTagged) {
            const { start, startLoc, end, value } = this.state, elemStart = start + 1, elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
            value === null && (isTagged || this.raise(ErrorMessages.InvalidEscapeSequenceTemplate, { at: createPositionWithColumnOffset(startLoc, 2) }));
            const isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end + endOffset;
            return elem.value = { raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"), cooked: value === null ? null : value.slice(1, endOffset) }, elem.tail = isTail, this.next(), this.finishNode(elem, "TemplateElement"), this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), elem;
          }
          parseTemplate(isTagged) {
            const node = this.startNode();
            node.expressions = [];
            let curElt = this.parseTemplateElement(isTagged);
            for (node.quasis = [curElt]; !curElt.tail; )
              node.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), node.quasis.push(curElt = this.parseTemplateElement(isTagged));
            return this.finishNode(node, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
            isRecord && this.expectPlugin("recordAndTuple");
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const propHash = /* @__PURE__ */ Object.create(null);
            let first = true;
            const node = this.startNode();
            for (node.properties = [], this.next(); !this.match(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                this.addTrailingCommaExtraToNode(node);
                break;
              }
              let prop;
              isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), this.checkProto(prop, isRecord, propHash, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement" && this.raise(ErrorMessages.InvalidRecordProperty, { node: prop }), prop.shorthand && this.addExtra(prop, "shorthand", true), node.properties.push(prop);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
            let type = "ObjectExpression";
            return isPattern ? type = "ObjectPattern" : isRecord && (type = "RecordExpression"), this.finishNode(node, type);
          }
          addTrailingCommaExtraToNode(node) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart), this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(prop) {
            return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(51));
          }
          parsePropertyDefinition(refExpressionErrors) {
            let decorators = [];
            if (this.match(26))
              for (this.hasPlugin("decorators") && this.raise(ErrorMessages.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                decorators.push(this.parseDecorator());
            const prop = this.startNode();
            let startPos, startLoc, isAsync = false, isAccessor = false;
            if (this.match(21))
              return decorators.length && this.unexpected(), this.parseSpread();
            decorators.length && (prop.decorators = decorators, decorators = []), prop.method = false, refExpressionErrors && (startPos = this.state.start, startLoc = this.state.startLoc);
            let isGenerator = this.eat(51);
            this.parsePropertyNamePrefixOperator(prop);
            const containsEsc = this.state.containsEsc, key = this.parsePropertyName(prop);
            if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
              const keyName = key.name;
              keyName !== "async" || this.hasPrecedingLineBreak() || (isAsync = true, this.resetPreviousNodeTrailingComments(key), isGenerator = this.eat(51), this.parsePropertyName(prop)), keyName !== "get" && keyName !== "set" || (isAccessor = true, this.resetPreviousNodeTrailingComments(key), prop.kind = keyName, this.match(51) && (isGenerator = true, this.raise(ErrorMessages.AccessorIsGenerator, { at: this.state.curPosition() }, keyName), this.next()), this.parsePropertyName(prop));
            }
            return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors), prop;
          }
          getGetterSetterExpectedParamCount(method) {
            return method.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(method) {
            return method.params;
          }
          checkGetterSetterParams(method) {
            var _params;
            const paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
            params.length !== paramCount && this.raise(method.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, { node: method }), method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement" && this.raise(ErrorMessages.BadSetterRestParameter, { node: method });
          }
          parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            return isAccessor ? (this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(prop), prop) : isAsync || isGenerator || this.match(10) ? (isPattern && this.unexpected(), prop.kind = "method", prop.method = true, this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod")) : void 0;
          }
          parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
            if (prop.shorthand = false, this.eat(14))
              return prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors), this.finishNode(prop, "ObjectProperty");
            if (!prop.computed && prop.key.type === "Identifier") {
              if (this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false), isPattern)
                prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
              else if (this.match(29)) {
                const shorthandAssignLoc = this.state.startLoc;
                refExpressionErrors != null ? refExpressionErrors.shorthandAssignLoc === null && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(ErrorMessages.InvalidCoverInitializedName, { at: shorthandAssignLoc }), prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
              } else
                prop.value = cloneIdentifier(prop.key);
              return prop.shorthand = true, this.finishNode(prop, "ObjectProperty");
            }
          }
          parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
            return node || this.unexpected(), node;
          }
          parsePropertyName(prop) {
            if (this.eat(0))
              prop.computed = true, prop.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type, value } = this.state;
              let key;
              if (tokenIsKeywordOrIdentifier(type))
                key = this.parseIdentifier(true);
              else
                switch (type) {
                  case 126:
                    key = this.parseNumericLiteral(value);
                    break;
                  case 125:
                    key = this.parseStringLiteral(value);
                    break;
                  case 127:
                    key = this.parseBigIntLiteral(value);
                    break;
                  case 128:
                    key = this.parseDecimalLiteral(value);
                    break;
                  case 130:
                    this.raise(ErrorMessages.UnexpectedPrivateField, { at: createPositionWithColumnOffset(this.state.startLoc, 1) }), key = this.parsePrivateName();
                    break;
                  default:
                    throw this.unexpected();
                }
              prop.key = key, type !== 130 && (prop.computed = false);
            }
            return prop.key;
          }
          initFunction(node, isAsync) {
            node.id = null, node.generator = false, node.async = !!isAsync;
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
            this.initFunction(node, isAsync), node.generator = !!isGenerator;
            const allowModifiers = isConstructor;
            return this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), this.prodParam.enter(functionFlags(isAsync, node.generator)), this.parseFunctionParams(node, allowModifiers), this.parseFunctionBodyAndFinish(node, type, true), this.prodParam.exit(), this.scope.exit(), node;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            isTuple && this.expectPlugin("recordAndTuple");
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const node = this.startNode();
            return this.next(), node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
            this.scope.enter(6);
            let flags = functionFlags(isAsync, false);
            !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), this.initFunction(node, isAsync);
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            return params && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(node, params, trailingCommaLoc)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(node, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.finishNode(node, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(node, params, trailingCommaLoc) {
            node.params = this.toAssignableList(params, trailingCommaLoc, false);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = false) {
            this.parseFunctionBody(node, false, isMethod), this.finishNode(node, type);
          }
          parseFunctionBody(node, allowExpression, isMethod = false) {
            const isExpression = allowExpression && !this.match(5);
            if (this.expressionScope.enter(newExpressionScope()), isExpression)
              node.body = this.parseMaybeAssign(), this.checkParams(node, false, allowExpression, false);
            else {
              const oldStrict = this.state.strict, oldLabels = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
                const nonSimple = !this.isSimpleParamList(node.params);
                if (hasStrictModeDirective && nonSimple) {
                  const errorOrigin = node.kind !== "method" && node.kind !== "constructor" || !node.key ? { node } : { at: node.key.loc.end };
                  this.raise(ErrorMessages.IllegalLanguageModeDirective, errorOrigin);
                }
                const strictModeChanged = !oldStrict && this.state.strict;
                this.checkParams(node, !(this.state.strict || allowExpression || isMethod || nonSimple), allowExpression, strictModeChanged), this.state.strict && node.id && this.checkLVal(node.id, "function name", 65, void 0, void 0, strictModeChanged);
              }), this.prodParam.exit(), this.state.labels = oldLabels;
            }
            this.expressionScope.exit();
          }
          isSimpleParamList(params) {
            for (let i = 0, len = params.length; i < len; i++)
              if (params[i].type !== "Identifier")
                return false;
            return true;
          }
          checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
            const checkClashes = /* @__PURE__ */ new Set();
            for (const param of node.params)
              this.checkLVal(param, "function parameter list", 5, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
          }
          parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
            const elts = [];
            let first = true;
            for (; !this.eat(close); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.match(close)) {
                nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
                break;
              }
              elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
            }
            return elts;
          }
          parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
            let elt;
            if (this.match(12))
              allowEmpty || this.raise(ErrorMessages.UnexpectedToken, { at: this.state.curPosition() }, ","), elt = null;
            else if (this.match(21)) {
              const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
              elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(ErrorMessages.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
              const node = this.startNode();
              this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
            } else
              elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
            return elt;
          }
          parseIdentifier(liberal) {
            const node = this.startNode(), name = this.parseIdentifierName(node.start, liberal);
            return this.createIdentifier(node, name);
          }
          createIdentifier(node, name) {
            return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
          }
          parseIdentifierName(pos, liberal) {
            let name;
            const { startLoc, type } = this.state;
            if (!tokenIsKeywordOrIdentifier(type))
              throw this.unexpected();
            name = this.state.value;
            const tokenIsKeyword2 = type <= 88;
            return liberal ? tokenIsKeyword2 && this.replaceToken(124) : this.checkReservedWord(name, startLoc, tokenIsKeyword2, false), this.next(), name;
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            if (word.length > 10)
              return;
            if (!function(word2) {
              return reservedWordLikeSet.has(word2);
            }(word))
              return;
            if (word === "yield") {
              if (this.prodParam.hasYield)
                return void this.raise(ErrorMessages.YieldBindingIdentifier, { at: startLoc });
            } else if (word === "await") {
              if (this.prodParam.hasAwait)
                return void this.raise(ErrorMessages.AwaitBindingIdentifier, { at: startLoc });
              if (this.scope.inStaticBlock)
                return void this.raise(ErrorMessages.AwaitBindingIdentifierInStaticBlock, { at: startLoc });
              this.expressionScope.recordAsyncArrowParametersError(ErrorMessages.AwaitBindingIdentifier, startLoc);
            } else if (word === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
              return void this.raise(ErrorMessages.ArgumentsInClass, { at: startLoc });
            if (checkKeywords && function(word2) {
              return keywords.has(word2);
            }(word))
              return void this.raise(ErrorMessages.UnexpectedKeyword, { at: startLoc }, word);
            (this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule) && this.raise(ErrorMessages.UnexpectedReservedWord, { at: startLoc }, word);
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            return this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.AwaitExpressionFormalParameter), this.eat(51) && this.raise(ErrorMessages.ObsoleteAwaitStar, { node }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (node.argument = this.parseMaybeUnary(null, true)), this.finishNode(node, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return true;
            const { type } = this.state;
            return type === 49 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 129 || type === 52 || this.hasPlugin("v8intrinsic") && type === 50;
          }
          parseYield() {
            const node = this.startNode();
            this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.YieldInParameter), this.next();
            let delegating = false, argument = null;
            if (!this.hasPrecedingLineBreak())
              switch (delegating = this.eat(51), this.state.type) {
                case 13:
                case 131:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!delegating)
                    break;
                default:
                  argument = this.parseMaybeAssign();
              }
            return node.delegate = delegating, node.argument = argument, this.finishNode(node, "YieldExpression");
          }
          checkPipelineAtInfixOperator(left, leftStartLoc) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && left.type === "SequenceExpression" && this.raise(ErrorMessages.PipelineHeadSequenceExpression, { at: leftStartLoc });
          }
          parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
            const bodyNode = this.startNodeAt(startPos, startLoc);
            return this.isSimpleReference(childExpr) ? (bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(startLoc), bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression"));
          }
          isSimpleReference(expression) {
            switch (expression.type) {
              case "MemberExpression":
                return !expression.computed && this.isSimpleReference(expression.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(startLoc) {
            if (this.match(19))
              throw this.raise(ErrorMessages.PipelineBodyNoArrow, { at: this.state.startLoc });
            this.topicReferenceWasUsedInCurrentContext() || this.raise(ErrorMessages.PipelineTopicUnused, { at: startLoc });
          }
          withTopicBindingContext(callback) {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
          withSmartMixTopicForbiddingContext(callback) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }]))
              return callback();
            {
              const outerContextTopicState = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return callback();
              } finally {
                this.state.topicContext = outerContextTopicState;
              }
            }
          }
          withSoloAwaitPermittingContext(callback) {
            const outerContextSoloAwaitState = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return callback();
            } finally {
              this.state.soloAwait = outerContextSoloAwaitState;
            }
          }
          allowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            if (8 & ~flags) {
              this.prodParam.enter(8 | flags);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          disallowInAnd(callback) {
            const flags = this.prodParam.currentFlags();
            if (8 & flags) {
              this.prodParam.enter(-9 & flags);
              try {
                return callback();
              } finally {
                this.prodParam.exit();
              }
            }
            return callback();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(prec) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
            return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const node = this.startNode();
            this.next(), this.eat(5);
            const revertScopes = this.initializeScopes(true);
            this.enterInitialScopes();
            const program = this.startNode();
            try {
              node.body = this.parseProgram(program, 8, "module");
            } finally {
              revertScopes();
            }
            return this.eat(8), this.finishNode(node, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(prop) {
          }
        } {
          parseTopLevel(file, program) {
            return file.program = this.parseProgram(program), file.comments = this.state.comments, this.options.tokens && (file.tokens = function(tokens, input) {
              for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i], { type } = token;
                if (typeof type == "number") {
                  if (type === 130) {
                    const { loc, start, value, end } = token, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                    tokens.splice(i, 1, new Token({ type: getExportedToken(27), value: "#", start, end: hashEndPos, startLoc: loc.start, endLoc: hashEndLoc }), new Token({ type: getExportedToken(124), value, start: hashEndPos, end, startLoc: hashEndLoc, endLoc: loc.end })), i++;
                    continue;
                  }
                  if (tokenIsTemplate(type)) {
                    const { loc, start, value, end } = token, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                    let startToken, templateValue, templateElementEnd, templateElementEndLoc, endToken;
                    startToken = input.charCodeAt(start) === 96 ? new Token({ type: getExportedToken(22), value: "`", start, end: backquoteEnd, startLoc: loc.start, endLoc: backquoteEndLoc }) : new Token({ type: getExportedToken(8), value: "}", start, end: backquoteEnd, startLoc: loc.start, endLoc: backquoteEndLoc }), type === 24 ? (templateElementEnd = end - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), templateValue = value === null ? null : value.slice(1, -1), endToken = new Token({ type: getExportedToken(22), value: "`", start: templateElementEnd, end, startLoc: templateElementEndLoc, endLoc: loc.end })) : (templateElementEnd = end - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), templateValue = value === null ? null : value.slice(1, -2), endToken = new Token({ type: getExportedToken(23), value: "${", start: templateElementEnd, end, startLoc: templateElementEndLoc, endLoc: loc.end })), tokens.splice(i, 1, startToken, new Token({ type: getExportedToken(20), value: templateValue, start: backquoteEnd, end: templateElementEnd, startLoc: backquoteEndLoc, endLoc: templateElementEndLoc }), endToken), i += 2;
                    continue;
                  }
                  token.type = getExportedToken(type);
                }
              }
              return tokens;
            }(this.tokens, this.input)), this.finishNode(file, "File");
          }
          parseProgram(program, end = 131, sourceType = this.options.sourceType) {
            if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(program, true, true, end), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (const [name, loc] of Array.from(this.scope.undefinedExports))
                this.raise(ErrorMessages.ModuleExportUndefined, { at: loc }, name);
            return this.finishNode(program, "Program");
          }
          stmtToDirective(stmt) {
            const directive = stmt;
            directive.type = "Directive", directive.value = directive.expression, delete directive.expression;
            const directiveLiteral = directive.value, expressionValue = directiveLiteral.value, raw = this.input.slice(directiveLiteral.start, directiveLiteral.end), val = directiveLiteral.value = raw.slice(1, -1);
            return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), this.addExtra(directiveLiteral, "expressionValue", expressionValue), directiveLiteral.type = "DirectiveLiteral", directive;
          }
          parseInterpreterDirective() {
            if (!this.match(28))
              return null;
            const node = this.startNode();
            return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
          }
          isLet(context) {
            return !!this.isContextual(95) && this.isLetKeyword(context);
          }
          isLetKeyword(context) {
            const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
            if (nextCh === 92 || nextCh === 91)
              return true;
            if (context)
              return false;
            if (nextCh === 123)
              return true;
            if (isIdentifierStart(nextCh)) {
              if (keywordRelationalOperator.lastIndex = next, keywordRelationalOperator.test(this.input)) {
                const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
                if (!isIdentifierChar(endCh) && endCh !== 92)
                  return false;
              }
              return true;
            }
            return false;
          }
          parseStatement(context, topLevel) {
            return this.match(26) && this.parseDecorators(true), this.parseStatementContent(context, topLevel);
          }
          parseStatementContent(context, topLevel) {
            let starttype = this.state.type;
            const node = this.startNode();
            let kind;
            switch (this.isLet(context) && (starttype = 70, kind = "let"), starttype) {
              case 56:
                return this.parseBreakContinueStatement(node, true);
              case 59:
                return this.parseBreakContinueStatement(node, false);
              case 60:
                return this.parseDebuggerStatement(node);
              case 86:
                return this.parseDoStatement(node);
              case 87:
                return this.parseForStatement(node);
              case 64:
                if (this.lookaheadCharCode() === 46)
                  break;
                return context && (this.state.strict ? this.raise(ErrorMessages.StrictFunction, { at: this.state.startLoc }) : context !== "if" && context !== "label" && this.raise(ErrorMessages.SloppyFunction, { at: this.state.startLoc })), this.parseFunctionStatement(node, false, !context);
              case 76:
                return context && this.unexpected(), this.parseClass(node, true);
              case 65:
                return this.parseIfStatement(node);
              case 66:
                return this.parseReturnStatement(node);
              case 67:
                return this.parseSwitchStatement(node);
              case 68:
                return this.parseThrowStatement(node);
              case 69:
                return this.parseTryStatement(node);
              case 71:
              case 70:
                return kind = kind || this.state.value, context && kind !== "var" && this.raise(ErrorMessages.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(node, kind);
              case 88:
                return this.parseWhileStatement(node);
              case 72:
                return this.parseWithStatement(node);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(node);
              case 79: {
                const nextTokenCharCode = this.lookaheadCharCode();
                if (nextTokenCharCode === 40 || nextTokenCharCode === 46)
                  break;
              }
              case 78: {
                let result;
                return this.options.allowImportExportEverywhere || topLevel || this.raise(ErrorMessages.UnexpectedImportExport, { at: this.state.startLoc }), this.next(), starttype === 79 ? (result = this.parseImport(node), result.type !== "ImportDeclaration" || result.importKind && result.importKind !== "value" || (this.sawUnambiguousESM = true)) : (result = this.parseExport(node), (result.type !== "ExportNamedDeclaration" || result.exportKind && result.exportKind !== "value") && (result.type !== "ExportAllDeclaration" || result.exportKind && result.exportKind !== "value") && result.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(node), result;
              }
              default:
                if (this.isAsyncFunction())
                  return context && this.raise(ErrorMessages.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(node, true, !context);
            }
            const maybeName = this.state.value, expr = this.parseExpression();
            return tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
          }
          assertModuleNodeAllowed(node) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(SourceTypeModuleErrorMessages.ImportOutsideModule, { node });
          }
          takeDecorators(node) {
            const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            decorators.length && (node.decorators = decorators, this.resetStartLocationFromNode(node, decorators[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
          }
          canHaveLeadingDecorator() {
            return this.match(76);
          }
          parseDecorators(allowExport) {
            const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
            for (; this.match(26); ) {
              const decorator = this.parseDecorator();
              currentContextDecorators.push(decorator);
            }
            if (this.match(78))
              allowExport || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(ErrorMessages.DecoratorExportClass, { at: this.state.startLoc });
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(ErrorMessages.UnexpectedLeadingDecorator, { at: this.state.startLoc });
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators-legacy", "decorators"]);
            const node = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              this.state.decoratorStack.push([]);
              const startPos = this.state.start, startLoc = this.state.startLoc;
              let expr;
              if (this.eat(10))
                expr = this.parseExpression(), this.expect(11);
              else
                for (expr = this.parseIdentifier(false); this.eat(16); ) {
                  const node2 = this.startNodeAt(startPos, startLoc);
                  node2.object = expr, node2.property = this.parseIdentifier(true), node2.computed = false, expr = this.finishNode(node2, "MemberExpression");
                }
              node.expression = this.parseMaybeDecoratorArguments(expr), this.state.decoratorStack.pop();
            } else
              node.expression = this.parseExprSubscripts();
            return this.finishNode(node, "Decorator");
          }
          parseMaybeDecoratorArguments(expr) {
            if (this.eat(10)) {
              const node = this.startNodeAtNode(expr);
              return node.callee = expr, node.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
            }
            return expr;
          }
          parseBreakContinueStatement(node, isBreak) {
            return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(node, isBreak), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(node, isBreak) {
            let i;
            for (i = 0; i < this.state.labels.length; ++i) {
              const lab = this.state.labels[i];
              if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop"))
                  break;
                if (node.label && isBreak)
                  break;
              }
            }
            i === this.state.labels.length && this.raise(ErrorMessages.IllegalBreakContinue, { node }, isBreak ? "break" : "continue");
          }
          parseDebuggerStatement(node) {
            return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const val = this.parseExpression();
            return this.expect(11), val;
          }
          parseDoStatement(node) {
            return this.next(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(88), node.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(node, "DoWhileStatement");
          }
          parseForStatement(node) {
            this.next(), this.state.labels.push(loopLabel);
            let awaitAt = null;
            if (this.isAwaitAllowed() && this.eatContextual(92) && (awaitAt = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
              return awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, null);
            const startsWithLet = this.isContextual(95), isLet = startsWithLet && this.isLetKeyword();
            if (this.match(70) || this.match(71) || isLet) {
              const init2 = this.startNode(), kind = isLet ? "let" : this.state.value;
              return this.next(), this.parseVar(init2, true, kind), this.finishNode(init2, "VariableDeclaration"), (this.match(54) || this.isContextual(97)) && init2.declarations.length === 1 ? this.parseForIn(node, init2, awaitAt) : (awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init2));
            }
            const startsWithAsync = this.isContextual(91), refExpressionErrors = new ExpressionErrors(), init = this.parseExpression(true, refExpressionErrors), isForOf = this.isContextual(97);
            if (isForOf && (startsWithLet && this.raise(ErrorMessages.ForOfLet, { node: init }), awaitAt === null && startsWithAsync && init.type === "Identifier" && this.raise(ErrorMessages.ForOfAsync, { node: init })), isForOf || this.match(54)) {
              this.toAssignable(init, true);
              const description = isForOf ? "for-of statement" : "for-in statement";
              return this.checkLVal(init, description), this.parseForIn(node, init, awaitAt);
            }
            return this.checkExpressionErrors(refExpressionErrors, true), awaitAt !== null && this.unexpected(awaitAt), this.parseFor(node, init);
          }
          parseFunctionStatement(node, isAsync, declarationPosition) {
            return this.next(), this.parseFunction(node, 1 | (declarationPosition ? 0 : 2), isAsync);
          }
          parseIfStatement(node) {
            return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatement("if"), node.alternate = this.eat(62) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
          }
          parseReturnStatement(node) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(ErrorMessages.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), this.semicolon()), this.finishNode(node, "ReturnStatement");
          }
          parseSwitchStatement(node) {
            this.next(), node.discriminant = this.parseHeaderExpression();
            const cases = node.cases = [];
            let cur, sawDefault;
            for (this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(0); !this.match(8); )
              if (this.match(57) || this.match(61)) {
                const isCase = this.match(57);
                cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(ErrorMessages.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), sawDefault = true, cur.test = null), this.expect(14);
              } else
                cur ? cur.consequent.push(this.parseStatement(null)) : this.unexpected();
            return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
          }
          parseThrowStatement(node) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(ErrorMessages.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const param = this.parseBindingAtom(), simple = param.type === "Identifier";
            return this.scope.enter(simple ? 8 : 0), this.checkLVal(param, "catch clause", 9), param;
          }
          parseTryStatement(node) {
            if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(58)) {
              const clause = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), node.handler = this.finishNode(clause, "CatchClause");
            }
            return node.finalizer = this.eat(63) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(ErrorMessages.NoCatchOrFinally, { node }), this.finishNode(node, "TryStatement");
          }
          parseVarStatement(node, kind) {
            return this.next(), this.parseVar(node, false, kind), this.semicolon(), this.finishNode(node, "VariableDeclaration");
          }
          parseWhileStatement(node) {
            return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(node, "WhileStatement");
          }
          parseWithStatement(node) {
            return this.state.strict && this.raise(ErrorMessages.StrictWith, { at: this.state.startLoc }), this.next(), node.object = this.parseHeaderExpression(), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(node, "WithStatement");
          }
          parseEmptyStatement(node) {
            return this.next(), this.finishNode(node, "EmptyStatement");
          }
          parseLabeledStatement(node, maybeName, expr, context) {
            for (const label of this.state.labels)
              label.name === maybeName && this.raise(ErrorMessages.LabelRedeclaration, { node: expr }, maybeName);
            const kind = (token = this.state.type) >= 86 && token <= 88 ? "loop" : this.match(67) ? "switch" : null;
            var token;
            for (let i = this.state.labels.length - 1; i >= 0; i--) {
              const label = this.state.labels[i];
              if (label.statementStart !== node.start)
                break;
              label.statementStart = this.state.start, label.kind = kind;
            }
            return this.state.labels.push({ name: maybeName, kind, statementStart: this.state.start }), node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label"), this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
          }
          parseExpressionStatement(node, expr) {
            return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
          }
          parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
            const node = this.startNode();
            return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), this.finishNode(node, "BlockStatement");
          }
          isValidDirective(stmt) {
            return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
          }
          parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
            const body = node.body = [], directives = node.directives = [];
            this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
          }
          parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
            const oldStrict = this.state.strict;
            let hasStrictModeDirective = false, parsedNonDirective = false;
            for (; !this.match(end); ) {
              const stmt = this.parseStatement(null, topLevel);
              if (directives && !parsedNonDirective) {
                if (this.isValidDirective(stmt)) {
                  const directive = this.stmtToDirective(stmt);
                  directives.push(directive), hasStrictModeDirective || directive.value.value !== "use strict" || (hasStrictModeDirective = true, this.setStrict(true));
                  continue;
                }
                parsedNonDirective = true, this.state.strictErrors.clear();
              }
              body.push(stmt);
            }
            afterBlockParse && afterBlockParse.call(this, hasStrictModeDirective), oldStrict || this.setStrict(false), this.next();
          }
          parseFor(node, init) {
            return node.init = init, this.semicolon(false), node.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), node.update = this.match(11) ? null : this.parseExpression(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
          }
          parseForIn(node, init, awaitAt) {
            const isForIn = this.match(54);
            return this.next(), isForIn ? awaitAt !== null && this.unexpected(awaitAt) : node.await = awaitAt !== null, init.type !== "VariableDeclaration" || init.declarations[0].init == null || isForIn && !this.state.strict && init.kind === "var" && init.declarations[0].id.type === "Identifier" || this.raise(ErrorMessages.ForInOfLoopInitializer, { node: init }, isForIn ? "for-in" : "for-of"), init.type === "AssignmentPattern" && this.raise(ErrorMessages.InvalidLhs, { node: init }, "for-loop"), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(node, isFor, kind) {
            const declarations = node.declarations = [], isTypescript = this.hasPlugin("typescript");
            for (node.kind = kind; ; ) {
              const decl = this.startNode();
              if (this.parseVarId(decl, kind), this.eat(29) ? decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (kind !== "const" || this.match(54) || this.isContextual(97) ? decl.id.type === "Identifier" || isFor && (this.match(54) || this.isContextual(97)) || this.raise(ErrorMessages.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc }, "Complex binding patterns") : isTypescript || this.raise(ErrorMessages.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc }, "Const declarations"), decl.init = null), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return node;
          }
          parseVarId(decl, kind) {
            decl.id = this.parseBindingAtom(), this.checkLVal(decl.id, "variable declaration", kind === "var" ? 5 : 9, void 0, kind !== "var");
          }
          parseFunction(node, statement = 0, isAsync = false) {
            const isStatement = 1 & statement, isHangingStatement = 2 & statement, requireId = !(!isStatement || 4 & statement);
            this.initFunction(node, isAsync), this.match(51) && isHangingStatement && this.raise(ErrorMessages.GeneratorInSingleStatementContext, { at: this.state.startLoc }), node.generator = this.eat(51), isStatement && (node.id = this.parseFunctionId(requireId));
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(functionFlags(isAsync, node.generator)), isStatement || (node.id = this.parseFunctionId()), this.parseFunctionParams(node, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), isStatement && !isHangingStatement && this.registerFunctionStatementId(node), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
          }
          parseFunctionId(requireId) {
            return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(node, allowModifiers) {
            this.expect(10), this.expressionScope.enter(new ExpressionScope(3)), node.params = this.parseBindingList(11, 41, false, allowModifiers), this.expressionScope.exit();
          }
          registerFunctionStatementId(node) {
            node.id && this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, node.id.loc.start);
          }
          parseClass(node, isStatement, optionalId) {
            this.next(), this.takeDecorators(node);
            const oldStrict = this.state.strict;
            return this.state.strict = true, this.parseClassId(node, isStatement, optionalId), this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          isNonstaticConstructor(method) {
            return !(method.computed || method.static || method.key.name !== "constructor" && method.key.value !== "constructor");
          }
          parseClassBody(hadSuperClass, oldStrict) {
            this.classScope.enter();
            const state = { hadConstructor: false, hadSuperClass };
            let decorators = [];
            const classBody = this.startNode();
            if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (decorators.length > 0)
                    throw this.raise(ErrorMessages.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                  continue;
                }
                if (this.match(26)) {
                  decorators.push(this.parseDecorator());
                  continue;
                }
                const member = this.startNode();
                decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), decorators = []), this.parseClassMember(classBody, member, state), member.kind === "constructor" && member.decorators && member.decorators.length > 0 && this.raise(ErrorMessages.DecoratorConstructor, { node: member });
              }
            }), this.state.strict = oldStrict, this.next(), decorators.length)
              throw this.raise(ErrorMessages.TrailingDecorator, { at: this.state.startLoc });
            return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
          }
          parseClassMemberFromModifier(classBody, member) {
            const key = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const method = member;
              return method.kind = "method", method.computed = false, method.key = key, method.static = false, this.pushClassMethod(classBody, method, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const prop = member;
              return prop.computed = false, prop.key = key, prop.static = false, classBody.body.push(this.parseClassProperty(prop)), true;
            }
            return this.resetPreviousNodeTrailingComments(key), false;
          }
          parseClassMember(classBody, member, state) {
            const isStatic = this.isContextual(100);
            if (isStatic) {
              if (this.parseClassMemberFromModifier(classBody, member))
                return;
              if (this.eat(5))
                return void this.parseClassStaticBlock(classBody, member);
            }
            this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, method = publicMethod, publicMember = publicMethod;
            if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(51)) {
              method.kind = "method";
              const isPrivateName = this.match(130);
              return this.parseClassElementName(method), isPrivateName ? void this.pushClassPrivateMethod(classBody, privateMethod, true, false) : (this.isNonstaticConstructor(publicMethod) && this.raise(ErrorMessages.ConstructorIsGenerator, { node: publicMethod.key }), void this.pushClassMethod(classBody, publicMethod, true, false, false, false));
            }
            const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc, isPrivate = this.match(130), key = this.parseClassElementName(member), maybeQuestionTokenStartLoc = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
              if (method.kind = "method", isPrivate)
                return void this.pushClassPrivateMethod(classBody, privateMethod, false, false);
              const isConstructor = this.isNonstaticConstructor(publicMethod);
              let allowsDirectSuper = false;
              isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(ErrorMessages.DuplicateConstructor, { node: key }), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(ErrorMessages.OverrideOnConstructor, { node: key }), state.hadConstructor = true, allowsDirectSuper = state.hadSuperClass), this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
            } else if (this.isClassProperty())
              isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp);
            else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(key);
              const isGenerator = this.eat(51);
              publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
              const isPrivate2 = this.match(130);
              this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true) : (this.isNonstaticConstructor(publicMethod) && this.raise(ErrorMessages.ConstructorIsAsync, { node: publicMethod.key }), this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false));
            } else if (!isContextual || key.name !== "get" && key.name !== "set" || this.match(51) && this.isLineTerminator())
              this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(key), method.kind = key.name;
              const isPrivate2 = this.match(130);
              this.parseClassElementName(publicMethod), isPrivate2 ? this.pushClassPrivateMethod(classBody, privateMethod, false, false) : (this.isNonstaticConstructor(publicMethod) && this.raise(ErrorMessages.ConstructorIsAccessor, { node: publicMethod.key }), this.pushClassMethod(classBody, publicMethod, false, false, false, false)), this.checkGetterSetterParams(publicMethod);
            }
          }
          parseClassElementName(member) {
            const { type, value } = this.state;
            if (type !== 124 && type !== 125 || !member.static || value !== "prototype" || this.raise(ErrorMessages.StaticPrototype, { at: this.state.startLoc }), type === 130) {
              value === "constructor" && this.raise(ErrorMessages.ConstructorClassPrivateField, { at: this.state.startLoc });
              const key = this.parsePrivateName();
              return member.key = key, key;
            }
            return this.parsePropertyName(member);
          }
          parseClassStaticBlock(classBody, member) {
            var _member$decorators;
            this.scope.enter(208);
            const oldLabels = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const body = member.body = [];
            this.parseBlockOrModuleBlockBody(body, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), (_member$decorators = member.decorators) != null && _member$decorators.length && this.raise(ErrorMessages.DecoratorStaticBlock, { node: member });
          }
          pushClassProperty(classBody, prop) {
            prop.computed || prop.key.name !== "constructor" && prop.key.value !== "constructor" || this.raise(ErrorMessages.ConstructorClassField, { node: prop.key }), classBody.body.push(this.parseClassProperty(prop));
          }
          pushClassPrivateProperty(classBody, prop) {
            const node = this.parseClassPrivateProperty(prop);
            classBody.body.push(node), this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
            classBody.body.push(node);
            const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(node, kind);
          }
          declareClassPrivateMethodInScope(node, kind) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
          }
          parsePostMemberNameModifiers(methodOrProp) {
          }
          parseClassPrivateProperty(node) {
            return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassPrivateProperty");
          }
          parseClassProperty(node) {
            return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassProperty");
          }
          parseInitializer(node) {
            this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(node, isStatement, optionalId, bindingType = 139) {
            if (tokenIsIdentifier(this.state.type))
              node.id = this.parseIdentifier(), isStatement && this.checkLVal(node.id, "class name", bindingType);
            else {
              if (!optionalId && isStatement)
                throw this.raise(ErrorMessages.MissingClassName, { at: this.state.startLoc });
              node.id = null;
            }
          }
          parseClassSuper(node) {
            node.superClass = this.eat(77) ? this.parseExprSubscripts() : null;
          }
          parseExport(node) {
            const hasDefault = this.maybeParseExportDefaultSpecifier(node), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
            if (hasStar && !hasNamespace)
              return hasDefault && this.unexpected(), this.parseExportFrom(node, true), this.finishNode(node, "ExportAllDeclaration");
            const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
            if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers)
              throw this.unexpected(null, 5);
            let hasDeclaration;
            if (isFromRequired || hasSpecifiers ? (hasDeclaration = false, this.parseExportFrom(node, isFromRequired)) : hasDeclaration = this.maybeParseExportDeclaration(node), isFromRequired || hasSpecifiers || hasDeclaration)
              return this.checkExport(node, true, false, !!node.source), this.finishNode(node, "ExportNamedDeclaration");
            if (this.eat(61))
              return node.declaration = this.parseExportDefaultExpression(), this.checkExport(node, true, true), this.finishNode(node, "ExportDefaultDeclaration");
            throw this.unexpected(null, 5);
          }
          eatExportStar(node) {
            return this.eat(51);
          }
          maybeParseExportDefaultSpecifier(node) {
            if (this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom");
              const specifier = this.startNode();
              return specifier.exported = this.parseIdentifier(true), node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(node) {
            if (this.isContextual(89)) {
              node.specifiers || (node.specifiers = []);
              const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
              return this.next(), specifier.exported = this.parseModuleExportName(), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(node) {
            if (this.match(5)) {
              node.specifiers || (node.specifiers = []);
              const isTypeExport = node.exportKind === "type";
              return node.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node.source = null, node.declaration = null, this.hasPlugin("importAssertions") && (node.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(node) {
            return !!this.shouldParseExportDeclaration() && (node.specifiers = [], node.source = null, this.hasPlugin("importAssertions") && (node.assertions = []), node.declaration = this.parseExportDeclaration(node), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(91))
              return false;
            const next = this.nextTokenStart();
            return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
          }
          parseExportDefaultExpression() {
            const expr = this.startNode(), isAsync = this.isAsyncFunction();
            if (this.match(64) || isAsync)
              return this.next(), isAsync && this.next(), this.parseFunction(expr, 5, isAsync);
            if (this.match(76))
              return this.parseClass(expr, true, true);
            if (this.match(26))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(ErrorMessages.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseDecorators(false), this.parseClass(expr, true, true);
            if (this.match(71) || this.match(70) || this.isLet())
              throw this.raise(ErrorMessages.UnsupportedDefaultExport, { at: this.state.startLoc });
            const res = this.parseMaybeAssignAllowIn();
            return this.semicolon(), res;
          }
          parseExportDeclaration(node) {
            return this.parseStatement(null);
          }
          isExportDefaultSpecifier() {
            const { type } = this.state;
            if (tokenIsIdentifier(type)) {
              if (type === 91 && !this.state.containsEsc || type === 95)
                return false;
              if ((type === 122 || type === 121) && !this.state.containsEsc) {
                const { type: nextType } = this.lookahead();
                if (tokenIsIdentifier(nextType) && nextType !== 93 || nextType === 5)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(61))
              return false;
            const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
            if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom)
              return true;
            if (this.match(61) && hasFrom) {
              const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
              return nextAfterFrom === 34 || nextAfterFrom === 39;
            }
            return false;
          }
          parseExportFrom(node, expect) {
            if (this.eatContextual(93)) {
              node.source = this.parseImportSource(), this.checkExport(node);
              const assertions = this.maybeParseImportAssertions();
              assertions && (node.assertions = assertions);
            } else
              expect && this.unexpected();
            this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type } = this.state;
            if (type === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
              if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
                throw this.raise(ErrorMessages.DecoratorBeforeExport, { at: this.state.startLoc });
              return true;
            }
            return type === 70 || type === 71 || type === 64 || type === 76 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(node, checkNames, isDefault, isFrom) {
            if (checkNames) {
              if (isDefault) {
                if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var _declaration$extra;
                  const declaration = node.declaration;
                  declaration.type !== "Identifier" || declaration.name !== "from" || declaration.end - declaration.start != 4 || (_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized || this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, { node: declaration });
                }
              } else if (node.specifiers && node.specifiers.length)
                for (const specifier of node.specifiers) {
                  const { exported } = specifier, exportedName = exported.type === "Identifier" ? exported.name : exported.value;
                  if (this.checkDuplicateExports(specifier, exportedName), !isFrom && specifier.local) {
                    const { local } = specifier;
                    local.type !== "Identifier" ? this.raise(ErrorMessages.ExportBindingIsString, { node: specifier }, local.value, exportedName) : (this.checkReservedWord(local.name, local.loc.start, true, false), this.scope.checkLocalExport(local));
                  }
                }
              else if (node.declaration) {
                if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
                  const id = node.declaration.id;
                  if (!id)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(node, id.name);
                } else if (node.declaration.type === "VariableDeclaration")
                  for (const declaration of node.declaration.declarations)
                    this.checkDeclaration(declaration.id);
              }
            }
            if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
              throw this.raise(ErrorMessages.UnsupportedDecoratorExport, { node });
          }
          checkDeclaration(node) {
            if (node.type === "Identifier")
              this.checkDuplicateExports(node, node.name);
            else if (node.type === "ObjectPattern")
              for (const prop of node.properties)
                this.checkDeclaration(prop);
            else if (node.type === "ArrayPattern")
              for (const elem of node.elements)
                elem && this.checkDeclaration(elem);
            else
              node.type === "ObjectProperty" ? this.checkDeclaration(node.value) : node.type === "RestElement" ? this.checkDeclaration(node.argument) : node.type === "AssignmentPattern" && this.checkDeclaration(node.left);
          }
          checkDuplicateExports(node, name) {
            this.exportedIdentifiers.has(name) && this.raise(name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, { node }, name), this.exportedIdentifiers.add(name);
          }
          parseExportSpecifiers(isInTypeExport) {
            const nodes = [];
            let first = true;
            for (this.expect(5); !this.eat(8); ) {
              if (first)
                first = false;
              else if (this.expect(12), this.eat(8))
                break;
              const isMaybeTypeOnly = this.isContextual(122), isString = this.match(125), node = this.startNode();
              node.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
            }
            return nodes;
          }
          parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            return this.eatContextual(89) ? node.exported = this.parseModuleExportName() : isString ? node.exported = cloneStringLiteral(node.local) : node.exported || (node.exported = cloneIdentifier(node.local)), this.finishNode(node, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(125)) {
              const result = this.parseStringLiteral(this.state.value), surrogate = result.value.match(loneSurrogate);
              return surrogate && this.raise(ErrorMessages.ModuleExportNameHasLoneSurrogate, { node: result }, surrogate[0].charCodeAt(0).toString(16)), result;
            }
            return this.parseIdentifier(true);
          }
          parseImport(node) {
            if (node.specifiers = [], !this.match(125)) {
              const parseNext = !this.maybeParseDefaultImportSpecifier(node) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
              parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual(93);
            }
            node.source = this.parseImportSource();
            const assertions = this.maybeParseImportAssertions();
            if (assertions)
              node.assertions = assertions;
            else {
              const attributes = this.maybeParseModuleAttributes();
              attributes && (node.attributes = attributes);
            }
            return this.semicolon(), this.finishNode(node, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(125) || this.unexpected(), this.parseExprAtom();
          }
          shouldParseDefaultImport(node) {
            return tokenIsIdentifier(this.state.type);
          }
          parseImportSpecifierLocal(node, specifier, type, contextDescription) {
            specifier.local = this.parseIdentifier(), this.checkLVal(specifier.local, contextDescription, 9), node.specifiers.push(this.finishNode(specifier, type));
          }
          parseAssertEntries() {
            const attrs = [], attrNames = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              const node = this.startNode(), keyName = this.state.value;
              if (attrNames.has(keyName) && this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc }, keyName), attrNames.add(keyName), this.match(125) ? node.key = this.parseStringLiteral(keyName) : node.key = this.parseIdentifier(true), this.expect(14), !this.match(125))
                throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              node.value = this.parseStringLiteral(this.state.value), this.finishNode(node, "ImportAttribute"), attrs.push(node);
            } while (this.eat(12));
            return attrs;
          }
          maybeParseModuleAttributes() {
            if (!this.match(72) || this.hasPrecedingLineBreak())
              return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            const attrs = [], attributes = /* @__PURE__ */ new Set();
            do {
              const node = this.startNode();
              if (node.key = this.parseIdentifier(true), node.key.name !== "type" && this.raise(ErrorMessages.ModuleAttributeDifferentFromType, { node: node.key }, node.key.name), attributes.has(node.key.name) && this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, { node: node.key }, node.key.name), attributes.add(node.key.name), this.expect(14), !this.match(125))
                throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, { at: this.state.startLoc });
              node.value = this.parseStringLiteral(this.state.value), this.finishNode(node, "ImportAttribute"), attrs.push(node);
            } while (this.eat(12));
            return attrs;
          }
          maybeParseImportAssertions() {
            if (!this.isContextual(90) || this.hasPrecedingLineBreak())
              return this.hasPlugin("importAssertions") ? [] : null;
            this.expectPlugin("importAssertions"), this.next(), this.eat(5);
            const attrs = this.parseAssertEntries();
            return this.eat(8), attrs;
          }
          maybeParseDefaultImportSpecifier(node) {
            return !!this.shouldParseDefaultImport(node) && (this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
          }
          maybeParseStarImportSpecifier(node) {
            if (this.match(51)) {
              const specifier = this.startNode();
              return this.next(), this.expectContextual(89), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(node) {
            let first = true;
            for (this.expect(5); !this.eat(8); ) {
              if (first)
                first = false;
              else {
                if (this.eat(14))
                  throw this.raise(ErrorMessages.DestructureNamedImport, { at: this.state.startLoc });
                if (this.expect(12), this.eat(8))
                  break;
              }
              const specifier = this.startNode(), importedIsString = this.match(125), isMaybeTypeOnly = this.isContextual(122);
              specifier.imported = this.parseModuleExportName();
              const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
              node.specifiers.push(importSpecifier);
            }
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            if (this.eatContextual(89))
              specifier.local = this.parseIdentifier();
            else {
              const { imported } = specifier;
              if (importedIsString)
                throw this.raise(ErrorMessages.ImportBindingIsString, { node: specifier }, imported.value);
              this.checkReservedWord(imported.name, specifier.loc.start, true, true), specifier.local || (specifier.local = cloneIdentifier(imported));
            }
            return this.checkLVal(specifier.local, "import specifier", 9), this.finishNode(specifier, "ImportSpecifier");
          }
          isThisParam(param) {
            return param.type === "Identifier" && param.name === "this";
          }
        } {
          constructor(options, input) {
            super(options = function(opts) {
              const options2 = {};
              for (const key of Object.keys(defaultOptions))
                options2[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
              return options2;
            }(options), input), this.options = options, this.initializeScopes(), this.plugins = function(plugins) {
              const pluginMap = /* @__PURE__ */ new Map();
              for (const plugin of plugins) {
                const [name, options2] = Array.isArray(plugin) ? plugin : [plugin, {}];
                pluginMap.has(name) || pluginMap.set(name, options2 || {});
              }
              return pluginMap;
            }(this.options.plugins), this.filename = options.sourceFilename;
          }
          getScopeHandler() {
            return ScopeHandler;
          }
          parse() {
            this.enterInitialScopes();
            const file = this.startNode(), program = this.startNode();
            return this.nextToken(), file.errors = null, this.parseTopLevel(file, program), file.errors = this.state.errors, file;
          }
        }
        const tokTypes = function(internalTokenTypes) {
          const tokenTypes2 = {};
          for (const typeName of Object.keys(internalTokenTypes))
            tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
          return tokenTypes2;
        }(tt);
        function getParser(options, input) {
          let cls = Parser;
          return options != null && options.plugins && (!function(plugins) {
            if (hasPlugin(plugins, "decorators")) {
              if (hasPlugin(plugins, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
              if (decoratorsBeforeExport == null)
                throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
              if (typeof decoratorsBeforeExport != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (hasPlugin(plugins, "pipelineOperator")) {
              const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
              if (!PIPELINE_PROPOSALS.includes(proposal)) {
                const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
              }
              const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", { syntaxType: "hash" }]);
              if (proposal === "hack") {
                if (hasPlugin(plugins, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (hasPlugin(plugins, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
                if (!TOPIC_TOKENS.includes(topicToken)) {
                  const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
                }
                if (topicToken === "#" && tupleSyntaxIsHash)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (proposal === "smart" && tupleSyntaxIsHash)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (hasPlugin(plugins, "moduleAttributes")) {
              if (hasPlugin(plugins, "importAssertions"))
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (getPluginOption(plugins, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType")))
              throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
              const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw error.missingPlugins = "doExpressions", error;
            }
          }(options.plugins), cls = function(pluginsFromOptions) {
            const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name)), key = pluginList.join("/");
            let cls2 = parserClassCache[key];
            if (!cls2) {
              cls2 = Parser;
              for (const plugin of pluginList)
                cls2 = mixinPlugins[plugin](cls2);
              parserClassCache[key] = cls2;
            }
            return cls2;
          }(options.plugins)), new cls(options, input);
        }
        const parserClassCache = {};
        exports2.parse = function(input, options) {
          var _options;
          if (((_options = options) == null ? void 0 : _options.sourceType) !== "unambiguous")
            return getParser(options, input).parse();
          options = Object.assign({}, options);
          try {
            options.sourceType = "module";
            const parser = getParser(options, input), ast = parser.parse();
            if (parser.sawUnambiguousESM)
              return ast;
            if (parser.ambiguousScriptDifferentAst)
              try {
                return options.sourceType = "script", getParser(options, input).parse();
              } catch (_unused) {
              }
            else
              ast.program.sourceType = "script";
            return ast;
          } catch (moduleError) {
            try {
              return options.sourceType = "script", getParser(options, input).parse();
            } catch (_unused2) {
            }
            throw moduleError;
          }
        }, exports2.parseExpression = function(input, options) {
          const parser = getParser(options, input);
          return parser.options.strictMode && (parser.state.strict = true), parser.getExpression();
        }, exports2.tokTypes = tokTypes;
      }, "./node_modules/@babel/plugin-proposal-decorators/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxDecorators = __webpack_require__2("./node_modules/@babel/plugin-syntax-decorators/lib/index.js"), _helperCreateClassFeaturesPlugin = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), _transformerLegacy = __webpack_require__2("./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js"), _default = (0, _helperPluginUtils.declare)((api, options) => {
          api.assertVersion(7);
          const { legacy = false } = options;
          if (typeof legacy != "boolean")
            throw new Error("'legacy' must be a boolean.");
          const { decoratorsBeforeExport } = options;
          if (decoratorsBeforeExport === void 0) {
            if (!legacy)
              throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.");
          } else {
            if (legacy)
              throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
            if (typeof decoratorsBeforeExport != "boolean")
              throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
          return legacy ? { name: "proposal-decorators", inherits: _pluginSyntaxDecorators.default, manipulateOptions({ generatorOpts }) {
            generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
          }, visitor: _transformerLegacy.default } : (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({ name: "proposal-decorators", api, feature: _helperCreateClassFeaturesPlugin.FEATURES.decorators, manipulateOptions({ generatorOpts, parserOpts }) {
            parserOpts.plugins.push(["decorators", { decoratorsBeforeExport }]), generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
          } });
        });
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js");
        const buildClassDecorator = (0, _core.template)("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"), buildClassPrototype = (0, _core.template)("\n  CLASS_REF.prototype;\n"), buildGetDescriptor = (0, _core.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"), buildGetObjectInitializer = (0, _core.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"), WARNING_CALLS = /* @__PURE__ */ new WeakSet();
        function applyEnsureOrdering(path) {
          const identDecorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce((acc, prop) => acc.concat(prop.node.decorators || []), []).filter((decorator) => !_core.types.isIdentifier(decorator.expression));
          if (identDecorators.length !== 0)
            return _core.types.sequenceExpression(identDecorators.map((decorator) => {
              const expression = decorator.expression, id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
              return _core.types.assignmentExpression("=", id, expression);
            }).concat([path.node]));
        }
        function hasClassDecorators(classNode) {
          return !(!classNode.decorators || !classNode.decorators.length);
        }
        function hasMethodDecorators(body) {
          return body.some((node) => {
            var _node$decorators;
            return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;
          });
        }
        function applyTargetDecorators(path, state, decoratedProps) {
          const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj"), exprs = decoratedProps.reduce(function(acc, node) {
            const decorators = node.decorators || [];
            if (node.decorators = null, decorators.length === 0)
              return acc;
            if (node.computed)
              throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const property = _core.types.isLiteral(node.key) ? node.key : _core.types.stringLiteral(node.key.name), target = path.isClass() && !node.static ? buildClassPrototype({ CLASS_REF: name }).expression : name;
            if (_core.types.isClassProperty(node, { static: false })) {
              const descriptor = path.scope.generateDeclaredUidIdentifier("descriptor"), initializer = node.value ? _core.types.functionExpression(null, [], _core.types.blockStatement([_core.types.returnStatement(node.value)])) : _core.types.nullLiteral();
              node.value = _core.types.callExpression(state.addHelper("initializerWarningHelper"), [descriptor, _core.types.thisExpression()]), WARNING_CALLS.add(node.value), acc.push(_core.types.assignmentExpression("=", _core.types.cloneNode(descriptor), _core.types.callExpression(state.addHelper("applyDecoratedDescriptor"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map((dec) => _core.types.cloneNode(dec.expression))), _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier("configurable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("enumerable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("writable"), _core.types.booleanLiteral(true)), _core.types.objectProperty(_core.types.identifier("initializer"), initializer)])])));
            } else
              acc.push(_core.types.callExpression(state.addHelper("applyDecoratedDescriptor"), [_core.types.cloneNode(target), _core.types.cloneNode(property), _core.types.arrayExpression(decorators.map((dec) => _core.types.cloneNode(dec.expression))), _core.types.isObjectProperty(node) || _core.types.isClassProperty(node, { static: true }) ? buildGetObjectInitializer({ TEMP: path.scope.generateDeclaredUidIdentifier("init"), TARGET: _core.types.cloneNode(target), PROPERTY: _core.types.cloneNode(property) }).expression : buildGetDescriptor({ TARGET: _core.types.cloneNode(target), PROPERTY: _core.types.cloneNode(property) }).expression, _core.types.cloneNode(target)]));
            return acc;
          }, []);
          return _core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(name), path.node), _core.types.sequenceExpression(exprs), _core.types.cloneNode(name)]);
        }
        function decoratedClassToExpression({ node, scope }) {
          if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body))
            return;
          const ref = node.id ? _core.types.cloneNode(node.id) : scope.generateUidIdentifier("class");
          return _core.types.variableDeclaration("let", [_core.types.variableDeclarator(ref, _core.types.toExpression(node))]);
        }
        var _default = { ExportDefaultDeclaration(path) {
          const decl = path.get("declaration");
          if (!decl.isClassDeclaration())
            return;
          const replacement = decoratedClassToExpression(decl);
          if (replacement) {
            const [varDeclPath] = path.replaceWithMultiple([replacement, _core.types.exportNamedDeclaration(null, [_core.types.exportSpecifier(_core.types.cloneNode(replacement.declarations[0].id), _core.types.identifier("default"))])]);
            decl.node.id || path.scope.registerDeclaration(varDeclPath);
          }
        }, ClassDeclaration(path) {
          const replacement = decoratedClassToExpression(path);
          replacement && path.replaceWith(replacement);
        }, ClassExpression(path, state) {
          const decoratedClass = applyEnsureOrdering(path) || function(classPath) {
            if (!hasClassDecorators(classPath.node))
              return;
            const decorators = classPath.node.decorators || [];
            classPath.node.decorators = null;
            const name = classPath.scope.generateDeclaredUidIdentifier("class");
            return decorators.map((dec) => dec.expression).reverse().reduce(function(acc, decorator) {
              return buildClassDecorator({ CLASS_REF: _core.types.cloneNode(name), DECORATOR: _core.types.cloneNode(decorator), INNER: acc }).expression;
            }, classPath.node);
          }(path) || function(path2, state2) {
            if (hasMethodDecorators(path2.node.body.body))
              return applyTargetDecorators(path2, state2, path2.node.body.body);
          }(path, state);
          decoratedClass && path.replaceWith(decoratedClass);
        }, ObjectExpression(path, state) {
          const decoratedObject = applyEnsureOrdering(path) || function(path2, state2) {
            if (hasMethodDecorators(path2.node.properties))
              return applyTargetDecorators(path2, state2, path2.node.properties);
          }(path, state);
          decoratedObject && path.replaceWith(decoratedObject);
        }, AssignmentExpression(path, state) {
          WARNING_CALLS.has(path.node.right) && path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"), [_core.types.cloneNode(path.get("left.object").node), _core.types.stringLiteral(path.get("left.property").node.name || path.get("left.property").node.value), _core.types.cloneNode(path.get("right.arguments")[0].node), _core.types.cloneNode(path.get("right.arguments")[1].node)]));
        }, CallExpression(path, state) {
          path.node.arguments.length === 3 && WARNING_CALLS.has(path.node.arguments[2]) && path.node.callee.name === state.addHelper("defineProperty").name && path.replaceWith(_core.types.callExpression(state.addHelper("initializerDefineProperty"), [_core.types.cloneNode(path.get("arguments")[0].node), _core.types.cloneNode(path.get("arguments")[1].node), _core.types.cloneNode(path.get("arguments.2.arguments")[0].node), _core.types.cloneNode(path.get("arguments.2.arguments")[1].node)]));
        } };
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxNullishCoalescingOperator = __webpack_require__2("./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js"), _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _default = (0, _helperPluginUtils.declare)((api, { loose = false }) => {
          var _api$assumption;
          api.assertVersion(7);
          const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
          return { name: "proposal-nullish-coalescing-operator", inherits: _pluginSyntaxNullishCoalescingOperator.default, visitor: { LogicalExpression(path) {
            const { node, scope } = path;
            if (node.operator !== "??")
              return;
            let ref, assignment;
            if (scope.isStatic(node.left))
              ref = node.left, assignment = _core.types.cloneNode(node.left);
            else {
              if (scope.path.isPattern())
                return void path.replaceWith(_core.template.ast`(() => ${path.node})()`);
              ref = scope.generateUidIdentifierBasedOnNode(node.left), scope.push({ id: _core.types.cloneNode(ref) }), assignment = _core.types.assignmentExpression("=", ref, node.left);
            }
            path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
          } } };
        });
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var helperPluginUtils = __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js"), syntaxOptionalChaining = __webpack_require__2("./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js"), core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), helperSkipTransparentExpressionWrappers = __webpack_require__2("./node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        function _interopDefaultLegacy(e2) {
          return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
        }
        var syntaxOptionalChaining__default = _interopDefaultLegacy(syntaxOptionalChaining);
        function willPathCastToBoolean(path) {
          const maybeWrapped = findOutermostTransparentParent(path), { node, parentPath } = maybeWrapped;
          if (parentPath.isLogicalExpression()) {
            const { operator, right } = parentPath.node;
            if (operator === "&&" || operator === "||" || operator === "??" && node === right)
              return willPathCastToBoolean(parentPath);
          }
          if (parentPath.isSequenceExpression()) {
            const { expressions } = parentPath.node;
            return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
          }
          return parentPath.isConditional({ test: node }) || parentPath.isUnaryExpression({ operator: "!" }) || parentPath.isLoop({ test: node });
        }
        function findOutermostTransparentParent(path) {
          let maybeWrapped = path;
          return path.findParent((p) => {
            if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node))
              return true;
            maybeWrapped = p;
          }), maybeWrapped;
        }
        const { ast } = core.template.expression;
        function isSimpleMemberExpression(expression) {
          return expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression), core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
        }
        function transform(path, { pureGetters, noDocumentAll }) {
          const { scope } = path, maybeWrapped = findOutermostTransparentParent(path), { parentPath } = maybeWrapped, willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);
          let isDeleteOperation = false;
          const parentIsCall = parentPath.isCallExpression({ callee: maybeWrapped.node }) && path.isOptionalMemberExpression(), optionals = [];
          let optionalPath = path;
          if (scope.path.isPattern() && function(path2) {
            let optionalPath2 = path2;
            const { scope: scope2 } = path2;
            for (; optionalPath2.isOptionalMemberExpression() || optionalPath2.isOptionalCallExpression(); ) {
              const { node } = optionalPath2, childKey = optionalPath2.isOptionalMemberExpression() ? "object" : "callee", childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath2.get(childKey));
              if (node.optional)
                return !scope2.isStatic(childPath.node);
              optionalPath2 = childPath;
            }
          }(optionalPath))
            return void path.replaceWith(core.template.ast`(() => ${path.node})()`);
          for (; optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression(); ) {
            const { node } = optionalPath;
            node.optional && optionals.push(node), optionalPath.isOptionalMemberExpression() ? (optionalPath.node.type = "MemberExpression", optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"))) : optionalPath.isOptionalCallExpression() && (optionalPath.node.type = "CallExpression", optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee")));
          }
          let replacementPath = path;
          parentPath.isUnaryExpression({ operator: "delete" }) && (replacementPath = parentPath, isDeleteOperation = true);
          for (let i = optionals.length - 1; i >= 0; i--) {
            const node = optionals[i], isCall = core.types.isCallExpression(node), replaceKey = isCall ? "callee" : "object", chainWithTypes = node[replaceKey], chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
            let ref, check;
            if (isCall && core.types.isIdentifier(chain, { name: "eval" }) ? (check = ref = chain, node[replaceKey] = core.types.sequenceExpression([core.types.numericLiteral(0), ref])) : pureGetters && isCall && isSimpleMemberExpression(chain) ? check = ref = chainWithTypes : (ref = scope.maybeGenerateMemoised(chain), ref ? (check = core.types.assignmentExpression("=", core.types.cloneNode(ref), chainWithTypes), node[replaceKey] = ref) : check = ref = chainWithTypes), isCall && core.types.isMemberExpression(chain))
              if (pureGetters && isSimpleMemberExpression(chain))
                node.callee = chainWithTypes;
              else {
                const { object } = chain;
                let context = scope.maybeGenerateMemoised(object);
                context ? chain.object = core.types.assignmentExpression("=", context, object) : context = core.types.isSuper(object) ? core.types.thisExpression() : object, node.arguments.unshift(core.types.cloneNode(context)), node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
              }
            let replacement = replacementPath.node;
            if (i === 0 && parentIsCall) {
              var _baseRef;
              const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
              let baseRef;
              pureGetters && isSimpleMemberExpression(object) || (baseRef = scope.maybeGenerateMemoised(object), baseRef && (replacement.object = core.types.assignmentExpression("=", baseRef, object))), replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);
            }
            if (willReplacementCastToBoolean) {
              const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`
            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;
              replacementPath.replaceWith(core.types.logicalExpression("&&", nonNullishCheck, replacement)), replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("right"));
            } else {
              const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`
            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`, returnValue = isDeleteOperation ? ast`true` : ast`void 0`;
              replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement)), replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("alternate"));
            }
          }
        }
        var index = helperPluginUtils.declare((api, options) => {
          var _api$assumption, _api$assumption2;
          api.assertVersion(7);
          const { loose = false } = options, noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose, pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
          return { name: "proposal-optional-chaining", inherits: syntaxOptionalChaining__default.default.default, visitor: { "OptionalCallExpression|OptionalMemberExpression"(path) {
            transform(path, { noDocumentAll, pureGetters });
          } } };
        });
        exports2.default = index, exports2.transform = transform;
      }, "./node_modules/@babel/plugin-syntax-class-properties/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-syntax-decorators/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api, options) => {
          api.assertVersion(7);
          const { legacy = false } = options;
          if (typeof legacy != "boolean")
            throw new Error("'legacy' must be a boolean.");
          const { decoratorsBeforeExport } = options;
          if (decoratorsBeforeExport === void 0) {
            if (!legacy)
              throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you want to use the legacy decorators semantics, you can set the 'legacy: true' option.");
          } else {
            if (legacy)
              throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
            if (typeof decoratorsBeforeExport != "boolean")
              throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
          return { name: "syntax-decorators", manipulateOptions(opts, parserOpts) {
            parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", { decoratorsBeforeExport }]);
          } };
        });
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-nullish-coalescing-operator", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        } }));
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api) => (api.assertVersion(7), { name: "syntax-optional-chaining", manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        } }));
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-syntax-typescript/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        function removePlugin(plugins, name) {
          const indices = [];
          plugins.forEach((plugin, i) => {
            (Array.isArray(plugin) ? plugin[0] : plugin) === name && indices.unshift(i);
          });
          for (const i of indices)
            plugins.splice(i, 1);
        }
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((api, { isTSX, disallowAmbiguousJSXLike }) => (api.assertVersion(7), { name: "syntax-typescript", manipulateOptions(opts, parserOpts) {
          const { plugins } = parserOpts;
          removePlugin(plugins, "flow"), removePlugin(plugins, "jsx"), parserOpts.plugins.push(["typescript", { disallowAmbiguousJSXLike }], "classProperties"), parserOpts.plugins.push("objectRestSpread"), isTSX && parserOpts.plugins.push("jsx");
        } }));
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js"), _helperModuleTransforms = __webpack_require__2("./node_modules/@babel/helper-module-transforms/lib/index.js"), _helperSimpleAccess = __webpack_require__2("./node_modules/@babel/helper-simple-access/lib/index.js"), _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _utils = __webpack_require__2("./node_modules/babel-plugin-dynamic-import-node/utils.js"), _default = (0, _helperPluginUtils.declare)((api, options) => {
          var _api$assumption, _api$assumption2, _api$assumption3;
          api.assertVersion(7);
          const transformImportCall = (0, _utils.createDynamicImportTransform)(api), { strictNamespace = false, mjsStrictNamespace = true, allowTopLevelThis, strict, strictMode, noInterop, importInterop, lazy = false, allowCommonJSExports = true } = options, constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose, enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose, noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null && _api$assumption3;
          if (!(typeof lazy == "boolean" || typeof lazy == "function" || Array.isArray(lazy) && lazy.every((item) => typeof item == "string")))
            throw new Error(".lazy must be a boolean, array of strings, or a function");
          if (typeof strictNamespace != "boolean")
            throw new Error(".strictNamespace must be a boolean, or undefined");
          if (typeof mjsStrictNamespace != "boolean")
            throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const getAssertion = (localName) => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, moduleExportsVisitor = { ReferencedIdentifier(path) {
            const localName = path.node.name;
            if (localName !== "module" && localName !== "exports")
              return;
            const localBinding = path.scope.getBinding(localName);
            this.scope.getBinding(localName) !== localBinding || path.parentPath.isObjectProperty({ value: path.node }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({ left: path.node }) || path.isAssignmentExpression({ left: path.node }) || path.replaceWith(getAssertion(localName));
          }, AssignmentExpression(path) {
            const left = path.get("left");
            if (left.isIdentifier()) {
              const localName = path.node.name;
              if (localName !== "module" && localName !== "exports")
                return;
              const localBinding = path.scope.getBinding(localName);
              if (this.scope.getBinding(localName) !== localBinding)
                return;
              const right = path.get("right");
              right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
            } else if (left.isPattern()) {
              const ids = left.getOuterBindingIdentifiers(), localName = Object.keys(ids).filter((localName2) => (localName2 === "module" || localName2 === "exports") && this.scope.getBinding(localName2) === path.scope.getBinding(localName2))[0];
              if (localName) {
                const right = path.get("right");
                right.replaceWith(_core.types.sequenceExpression([right.node, getAssertion(localName)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs");
          }, visitor: { CallExpression(path) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import"))
              return;
            if (!path.get("callee").isImport())
              return;
            let { scope } = path;
            do {
              scope.rename("require");
            } while (scope = scope.parent);
            transformImportCall(this, path.get("callee"));
          }, Program: { exit(path, state) {
            if (!(0, _helperModuleTransforms.isModule)(path))
              return;
            path.scope.rename("exports"), path.scope.rename("module"), path.scope.rename("require"), path.scope.rename("__filename"), path.scope.rename("__dirname"), allowCommonJSExports || ((0, _helperSimpleAccess.default)(path, /* @__PURE__ */ new Set(["module", "exports"])), path.traverse(moduleExportsVisitor, { scope: path.scope }));
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName));
            const { meta, headers } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, { exportName: "exports", constantReexports, enumerableModuleMeta, strict, strictMode, allowTopLevelThis, noInterop, importInterop, lazy, esNamespaceOnly: typeof state.filename == "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace, noIncompleteNsImportDetection });
            for (const [source, metadata] of meta.source) {
              const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [_core.types.stringLiteral(source)]);
              let header;
              if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                if (metadata.lazy)
                  throw new Error("Assertion failure");
                header = _core.types.expressionStatement(loadExpr);
              } else {
                const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
                header = metadata.lazy ? _core.template.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                ` : _core.template.ast`
                  var ${metadata.name} = ${init};
                `;
              }
              header.loc = metadata.loc, headers.push(header), headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers), path.get("body").forEach((path2) => {
              headers.indexOf(path2.node) !== -1 && path2.isVariableDeclaration() && path2.scope.registerDeclaration(path2);
            });
          } } } };
        });
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path, t) {
          const { name } = path.node.id, parentIsExport = path.parentPath.isExportNamedDeclaration();
          let isExported = parentIsExport;
          !isExported && t.isProgram(path.parent) && (isExported = path.parent.body.some((stmt) => t.isExportNamedDeclaration(stmt) && !stmt.source && stmt.specifiers.some((spec) => t.isExportSpecifier(spec) && spec.local.name === name)));
          const entries = (0, _enum.translateEnumValues)(path, t);
          if (isExported) {
            const obj = t.objectExpression(entries.map(([name2, value]) => t.objectProperty(t.isValidIdentifier(name2) ? t.identifier(name2) : t.stringLiteral(name2), value)));
            return void (path.scope.hasOwnBinding(name) ? (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path.node.id, obj]))) : (path.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path.node.id, obj)])), path.scope.registerDeclaration(path)));
          }
          const entriesMap = new Map(entries);
          path.scope.path.traverse({ Scope(path2) {
            path2.scope.hasOwnBinding(name) && path2.skip();
          }, MemberExpression(path2) {
            if (!t.isIdentifier(path2.node.object, { name }))
              return;
            let key;
            if (path2.node.computed) {
              if (!t.isStringLiteral(path2.node.property))
                return;
              key = path2.node.property.value;
            } else {
              if (!t.isIdentifier(path2.node.property))
                return;
              key = path2.node.property.name;
            }
            entriesMap.has(key) && path2.replaceWith(t.cloneNode(entriesMap.get(key)));
          } }), path.remove();
        };
        var _enum = __webpack_require__2("./node_modules/@babel/plugin-transform-typescript/lib/enum.js");
      }, "./node_modules/@babel/plugin-transform-typescript/lib/enum.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path, t) {
          const { node } = path;
          if (node.declare)
            return void path.remove();
          const name = node.id.name, fill = function(path2, t2, id) {
            const assignments = translateEnumValues(path2, t2).map(([memberName, memberValue]) => {
              return isString = t2.isStringLiteral(memberValue), options = { ENUM: t2.cloneNode(id), NAME: memberName, VALUE: memberValue }, (isString ? buildStringAssignment : buildNumericAssignment)(options);
              var isString, options;
            });
            return buildEnumWrapper({ ID: t2.cloneNode(id), ASSIGNMENTS: assignments });
          }(path, t, node.id);
          switch (path.parent.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program":
              if (path.insertAfter(fill), function seen(parentPath) {
                if (parentPath.isExportDeclaration())
                  return seen(parentPath.parentPath);
                return !!parentPath.getData(name) || (parentPath.setData(name, true), false);
              }(path.parentPath))
                path.remove();
              else {
                const isGlobal = t.isProgram(path.parent);
                path.scope.registerDeclaration(path.replaceWith(function(id, t2, kind) {
                  return t2.variableDeclaration(kind, [t2.variableDeclarator(id)]);
                }(node.id, t, isGlobal ? "var" : "let"))[0]);
              }
              break;
            default:
              throw new Error(`Unexpected enum parent '${path.parent.type}`);
          }
        }, exports2.translateEnumValues = translateEnumValues;
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _assert = __webpack_require__2("assert");
        const buildEnumWrapper = (0, _core.template)("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n"), buildStringAssignment = (0, _core.template)('\n  ENUM["NAME"] = VALUE;\n'), buildNumericAssignment = (0, _core.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');
        function ReferencedIdentifier(expr, state) {
          const { seen, path, t } = state, name = expr.node.name;
          seen.has(name) && !expr.scope.hasOwnBinding(name) && (expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node))), expr.skip());
        }
        const enumSelfReferenceVisitor = { ReferencedIdentifier };
        function translateEnumValues(path, t) {
          const seen = /* @__PURE__ */ new Map();
          let lastName, constValue = -1;
          return path.get("members").map((memberPath) => {
            const member = memberPath.node, name = t.isIdentifier(member.id) ? member.id.name : member.id.value, initializer = member.initializer;
            let value;
            if (initializer)
              if (constValue = function(expr, seen2) {
                return evalConstant(expr);
                function evalConstant(expr2) {
                  switch (expr2.type) {
                    case "StringLiteral":
                      return expr2.value;
                    case "UnaryExpression":
                      return evalUnaryExpression(expr2);
                    case "BinaryExpression":
                      return evalBinaryExpression(expr2);
                    case "NumericLiteral":
                      return expr2.value;
                    case "ParenthesizedExpression":
                      return evalConstant(expr2.expression);
                    case "Identifier":
                      return seen2.get(expr2.name);
                    case "TemplateLiteral":
                      if (expr2.quasis.length === 1)
                        return expr2.quasis[0].value.cooked;
                    default:
                      return;
                  }
                }
                function evalUnaryExpression({ argument, operator }) {
                  const value2 = evalConstant(argument);
                  if (value2 !== void 0)
                    switch (operator) {
                      case "+":
                        return value2;
                      case "-":
                        return -value2;
                      case "~":
                        return ~value2;
                      default:
                        return;
                    }
                }
                function evalBinaryExpression(expr2) {
                  const left = evalConstant(expr2.left);
                  if (left === void 0)
                    return;
                  const right = evalConstant(expr2.right);
                  if (right !== void 0)
                    switch (expr2.operator) {
                      case "|":
                        return left | right;
                      case "&":
                        return left & right;
                      case ">>":
                        return left >> right;
                      case ">>>":
                        return left >>> right;
                      case "<<":
                        return left << right;
                      case "^":
                        return left ^ right;
                      case "*":
                        return left * right;
                      case "/":
                        return left / right;
                      case "+":
                        return left + right;
                      case "-":
                        return left - right;
                      case "%":
                        return left % right;
                      default:
                        return;
                    }
                }
              }(initializer, seen), constValue !== void 0)
                seen.set(name, constValue), typeof constValue == "number" ? value = t.numericLiteral(constValue) : (_assert(typeof constValue == "string"), value = t.stringLiteral(constValue));
              else {
                const initializerPath = memberPath.get("initializer");
                initializerPath.isReferencedIdentifier() ? ReferencedIdentifier(initializerPath, { t, seen, path }) : initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path }), value = initializerPath.node, seen.set(name, void 0);
              }
            else if (typeof constValue == "number")
              constValue += 1, value = t.numericLiteral(constValue), seen.set(name, constValue);
            else {
              if (typeof constValue == "string")
                throw path.buildCodeFrameError("Enum member must have initializer.");
              {
                const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);
                value = t.binaryExpression("+", t.numericLiteral(1), lastRef), seen.set(name, void 0);
              }
            }
            return lastName = name, [name, value];
          });
        }
      }, "./node_modules/@babel/plugin-transform-typescript/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _helperPluginUtils = __webpack_require__2("./node_modules/@babel/helper-plugin-utils/lib/index.js"), _pluginSyntaxTypescript = __webpack_require__2("./node_modules/@babel/plugin-syntax-typescript/lib/index.js"), _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js"), _helperCreateClassFeaturesPlugin = __webpack_require__2("./node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), _constEnum = __webpack_require__2("./node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), _enum = __webpack_require__2("./node_modules/@babel/plugin-transform-typescript/lib/enum.js"), _namespace = __webpack_require__2("./node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function isInType(path) {
          switch (path.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            case "ExportSpecifier":
              return path.parentPath.parent.exportKind === "type";
            default:
              return false;
          }
        }
        const GLOBAL_TYPES = /* @__PURE__ */ new WeakMap(), NEEDS_EXPLICIT_ESM = /* @__PURE__ */ new WeakMap(), PARSED_PARAMS = /* @__PURE__ */ new WeakSet();
        function isGlobalType(path, name) {
          const program = path.find((path2) => path2.isProgram()).node;
          return !path.scope.hasOwnBinding(name) && (!!GLOBAL_TYPES.get(program).has(name) || (console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${name}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), false));
        }
        function registerGlobalType(programNode, name) {
          GLOBAL_TYPES.get(programNode).add(name);
        }
        var _default = (0, _helperPluginUtils.declare)((api, opts) => {
          api.assertVersion(7);
          const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces = true, jsxPragma = "React.createElement", jsxPragmaFrag = "React.Fragment", onlyRemoveTypeImports = false, optimizeConstEnums = false } = opts;
          var { allowDeclareFields = false } = opts;
          const classMemberVisitors = { field(path) {
            const { node } = path;
            if (!allowDeclareFields && node.declare)
              throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (node.declare) {
              if (node.value)
                throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              node.decorators || path.remove();
            } else if (node.definite) {
              if (node.value)
                throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              allowDeclareFields || node.decorators || path.remove();
            } else
              allowDeclareFields || node.value || node.decorators || _core.types.isClassPrivateProperty(node) || path.remove();
            node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.readonly && (node.readonly = null), node.optional && (node.optional = null), node.typeAnnotation && (node.typeAnnotation = null), node.definite && (node.definite = null), node.declare && (node.declare = null), node.override && (node.override = null);
          }, method({ node }) {
            node.accessibility && (node.accessibility = null), node.abstract && (node.abstract = null), node.optional && (node.optional = null), node.override && (node.override = null);
          }, constructor(path, classPath) {
            path.node.accessibility && (path.node.accessibility = null);
            const parameterProperties = [];
            for (const param of path.node.params)
              param.type !== "TSParameterProperty" || PARSED_PARAMS.has(param.parameter) || (PARSED_PARAMS.add(param.parameter), parameterProperties.push(param.parameter));
            if (parameterProperties.length) {
              const assigns = parameterProperties.map((p) => {
                let id;
                if (_core.types.isIdentifier(p))
                  id = p;
                else {
                  if (!_core.types.isAssignmentPattern(p) || !_core.types.isIdentifier(p.left))
                    throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  id = p.left;
                }
                return _core.template.statement.ast`
              this.${_core.types.cloneNode(id)} = ${_core.types.cloneNode(id)}`;
              });
              (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);
            }
          } };
          return { name: "transform-typescript", inherits: _pluginSyntaxTypescript.default, visitor: { Pattern: visitPattern, Identifier: visitPattern, RestElement: visitPattern, Program: { enter(path, state) {
            const { file } = state;
            let fileJsxPragma = null, fileJsxPragmaFrag = null;
            const programNode = path.node;
            if (GLOBAL_TYPES.has(programNode) || GLOBAL_TYPES.set(programNode, /* @__PURE__ */ new Set()), file.ast.comments)
              for (const comment of file.ast.comments) {
                const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
                jsxMatches && (jsxMatches[1] ? fileJsxPragmaFrag = jsxMatches[2] : fileJsxPragma = jsxMatches[2]);
              }
            let pragmaImportName = fileJsxPragma || jsxPragma;
            pragmaImportName && ([pragmaImportName] = pragmaImportName.split("."));
            let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
            pragmaFragImportName && ([pragmaFragImportName] = pragmaFragImportName.split("."));
            for (let stmt of path.get("body"))
              if (stmt.isImportDeclaration()) {
                if (NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), stmt.node.importKind === "type") {
                  for (const specifier of stmt.node.specifiers)
                    registerGlobalType(programNode, specifier.local.name);
                  stmt.remove();
                  continue;
                }
                const importsToRemove = /* @__PURE__ */ new Set(), specifiersLength = stmt.node.specifiers.length, isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
                for (const specifier of stmt.node.specifiers)
                  if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                    registerGlobalType(programNode, specifier.local.name);
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    binding && importsToRemove.add(binding.path);
                  }
                if (onlyRemoveTypeImports)
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                else {
                  if (stmt.node.specifiers.length === 0) {
                    NEEDS_EXPLICIT_ESM.set(path.node, false);
                    continue;
                  }
                  for (const specifier of stmt.node.specifiers) {
                    const binding = stmt.scope.getBinding(specifier.local.name);
                    binding && !importsToRemove.has(binding.path) && (isImportTypeOnly({ binding, programPath: path, pragmaImportName, pragmaFragImportName }) ? importsToRemove.add(binding.path) : NEEDS_EXPLICIT_ESM.set(path.node, false));
                  }
                }
                if (isAllSpecifiersElided())
                  stmt.remove();
                else
                  for (const importPath of importsToRemove)
                    importPath.remove();
              } else if (stmt.isExportDeclaration() && (stmt = stmt.get("declaration")), stmt.isVariableDeclaration({ declare: true }))
                for (const name of Object.keys(stmt.getBindingIdentifiers()))
                  registerGlobalType(programNode, name);
              else
                (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({ declare: true }) || stmt.isTSEnumDeclaration({ declare: true }) || stmt.isTSModuleDeclaration({ declare: true }) && stmt.get("id").isIdentifier()) && registerGlobalType(programNode, stmt.node.id.name);
          }, exit(path) {
            path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node) && path.pushContainer("body", _core.types.exportNamedDeclaration());
          } }, ExportNamedDeclaration(path, state) {
            NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), path.node.exportKind !== "type" ? path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier) => specifier.type === "ExportSpecifier" && specifier.exportKind === "type") || !path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier) => _core.types.isExportSpecifier(specifier) && isGlobalType(path, specifier.local.name)) ? path.remove() : NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false) : path.remove();
          }, ExportSpecifier(path) {
            (!path.parent.source && isGlobalType(path, path.node.local.name) || path.node.exportKind === "type") && path.remove();
          }, ExportDefaultDeclaration(path, state) {
            NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true), _core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name) ? path.remove() : NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
          }, TSDeclareFunction(path) {
            path.remove();
          }, TSDeclareMethod(path) {
            path.remove();
          }, VariableDeclaration(path) {
            path.node.declare && path.remove();
          }, VariableDeclarator({ node }) {
            node.definite && (node.definite = null);
          }, TSIndexSignature(path) {
            path.remove();
          }, ClassDeclaration(path) {
            const { node } = path;
            node.declare && path.remove();
          }, Class(path) {
            const { node } = path;
            node.typeParameters && (node.typeParameters = null), node.superTypeParameters && (node.superTypeParameters = null), node.implements && (node.implements = null), node.abstract && (node.abstract = null), path.get("body.body").forEach((child) => {
              child.isClassMethod() || child.isClassPrivateMethod() ? child.node.kind === "constructor" ? classMemberVisitors.constructor(child, path) : classMemberVisitors.method(child) : (child.isClassProperty() || child.isClassPrivateProperty()) && classMemberVisitors.field(child);
            });
          }, Function(path) {
            const { node, scope } = path;
            node.typeParameters && (node.typeParameters = null), node.returnType && (node.returnType = null);
            const params = node.params;
            params.length > 0 && _core.types.isIdentifier(params[0], { name: "this" }) && params.shift();
            const paramsPath = path.get("params");
            for (const p of paramsPath)
              p.type === "TSParameterProperty" && (p.replaceWith(p.get("parameter")), scope.registerBinding("param", p));
          }, TSModuleDeclaration(path) {
            (0, _namespace.default)(path, _core.types, allowNamespaces);
          }, TSInterfaceDeclaration(path) {
            path.remove();
          }, TSTypeAliasDeclaration(path) {
            path.remove();
          }, TSEnumDeclaration(path) {
            optimizeConstEnums && path.node.const ? (0, _constEnum.default)(path, _core.types) : (0, _enum.default)(path, _core.types);
          }, TSImportEqualsDeclaration(path) {
            if (_core.types.isTSExternalModuleReference(path.node.moduleReference))
              throw path.buildCodeFrameError(`\`import ${path.node.id.name} = require('${path.node.moduleReference.expression.value}')\` is not supported by @babel/plugin-transform-typescript
Please consider using \`import ${path.node.id.name} from '${path.node.moduleReference.expression.value}';\` alongside Typescript's --allowSyntheticDefaultImports option.`);
            path.replaceWith(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(path.node.id, entityNameToExpr(path.node.moduleReference))]));
          }, TSExportAssignment(path) {
            throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.");
          }, TSTypeAssertion(path) {
            path.replaceWith(path.node.expression);
          }, TSAsExpression(path) {
            let { node } = path;
            do {
              node = node.expression;
            } while (_core.types.isTSAsExpression(node));
            path.replaceWith(node);
          }, TSNonNullExpression(path) {
            path.replaceWith(path.node.expression);
          }, CallExpression(path) {
            path.node.typeParameters = null;
          }, OptionalCallExpression(path) {
            path.node.typeParameters = null;
          }, NewExpression(path) {
            path.node.typeParameters = null;
          }, JSXOpeningElement(path) {
            path.node.typeParameters = null;
          }, TaggedTemplateExpression(path) {
            path.node.typeParameters = null;
          } } };
          function entityNameToExpr(node) {
            return _core.types.isTSQualifiedName(node) ? _core.types.memberExpression(entityNameToExpr(node.left), node.right) : node;
          }
          function visitPattern({ node }) {
            node.typeAnnotation && (node.typeAnnotation = null), _core.types.isIdentifier(node) && node.optional && (node.optional = null);
          }
          function isImportTypeOnly({ binding, programPath, pragmaImportName, pragmaFragImportName }) {
            for (const path of binding.referencePaths)
              if (!isInType(path))
                return false;
            if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName)
              return true;
            let sourceFileHasJsx = false;
            return programPath.traverse({ "JSXElement|JSXFragment"(path) {
              sourceFileHasJsx = true, path.stop();
            } }), !sourceFileHasJsx;
          }
        });
        exports2.default = _default;
      }, "./node_modules/@babel/plugin-transform-typescript/lib/namespace.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(path, t, allowNamespaces) {
          if (path.node.declare || path.node.id.type === "StringLiteral")
            return void path.remove();
          if (!allowNamespaces)
            throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const name = path.node.id.name, value = handleNested(path, t, t.cloneDeep(path.node)), bound = path.scope.hasOwnBinding(name);
          path.parent.type === "ExportNamedDeclaration" ? bound ? path.parentPath.replaceWith(value) : (path.parentPath.insertAfter(value), path.replaceWith(getDeclaration(t, name)), path.scope.registerDeclaration(path.parentPath)) : bound ? path.replaceWith(value) : path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
        };
        var _core = __webpack_require__2("./node_modules/@babel/core/lib/index.js");
        function getDeclaration(t, name) {
          return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
        }
        function getMemberExpression(t, name, itemName) {
          return t.memberExpression(t.identifier(name), t.identifier(itemName));
        }
        function handleVariableDeclaration(node, name, hub) {
          if (node.kind !== "const")
            throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations } = node;
          if (declarations.every((declarator) => _core.types.isIdentifier(declarator.id))) {
            for (const declarator of declarations)
              declarator.init = _core.types.assignmentExpression("=", getMemberExpression(_core.types, name, declarator.id.name), declarator.init);
            return [node];
          }
          const bindingIdentifiers = _core.types.getBindingIdentifiers(node), assignments = [];
          for (const idName in bindingIdentifiers)
            assignments.push(_core.types.assignmentExpression("=", getMemberExpression(_core.types, name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
          return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];
        }
        function buildNestedAmbiendModuleError(path, node) {
          throw path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function handleNested(path, t, node, parentExport) {
          const names = /* @__PURE__ */ new Set(), realName = node.id;
          t.assertIdentifier(realName);
          const name = path.scope.generateUid(realName.name), namespaceTopLevel = t.isTSModuleBlock(node.body) ? node.body.body : [t.exportNamedDeclaration(node.body)];
          for (let i = 0; i < namespaceTopLevel.length; i++) {
            const subNode = namespaceTopLevel[i];
            switch (subNode.type) {
              case "TSModuleDeclaration": {
                if (!t.isIdentifier(subNode.id))
                  throw buildNestedAmbiendModuleError(path, subNode);
                const transformed = handleNested(path, t, subNode), moduleName = subNode.id.name;
                names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed));
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                names.add(subNode.id.name);
                continue;
              case "VariableDeclaration":
                for (const name2 in t.getBindingIdentifiers(subNode))
                  names.add(name2);
                continue;
              default:
                continue;
              case "ExportNamedDeclaration":
            }
            switch (subNode.declaration.type) {
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration": {
                const itemName = subNode.declaration.id.name;
                names.add(itemName), namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
                break;
              }
              case "VariableDeclaration": {
                const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
                namespaceTopLevel.splice(i, nodes.length, ...nodes), i += nodes.length - 1;
                break;
              }
              case "TSModuleDeclaration": {
                if (!t.isIdentifier(subNode.declaration.id))
                  throw buildNestedAmbiendModuleError(path, subNode.declaration);
                const transformed = handleNested(path, t, subNode.declaration, t.identifier(name)), moduleName = subNode.declaration.id.name;
                names.has(moduleName) ? namespaceTopLevel[i] = transformed : (names.add(moduleName), namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed));
              }
            }
          }
          let fallthroughValue = t.objectExpression([]);
          if (parentExport) {
            const memberExpr = t.memberExpression(parentExport, realName);
            fallthroughValue = _core.template.expression.ast`
      ${t.cloneNode(memberExpr)} ||
        (${t.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
          }
          return _core.template.statement.ast`
    (function (${t.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));
  `;
        }
      }, "./node_modules/@babel/template/lib/builder.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function createTemplateBuilder(formatter, defaultOpts) {
          const templateFnCache = /* @__PURE__ */ new WeakMap(), templateAstCache = /* @__PURE__ */ new WeakMap(), cachedOpts = defaultOpts || (0, _options.validate)(null);
          return Object.assign((tpl, ...args) => {
            if (typeof tpl == "string") {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
            }
            if (Array.isArray(tpl)) {
              let builder = templateFnCache.get(tpl);
              return builder || (builder = (0, _literal.default)(formatter, tpl, cachedOpts), templateFnCache.set(tpl, builder)), extendedTrace(builder(args));
            }
            if (typeof tpl == "object" && tpl) {
              if (args.length > 0)
                throw new Error("Unexpected extra params.");
              return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
            }
            throw new Error("Unexpected template param " + typeof tpl);
          }, { ast: (tpl, ...args) => {
            if (typeof tpl == "string") {
              if (args.length > 1)
                throw new Error("Unexpected extra params.");
              return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
            }
            if (Array.isArray(tpl)) {
              let builder = templateAstCache.get(tpl);
              return builder || (builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)), templateAstCache.set(tpl, builder)), builder(args)();
            }
            throw new Error("Unexpected template param " + typeof tpl);
          } });
        };
        var _options = __webpack_require__2("./node_modules/@babel/template/lib/options.js"), _string = __webpack_require__2("./node_modules/@babel/template/lib/string.js"), _literal = __webpack_require__2("./node_modules/@babel/template/lib/literal.js");
        const NO_PLACEHOLDER = (0, _options.validate)({ placeholderPattern: false });
        function extendedTrace(fn) {
          let rootStack = "";
          try {
            throw new Error();
          } catch (error) {
            error.stack && (rootStack = error.stack.split("\n").slice(3).join("\n"));
          }
          return (arg) => {
            try {
              return fn(arg);
            } catch (err) {
              throw err.stack += `
    =============
${rootStack}`, err;
            }
          };
        }
      }, "./node_modules/@babel/template/lib/formatters.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = void 0;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement } = _t;
        function makeStatementFormatter(fn) {
          return { code: (str) => `/* @babel/template */;
${str}`, validate: () => {
          }, unwrap: (ast) => fn(ast.program.body.slice(1)) };
        }
        const smart = makeStatementFormatter((body) => body.length > 1 ? body : body[0]);
        exports2.smart = smart;
        const statements = makeStatementFormatter((body) => body);
        exports2.statements = statements;
        const statement = makeStatementFormatter((body) => {
          if (body.length === 0)
            throw new Error("Found nothing to return.");
          if (body.length > 1)
            throw new Error("Found multiple statements but wanted one");
          return body[0];
        });
        exports2.statement = statement;
        const expression = { code: (str) => `(
${str}
)`, validate: (ast) => {
          if (ast.program.body.length > 1)
            throw new Error("Found multiple statements but wanted one");
          if (expression.unwrap(ast).start === 0)
            throw new Error("Parse result included parens.");
        }, unwrap: ({ program }) => {
          const [stmt] = program.body;
          return assertExpressionStatement(stmt), stmt.expression;
        } };
        exports2.expression = expression;
        exports2.program = { code: (str) => str, validate: () => {
        }, unwrap: (ast) => ast.program };
      }, "./node_modules/@babel/template/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = exports2.default = void 0;
        var formatters = __webpack_require__2("./node_modules/@babel/template/lib/formatters.js"), _builder = __webpack_require__2("./node_modules/@babel/template/lib/builder.js");
        const smart = (0, _builder.default)(formatters.smart);
        exports2.smart = smart;
        const statement = (0, _builder.default)(formatters.statement);
        exports2.statement = statement;
        const statements = (0, _builder.default)(formatters.statements);
        exports2.statements = statements;
        const expression = (0, _builder.default)(formatters.expression);
        exports2.expression = expression;
        const program = (0, _builder.default)(formatters.program);
        exports2.program = program;
        var _default = Object.assign(smart.bind(void 0), { smart, statement, statements, expression, program, ast: smart.ast });
        exports2.default = _default;
      }, "./node_modules/@babel/template/lib/literal.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(formatter, tpl, opts) {
          const { metadata, names } = function(formatter2, tpl2, opts2) {
            let names2, nameSet, metadata2, prefix = "";
            do {
              prefix += "$";
              const result = buildTemplateCode(tpl2, prefix);
              names2 = result.names, nameSet = new Set(names2), metadata2 = (0, _parse.default)(formatter2, formatter2.code(result.code), { parser: opts2.parser, placeholderWhitelist: new Set(result.names.concat(opts2.placeholderWhitelist ? Array.from(opts2.placeholderWhitelist) : [])), placeholderPattern: opts2.placeholderPattern, preserveComments: opts2.preserveComments, syntacticPlaceholders: opts2.syntacticPlaceholders });
            } while (metadata2.placeholders.some((placeholder) => placeholder.isDuplicate && nameSet.has(placeholder.name)));
            return { metadata: metadata2, names: names2 };
          }(formatter, tpl, opts);
          return (arg) => {
            const defaultReplacements = {};
            return arg.forEach((replacement, i) => {
              defaultReplacements[names[i]] = replacement;
            }), (arg2) => {
              const replacements = (0, _options.normalizeReplacements)(arg2);
              return replacements && Object.keys(replacements).forEach((key) => {
                if (Object.prototype.hasOwnProperty.call(defaultReplacements, key))
                  throw new Error("Unexpected replacement overlap.");
              }), formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
            };
          };
        };
        var _options = __webpack_require__2("./node_modules/@babel/template/lib/options.js"), _parse = __webpack_require__2("./node_modules/@babel/template/lib/parse.js"), _populate = __webpack_require__2("./node_modules/@babel/template/lib/populate.js");
        function buildTemplateCode(tpl, prefix) {
          const names = [];
          let code = tpl[0];
          for (let i = 1; i < tpl.length; i++) {
            const value = `${prefix}${i - 1}`;
            names.push(value), code += value + tpl[i];
          }
          return { names, code };
        }
      }, "./node_modules/@babel/template/lib/options.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.merge = function(a, b) {
          const { placeholderWhitelist = a.placeholderWhitelist, placeholderPattern = a.placeholderPattern, preserveComments = a.preserveComments, syntacticPlaceholders = a.syntacticPlaceholders } = b;
          return { parser: Object.assign({}, a.parser, b.parser), placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders };
        }, exports2.normalizeReplacements = function(replacements) {
          if (Array.isArray(replacements))
            return replacements.reduce((acc, replacement, i) => (acc["$" + i] = replacement, acc), {});
          if (typeof replacements == "object" || replacements == null)
            return replacements || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, exports2.validate = function(opts) {
          if (opts != null && typeof opts != "object")
            throw new Error("Unknown template options.");
          const _ref = opts || {}, { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = _ref, parser = function(source, excluded) {
            if (source == null)
              return {};
            var key, i, target = {}, sourceKeys = Object.keys(source);
            for (i = 0; i < sourceKeys.length; i++)
              key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
            return target;
          }(_ref, _excluded);
          if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set))
            throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false)
            throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (preserveComments != null && typeof preserveComments != "boolean")
            throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (syntacticPlaceholders != null && typeof syntacticPlaceholders != "boolean")
            throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser, placeholderWhitelist: placeholderWhitelist || void 0, placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern, preserveComments: preserveComments == null ? void 0 : preserveComments, syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders };
        };
        const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/@babel/template/lib/parse.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(formatter, code, opts) {
          const { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = opts, ast = function(code2, parserOpts, syntacticPlaceholders2) {
            const plugins = (parserOpts.plugins || []).slice();
            syntacticPlaceholders2 !== false && plugins.push("placeholders");
            parserOpts = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, parserOpts, { plugins });
            try {
              return (0, _parser.parse)(code2, parserOpts);
            } catch (err) {
              const loc = err.loc;
              throw loc && (err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code2, { start: loc }), err.code = "BABEL_TEMPLATE_PARSE_ERROR"), err;
            }
          }(code, opts.parser, syntacticPlaceholders);
          removePropertiesDeep(ast, { preserveComments }), formatter.validate(ast);
          const syntactic = { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy = { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, isLegacyRef = { value: void 0 };
          return traverse(ast, placeholderVisitorHandler, { syntactic, legacy, isLegacyRef, placeholderWhitelist, placeholderPattern, syntacticPlaceholders }), Object.assign({ ast }, isLegacyRef.value ? legacy : syntactic);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _parser = __webpack_require__2("./node_modules/@babel/parser/lib/index.js"), _codeFrame = __webpack_require__2("./stubs/babel_codeframe.js");
        const { isCallExpression, isExpressionStatement, isFunction, isIdentifier, isJSXIdentifier, isNewExpression, isPlaceholder, isStatement, isStringLiteral, removePropertiesDeep, traverse } = _t, PATTERN = /^[_$A-Z0-9]+$/;
        function placeholderVisitorHandler(node, ancestors, state) {
          var _state$placeholderWhi;
          let name;
          if (isPlaceholder(node)) {
            if (state.syntacticPlaceholders === false)
              throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            name = node.name.name, state.isLegacyRef.value = false;
          } else {
            if (state.isLegacyRef.value === false || state.syntacticPlaceholders)
              return;
            if (isIdentifier(node) || isJSXIdentifier(node))
              name = node.name, state.isLegacyRef.value = true;
            else {
              if (!isStringLiteral(node))
                return;
              name = node.value, state.isLegacyRef.value = true;
            }
          }
          if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null))
            throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && ((_state$placeholderWhi = state.placeholderWhitelist) == null || !_state$placeholderWhi.has(name)))
            return;
          ancestors = ancestors.slice();
          const { node: parent, key } = ancestors[ancestors.length - 1];
          let type;
          isStringLiteral(node) || isPlaceholder(node, { expectedNode: "StringLiteral" }) ? type = "string" : isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params" ? type = "param" : isExpressionStatement(parent) && !isPlaceholder(node) ? (type = "statement", ancestors = ancestors.slice(0, -1)) : type = isStatement(node) && isPlaceholder(node) ? "statement" : "other";
          const { placeholders, placeholderNames } = state.isLegacyRef.value ? state.legacy : state.syntactic;
          placeholders.push({ name, type, resolve: (ast) => function(ast2, ancestors2) {
            let parent2 = ast2;
            for (let i = 0; i < ancestors2.length - 1; i++) {
              const { key: key3, index: index2 } = ancestors2[i];
              parent2 = index2 === void 0 ? parent2[key3] : parent2[key3][index2];
            }
            const { key: key2, index } = ancestors2[ancestors2.length - 1];
            return { parent: parent2, key: key2, index };
          }(ast, ancestors), isDuplicate: placeholderNames.has(name) }), placeholderNames.add(name);
        }
      }, "./node_modules/@babel/template/lib/populate.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(metadata, replacements) {
          const ast = cloneNode(metadata.ast);
          replacements && (metadata.placeholders.forEach((placeholder) => {
            if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
              const placeholderName = placeholder.name;
              throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
          }), Object.keys(replacements).forEach((key) => {
            if (!metadata.placeholderNames.has(key))
              throw new Error(`Unknown substitution "${key}" given`);
          }));
          return metadata.placeholders.slice().reverse().forEach((placeholder) => {
            try {
              !function(placeholder2, ast2, replacement) {
                placeholder2.isDuplicate && (Array.isArray(replacement) ? replacement = replacement.map((node) => cloneNode(node)) : typeof replacement == "object" && (replacement = cloneNode(replacement)));
                const { parent, key, index } = placeholder2.resolve(ast2);
                if (placeholder2.type === "string") {
                  if (typeof replacement == "string" && (replacement = stringLiteral(replacement)), !replacement || !isStringLiteral(replacement))
                    throw new Error("Expected string substitution");
                } else if (placeholder2.type === "statement")
                  index === void 0 ? replacement ? Array.isArray(replacement) ? replacement = blockStatement(replacement) : typeof replacement == "string" ? replacement = expressionStatement(identifier(replacement)) : isStatement(replacement) || (replacement = expressionStatement(replacement)) : replacement = emptyStatement() : replacement && !Array.isArray(replacement) && (typeof replacement == "string" && (replacement = identifier(replacement)), isStatement(replacement) || (replacement = expressionStatement(replacement)));
                else if (placeholder2.type === "param") {
                  if (typeof replacement == "string" && (replacement = identifier(replacement)), index === void 0)
                    throw new Error("Assertion failure.");
                } else if (typeof replacement == "string" && (replacement = identifier(replacement)), Array.isArray(replacement))
                  throw new Error("Cannot replace single expression with an array.");
                if (index === void 0)
                  validate(parent, key, replacement), parent[key] = replacement;
                else {
                  const items = parent[key].slice();
                  placeholder2.type === "statement" || placeholder2.type === "param" ? replacement == null ? items.splice(index, 1) : Array.isArray(replacement) ? items.splice(index, 1, ...replacement) : items[index] = replacement : items[index] = replacement, validate(parent, key, items), parent[key] = items;
                }
              }(placeholder, ast, replacements && replacements[placeholder.name] || null);
            } catch (e2) {
              throw e2.message = `@babel/template placeholder "${placeholder.name}": ${e2.message}`, e2;
            }
          }), ast;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { blockStatement, cloneNode, emptyStatement, expressionStatement, identifier, isStatement, isStringLiteral, stringLiteral, validate } = _t;
      }, "./node_modules/@babel/template/lib/string.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(formatter, code, opts) {
          let metadata;
          return code = formatter.code(code), (arg) => {
            const replacements = (0, _options.normalizeReplacements)(arg);
            return metadata || (metadata = (0, _parse.default)(formatter, code, opts)), formatter.unwrap((0, _populate.default)(metadata, replacements));
          };
        };
        var _options = __webpack_require__2("./node_modules/@babel/template/lib/options.js"), _parse = __webpack_require__2("./node_modules/@babel/template/lib/parse.js"), _populate = __webpack_require__2("./node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/@babel/traverse/lib/cache.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.clear = function() {
          clearPath(), clearScope();
        }, exports2.clearPath = clearPath, exports2.clearScope = clearScope, exports2.scope = exports2.path = void 0;
        let path = /* @__PURE__ */ new WeakMap();
        exports2.path = path;
        let scope = /* @__PURE__ */ new WeakMap();
        function clearPath() {
          exports2.path = path = /* @__PURE__ */ new WeakMap();
        }
        function clearScope() {
          exports2.scope = scope = /* @__PURE__ */ new WeakMap();
        }
        exports2.scope = scope;
      }, "./node_modules/@babel/traverse/lib/context.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _path = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS } = _t;
        exports2.default = class {
          constructor(scope, opts, state, parentPath) {
            this.queue = null, this.priorityQueue = null, this.parentPath = parentPath, this.scope = scope, this.state = state, this.opts = opts;
          }
          shouldVisit(node) {
            const opts = this.opts;
            if (opts.enter || opts.exit)
              return true;
            if (opts[node.type])
              return true;
            const keys = VISITOR_KEYS[node.type];
            if (keys == null || !keys.length)
              return false;
            for (const key of keys)
              if (node[key])
                return true;
            return false;
          }
          create(node, obj, key, listKey) {
            return _path.default.get({ parentPath: this.parentPath, parent: node, container: obj, key, listKey });
          }
          maybeQueue(path, notPriority) {
            this.queue && (notPriority ? this.queue.push(path) : this.priorityQueue.push(path));
          }
          visitMultiple(container, parent, listKey) {
            if (container.length === 0)
              return false;
            const queue = [];
            for (let key = 0; key < container.length; key++) {
              const node = container[key];
              node && this.shouldVisit(node) && queue.push(this.create(parent, container, key, listKey));
            }
            return this.visitQueue(queue);
          }
          visitSingle(node, key) {
            return !!this.shouldVisit(node[key]) && this.visitQueue([this.create(node, node, key)]);
          }
          visitQueue(queue) {
            this.queue = queue, this.priorityQueue = [];
            const visited = /* @__PURE__ */ new WeakSet();
            let stop = false;
            for (const path of queue) {
              if (path.resync(), path.contexts.length !== 0 && path.contexts[path.contexts.length - 1] === this || path.pushContext(this), path.key === null)
                continue;
              const { node } = path;
              if (!visited.has(node)) {
                if (node && visited.add(node), path.visit()) {
                  stop = true;
                  break;
                }
                if (this.priorityQueue.length && (stop = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = queue, stop))
                  break;
              }
            }
            for (const path of queue)
              path.popContext();
            return this.queue = null, stop;
          }
          visit(node, key) {
            const nodes = node[key];
            return !!nodes && (Array.isArray(nodes) ? this.visitMultiple(nodes, node, key) : this.visitSingle(node, key));
          }
        };
      }, "./node_modules/@babel/traverse/lib/hub.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        exports2.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(node, msg, Error2 = TypeError) {
            return new Error2(msg);
          }
        };
      }, "./node_modules/@babel/traverse/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "Hub", { enumerable: true, get: function() {
          return _hub.default;
        } }), Object.defineProperty(exports2, "NodePath", { enumerable: true, get: function() {
          return _path.default;
        } }), Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
          return _scope.default;
        } }), exports2.visitors = exports2.default = void 0;
        var visitors = __webpack_require__2("./node_modules/@babel/traverse/lib/visitors.js");
        exports2.visitors = visitors;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js"), _traverseNode = __webpack_require__2("./node_modules/@babel/traverse/lib/traverse-node.js"), _path = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js"), _scope = __webpack_require__2("./node_modules/@babel/traverse/lib/scope/index.js"), _hub = __webpack_require__2("./node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS, removeProperties, traverseFast } = _t;
        function traverse(parent, opts = {}, scope, state, parentPath) {
          if (parent) {
            if (!opts.noScope && !scope && parent.type !== "Program" && parent.type !== "File")
              throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
            VISITOR_KEYS[parent.type] && (visitors.explode(opts), (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath));
          }
        }
        var _default = traverse;
        function hasDenylistedType(path, state) {
          path.node.type === state.type && (state.has = true, path.stop());
        }
        exports2.default = _default, traverse.visitors = visitors, traverse.verify = visitors.verify, traverse.explode = visitors.explode, traverse.cheap = function(node, enter) {
          return traverseFast(node, enter);
        }, traverse.node = function(node, opts, scope, state, path, skipKeys) {
          (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
        }, traverse.clearNode = function(node, opts) {
          removeProperties(node, opts), cache.path.delete(node);
        }, traverse.removeProperties = function(tree, opts) {
          return traverseFast(tree, traverse.clearNode, opts), tree;
        }, traverse.hasType = function(tree, type, denylistTypes) {
          if (denylistTypes != null && denylistTypes.includes(tree.type))
            return false;
          if (tree.type === type)
            return true;
          const state = { has: false, type };
          return traverse(tree, { noScope: true, denylist: denylistTypes, enter: hasDenylistedType }, null, state), state.has;
        }, traverse.cache = cache;
      }, "./node_modules/@babel/traverse/lib/path/ancestry.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.find = function(callback) {
          let path = this;
          do {
            if (callback(path))
              return path;
          } while (path = path.parentPath);
          return null;
        }, exports2.findParent = function(callback) {
          let path = this;
          for (; path = path.parentPath; )
            if (callback(path))
              return path;
          return null;
        }, exports2.getAncestry = function() {
          let path = this;
          const paths = [];
          do {
            paths.push(path);
          } while (path = path.parentPath);
          return paths;
        }, exports2.getDeepestCommonAncestorFrom = function(paths, filter) {
          if (!paths.length)
            return this;
          if (paths.length === 1)
            return paths[0];
          let lastCommonIndex, lastCommon, minDepth = 1 / 0;
          const ancestries = paths.map((path) => {
            const ancestry = [];
            do {
              ancestry.unshift(path);
            } while ((path = path.parentPath) && path !== this);
            return ancestry.length < minDepth && (minDepth = ancestry.length), ancestry;
          }), first = ancestries[0];
          depthLoop:
            for (let i = 0; i < minDepth; i++) {
              const shouldMatch = first[i];
              for (const ancestry of ancestries)
                if (ancestry[i] !== shouldMatch)
                  break depthLoop;
              lastCommonIndex = i, lastCommon = shouldMatch;
            }
          if (lastCommon)
            return filter ? filter(lastCommon, lastCommonIndex, ancestries) : lastCommon;
          throw new Error("Couldn't find intersection");
        }, exports2.getEarliestCommonAncestorFrom = function(paths) {
          return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
            let earliest;
            const keys = VISITOR_KEYS[deepest.type];
            for (const ancestry of ancestries) {
              const path = ancestry[i + 1];
              if (!earliest) {
                earliest = path;
                continue;
              }
              if (path.listKey && earliest.listKey === path.listKey && path.key < earliest.key) {
                earliest = path;
                continue;
              }
              keys.indexOf(earliest.parentKey) > keys.indexOf(path.parentKey) && (earliest = path);
            }
            return earliest;
          });
        }, exports2.getFunctionParent = function() {
          return this.findParent((p) => p.isFunction());
        }, exports2.getStatementParent = function() {
          let path = this;
          do {
            if (!path.parentPath || Array.isArray(path.container) && path.isStatement())
              break;
            path = path.parentPath;
          } while (path);
          if (path && (path.isProgram() || path.isFile()))
            throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return path;
        }, exports2.inType = function(...candidateTypes) {
          let path = this;
          for (; path; ) {
            for (const type of candidateTypes)
              if (path.node.type === type)
                return true;
            path = path.parentPath;
          }
          return false;
        }, exports2.isAncestor = function(maybeDescendant) {
          return maybeDescendant.isDescendant(this);
        }, exports2.isDescendant = function(maybeAncestor) {
          return !!this.findParent((parent) => parent === maybeAncestor);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js");
        const { VISITOR_KEYS } = _t;
      }, "./node_modules/@babel/traverse/lib/path/comments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.addComment = function(type, content, line) {
          _addComment(this.node, type, content, line);
        }, exports2.addComments = function(type, comments) {
          _addComments(this.node, type, comments);
        }, exports2.shareCommentsWithSiblings = function() {
          if (typeof this.key == "string")
            return;
          const node = this.node;
          if (!node)
            return;
          const trailing = node.trailingComments, leading = node.leadingComments;
          if (!trailing && !leading)
            return;
          const prev = this.getSibling(this.key - 1), next = this.getSibling(this.key + 1), hasPrev = Boolean(prev.node), hasNext = Boolean(next.node);
          hasPrev && !hasNext ? prev.addComments("trailing", trailing) : hasNext && !hasPrev && next.addComments("leading", leading);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { addComment: _addComment, addComments: _addComments } = _t;
      }, "./node_modules/@babel/traverse/lib/path/context.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._call = function(fns) {
          if (!fns)
            return false;
          for (const fn of fns) {
            if (!fn)
              continue;
            const node = this.node;
            if (!node)
              return true;
            const ret = fn.call(this.state, this, this.state);
            if (ret && typeof ret == "object" && typeof ret.then == "function")
              throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (ret)
              throw new Error(`Unexpected return value from visitor method ${fn}`);
            if (this.node !== node)
              return true;
            if (this._traverseFlags > 0)
              return true;
          }
          return false;
        }, exports2._getQueueContexts = function() {
          let path = this, contexts = this.contexts;
          for (; !contexts.length && (path = path.parentPath, path); )
            contexts = path.contexts;
          return contexts;
        }, exports2._resyncKey = function() {
          if (!this.container)
            return;
          if (this.node === this.container[this.key])
            return;
          if (Array.isArray(this.container)) {
            for (let i = 0; i < this.container.length; i++)
              if (this.container[i] === this.node)
                return this.setKey(i);
          } else
            for (const key of Object.keys(this.container))
              if (this.container[key] === this.node)
                return this.setKey(key);
          this.key = null;
        }, exports2._resyncList = function() {
          if (!this.parent || !this.inList)
            return;
          const newContainer = this.parent[this.listKey];
          if (this.container === newContainer)
            return;
          this.container = newContainer || null;
        }, exports2._resyncParent = function() {
          this.parentPath && (this.parent = this.parentPath.node);
        }, exports2._resyncRemoved = function() {
          this.key != null && this.container && this.container[this.key] === this.node || this._markRemoved();
        }, exports2.call = function(key) {
          const opts = this.opts;
          if (this.debug(key), this.node && this._call(opts[key]))
            return true;
          if (this.node)
            return this._call(opts[this.node.type] && opts[this.node.type][key]);
          return false;
        }, exports2.isBlacklisted = exports2.isDenylisted = function() {
          var _this$opts$denylist;
          const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
          return denylist && denylist.indexOf(this.node.type) > -1;
        }, exports2.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, exports2.pushContext = function(context) {
          this.contexts.push(context), this.setContext(context);
        }, exports2.requeue = function(pathToQueue = this) {
          if (pathToQueue.removed)
            return;
          const contexts = this.contexts;
          for (const context of contexts)
            context.maybeQueue(pathToQueue);
        }, exports2.resync = function() {
          if (this.removed)
            return;
          this._resyncParent(), this._resyncList(), this._resyncKey();
        }, exports2.setContext = function(context) {
          this.skipKeys != null && (this.skipKeys = {});
          this._traverseFlags = 0, context && (this.context = context, this.state = context.state, this.opts = context.opts);
          return this.setScope(), this;
        }, exports2.setKey = function(key) {
          var _this$node;
          this.key = key, this.node = this.container[this.key], this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
        }, exports2.setScope = function() {
          if (this.opts && this.opts.noScope)
            return;
          let target, path = this.parentPath;
          this.key === "key" && path.isMethod() && (path = path.parentPath);
          for (; path && !target; ) {
            if (path.opts && path.opts.noScope)
              return;
            target = path.scope, path = path.parentPath;
          }
          this.scope = this.getScope(target), this.scope && this.scope.init();
        }, exports2.setup = function(parentPath, container, listKey, key) {
          this.listKey = listKey, this.container = container, this.parentPath = parentPath || this.parentPath, this.setKey(key);
        }, exports2.skip = function() {
          this.shouldSkip = true;
        }, exports2.skipKey = function(key) {
          this.skipKeys == null && (this.skipKeys = {});
          this.skipKeys[key] = true;
        }, exports2.stop = function() {
          this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
        }, exports2.visit = function() {
          if (!this.node)
            return false;
          if (this.isDenylisted())
            return false;
          if (this.opts.shouldSkip && this.opts.shouldSkip(this))
            return false;
          const currentContext = this.context;
          if (this.shouldSkip || this.call("enter"))
            return this.debug("Skip..."), this.shouldStop;
          return restoreContext(this, currentContext), this.debug("Recursing into..."), this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), restoreContext(this, currentContext), this.call("exit"), this.shouldStop;
        };
        var _traverseNode = __webpack_require__2("./node_modules/@babel/traverse/lib/traverse-node.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js");
        function restoreContext(path, context) {
          path.context !== context && (path.context = context, path.state = context.state, path.opts = context.opts);
        }
      }, "./node_modules/@babel/traverse/lib/path/conversion.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.arrowFunctionToExpression = function({ allowInsertArrow = true, specCompliant = false, noNewArrows = !specCompliant } = {}) {
          if (!this.isArrowFunctionExpression())
            throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
          if (fn.ensureBlock(), fn.node.type = "FunctionExpression", !noNewArrows) {
            const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
            checkBinding && fn.parentPath.scope.push({ id: checkBinding, init: objectExpression([]) }), fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), identifier(checkBinding ? checkBinding.name : thisBinding)]))), fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
          }
        }, exports2.arrowFunctionToShadowed = function() {
          if (!this.isArrowFunctionExpression())
            return;
          this.arrowFunctionToExpression();
        }, exports2.ensureBlock = function() {
          const body = this.get("body"), bodyNode = body.node;
          if (Array.isArray(body))
            throw new Error("Can't convert array path to a block statement");
          if (!bodyNode)
            throw new Error("Can't convert node without a body");
          if (body.isBlockStatement())
            return bodyNode;
          const statements = [];
          let key, listKey, stringPath = "body";
          body.isStatement() ? (listKey = "body", key = 0, statements.push(body.node)) : (stringPath += ".body.0", this.isFunction() ? (key = "argument", statements.push(returnStatement(body.node))) : (key = "expression", statements.push(expressionStatement(body.node))));
          this.node.body = blockStatement(statements);
          const parentPath = this.get(stringPath);
          return body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key), this.node;
        }, exports2.toComputedKey = function() {
          let key;
          if (this.isMemberExpression())
            key = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod())
              throw new ReferenceError("todo");
            key = this.node.key;
          }
          this.node.computed || isIdentifier(key) && (key = stringLiteral(key.name));
          return key;
        }, exports2.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
            throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          hoistFunctionEnvironment(this);
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _helperEnvironmentVisitor = __webpack_require__2("./node_modules/@babel/helper-environment-visitor/lib/index.js"), _helperFunctionName = __webpack_require__2("./node_modules/@babel/helper-function-name/lib/index.js"), _visitors = __webpack_require__2("./node_modules/@babel/traverse/lib/visitors.js");
        const { arrowFunctionExpression, assignmentExpression, binaryExpression, blockStatement, callExpression, conditionalExpression, expressionStatement, identifier, isIdentifier, jsxIdentifier, logicalExpression, LOGICAL_OPERATORS, memberExpression, metaProperty, numericLiteral, objectExpression, restElement, returnStatement, sequenceExpression, spreadElement, stringLiteral, super: _super, thisExpression, toExpression, unaryExpression } = _t;
        const getSuperCallsVisitor = (0, _visitors.merge)([{ CallExpression(child, { allSuperCalls }) {
          child.get("callee").isSuper() && allSuperCalls.push(child);
        } }, _helperEnvironmentVisitor.default]);
        function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {
          let arrowParent, thisEnvFn = fnPath.findParent((p) => p.isArrowFunctionExpression() ? (arrowParent != null || (arrowParent = p), false) : p.isFunction() || p.isProgram() || p.isClassProperty({ static: false }) || p.isClassPrivateProperty({ static: false }));
          const inConstructor = thisEnvFn.isClassMethod({ kind: "constructor" });
          if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty())
            if (arrowParent)
              thisEnvFn = arrowParent;
            else {
              if (!allowInsertArrow)
                throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
              fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), [])), thisEnvFn = fnPath.get("callee"), fnPath = thisEnvFn.get("body");
            }
          const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } = function(fnPath2) {
            const thisPaths2 = [], argumentsPaths2 = [], newTargetPaths2 = [], superProps2 = [], superCalls2 = [];
            return fnPath2.traverse(getScopeInformationVisitor, { thisPaths: thisPaths2, argumentsPaths: argumentsPaths2, newTargetPaths: newTargetPaths2, superProps: superProps2, superCalls: superCalls2 }), { thisPaths: thisPaths2, argumentsPaths: argumentsPaths2, newTargetPaths: newTargetPaths2, superProps: superProps2, superCalls: superCalls2 };
          }(fnPath);
          if (inConstructor && superCalls.length > 0) {
            if (!allowInsertArrow)
              throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
            const allSuperCalls = [];
            thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });
            const superBinding = function(thisEnvFn2) {
              return getBinding(thisEnvFn2, "supercall", () => {
                const argsBinding = thisEnvFn2.scope.generateUidIdentifier("args");
                return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
              });
            }(thisEnvFn);
            allSuperCalls.forEach((superCall) => {
              const callee = identifier(superBinding);
              callee.loc = superCall.node.callee.loc, superCall.get("callee").replaceWith(callee);
            });
          }
          if (argumentsPaths.length > 0) {
            const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
              const args = () => identifier("arguments");
              return thisEnvFn.scope.path.isProgram() ? conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args()) : args();
            });
            argumentsPaths.forEach((argumentsChild) => {
              const argsRef = identifier(argumentsBinding);
              argsRef.loc = argumentsChild.node.loc, argumentsChild.replaceWith(argsRef);
            });
          }
          if (newTargetPaths.length > 0) {
            const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
            newTargetPaths.forEach((targetChild) => {
              const targetRef = identifier(newTargetBinding);
              targetRef.loc = targetChild.node.loc, targetChild.replaceWith(targetRef);
            });
          }
          if (superProps.length > 0) {
            if (!allowInsertArrow)
              throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
            superProps.reduce((acc, superProp) => acc.concat(function(superProp2) {
              if (superProp2.parentPath.isAssignmentExpression() && superProp2.parentPath.node.operator !== "=") {
                const assignmentPath = superProp2.parentPath, op = assignmentPath.node.operator.slice(0, -1), value = assignmentPath.node.right, isLogicalAssignment = function(op2) {
                  return LOGICAL_OPERATORS.includes(op2);
                }(op);
                if (superProp2.node.computed) {
                  const tmp = superProp2.scope.generateDeclaredUidIdentifier("tmp"), object = superProp2.node.object, property = superProp2.node.property;
                  assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
                } else {
                  const object = superProp2.node.object, property = superProp2.node.property;
                  assignmentPath.get("left").replaceWith(memberExpression(object, property)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
                }
                return isLogicalAssignment ? assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right)) : assignmentPath.node.operator = "=", [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
              }
              if (superProp2.parentPath.isUpdateExpression()) {
                const updateExpr = superProp2.parentPath, tmp = superProp2.scope.generateDeclaredUidIdentifier("tmp"), computedKey = superProp2.node.computed ? superProp2.scope.generateDeclaredUidIdentifier("prop") : null, parts = [assignmentExpression("=", tmp, memberExpression(superProp2.node.object, computedKey ? assignmentExpression("=", computedKey, superProp2.node.property) : superProp2.node.property, superProp2.node.computed)), assignmentExpression("=", memberExpression(superProp2.node.object, computedKey ? identifier(computedKey.name) : superProp2.node.property, superProp2.node.computed), binaryExpression(superProp2.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
                superProp2.parentPath.node.prefix || parts.push(identifier(tmp.name)), updateExpr.replaceWith(sequenceExpression(parts));
                return [updateExpr.get("expressions.0.right"), updateExpr.get("expressions.1.left")];
              }
              return [superProp2];
              function rightExpression(op, left, right) {
                return op === "=" ? assignmentExpression("=", left, right) : binaryExpression(op, left, right);
              }
            }(superProp)), []).forEach((superProp) => {
              const key = superProp.node.computed ? "" : superProp.get("property").node.name, isAssignment = superProp.parentPath.isAssignmentExpression({ left: superProp.node }), isCall = superProp.parentPath.isCallExpression({ callee: superProp.node }), superBinding = function(thisEnvFn2, isAssignment2, propName) {
                return getBinding(thisEnvFn2, `superprop_${isAssignment2 ? "set" : "get"}:${propName || ""}`, () => {
                  const argsList = [];
                  let fnBody;
                  if (propName)
                    fnBody = memberExpression(_super(), identifier(propName));
                  else {
                    const method = thisEnvFn2.scope.generateUidIdentifier("prop");
                    argsList.unshift(method), fnBody = memberExpression(_super(), identifier(method.name), true);
                  }
                  if (isAssignment2) {
                    const valueIdent = thisEnvFn2.scope.generateUidIdentifier("value");
                    argsList.push(valueIdent), fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
                  }
                  return arrowFunctionExpression(argsList, fnBody);
                });
              }(thisEnvFn, isAssignment, key), args = [];
              if (superProp.node.computed && args.push(superProp.get("property").node), isAssignment) {
                const value = superProp.parentPath.node.right;
                args.push(value);
              }
              const call = callExpression(identifier(superBinding), args);
              isCall ? (superProp.parentPath.unshiftContainer("arguments", thisExpression()), superProp.replaceWith(memberExpression(call, identifier("call"))), thisPaths.push(superProp.parentPath.get("arguments.0"))) : isAssignment ? superProp.parentPath.replaceWith(call) : superProp.replaceWith(call);
            });
          }
          let thisBinding;
          return (thisPaths.length > 0 || !noNewArrows) && (thisBinding = function(thisEnvFn2, inConstructor2) {
            return getBinding(thisEnvFn2, "this", (thisBinding2) => {
              if (!inConstructor2 || !hasSuperClass(thisEnvFn2))
                return thisExpression();
              thisEnvFn2.traverse(assignSuperThisVisitor, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: thisBinding2 });
            });
          }(thisEnvFn, inConstructor), (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) && (thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
            thisRef.loc = thisChild.node.loc, thisChild.replaceWith(thisRef);
          }), noNewArrows || (thisBinding = null))), { thisBinding, fnPath };
        }
        function hasSuperClass(thisEnvFn) {
          return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
        }
        const assignSuperThisVisitor = (0, _visitors.merge)([{ CallExpression(child, { supers, thisBinding }) {
          child.get("callee").isSuper() && (supers.has(child.node) || (supers.add(child.node), child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))])));
        } }, _helperEnvironmentVisitor.default]);
        function getBinding(thisEnvFn, key, init) {
          const cacheKey = "binding:" + key;
          let data = thisEnvFn.getData(cacheKey);
          if (!data) {
            const id = thisEnvFn.scope.generateUidIdentifier(key);
            data = id.name, thisEnvFn.setData(cacheKey, data), thisEnvFn.scope.push({ id, init: init(data) });
          }
          return data;
        }
        const getScopeInformationVisitor = (0, _visitors.merge)([{ ThisExpression(child, { thisPaths }) {
          thisPaths.push(child);
        }, JSXIdentifier(child, { thisPaths }) {
          child.node.name === "this" && (child.parentPath.isJSXMemberExpression({ object: child.node }) || child.parentPath.isJSXOpeningElement({ name: child.node })) && thisPaths.push(child);
        }, CallExpression(child, { superCalls }) {
          child.get("callee").isSuper() && superCalls.push(child);
        }, MemberExpression(child, { superProps }) {
          child.get("object").isSuper() && superProps.push(child);
        }, Identifier(child, { argumentsPaths }) {
          if (!child.isReferencedIdentifier({ name: "arguments" }))
            return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments"))
              return void curr.rename("arguments");
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression())
              break;
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        }, MetaProperty(child, { newTargetPaths }) {
          child.get("meta").isIdentifier({ name: "new" }) && child.get("property").isIdentifier({ name: "target" }) && newTargetPaths.push(child);
        } }, _helperEnvironmentVisitor.default]);
      }, "./node_modules/@babel/traverse/lib/path/evaluation.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.evaluate = function() {
          const state = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let value = evaluateCached(this, state);
          state.confident || (value = void 0);
          return { confident: state.confident, deopt: state.deoptPath, value };
        }, exports2.evaluateTruthy = function() {
          const res = this.evaluate();
          if (res.confident)
            return !!res.value;
        };
        const VALID_CALLEES = ["String", "Number", "Math"], INVALID_METHODS = ["random"];
        function deopt(path, state) {
          state.confident && (state.deoptPath = path, state.confident = false);
        }
        function evaluateCached(path, state) {
          const { node } = path, { seen } = state;
          if (seen.has(node)) {
            const existing = seen.get(node);
            return existing.resolved ? existing.value : void deopt(path, state);
          }
          {
            const item = { resolved: false };
            seen.set(node, item);
            const val = function(path2, state2) {
              if (!state2.confident)
                return;
              if (path2.isSequenceExpression()) {
                const exprs = path2.get("expressions");
                return evaluateCached(exprs[exprs.length - 1], state2);
              }
              if (path2.isStringLiteral() || path2.isNumericLiteral() || path2.isBooleanLiteral())
                return path2.node.value;
              if (path2.isNullLiteral())
                return null;
              if (path2.isTemplateLiteral())
                return evaluateQuasis(path2, path2.node.quasis, state2);
              if (path2.isTaggedTemplateExpression() && path2.get("tag").isMemberExpression()) {
                const object = path2.get("tag.object"), { node: { name } } = object, property = path2.get("tag.property");
                if (object.isIdentifier() && name === "String" && !path2.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw")
                  return evaluateQuasis(path2, path2.node.quasi.quasis, state2, true);
              }
              if (path2.isConditionalExpression()) {
                const testResult = evaluateCached(path2.get("test"), state2);
                if (!state2.confident)
                  return;
                return evaluateCached(testResult ? path2.get("consequent") : path2.get("alternate"), state2);
              }
              if (path2.isExpressionWrapper())
                return evaluateCached(path2.get("expression"), state2);
              if (path2.isMemberExpression() && !path2.parentPath.isCallExpression({ callee: path2.node })) {
                const property = path2.get("property"), object = path2.get("object");
                if (object.isLiteral() && property.isIdentifier()) {
                  const value = object.node.value, type = typeof value;
                  if (type === "number" || type === "string")
                    return value[property.node.name];
                }
              }
              if (path2.isReferencedIdentifier()) {
                const binding = path2.scope.getBinding(path2.node.name);
                if (binding && binding.constantViolations.length > 0)
                  return deopt(binding.path, state2);
                if (binding && path2.node.start < binding.path.node.end)
                  return deopt(binding.path, state2);
                if (binding != null && binding.hasValue)
                  return binding.value;
                {
                  if (path2.node.name === "undefined")
                    return binding ? deopt(binding.path, state2) : void 0;
                  if (path2.node.name === "Infinity")
                    return binding ? deopt(binding.path, state2) : 1 / 0;
                  if (path2.node.name === "NaN")
                    return binding ? deopt(binding.path, state2) : NaN;
                  const resolved = path2.resolve();
                  return resolved === path2 ? deopt(path2, state2) : evaluateCached(resolved, state2);
                }
              }
              if (path2.isUnaryExpression({ prefix: true })) {
                if (path2.node.operator === "void")
                  return;
                const argument = path2.get("argument");
                if (path2.node.operator === "typeof" && (argument.isFunction() || argument.isClass()))
                  return "function";
                const arg = evaluateCached(argument, state2);
                if (!state2.confident)
                  return;
                switch (path2.node.operator) {
                  case "!":
                    return !arg;
                  case "+":
                    return +arg;
                  case "-":
                    return -arg;
                  case "~":
                    return ~arg;
                  case "typeof":
                    return typeof arg;
                }
              }
              if (path2.isArrayExpression()) {
                const arr = [], elems = path2.get("elements");
                for (const elem of elems) {
                  const elemValue = elem.evaluate();
                  if (!elemValue.confident)
                    return deopt(elemValue.deopt, state2);
                  arr.push(elemValue.value);
                }
                return arr;
              }
              if (path2.isObjectExpression()) {
                const obj = {}, props = path2.get("properties");
                for (const prop of props) {
                  if (prop.isObjectMethod() || prop.isSpreadElement())
                    return deopt(prop, state2);
                  let key = prop.get("key");
                  if (prop.node.computed) {
                    if (key = key.evaluate(), !key.confident)
                      return deopt(key.deopt, state2);
                    key = key.value;
                  } else
                    key = key.isIdentifier() ? key.node.name : key.node.value;
                  let value = prop.get("value").evaluate();
                  if (!value.confident)
                    return deopt(value.deopt, state2);
                  value = value.value, obj[key] = value;
                }
                return obj;
              }
              if (path2.isLogicalExpression()) {
                const wasConfident = state2.confident, left = evaluateCached(path2.get("left"), state2), leftConfident = state2.confident;
                state2.confident = wasConfident;
                const right = evaluateCached(path2.get("right"), state2), rightConfident = state2.confident;
                switch (path2.node.operator) {
                  case "||":
                    if (state2.confident = leftConfident && (!!left || rightConfident), !state2.confident)
                      return;
                    return left || right;
                  case "&&":
                    if (state2.confident = leftConfident && (!left || rightConfident), !state2.confident)
                      return;
                    return left && right;
                }
              }
              if (path2.isBinaryExpression()) {
                const left = evaluateCached(path2.get("left"), state2);
                if (!state2.confident)
                  return;
                const right = evaluateCached(path2.get("right"), state2);
                if (!state2.confident)
                  return;
                switch (path2.node.operator) {
                  case "-":
                    return left - right;
                  case "+":
                    return left + right;
                  case "/":
                    return left / right;
                  case "*":
                    return left * right;
                  case "%":
                    return left % right;
                  case "**":
                    return Math.pow(left, right);
                  case "<":
                    return left < right;
                  case ">":
                    return left > right;
                  case "<=":
                    return left <= right;
                  case ">=":
                    return left >= right;
                  case "==":
                    return left == right;
                  case "!=":
                    return left != right;
                  case "===":
                    return left === right;
                  case "!==":
                    return left !== right;
                  case "|":
                    return left | right;
                  case "&":
                    return left & right;
                  case "^":
                    return left ^ right;
                  case "<<":
                    return left << right;
                  case ">>":
                    return left >> right;
                  case ">>>":
                    return left >>> right;
                }
              }
              if (path2.isCallExpression()) {
                const callee = path2.get("callee");
                let context, func;
                if (callee.isIdentifier() && !path2.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0 && (func = global[callee.node.name]), callee.isMemberExpression()) {
                  const object = callee.get("object"), property = callee.get("property");
                  if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0 && (context = global[object.node.name], func = context[property.node.name]), object.isLiteral() && property.isIdentifier()) {
                    const type = typeof object.node.value;
                    type !== "string" && type !== "number" || (context = object.node.value, func = context[property.node.name]);
                  }
                }
                if (func) {
                  const args = path2.get("arguments").map((arg) => evaluateCached(arg, state2));
                  if (!state2.confident)
                    return;
                  return func.apply(context, args);
                }
              }
              deopt(path2, state2);
            }(path, state);
            return state.confident && (item.resolved = true, item.value = val), val;
          }
        }
        function evaluateQuasis(path, quasis, state, raw = false) {
          let str = "", i = 0;
          const exprs = path.get("expressions");
          for (const elem of quasis) {
            if (!state.confident)
              break;
            str += raw ? elem.value.raw : elem.value.cooked;
            const expr = exprs[i++];
            expr && (str += String(evaluateCached(expr, state)));
          }
          if (state.confident)
            return str;
        }
      }, "./node_modules/@babel/traverse/lib/path/family.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._getKey = function(key, context) {
          const node = this.node, container = node[key];
          return Array.isArray(container) ? container.map((_, i) => _index.default.get({ listKey: key, parentPath: this, parent: node, container, key: i }).setContext(context)) : _index.default.get({ parentPath: this, parent: node, container: node, key }).setContext(context);
        }, exports2._getPattern = function(parts, context) {
          let path = this;
          for (const part of parts)
            path = part === "." ? path.parentPath : Array.isArray(path) ? path[part] : path.get(part, context);
          return path;
        }, exports2.get = function(key, context = true) {
          context === true && (context = this.context);
          const parts = key.split(".");
          return parts.length === 1 ? this._getKey(key, context) : this._getPattern(parts, context);
        }, exports2.getAllNextSiblings = function() {
          let _key = this.key, sibling = this.getSibling(++_key);
          const siblings = [];
          for (; sibling.node; )
            siblings.push(sibling), sibling = this.getSibling(++_key);
          return siblings;
        }, exports2.getAllPrevSiblings = function() {
          let _key = this.key, sibling = this.getSibling(--_key);
          const siblings = [];
          for (; sibling.node; )
            siblings.push(sibling), sibling = this.getSibling(--_key);
          return siblings;
        }, exports2.getBindingIdentifierPaths = function(duplicates = false, outerOnly = false) {
          const search = [this], ids = /* @__PURE__ */ Object.create(null);
          for (; search.length; ) {
            const id = search.shift();
            if (!id)
              continue;
            if (!id.node)
              continue;
            const keys = _getBindingIdentifiers.keys[id.node.type];
            if (id.isIdentifier())
              if (duplicates) {
                (ids[id.node.name] = ids[id.node.name] || []).push(id);
              } else
                ids[id.node.name] = id;
            else if (id.isExportDeclaration()) {
              const declaration = id.get("declaration");
              isDeclaration(declaration) && search.push(declaration);
            } else {
              if (outerOnly) {
                if (id.isFunctionDeclaration()) {
                  search.push(id.get("id"));
                  continue;
                }
                if (id.isFunctionExpression())
                  continue;
              }
              if (keys)
                for (let i = 0; i < keys.length; i++) {
                  const key = keys[i], child = id.get(key);
                  Array.isArray(child) ? search.push(...child) : child.node && search.push(child);
                }
            }
          }
          return ids;
        }, exports2.getBindingIdentifiers = function(duplicates) {
          return _getBindingIdentifiers(this.node, duplicates);
        }, exports2.getCompletionRecords = function() {
          return _getCompletionRecords(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((r) => r.path);
        }, exports2.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, exports2.getOpposite = function() {
          if (this.key === "left")
            return this.getSibling("right");
          if (this.key === "right")
            return this.getSibling("left");
          return null;
        }, exports2.getOuterBindingIdentifierPaths = function(duplicates) {
          return this.getBindingIdentifierPaths(duplicates, true);
        }, exports2.getOuterBindingIdentifiers = function(duplicates) {
          return _getOuterBindingIdentifiers(this.node, duplicates);
        }, exports2.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, exports2.getSibling = function(key) {
          return _index.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key }).setContext(this.context);
        };
        var _index = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { getBindingIdentifiers: _getBindingIdentifiers, getOuterBindingIdentifiers: _getOuterBindingIdentifiers, isDeclaration, numericLiteral, unaryExpression } = _t;
        function addCompletionRecords(path, records, context) {
          return path && records.push(..._getCompletionRecords(path, context)), records;
        }
        function normalCompletionToBreak(completions) {
          completions.forEach((c) => {
            c.type = 1;
          });
        }
        function replaceBreakStatementInBreakCompletion(completions, reachable) {
          completions.forEach((c) => {
            c.path.isBreakStatement({ label: null }) && (reachable ? c.path.replaceWith(unaryExpression("void", numericLiteral(0))) : c.path.remove());
          });
        }
        function getStatementListCompletion(paths, context) {
          const completions = [];
          if (context.canHaveBreak) {
            let lastNormalCompletions = [];
            for (let i = 0; i < paths.length; i++) {
              const path = paths[i], newContext = Object.assign({}, context, { inCaseClause: false });
              path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak) ? newContext.shouldPopulateBreak = true : newContext.shouldPopulateBreak = false;
              const statementCompletions = _getCompletionRecords(path, newContext);
              if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === 1)) {
                lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({ label: null })) ? (normalCompletionToBreak(lastNormalCompletions), completions.push(...lastNormalCompletions), lastNormalCompletions.some((c) => c.path.isDeclaration()) && (completions.push(...statementCompletions), replaceBreakStatementInBreakCompletion(statementCompletions, true)), replaceBreakStatementInBreakCompletion(statementCompletions, false)) : (completions.push(...statementCompletions), context.shouldPopulateBreak || replaceBreakStatementInBreakCompletion(statementCompletions, true));
                break;
              }
              if (i === paths.length - 1)
                completions.push(...statementCompletions);
              else {
                lastNormalCompletions = [];
                for (let i2 = 0; i2 < statementCompletions.length; i2++) {
                  const c = statementCompletions[i2];
                  c.type === 1 && completions.push(c), c.type === 0 && lastNormalCompletions.push(c);
                }
              }
            }
          } else if (paths.length)
            for (let i = paths.length - 1; i >= 0; i--) {
              const pathCompletions = _getCompletionRecords(paths[i], context);
              if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
                completions.push(...pathCompletions);
                break;
              }
            }
          return completions;
        }
        function _getCompletionRecords(path, context) {
          let records = [];
          if (path.isIfStatement())
            records = addCompletionRecords(path.get("consequent"), records, context), records = addCompletionRecords(path.get("alternate"), records, context);
          else {
            if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement())
              return addCompletionRecords(path.get("body"), records, context);
            if (path.isProgram() || path.isBlockStatement())
              return getStatementListCompletion(path.get("body"), context);
            if (path.isFunction())
              return _getCompletionRecords(path.get("body"), context);
            if (path.isTryStatement())
              records = addCompletionRecords(path.get("block"), records, context), records = addCompletionRecords(path.get("handler"), records, context);
            else {
              if (path.isCatchClause())
                return addCompletionRecords(path.get("body"), records, context);
              if (path.isSwitchStatement())
                return function(cases, records2, context2) {
                  let lastNormalCompletions = [];
                  for (let i = 0; i < cases.length; i++) {
                    const caseCompletions = _getCompletionRecords(cases[i], context2), normalCompletions = [], breakCompletions = [];
                    for (const c of caseCompletions)
                      c.type === 0 && normalCompletions.push(c), c.type === 1 && breakCompletions.push(c);
                    normalCompletions.length && (lastNormalCompletions = normalCompletions), records2.push(...breakCompletions);
                  }
                  return records2.push(...lastNormalCompletions), records2;
                }(path.get("cases"), records, context);
              if (path.isSwitchCase())
                return getStatementListCompletion(path.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
              path.isBreakStatement() ? records.push(function(path2) {
                return { type: 1, path: path2 };
              }(path)) : records.push(function(path2) {
                return { type: 0, path: path2 };
              }(path));
            }
          }
          return records;
        }
      }, "./node_modules/@babel/traverse/lib/path/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = exports2.SHOULD_STOP = exports2.SHOULD_SKIP = exports2.REMOVED = void 0;
        var virtualTypes = __webpack_require__2("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), _debug = __webpack_require__2("./node_modules/debug/src/index.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _scope = __webpack_require__2("./node_modules/@babel/traverse/lib/scope/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), t = _t, _cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js"), _generator = __webpack_require__2("./node_modules/@babel/generator/lib/index.js"), NodePath_ancestry = __webpack_require__2("./node_modules/@babel/traverse/lib/path/ancestry.js"), NodePath_inference = __webpack_require__2("./node_modules/@babel/traverse/lib/path/inference/index.js"), NodePath_replacement = __webpack_require__2("./node_modules/@babel/traverse/lib/path/replacement.js"), NodePath_evaluation = __webpack_require__2("./node_modules/@babel/traverse/lib/path/evaluation.js"), NodePath_conversion = __webpack_require__2("./node_modules/@babel/traverse/lib/path/conversion.js"), NodePath_introspection = __webpack_require__2("./node_modules/@babel/traverse/lib/path/introspection.js"), NodePath_context = __webpack_require__2("./node_modules/@babel/traverse/lib/path/context.js"), NodePath_removal = __webpack_require__2("./node_modules/@babel/traverse/lib/path/removal.js"), NodePath_modification = __webpack_require__2("./node_modules/@babel/traverse/lib/path/modification.js"), NodePath_family = __webpack_require__2("./node_modules/@babel/traverse/lib/path/family.js"), NodePath_comments = __webpack_require__2("./node_modules/@babel/traverse/lib/path/comments.js");
        const { validate } = _t, debug = _debug("babel");
        exports2.REMOVED = 1;
        exports2.SHOULD_STOP = 2;
        exports2.SHOULD_SKIP = 4;
        class NodePath {
          constructor(hub, parent) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = parent, this.hub = hub, this.data = null, this.context = null, this.scope = null;
          }
          static get({ hub, parentPath, parent, container, listKey, key }) {
            if (!hub && parentPath && (hub = parentPath.hub), !parent)
              throw new Error("To get a node path the parent needs to exist");
            const targetNode = container[key];
            let paths = _cache.path.get(parent);
            paths || (paths = /* @__PURE__ */ new Map(), _cache.path.set(parent, paths));
            let path = paths.get(targetNode);
            return path || (path = new NodePath(hub, parent), targetNode && paths.set(targetNode, path)), path.setup(parentPath, container, listKey, key), path;
          }
          getScope(scope) {
            return this.isScope() ? new _scope.default(this) : scope;
          }
          setData(key, val) {
            return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[key] = val;
          }
          getData(key, def) {
            this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
            let val = this.data[key];
            return val === void 0 && def !== void 0 && (val = this.data[key] = def), val;
          }
          buildCodeFrameError(msg, Error2 = SyntaxError) {
            return this.hub.buildError(this.node, msg, Error2);
          }
          traverse(visitor, state) {
            (0, _index.default)(this.node, visitor, this.scope, state, this);
          }
          set(key, node) {
            validate(this.node, key, node), this.node[key] = node;
          }
          getPathLocation() {
            const parts = [];
            let path = this;
            do {
              let key = path.key;
              path.inList && (key = `${path.listKey}[${key}]`), parts.unshift(key);
            } while (path = path.parentPath);
            return parts.join(".");
          }
          debug(message) {
            debug.enabled && debug(`${this.getPathLocation()} ${this.type}: ${message}`);
          }
          toString() {
            return (0, _generator.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(inList) {
            inList || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
          get shouldSkip() {
            return !!(4 & this._traverseFlags);
          }
          set shouldSkip(v) {
            v ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          get shouldStop() {
            return !!(2 & this._traverseFlags);
          }
          set shouldStop(v) {
            v ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get removed() {
            return !!(1 & this._traverseFlags);
          }
          set removed(v) {
            v ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
        }
        Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
        for (const type of t.TYPES) {
          const typeKey = `is${type}`, fn = t[typeKey];
          NodePath.prototype[typeKey] = function(opts) {
            return fn(this.node, opts);
          }, NodePath.prototype[`assert${type}`] = function(opts) {
            if (!fn(this.node, opts))
              throw new TypeError(`Expected node path of type ${type}`);
          };
        }
        for (const type of Object.keys(virtualTypes)) {
          if (type[0] === "_")
            continue;
          t.TYPES.indexOf(type) < 0 && t.TYPES.push(type);
          const virtualType = virtualTypes[type];
          NodePath.prototype[`is${type}`] = function(opts) {
            return virtualType.checkPath(this, opts);
          };
        }
        var _default = NodePath;
        exports2.default = _default;
      }, "./node_modules/@babel/traverse/lib/path/inference/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._getTypeAnnotation = function() {
          const node = this.node;
          if (!node) {
            if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
              const declar = this.parentPath.parentPath, declarParent = declar.parentPath;
              return declar.key === "left" && declarParent.isForInStatement() ? stringTypeAnnotation() : declar.key === "left" && declarParent.isForOfStatement() ? anyTypeAnnotation() : voidTypeAnnotation();
            }
            return;
          }
          if (node.typeAnnotation)
            return node.typeAnnotation;
          if (typeAnnotationInferringNodes.has(node))
            return;
          typeAnnotationInferringNodes.add(node);
          try {
            var _inferer;
            let inferer = inferers[node.type];
            if (inferer)
              return inferer.call(this, node);
            if (inferer = inferers[this.parentPath.type], (_inferer = inferer) != null && _inferer.validParent)
              return this.parentPath.getTypeAnnotation();
          } finally {
            typeAnnotationInferringNodes.delete(node);
          }
        }, exports2.baseTypeStrictlyMatches = function(rightArg) {
          const left = this.getTypeAnnotation(), right = rightArg.getTypeAnnotation();
          if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left))
            return right.type === left.type;
          return false;
        }, exports2.couldBeBaseType = function(name) {
          const type = this.getTypeAnnotation();
          if (isAnyTypeAnnotation(type))
            return true;
          if (isUnionTypeAnnotation(type)) {
            for (const type2 of type.types)
              if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true))
                return true;
            return false;
          }
          return _isBaseType(name, type, true);
        }, exports2.getTypeAnnotation = function() {
          if (this.typeAnnotation)
            return this.typeAnnotation;
          let type = this._getTypeAnnotation() || anyTypeAnnotation();
          isTypeAnnotation(type) && (type = type.typeAnnotation);
          return this.typeAnnotation = type;
        }, exports2.isBaseType = function(baseName, soft) {
          return _isBaseType(baseName, this.getTypeAnnotation(), soft);
        }, exports2.isGenericType = function(genericName) {
          const type = this.getTypeAnnotation();
          return isGenericTypeAnnotation(type) && isIdentifier(type.id, { name: genericName });
        };
        var inferers = __webpack_require__2("./node_modules/@babel/traverse/lib/path/inference/inferers.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation, isAnyTypeAnnotation, isBooleanTypeAnnotation, isEmptyTypeAnnotation, isFlowBaseAnnotation, isGenericTypeAnnotation, isIdentifier, isMixedTypeAnnotation, isNumberTypeAnnotation, isStringTypeAnnotation, isTypeAnnotation, isUnionTypeAnnotation, isVoidTypeAnnotation, stringTypeAnnotation, voidTypeAnnotation } = _t;
        const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
        function _isBaseType(baseName, type, soft) {
          if (baseName === "string")
            return isStringTypeAnnotation(type);
          if (baseName === "number")
            return isNumberTypeAnnotation(type);
          if (baseName === "boolean")
            return isBooleanTypeAnnotation(type);
          if (baseName === "any")
            return isAnyTypeAnnotation(type);
          if (baseName === "mixed")
            return isMixedTypeAnnotation(type);
          if (baseName === "empty")
            return isEmptyTypeAnnotation(type);
          if (baseName === "void")
            return isVoidTypeAnnotation(type);
          if (soft)
            return false;
          throw new Error(`Unknown base type ${baseName}`);
        }
      }, "./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          if (!this.isReferenced())
            return;
          const binding = this.scope.getBinding(node.name);
          if (binding)
            return binding.identifier.typeAnnotation ? binding.identifier.typeAnnotation : function(binding2, path, name) {
              const types = [], functionConstantViolations = [];
              let constantViolations = getConstantViolationsBefore(binding2, path, functionConstantViolations);
              const testType = getConditionalAnnotation(binding2, path, name);
              if (testType) {
                const testConstantViolations = getConstantViolationsBefore(binding2, testType.ifStatement);
                constantViolations = constantViolations.filter((path2) => testConstantViolations.indexOf(path2) < 0), types.push(testType.typeAnnotation);
              }
              if (constantViolations.length) {
                constantViolations.push(...functionConstantViolations);
                for (const violation of constantViolations)
                  types.push(violation.getTypeAnnotation());
              }
              if (!types.length)
                return;
              if (isTSTypeAnnotation(types[0]) && createTSUnionType)
                return createTSUnionType(types);
              if (createFlowUnionType)
                return createFlowUnionType(types);
              return createUnionTypeAnnotation(types);
            }(binding, this, node.name);
          if (node.name === "undefined")
            return voidTypeAnnotation();
          if (node.name === "NaN" || node.name === "Infinity")
            return numberTypeAnnotation();
          node.name;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS, createFlowUnionType, createTSUnionType, createTypeAnnotationBasedOnTypeof, createUnionTypeAnnotation, isTSTypeAnnotation, numberTypeAnnotation, voidTypeAnnotation } = _t;
        function getConstantViolationsBefore(binding, path, functions) {
          const violations = binding.constantViolations.slice();
          return violations.unshift(binding.path), violations.filter((violation) => {
            const status = (violation = violation.resolve())._guessExecutionStatusRelativeTo(path);
            return functions && status === "unknown" && functions.push(violation), status === "before";
          });
        }
        function inferAnnotationFromBinaryExpression(name, path) {
          const operator = path.node.operator, right = path.get("right").resolve(), left = path.get("left").resolve();
          let target, typeofPath, typePath;
          if (left.isIdentifier({ name }) ? target = right : right.isIdentifier({ name }) && (target = left), target)
            return operator === "===" ? target.getTypeAnnotation() : BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0 ? numberTypeAnnotation() : void 0;
          if (operator !== "===" && operator !== "==")
            return;
          if (left.isUnaryExpression({ operator: "typeof" }) ? (typeofPath = left, typePath = right) : right.isUnaryExpression({ operator: "typeof" }) && (typeofPath = right, typePath = left), !typeofPath)
            return;
          if (!typeofPath.get("argument").isIdentifier({ name }))
            return;
          if (typePath = typePath.resolve(), !typePath.isLiteral())
            return;
          const typeValue = typePath.node.value;
          return typeof typeValue == "string" ? createTypeAnnotationBasedOnTypeof(typeValue) : void 0;
        }
        function getConditionalAnnotation(binding, path, name) {
          const ifStatement = function(binding2, path2, name2) {
            let parentPath;
            for (; parentPath = path2.parentPath; ) {
              if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
                if (path2.key === "test")
                  return;
                return parentPath;
              }
              if (parentPath.isFunction() && parentPath.parentPath.scope.getBinding(name2) !== binding2)
                return;
              path2 = parentPath;
            }
          }(binding, path, name);
          if (!ifStatement)
            return;
          const paths = [ifStatement.get("test")], types = [];
          for (let i = 0; i < paths.length; i++) {
            const path2 = paths[i];
            if (path2.isLogicalExpression())
              path2.node.operator === "&&" && (paths.push(path2.get("left")), paths.push(path2.get("right")));
            else if (path2.isBinaryExpression()) {
              const type = inferAnnotationFromBinaryExpression(name, path2);
              type && types.push(type);
            }
          }
          return types.length ? isTSTypeAnnotation(types[0]) && createTSUnionType ? { typeAnnotation: createTSUnionType(types), ifStatement } : createFlowUnionType ? { typeAnnotation: createFlowUnionType(types), ifStatement } : { typeAnnotation: createUnionTypeAnnotation(types), ifStatement } : getConditionalAnnotation(ifStatement, name);
        }
      }, "./node_modules/@babel/traverse/lib/path/inference/inferers.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.ArrayExpression = ArrayExpression, exports2.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, exports2.BinaryExpression = function(node) {
          const operator = node.operator;
          if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0)
            return numberTypeAnnotation();
          if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0)
            return booleanTypeAnnotation();
          if (operator === "+") {
            const right = this.get("right"), left = this.get("left");
            return left.isBaseType("number") && right.isBaseType("number") ? numberTypeAnnotation() : left.isBaseType("string") || right.isBaseType("string") ? stringTypeAnnotation() : unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
          }
        }, exports2.BooleanLiteral = function() {
          return booleanTypeAnnotation();
        }, exports2.CallExpression = function() {
          const { callee } = this.node;
          if (isObjectKeys(callee))
            return arrayTypeAnnotation(stringTypeAnnotation());
          if (isArrayFrom(callee) || isObjectValues(callee))
            return arrayTypeAnnotation(anyTypeAnnotation());
          if (isObjectEntries(callee))
            return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
          return resolveCall(this.get("callee"));
        }, exports2.ConditionalExpression = function() {
          const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType)
            return createTSUnionType(argumentTypes);
          if (createFlowUnionType)
            return createFlowUnionType(argumentTypes);
          return createUnionTypeAnnotation(argumentTypes);
        }, exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = function() {
          return genericTypeAnnotation(identifier("Function"));
        }, Object.defineProperty(exports2, "Identifier", { enumerable: true, get: function() {
          return _infererReference.default;
        } }), exports2.LogicalExpression = function() {
          const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType)
            return createTSUnionType(argumentTypes);
          if (createFlowUnionType)
            return createFlowUnionType(argumentTypes);
          return createUnionTypeAnnotation(argumentTypes);
        }, exports2.NewExpression = function(node) {
          if (this.get("callee").isIdentifier())
            return genericTypeAnnotation(node.callee);
        }, exports2.NullLiteral = function() {
          return nullLiteralTypeAnnotation();
        }, exports2.NumericLiteral = function() {
          return numberTypeAnnotation();
        }, exports2.ObjectExpression = function() {
          return genericTypeAnnotation(identifier("Object"));
        }, exports2.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, exports2.RegExpLiteral = function() {
          return genericTypeAnnotation(identifier("RegExp"));
        }, exports2.RestElement = RestElement, exports2.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, exports2.StringLiteral = function() {
          return stringTypeAnnotation();
        }, exports2.TaggedTemplateExpression = function() {
          return resolveCall(this.get("tag"));
        }, exports2.TemplateLiteral = function() {
          return stringTypeAnnotation();
        }, exports2.TypeCastExpression = TypeCastExpression, exports2.UnaryExpression = function(node) {
          const operator = node.operator;
          if (operator === "void")
            return voidTypeAnnotation();
          if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0)
            return numberTypeAnnotation();
          if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0)
            return stringTypeAnnotation();
          if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0)
            return booleanTypeAnnotation();
        }, exports2.UpdateExpression = function(node) {
          const operator = node.operator;
          if (operator === "++" || operator === "--")
            return numberTypeAnnotation();
        }, exports2.VariableDeclarator = function() {
          var _type;
          if (!this.get("id").isIdentifier())
            return;
          const init = this.get("init");
          let type = init.getTypeAnnotation();
          ((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation" && init.isCallExpression() && init.get("callee").isIdentifier({ name: "Array" }) && !init.scope.hasBinding("Array", true) && (type = ArrayExpression());
          return type;
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _infererReference = __webpack_require__2("./node_modules/@babel/traverse/lib/path/inference/inferer-reference.js");
        const { BOOLEAN_BINARY_OPERATORS, BOOLEAN_UNARY_OPERATORS, NUMBER_BINARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS, anyTypeAnnotation, arrayTypeAnnotation, booleanTypeAnnotation, buildMatchMemberExpression, createFlowUnionType, createTSUnionType, createUnionTypeAnnotation, genericTypeAnnotation, identifier, isTSTypeAnnotation, nullLiteralTypeAnnotation, numberTypeAnnotation, stringTypeAnnotation, tupleTypeAnnotation, unionTypeAnnotation, voidTypeAnnotation } = _t;
        function TypeCastExpression(node) {
          return node.typeAnnotation;
        }
        function ArrayExpression() {
          return genericTypeAnnotation(identifier("Array"));
        }
        function RestElement() {
          return ArrayExpression();
        }
        TypeCastExpression.validParent = true, RestElement.validParent = true;
        const isArrayFrom = buildMatchMemberExpression("Array.from"), isObjectKeys = buildMatchMemberExpression("Object.keys"), isObjectValues = buildMatchMemberExpression("Object.values"), isObjectEntries = buildMatchMemberExpression("Object.entries");
        function resolveCall(callee) {
          if ((callee = callee.resolve()).isFunction()) {
            if (callee.is("async"))
              return callee.is("generator") ? genericTypeAnnotation(identifier("AsyncIterator")) : genericTypeAnnotation(identifier("Promise"));
            if (callee.node.returnType)
              return callee.node.returnType;
          }
        }
      }, "./node_modules/@babel/traverse/lib/path/introspection.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._guessExecutionStatusRelativeTo = function(target) {
          const funcParent = { this: getOuterFunction(this), target: getOuterFunction(target) };
          if (funcParent.target.node !== funcParent.this.node)
            return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
          const paths = { target: target.getAncestry(), this: this.getAncestry() };
          if (paths.target.indexOf(this) >= 0)
            return "after";
          if (paths.this.indexOf(target) >= 0)
            return "before";
          let commonPath;
          const commonIndex = { target: 0, this: 0 };
          for (; !commonPath && commonIndex.this < paths.this.length; ) {
            const path = paths.this[commonIndex.this];
            commonIndex.target = paths.target.indexOf(path), commonIndex.target >= 0 ? commonPath = path : commonIndex.this++;
          }
          if (!commonPath)
            throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1))
            return "unknown";
          const divergence = { this: paths.this[commonIndex.this - 1], target: paths.target[commonIndex.target - 1] };
          if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container)
            return divergence.target.key > divergence.this.key ? "before" : "after";
          const keys = VISITOR_KEYS[commonPath.type], keyPosition = { this: keys.indexOf(divergence.this.parentKey), target: keys.indexOf(divergence.target.parentKey) };
          return keyPosition.target > keyPosition.this ? "before" : "after";
        }, exports2._guessExecutionStatusRelativeToDifferentFunctions = function(target) {
          if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration())
            return "unknown";
          const binding = target.scope.getBinding(target.node.id.name);
          if (!binding.references)
            return "before";
          const referencePaths = binding.referencePaths;
          let allStatus;
          for (const path of referencePaths) {
            if (!!path.find((path2) => path2.node === target.node))
              continue;
            if (path.key !== "callee" || !path.parentPath.isCallExpression())
              return "unknown";
            if (executionOrderCheckedNodes.has(path.node))
              continue;
            executionOrderCheckedNodes.add(path.node);
            const status = this._guessExecutionStatusRelativeTo(path);
            if (executionOrderCheckedNodes.delete(path.node), allStatus && allStatus !== status)
              return "unknown";
            allStatus = status;
          }
          return allStatus;
        }, exports2._resolve = function(dangerous, resolved) {
          if (resolved && resolved.indexOf(this) >= 0)
            return;
          if ((resolved = resolved || []).push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier())
              return this.get("init").resolve(dangerous, resolved);
          } else if (this.isReferencedIdentifier()) {
            const binding = this.scope.getBinding(this.node.name);
            if (!binding)
              return;
            if (!binding.constant)
              return;
            if (binding.kind === "module")
              return;
            if (binding.path !== this) {
              const ret = binding.path.resolve(dangerous, resolved);
              if (this.find((parent) => parent.node === ret.node))
                return;
              return ret;
            }
          } else {
            if (this.isTypeCastExpression())
              return this.get("expression").resolve(dangerous, resolved);
            if (dangerous && this.isMemberExpression()) {
              const targetKey = this.toComputedKey();
              if (!isLiteral(targetKey))
                return;
              const targetName = targetKey.value, target = this.get("object").resolve(dangerous, resolved);
              if (target.isObjectExpression()) {
                const props = target.get("properties");
                for (const prop of props) {
                  if (!prop.isProperty())
                    continue;
                  const key = prop.get("key");
                  let match = prop.isnt("computed") && key.isIdentifier({ name: targetName });
                  if (match = match || key.isLiteral({ value: targetName }), match)
                    return prop.get("value").resolve(dangerous, resolved);
                }
              } else if (target.isArrayExpression() && !isNaN(+targetName)) {
                const elem = target.get("elements")[targetName];
                if (elem)
                  return elem.resolve(dangerous, resolved);
              }
            }
          }
        }, exports2.canHaveVariableDeclarationOrExpression = function() {
          return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
        }, exports2.canSwapBetweenExpressionAndStatement = function(replacement) {
          if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression())
            return false;
          if (this.isExpression())
            return isBlockStatement(replacement);
          if (this.isBlockStatement())
            return isExpression(replacement);
          return false;
        }, exports2.equals = function(key, value) {
          return this.node[key] === value;
        }, exports2.getSource = function() {
          const node = this.node;
          if (node.end) {
            const code = this.hub.getCode();
            if (code)
              return code.slice(node.start, node.end);
          }
          return "";
        }, exports2.has = has, exports2.is = void 0, exports2.isCompletionRecord = function(allowInsideFunction) {
          let path = this, first = true;
          do {
            const container = path.container;
            if (path.isFunction() && !first)
              return !!allowInsideFunction;
            if (first = false, Array.isArray(container) && path.key !== container.length - 1)
              return false;
          } while ((path = path.parentPath) && !path.isProgram());
          return true;
        }, exports2.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const binding = this.scope.getBinding(this.node.name);
            return !!binding && binding.constant;
          }
          if (this.isLiteral())
            return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((expression) => expression.isConstantExpression()));
          if (this.isUnaryExpression())
            return this.node.operator === "void" && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression())
            return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          return false;
        }, exports2.isInStrictMode = function() {
          const start = this.isProgram() ? this : this.parentPath;
          return !!start.find((path) => {
            if (path.isProgram({ sourceType: "module" }))
              return true;
            if (path.isClass())
              return true;
            if (!path.isProgram() && !path.isFunction())
              return false;
            if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement())
              return false;
            const body = path.isFunction() ? path.node.body : path.node;
            for (const directive of body.directives)
              if (directive.value.value === "use strict")
                return true;
          });
        }, exports2.isNodeType = function(type) {
          return isType(this.type, type);
        }, exports2.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !isBlockStatement(this.container) && STATEMENT_OR_BLOCK_KEYS.includes(this.key);
        }, exports2.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, exports2.isnt = function(key) {
          return !this.has(key);
        }, exports2.matchesPattern = function(pattern, allowPartial) {
          return _matchesPattern(this.node, pattern, allowPartial);
        }, exports2.referencesImport = function(moduleSource, importName) {
          if (!this.isReferencedIdentifier()) {
            if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, { value: importName }) : this.node.property.name === importName)) {
              const object = this.get("object");
              return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
            }
            return false;
          }
          const binding = this.scope.getBinding(this.node.name);
          if (!binding || binding.kind !== "module")
            return false;
          const path = binding.path, parent = path.parentPath;
          if (!parent.isImportDeclaration())
            return false;
          if (parent.node.source.value !== moduleSource)
            return false;
          if (!importName)
            return true;
          if (path.isImportDefaultSpecifier() && importName === "default")
            return true;
          if (path.isImportNamespaceSpecifier() && importName === "*")
            return true;
          if (path.isImportSpecifier() && isIdentifier(path.node.imported, { name: importName }))
            return true;
          return false;
        }, exports2.resolve = function(dangerous, resolved) {
          return this._resolve(dangerous, resolved) || this;
        }, exports2.willIMaybeExecuteBefore = function(target) {
          return this._guessExecutionStatusRelativeTo(target) !== "after";
        };
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS, VISITOR_KEYS, isBlockStatement, isExpression, isIdentifier, isLiteral, isStringLiteral, isType, matchesPattern: _matchesPattern } = _t;
        function has(key) {
          const val = this.node && this.node[key];
          return val && Array.isArray(val) ? !!val.length : !!val;
        }
        const is = has;
        function getOuterFunction(path) {
          return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
        }
        function isExecutionUncertain(type, key) {
          switch (type) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return key === "right";
            case "ConditionalExpression":
            case "IfStatement":
              return key === "consequent" || key === "alternate";
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return key === "body";
            case "ForStatement":
              return key === "body" || key === "update";
            case "SwitchStatement":
              return key === "cases";
            case "TryStatement":
              return key === "handler";
            case "OptionalMemberExpression":
              return key === "property";
            case "OptionalCallExpression":
              return key === "arguments";
            default:
              return false;
          }
        }
        function isExecutionUncertainInList(paths, maxIndex) {
          for (let i = 0; i < maxIndex; i++) {
            const path = paths[i];
            if (isExecutionUncertain(path.parent.type, path.parentKey))
              return true;
          }
          return false;
        }
        exports2.is = is;
        const executionOrderCheckedNodes = /* @__PURE__ */ new WeakSet();
      }, "./node_modules/@babel/traverse/lib/path/lib/hoister.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _t2 = _t;
        const { react } = _t, { cloneNode, jsxExpressionContainer, variableDeclaration, variableDeclarator } = _t2, referenceVisitor = { ReferencedIdentifier(path, state) {
          if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression())
            return;
          if (path.node.name === "this") {
            let scope = path.scope;
            do {
              if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
                break;
            } while (scope = scope.parent);
            scope && state.breakOnScopePaths.push(scope.path);
          }
          const binding = path.scope.getBinding(path.node.name);
          if (binding) {
            for (const violation of binding.constantViolations)
              if (violation.scope !== binding.path.scope)
                return state.mutableBinding = true, void path.stop();
            binding === state.scope.getBinding(path.node.name) && (state.bindings[path.node.name] = binding);
          }
        } };
        exports2.default = class {
          constructor(path, scope) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = scope, this.path = path, this.attachAfter = false;
          }
          isCompatibleScope(scope) {
            for (const key of Object.keys(this.bindings)) {
              const binding = this.bindings[key];
              if (!scope.bindingIdentifierEquals(key, binding.identifier))
                return false;
            }
            return true;
          }
          getCompatibleScopes() {
            let scope = this.path.scope;
            do {
              if (!this.isCompatibleScope(scope))
                break;
              if (this.scopes.push(scope), this.breakOnScopePaths.indexOf(scope.path) >= 0)
                break;
            } while (scope = scope.parent);
          }
          getAttachmentPath() {
            let path = this._getAttachmentPath();
            if (!path)
              return;
            let targetScope = path.scope;
            if (targetScope.path === path && (targetScope = path.scope.parent), targetScope.path.isProgram() || targetScope.path.isFunction())
              for (const name of Object.keys(this.bindings)) {
                if (!targetScope.hasOwnBinding(name))
                  continue;
                const binding = this.bindings[name];
                if (binding.kind === "param" || binding.path.parentKey === "params")
                  continue;
                if (this.getAttachmentParentForPath(binding.path).key >= path.key) {
                  this.attachAfter = true, path = binding.path;
                  for (const violationPath of binding.constantViolations)
                    this.getAttachmentParentForPath(violationPath).key > path.key && (path = violationPath);
                }
              }
            return path;
          }
          _getAttachmentPath() {
            const scope = this.scopes.pop();
            if (scope) {
              if (scope.path.isFunction()) {
                if (!this.hasOwnParamBindings(scope))
                  return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === scope)
                    return;
                  const bodies = scope.path.get("body").get("body");
                  for (let i = 0; i < bodies.length; i++)
                    if (!bodies[i].node._blockHoist)
                      return bodies[i];
                }
              } else if (scope.path.isProgram())
                return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const scope = this.scopes.pop();
            if (scope)
              return this.getAttachmentParentForPath(scope.path);
          }
          getAttachmentParentForPath(path) {
            do {
              if (!path.parentPath || Array.isArray(path.container) && path.isStatement())
                return path;
            } while (path = path.parentPath);
          }
          hasOwnParamBindings(scope) {
            for (const name of Object.keys(this.bindings)) {
              if (!scope.hasOwnBinding(name))
                continue;
              const binding = this.bindings[name];
              if (binding.kind === "param" && binding.constant)
                return true;
            }
            return false;
          }
          run() {
            if (this.path.traverse(referenceVisitor, this), this.mutableBinding)
              return;
            this.getCompatibleScopes();
            const attachTo = this.getAttachmentPath();
            if (!attachTo)
              return;
            if (attachTo.getFunctionParent() === this.path.getFunctionParent())
              return;
            let uid = attachTo.scope.generateUidIdentifier("ref");
            const declarator = variableDeclarator(uid, this.path.node), insertFn = this.attachAfter ? "insertAfter" : "insertBefore", [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]), parent = this.path.parentPath;
            return parent.isJSXElement() && this.path.container === parent.node.children && (uid = jsxExpressionContainer(uid)), this.path.replaceWith(cloneNode(uid)), attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
          }
        };
      }, "./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.hooks = void 0;
        exports2.hooks = [function(self2, parent) {
          if (self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement())
            return parent.remove(), true;
        }, function(self2, parent) {
          if (parent.isSequenceExpression() && parent.node.expressions.length === 1)
            return parent.replaceWith(parent.node.expressions[0]), true;
        }, function(self2, parent) {
          if (parent.isBinary())
            return self2.key === "left" ? parent.replaceWith(parent.node.right) : parent.replaceWith(parent.node.left), true;
        }, function(self2, parent) {
          if (parent.isIfStatement() && (self2.key === "consequent" || self2.key === "alternate") || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression()))
            return self2.replaceWith({ type: "BlockStatement", body: [] }), true;
        }];
      }, "./node_modules/@babel/traverse/lib/path/lib/virtual-types.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.Var = exports2.User = exports2.Statement = exports2.SpreadProperty = exports2.Scope = exports2.RestProperty = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = exports2.Referenced = exports2.Pure = exports2.NumericLiteralTypeAnnotation = exports2.Generated = exports2.ForAwaitStatement = exports2.Flow = exports2.Expression = exports2.ExistentialTypeParam = exports2.BlockScoped = exports2.BindingIdentifier = void 0;
        var _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { isBinding, isBlockScoped, isExportDeclaration, isExpression, isFlow, isForStatement, isForXStatement, isIdentifier, isImportDeclaration, isImportSpecifier, isJSXIdentifier, isJSXMemberExpression, isMemberExpression, isReferenced, isScope, isStatement, isVar, isVariableDeclaration, react } = _t, { isCompatTag } = react, ReferencedIdentifier = { types: ["Identifier", "JSXIdentifier"], checkPath(path, opts) {
          const { node, parent } = path;
          if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
            if (!isJSXIdentifier(node, opts))
              return false;
            if (isCompatTag(node.name))
              return false;
          }
          return isReferenced(node, parent, path.parentPath.parent);
        } };
        exports2.ReferencedIdentifier = ReferencedIdentifier;
        const ReferencedMemberExpression = { types: ["MemberExpression"], checkPath: ({ node, parent }) => isMemberExpression(node) && isReferenced(node, parent) };
        exports2.ReferencedMemberExpression = ReferencedMemberExpression;
        const BindingIdentifier = { types: ["Identifier"], checkPath(path) {
          const { node, parent } = path, grandparent = path.parentPath.parent;
          return isIdentifier(node) && isBinding(node, parent, grandparent);
        } };
        exports2.BindingIdentifier = BindingIdentifier;
        const Statement = { types: ["Statement"], checkPath({ node, parent }) {
          if (isStatement(node)) {
            if (isVariableDeclaration(node)) {
              if (isForXStatement(parent, { left: node }))
                return false;
              if (isForStatement(parent, { init: node }))
                return false;
            }
            return true;
          }
          return false;
        } };
        exports2.Statement = Statement;
        const Expression = { types: ["Expression"], checkPath: (path) => path.isIdentifier() ? path.isReferencedIdentifier() : isExpression(path.node) };
        exports2.Expression = Expression;
        const Scope = { types: ["Scopable", "Pattern"], checkPath: (path) => isScope(path.node, path.parent) };
        exports2.Scope = Scope;
        const Referenced = { checkPath: (path) => isReferenced(path.node, path.parent) };
        exports2.Referenced = Referenced;
        const BlockScoped = { checkPath: (path) => isBlockScoped(path.node) };
        exports2.BlockScoped = BlockScoped;
        const Var = { types: ["VariableDeclaration"], checkPath: (path) => isVar(path.node) };
        exports2.Var = Var;
        const User = { checkPath: (path) => path.node && !!path.node.loc };
        exports2.User = User;
        const Generated = { checkPath: (path) => !path.isUser() };
        exports2.Generated = Generated;
        const Pure = { checkPath: (path, opts) => path.scope.isPure(path.node, opts) };
        exports2.Pure = Pure;
        const Flow = { types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], checkPath: ({ node }) => !!isFlow(node) || (isImportDeclaration(node) ? node.importKind === "type" || node.importKind === "typeof" : isExportDeclaration(node) ? node.exportKind === "type" : !!isImportSpecifier(node) && (node.importKind === "type" || node.importKind === "typeof")) };
        exports2.Flow = Flow;
        const RestProperty = { types: ["RestElement"], checkPath: (path) => path.parentPath && path.parentPath.isObjectPattern() };
        exports2.RestProperty = RestProperty;
        const SpreadProperty = { types: ["RestElement"], checkPath: (path) => path.parentPath && path.parentPath.isObjectExpression() };
        exports2.SpreadProperty = SpreadProperty;
        exports2.ExistentialTypeParam = { types: ["ExistsTypeAnnotation"] };
        exports2.NumericLiteralTypeAnnotation = { types: ["NumberLiteralTypeAnnotation"] };
        const ForAwaitStatement = { types: ["ForOfStatement"], checkPath: ({ node }) => node.await === true };
        exports2.ForAwaitStatement = ForAwaitStatement;
      }, "./node_modules/@babel/traverse/lib/path/modification.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._containerInsert = function(from, nodes) {
          this.updateSiblingKeys(from, nodes.length);
          const paths = [];
          this.container.splice(from, 0, ...nodes);
          for (let i = 0; i < nodes.length; i++) {
            const to = from + i, path = this.getSibling(to);
            paths.push(path), this.context && this.context.queue && path.pushContext(this.context);
          }
          const contexts = this._getQueueContexts();
          for (const path of paths) {
            path.setScope(), path.debug("Inserted.");
            for (const context of contexts)
              context.maybeQueue(path, true);
          }
          return paths;
        }, exports2._containerInsertAfter = function(nodes) {
          return this._containerInsert(this.key + 1, nodes);
        }, exports2._containerInsertBefore = function(nodes) {
          return this._containerInsert(this.key, nodes);
        }, exports2._verifyNodeList = function(nodes) {
          if (!nodes)
            return [];
          Array.isArray(nodes) || (nodes = [nodes]);
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            let msg;
            if (node ? typeof node != "object" ? msg = "contains a non-object node" : node.type ? node instanceof _index.default && (msg = "has a NodePath when it expected a raw object") : msg = "without a type" : msg = "has falsy node", msg) {
              const type = Array.isArray(node) ? "array" : typeof node;
              throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
            }
          }
          return nodes;
        }, exports2.hoist = function(scope = this.scope) {
          return new _hoister.default(this, scope).run();
        }, exports2.insertAfter = function(nodes_) {
          this._assertUnremoved();
          const nodes = this._verifyNodeList(nodes_), { parentPath } = this;
          if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            return parentPath.insertAfter(nodes.map((node) => isExpression(node) ? expressionStatement(node) : node));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
            if (this.node) {
              const node = this.node;
              let { scope } = this;
              if (scope.path.isPattern())
                return assertExpression(node), this.replaceWith(callExpression(arrowFunctionExpression([], node), [])), this.get("callee.body").insertAfter(nodes), [this];
              parentPath.isMethod({ computed: true, key: node }) && (scope = scope.parent);
              const temp = scope.generateDeclaredUidIdentifier();
              nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node))), nodes.push(expressionStatement(cloneNode(temp)));
            }
            return this.replaceExpressionWithStatements(nodes);
          }
          if (Array.isArray(this.container))
            return this._containerInsertAfter(nodes);
          if (this.isStatementOrBlock()) {
            const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
            return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : [])), this.pushContainer("body", nodes);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, exports2.insertBefore = function(nodes_) {
          this._assertUnremoved();
          const nodes = this._verifyNodeList(nodes_), { parentPath } = this;
          if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration())
            return parentPath.insertBefore(nodes);
          if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init")
            return this.node && nodes.push(this.node), this.replaceExpressionWithStatements(nodes);
          if (Array.isArray(this.container))
            return this._containerInsertBefore(nodes);
          if (this.isStatementOrBlock()) {
            const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
            return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : [])), this.unshiftContainer("body", nodes);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, exports2.pushContainer = function(listKey, nodes) {
          this._assertUnremoved();
          const verifiedNodes = this._verifyNodeList(nodes), container = this.node[listKey];
          return _index.default.get({ parentPath: this, parent: this.node, container, listKey, key: container.length }).setContext(this.context).replaceWithMultiple(verifiedNodes);
        }, exports2.unshiftContainer = function(listKey, nodes) {
          this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
          return _index.default.get({ parentPath: this, parent: this.node, container: this.node[listKey], listKey, key: 0 }).setContext(this.context)._containerInsertBefore(nodes);
        }, exports2.updateSiblingKeys = function(fromIndex, incrementBy) {
          if (!this.parent)
            return;
          const paths = _cache.path.get(this.parent);
          for (const [, path] of paths)
            path.key >= fromIndex && (path.key += incrementBy);
        };
        var _cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js"), _hoister = __webpack_require__2("./node_modules/@babel/traverse/lib/path/lib/hoister.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { arrowFunctionExpression, assertExpression, assignmentExpression, blockStatement, callExpression, cloneNode, expressionStatement, isExpression } = _t;
      }, "./node_modules/@babel/traverse/lib/path/removal.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._assertUnremoved = function() {
          if (this.removed)
            throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }, exports2._callRemovalHooks = function() {
          for (const fn of _removalHooks.hooks)
            if (fn(this, this.parentPath))
              return true;
        }, exports2._markRemoved = function() {
          this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED, this.parent && _cache.path.get(this.parent).delete(this.node);
          this.node = null;
        }, exports2._remove = function() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
        }, exports2._removeFromScope = function() {
          const bindings = this.getBindingIdentifiers();
          Object.keys(bindings).forEach((name) => this.scope.removeBinding(name));
        }, exports2.remove = function() {
          var _this$opts;
          this._assertUnremoved(), this.resync(), (_this$opts = this.opts) != null && _this$opts.noScope || this._removeFromScope();
          if (this._callRemovalHooks())
            return void this._markRemoved();
          this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
        };
        var _removalHooks = __webpack_require__2("./node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), _cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js");
      }, "./node_modules/@babel/traverse/lib/path/replacement.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2._replaceWith = function(node) {
          var _pathCache$get2;
          if (!this.container)
            throw new ReferenceError("Container is falsy");
          this.inList ? validate(this.parent, this.key, [node]) : validate(this.parent, this.key, node);
          this.debug(`Replace with ${node == null ? void 0 : node.type}`), (_pathCache$get2 = _cache.path.get(this.parent)) == null || _pathCache$get2.set(node, this).delete(this.node), this.node = this.container[this.key] = node;
        }, exports2.replaceExpressionWithStatements = function(nodes) {
          this.resync();
          const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
          if (nodesAsSequenceExpression)
            return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
          const functionParent = this.getFunctionParent(), isParentAsync = functionParent == null ? void 0 : functionParent.is("async"), isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator"), container = arrowFunctionExpression([], blockStatement(nodes));
          this.replaceWith(callExpression(container, []));
          const callee = this.get("callee");
          (0, _helperHoistVariables.default)(callee.get("body"), (id) => {
            this.scope.push({ id });
          }, "var");
          const completionRecords = this.get("callee").getCompletionRecords();
          for (const path of completionRecords) {
            if (!path.isExpressionStatement())
              continue;
            const loop = path.findParent((path2) => path2.isLoop());
            if (loop) {
              let uid = loop.getData("expressionReplacementReturnUid");
              uid ? uid = identifier(uid.name) : (uid = callee.scope.generateDeclaredUidIdentifier("ret"), callee.get("body").pushContainer("body", returnStatement(cloneNode(uid))), loop.setData("expressionReplacementReturnUid", uid)), path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
            } else
              path.replaceWith(returnStatement(path.node.expression));
          }
          callee.arrowFunctionToExpression();
          const newCallee = callee, needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES), needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
          needToAwaitFunction && (newCallee.set("async", true), needToYieldFunction || this.replaceWith(awaitExpression(this.node)));
          needToYieldFunction && (newCallee.set("generator", true), this.replaceWith(yieldExpression(this.node, true)));
          return newCallee.get("body.body");
        }, exports2.replaceInline = function(nodes) {
          if (this.resync(), Array.isArray(nodes)) {
            if (Array.isArray(this.container)) {
              nodes = this._verifyNodeList(nodes);
              const paths = this._containerInsertAfter(nodes);
              return this.remove(), paths;
            }
            return this.replaceWithMultiple(nodes);
          }
          return this.replaceWith(nodes);
        }, exports2.replaceWith = function(replacement) {
          if (this.resync(), this.removed)
            throw new Error("You can't replace this node, we've already removed it");
          replacement instanceof _index2.default && (replacement = replacement.node);
          if (!replacement)
            throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === replacement)
            return [this];
          if (this.isProgram() && !isProgram(replacement))
            throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(replacement))
            throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if (typeof replacement == "string")
            throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let nodePath = "";
          this.isNodeType("Statement") && isExpression(replacement) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(replacement) || this.parentPath.isExportDefaultDeclaration() || (replacement = expressionStatement(replacement), nodePath = "expression"));
          if (this.isNodeType("Expression") && isStatement(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement))
            return this.replaceExpressionWithStatements([replacement]);
          const oldNode = this.node;
          oldNode && (inheritsComments(replacement, oldNode), removeComments(oldNode));
          return this._replaceWith(replacement), this.type = replacement.type, this.setScope(), this.requeue(), [nodePath ? this.get(nodePath) : this];
        }, exports2.replaceWithMultiple = function(nodes) {
          var _pathCache$get;
          this.resync(), nodes = this._verifyNodeList(nodes), inheritLeadingComments(nodes[0], this.node), inheritTrailingComments(nodes[nodes.length - 1], this.node), (_pathCache$get = _cache.path.get(this.parent)) == null || _pathCache$get.delete(this.node), this.node = this.container[this.key] = null;
          const paths = this.insertAfter(nodes);
          this.node ? this.requeue() : this.remove();
          return paths;
        }, exports2.replaceWithSourceString = function(replacement) {
          this.resync();
          try {
            replacement = `(${replacement})`, replacement = (0, _parser.parse)(replacement);
          } catch (err) {
            const loc = err.loc;
            throw loc && (err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, { start: { line: loc.line, column: loc.column + 1 } }), err.code = "BABEL_REPLACE_SOURCE_ERROR"), err;
          }
          return replacement = replacement.program.body[0].expression, _index.default.removeProperties(replacement), this.replaceWith(replacement);
        };
        var _codeFrame = __webpack_require__2("./stubs/babel_codeframe.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _index2 = __webpack_require__2("./node_modules/@babel/traverse/lib/path/index.js"), _cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js"), _parser = __webpack_require__2("./node_modules/@babel/parser/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _helperHoistVariables = __webpack_require__2("./node_modules/@babel/helper-hoist-variables/lib/index.js");
        const { FUNCTION_TYPES, arrowFunctionExpression, assignmentExpression, awaitExpression, blockStatement, callExpression, cloneNode, expressionStatement, identifier, inheritLeadingComments, inheritTrailingComments, inheritsComments, isExpression, isProgram, isStatement, removeComments, returnStatement, toSequenceExpression, validate, yieldExpression } = _t;
      }, "./node_modules/@babel/traverse/lib/scope/binding.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        exports2.default = class {
          constructor({ identifier, scope, path, kind }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = identifier, this.scope = scope, this.path = path, this.kind = kind, this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = true;
          }
          setValue(value) {
            this.hasDeoptedValue || (this.hasValue = true, this.value = value);
          }
          clearValue() {
            this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
          }
          reassign(path) {
            this.constant = false, this.constantViolations.indexOf(path) === -1 && this.constantViolations.push(path);
          }
          reference(path) {
            this.referencePaths.indexOf(path) === -1 && (this.referenced = true, this.references++, this.referencePaths.push(path));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/@babel/traverse/lib/scope/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _renamer = __webpack_require__2("./node_modules/@babel/traverse/lib/scope/lib/renamer.js"), _index = __webpack_require__2("./node_modules/@babel/traverse/lib/index.js"), _binding = __webpack_require__2("./node_modules/@babel/traverse/lib/scope/binding.js"), _globals = __webpack_require__2("./node_modules/@babel/traverse/node_modules/globals/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js"), _cache = __webpack_require__2("./node_modules/@babel/traverse/lib/cache.js");
        const { NOT_LOCAL_BINDING, callExpression, cloneNode, getBindingIdentifiers, identifier, isArrayExpression, isBinary, isClass, isClassBody, isClassDeclaration, isExportAllDeclaration, isExportDefaultDeclaration, isExportNamedDeclaration, isFunctionDeclaration, isIdentifier, isImportDeclaration, isLiteral, isMethod, isModuleDeclaration, isModuleSpecifier, isObjectExpression, isProperty, isPureish, isSuper, isTaggedTemplateExpression, isTemplateLiteral, isThisExpression, isUnaryExpression, isVariableDeclaration, matchesPattern, memberExpression, numericLiteral, toIdentifier, unaryExpression, variableDeclaration, variableDeclarator } = _t;
        function gatherNodeParts(node, parts) {
          switch (node == null ? void 0 : node.type) {
            default:
              if (isModuleDeclaration(node))
                if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source)
                  gatherNodeParts(node.source, parts);
                else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length)
                  for (const e2 of node.specifiers)
                    gatherNodeParts(e2, parts);
                else
                  (isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration && gatherNodeParts(node.declaration, parts);
              else
                isModuleSpecifier(node) ? gatherNodeParts(node.local, parts) : isLiteral(node) && parts.push(node.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              gatherNodeParts(node.object, parts), gatherNodeParts(node.property, parts);
              break;
            case "Identifier":
            case "JSXIdentifier":
            case "JSXOpeningElement":
              parts.push(node.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              gatherNodeParts(node.callee, parts);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const e2 of node.properties)
                gatherNodeParts(e2, parts);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              gatherNodeParts(node.argument, parts);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              gatherNodeParts(node.key, parts);
              break;
            case "ThisExpression":
              parts.push("this");
              break;
            case "Super":
              parts.push("super");
              break;
            case "Import":
              parts.push("import");
              break;
            case "DoExpression":
              parts.push("do");
              break;
            case "YieldExpression":
              parts.push("yield"), gatherNodeParts(node.argument, parts);
              break;
            case "AwaitExpression":
              parts.push("await"), gatherNodeParts(node.argument, parts);
              break;
            case "AssignmentExpression":
              gatherNodeParts(node.left, parts);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              gatherNodeParts(node.id, parts);
              break;
            case "ParenthesizedExpression":
              gatherNodeParts(node.expression, parts);
              break;
            case "MetaProperty":
              gatherNodeParts(node.meta, parts), gatherNodeParts(node.property, parts);
              break;
            case "JSXElement":
              gatherNodeParts(node.openingElement, parts);
              break;
            case "JSXFragment":
              gatherNodeParts(node.openingFragment, parts);
              break;
            case "JSXOpeningFragment":
              parts.push("Fragment");
              break;
            case "JSXNamespacedName":
              gatherNodeParts(node.namespace, parts), gatherNodeParts(node.name, parts);
          }
        }
        const collectorVisitor = { ForStatement(path) {
          const declar = path.get("init");
          if (declar.isVar()) {
            const { scope } = path;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", declar);
          }
        }, Declaration(path) {
          if (path.isBlockScoped())
            return;
          if (path.isImportDeclaration())
            return;
          if (path.isExportDeclaration())
            return;
          (path.scope.getFunctionParent() || path.scope.getProgramParent()).registerDeclaration(path);
        }, ImportDeclaration(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        }, ReferencedIdentifier(path, state) {
          state.references.push(path);
        }, ForXStatement(path, state) {
          const left = path.get("left");
          if (left.isPattern() || left.isIdentifier())
            state.constantViolations.push(path);
          else if (left.isVar()) {
            const { scope } = path;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", left);
          }
        }, ExportDeclaration: { exit(path) {
          const { node, scope } = path;
          if (isExportAllDeclaration(node))
            return;
          const declar = node.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id = declar.id;
            if (!id)
              return;
            const binding = scope.getBinding(id.name);
            binding == null || binding.reference(path);
          } else if (isVariableDeclaration(declar))
            for (const decl of declar.declarations)
              for (const name of Object.keys(getBindingIdentifiers(decl))) {
                const binding = scope.getBinding(name);
                binding == null || binding.reference(path);
              }
        } }, LabeledStatement(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        }, AssignmentExpression(path, state) {
          state.assignments.push(path);
        }, UpdateExpression(path, state) {
          state.constantViolations.push(path);
        }, UnaryExpression(path, state) {
          path.node.operator === "delete" && state.constantViolations.push(path);
        }, BlockScoped(path) {
          let scope = path.scope;
          scope.path === path && (scope = scope.parent);
          if (scope.getBlockParent().registerDeclaration(path), path.isClassDeclaration() && path.node.id) {
            const name = path.node.id.name;
            path.scope.bindings[name] = path.scope.parent.getBinding(name);
          }
        }, CatchClause(path) {
          path.scope.registerBinding("let", path);
        }, Function(path) {
          const params = path.get("params");
          for (const param of params)
            path.scope.registerBinding("param", param);
          path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path.get("id"), path);
        }, ClassExpression(path) {
          path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path);
        } };
        let uid = 0;
        class Scope {
          constructor(path) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node } = path, cached = _cache.scope.get(node);
            if ((cached == null ? void 0 : cached.path) === path)
              return cached;
            _cache.scope.set(node, this), this.uid = uid++, this.block = node, this.path = path, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
          }
          get parent() {
            var _parent;
            let parent, path = this.path;
            do {
              const isKey = path.key === "key";
              path = path.parentPath, isKey && path.isMethod() && (path = path.parentPath), path && path.isScope() && (parent = path);
            } while (path && !parent);
            return (_parent = parent) == null ? void 0 : _parent.scope;
          }
          get parentBlock() {
            return this.path.parent;
          }
          get hub() {
            return this.path.hub;
          }
          traverse(node, opts, state) {
            (0, _index.default)(node, opts, this, state, this.path);
          }
          generateDeclaredUidIdentifier(name) {
            const id = this.generateUidIdentifier(name);
            return this.push({ id }), cloneNode(id);
          }
          generateUidIdentifier(name) {
            return identifier(this.generateUid(name));
          }
          generateUid(name = "temp") {
            let uid2;
            name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            let i = 1;
            do {
              uid2 = this._generateUid(name, i), i++;
            } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
            const program = this.getProgramParent();
            return program.references[uid2] = true, program.uids[uid2] = true, uid2;
          }
          _generateUid(name, i) {
            let id = name;
            return i > 1 && (id += i), `_${id}`;
          }
          generateUidBasedOnNode(node, defaultName) {
            const parts = [];
            gatherNodeParts(node, parts);
            let id = parts.join("$");
            return id = id.replace(/^_/, "") || defaultName || "ref", this.generateUid(id.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(node, defaultName) {
            return identifier(this.generateUidBasedOnNode(node, defaultName));
          }
          isStatic(node) {
            if (isThisExpression(node) || isSuper(node))
              return true;
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              return binding ? binding.constant : this.hasBinding(node.name);
            }
            return false;
          }
          maybeGenerateMemoised(node, dontPush) {
            if (this.isStatic(node))
              return null;
            {
              const id = this.generateUidIdentifierBasedOnNode(node);
              return dontPush ? id : (this.push({ id }), cloneNode(id));
            }
          }
          checkBlockScopedCollisions(local, kind, name, id) {
            if (kind === "param")
              return;
            if (local.kind === "local")
              return;
            if (kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const")
              throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
          }
          rename(oldName, newName, block) {
            const binding = this.getBinding(oldName);
            if (binding)
              return newName = newName || this.generateUidIdentifier(oldName).name, new _renamer.default(binding, oldName, newName).rename(block);
          }
          _renameFromMap(map, oldName, newName, value) {
            map[oldName] && (map[newName] = value, map[oldName] = null);
          }
          dump() {
            const sep = "-".repeat(60);
            console.log(sep);
            let scope = this;
            do {
              console.log("#", scope.block.type);
              for (const name of Object.keys(scope.bindings)) {
                const binding = scope.bindings[name];
                console.log(" -", name, { constant: binding.constant, references: binding.references, violations: binding.constantViolations.length, kind: binding.kind });
              }
            } while (scope = scope.parent);
            console.log(sep);
          }
          toArray(node, i, arrayLikeIsIterable) {
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              if (binding != null && binding.constant && binding.path.isGenericType("Array"))
                return node;
            }
            if (isArrayExpression(node))
              return node;
            if (isIdentifier(node, { name: "arguments" }))
              return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
            let helperName;
            const args = [node];
            return i === true ? helperName = "toConsumableArray" : i ? (args.push(numericLiteral(i)), helperName = "slicedToArray") : helperName = "toArray", arrayLikeIsIterable && (args.unshift(this.hub.addHelper(helperName)), helperName = "maybeArrayLike"), callExpression(this.hub.addHelper(helperName), args);
          }
          hasLabel(name) {
            return !!this.getLabel(name);
          }
          getLabel(name) {
            return this.labels.get(name);
          }
          registerLabel(path) {
            this.labels.set(path.node.label.name, path);
          }
          registerDeclaration(path) {
            if (path.isLabeledStatement())
              this.registerLabel(path);
            else if (path.isFunctionDeclaration())
              this.registerBinding("hoisted", path.get("id"), path);
            else if (path.isVariableDeclaration()) {
              const declarations = path.get("declarations");
              for (const declar of declarations)
                this.registerBinding(path.node.kind, declar);
            } else if (path.isClassDeclaration()) {
              if (path.node.declare)
                return;
              this.registerBinding("let", path);
            } else if (path.isImportDeclaration()) {
              const specifiers = path.get("specifiers");
              for (const specifier of specifiers)
                this.registerBinding("module", specifier);
            } else if (path.isExportDeclaration()) {
              const declar = path.get("declaration");
              (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) && this.registerDeclaration(declar);
            } else
              this.registerBinding("unknown", path);
          }
          buildUndefinedNode() {
            return unaryExpression("void", numericLiteral(0), true);
          }
          registerConstantViolation(path) {
            const ids = path.getBindingIdentifiers();
            for (const name of Object.keys(ids)) {
              const binding = this.getBinding(name);
              binding && binding.reassign(path);
            }
          }
          registerBinding(kind, path, bindingPath = path) {
            if (!kind)
              throw new ReferenceError("no `kind`");
            if (path.isVariableDeclaration()) {
              const declarators = path.get("declarations");
              for (const declar of declarators)
                this.registerBinding(kind, declar);
              return;
            }
            const parent = this.getProgramParent(), ids = path.getOuterBindingIdentifiers(true);
            for (const name of Object.keys(ids)) {
              parent.references[name] = true;
              for (const id of ids[name]) {
                const local = this.getOwnBinding(name);
                if (local) {
                  if (local.identifier === id)
                    continue;
                  this.checkBlockScopedCollisions(local, kind, name, id);
                }
                local ? this.registerConstantViolation(bindingPath) : this.bindings[name] = new _binding.default({ identifier: id, scope: this, path: bindingPath, kind });
              }
            }
          }
          addGlobal(node) {
            this.globals[node.name] = node;
          }
          hasUid(name) {
            let scope = this;
            do {
              if (scope.uids[name])
                return true;
            } while (scope = scope.parent);
            return false;
          }
          hasGlobal(name) {
            let scope = this;
            do {
              if (scope.globals[name])
                return true;
            } while (scope = scope.parent);
            return false;
          }
          hasReference(name) {
            return !!this.getProgramParent().references[name];
          }
          isPure(node, constantsOnly) {
            if (isIdentifier(node)) {
              const binding = this.getBinding(node.name);
              return !!binding && (!constantsOnly || binding.constant);
            }
            if (isClass(node))
              return !(node.superClass && !this.isPure(node.superClass, constantsOnly)) && this.isPure(node.body, constantsOnly);
            if (isClassBody(node)) {
              for (const method of node.body)
                if (!this.isPure(method, constantsOnly))
                  return false;
              return true;
            }
            if (isBinary(node))
              return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
            if (isArrayExpression(node)) {
              for (const elem of node.elements)
                if (!this.isPure(elem, constantsOnly))
                  return false;
              return true;
            }
            if (isObjectExpression(node)) {
              for (const prop of node.properties)
                if (!this.isPure(prop, constantsOnly))
                  return false;
              return true;
            }
            if (isMethod(node))
              return !(node.computed && !this.isPure(node.key, constantsOnly)) && (node.kind !== "get" && node.kind !== "set");
            if (isProperty(node))
              return !(node.computed && !this.isPure(node.key, constantsOnly)) && this.isPure(node.value, constantsOnly);
            if (isUnaryExpression(node))
              return this.isPure(node.argument, constantsOnly);
            if (isTaggedTemplateExpression(node))
              return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
            if (isTemplateLiteral(node)) {
              for (const expression of node.expressions)
                if (!this.isPure(expression, constantsOnly))
                  return false;
              return true;
            }
            return isPureish(node);
          }
          setData(key, val) {
            return this.data[key] = val;
          }
          getData(key) {
            let scope = this;
            do {
              const data = scope.data[key];
              if (data != null)
                return data;
            } while (scope = scope.parent);
          }
          removeData(key) {
            let scope = this;
            do {
              scope.data[key] != null && (scope.data[key] = null);
            } while (scope = scope.parent);
          }
          init() {
            this.inited || (this.inited = true, this.crawl());
          }
          crawl() {
            const path = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            const programParent = this.getProgramParent();
            if (programParent.crawling)
              return;
            const state = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = true, path.type !== "Program" && collectorVisitor._exploded) {
              for (const visit of collectorVisitor.enter)
                visit(path, state);
              const typeVisitors = collectorVisitor[path.type];
              if (typeVisitors)
                for (const visit of typeVisitors.enter)
                  visit(path, state);
            }
            path.traverse(collectorVisitor, state), this.crawling = false;
            for (const path2 of state.assignments) {
              const ids = path2.getBindingIdentifiers();
              for (const name of Object.keys(ids))
                path2.scope.getBinding(name) || programParent.addGlobal(ids[name]);
              path2.scope.registerConstantViolation(path2);
            }
            for (const ref of state.references) {
              const binding = ref.scope.getBinding(ref.node.name);
              binding ? binding.reference(ref) : programParent.addGlobal(ref.node);
            }
            for (const path2 of state.constantViolations)
              path2.scope.registerConstantViolation(path2);
          }
          push(opts) {
            let path = this.path;
            path.isBlockStatement() || path.isProgram() || (path = this.getBlockParent().path), path.isSwitchStatement() && (path = (this.getFunctionParent() || this.getProgramParent()).path), (path.isLoop() || path.isCatchClause() || path.isFunction()) && (path.ensureBlock(), path = path.get("body"));
            const unique = opts.unique, kind = opts.kind || "var", blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist, dataKey = `declaration:${kind}:${blockHoist}`;
            let declarPath = !unique && path.getData(dataKey);
            if (!declarPath) {
              const declar = variableDeclaration(kind, []);
              declar._blockHoist = blockHoist, [declarPath] = path.unshiftContainer("body", [declar]), unique || path.setData(dataKey, declarPath);
            }
            const declarator = variableDeclarator(opts.id, opts.init);
            declarPath.node.declarations.push(declarator), this.registerBinding(kind, declarPath.get("declarations").pop());
          }
          getProgramParent() {
            let scope = this;
            do {
              if (scope.path.isProgram())
                return scope;
            } while (scope = scope.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let scope = this;
            do {
              if (scope.path.isFunctionParent())
                return scope;
            } while (scope = scope.parent);
            return null;
          }
          getBlockParent() {
            let scope = this;
            do {
              if (scope.path.isBlockParent())
                return scope;
            } while (scope = scope.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const ids = /* @__PURE__ */ Object.create(null);
            let scope = this;
            do {
              for (const key of Object.keys(scope.bindings))
                key in ids == false && (ids[key] = scope.bindings[key]);
              scope = scope.parent;
            } while (scope);
            return ids;
          }
          getAllBindingsOfKind(...kinds) {
            const ids = /* @__PURE__ */ Object.create(null);
            for (const kind of kinds) {
              let scope = this;
              do {
                for (const name of Object.keys(scope.bindings)) {
                  const binding = scope.bindings[name];
                  binding.kind === kind && (ids[name] = binding);
                }
                scope = scope.parent;
              } while (scope);
            }
            return ids;
          }
          bindingIdentifierEquals(name, node) {
            return this.getBindingIdentifier(name) === node;
          }
          getBinding(name) {
            let previousPath, scope = this;
            do {
              const binding = scope.getOwnBinding(name);
              var _previousPath;
              if (binding) {
                if ((_previousPath = previousPath) == null || !_previousPath.isPattern() || binding.kind === "param" || binding.kind === "local")
                  return binding;
              } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
                break;
              previousPath = scope.path;
            } while (scope = scope.parent);
          }
          getOwnBinding(name) {
            return this.bindings[name];
          }
          getBindingIdentifier(name) {
            var _this$getBinding;
            return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
          }
          getOwnBindingIdentifier(name) {
            const binding = this.bindings[name];
            return binding == null ? void 0 : binding.identifier;
          }
          hasOwnBinding(name) {
            return !!this.getOwnBinding(name);
          }
          hasBinding(name, noGlobals) {
            return !!name && (!!this.hasOwnBinding(name) || (!!this.parentHasBinding(name, noGlobals) || (!!this.hasUid(name) || (!(noGlobals || !Scope.globals.includes(name)) || !(noGlobals || !Scope.contextVariables.includes(name))))));
          }
          parentHasBinding(name, noGlobals) {
            var _this$parent;
            return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
          }
          moveBindingTo(name, scope) {
            const info = this.getBinding(name);
            info && (info.scope.removeOwnBinding(name), info.scope = scope, scope.bindings[name] = info);
          }
          removeOwnBinding(name) {
            delete this.bindings[name];
          }
          removeBinding(name) {
            var _this$getBinding2;
            (_this$getBinding2 = this.getBinding(name)) == null || _this$getBinding2.scope.removeOwnBinding(name);
            let scope = this;
            do {
              scope.uids[name] && (scope.uids[name] = false);
            } while (scope = scope.parent);
          }
        }
        exports2.default = Scope, Scope.globals = Object.keys(_globals.builtin), Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
      }, "./node_modules/@babel/traverse/lib/scope/lib/renamer.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        __webpack_require__2("./node_modules/@babel/traverse/lib/scope/binding.js");
        var _helperSplitExportDeclaration = __webpack_require__2("./node_modules/@babel/helper-split-export-declaration/lib/index.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS, assignmentExpression, identifier, toExpression, variableDeclaration, variableDeclarator } = _t, renameVisitor = { ReferencedIdentifier({ node }, state) {
          node.name === state.oldName && (node.name = state.newName);
        }, Scope(path, state) {
          path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier) || function(path2) {
            if (!path2.isMethod() || !path2.node.computed)
              return void path2.skip();
            const keys = VISITOR_KEYS[path2.type];
            for (const key of keys)
              key !== "key" && path2.skipKey(key);
          }(path);
        }, "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
          if (path.isVariableDeclaration())
            return;
          const ids = path.getOuterBindingIdentifiers();
          for (const name in ids)
            name === state.oldName && (ids[name].name = state.newName);
        } };
        exports2.default = class {
          constructor(binding, oldName, newName) {
            this.newName = newName, this.oldName = oldName, this.binding = binding;
          }
          maybeConvertFromExportDeclaration(parentDeclar) {
            const maybeExportDeclar = parentDeclar.parentPath;
            maybeExportDeclar.isExportDeclaration() && (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id || (0, _helperSplitExportDeclaration.default)(maybeExportDeclar));
          }
          maybeConvertFromClassFunctionDeclaration(path) {
          }
          maybeConvertFromClassFunctionExpression(path) {
          }
          rename(block) {
            const { binding, oldName, newName } = this, { scope, path } = binding, parentDeclar = path.find((path2) => path2.isDeclaration() || path2.isFunctionExpression() || path2.isClassExpression());
            if (parentDeclar) {
              parentDeclar.getOuterBindingIdentifiers()[oldName] === binding.identifier && this.maybeConvertFromExportDeclaration(parentDeclar);
            }
            const blockToTraverse = block || scope.block;
            (blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement" ? blockToTraverse.cases.forEach((c) => {
              scope.traverse(c, renameVisitor, this);
            }) : scope.traverse(blockToTraverse, renameVisitor, this), block || (scope.removeOwnBinding(oldName), scope.bindings[newName] = binding, this.binding.identifier.name = newName), parentDeclar && (this.maybeConvertFromClassFunctionDeclaration(parentDeclar), this.maybeConvertFromClassFunctionExpression(parentDeclar));
          }
        };
      }, "./node_modules/@babel/traverse/lib/traverse-node.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.traverseNode = function(node, opts, scope, state, path, skipKeys) {
          const keys = VISITOR_KEYS[node.type];
          if (!keys)
            return false;
          const context = new _context.default(scope, opts, state, path);
          for (const key of keys)
            if ((!skipKeys || !skipKeys[key]) && context.visit(node, key))
              return true;
          return false;
        };
        var _context = __webpack_require__2("./node_modules/@babel/traverse/lib/context.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS } = _t;
      }, "./node_modules/@babel/traverse/lib/visitors.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.explode = explode, exports2.merge = function(visitors, states = [], wrapper) {
          const rootVisitor = {};
          for (let i = 0; i < visitors.length; i++) {
            const visitor = visitors[i], state = states[i];
            explode(visitor);
            for (const type of Object.keys(visitor)) {
              let visitorType = visitor[type];
              (state || wrapper) && (visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper));
              mergePair(rootVisitor[type] = rootVisitor[type] || {}, visitorType);
            }
          }
          return rootVisitor;
        }, exports2.verify = verify;
        var virtualTypes = __webpack_require__2("./node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), _t = __webpack_require__2("./node_modules/@babel/types/lib/index.js");
        const { DEPRECATED_KEYS, FLIPPED_ALIAS_KEYS, TYPES } = _t;
        function explode(visitor) {
          if (visitor._exploded)
            return visitor;
          visitor._exploded = true;
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            const parts = nodeType.split("|");
            if (parts.length === 1)
              continue;
            const fns = visitor[nodeType];
            delete visitor[nodeType];
            for (const part of parts)
              visitor[part] = fns;
          }
          verify(visitor), delete visitor.__esModule, function(obj) {
            for (const key of Object.keys(obj)) {
              if (shouldIgnoreKey(key))
                continue;
              const fns = obj[key];
              typeof fns == "function" && (obj[key] = { enter: fns });
            }
          }(visitor), ensureCallbackArrays(visitor);
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            const wrapper = virtualTypes[nodeType];
            if (!wrapper)
              continue;
            const fns = visitor[nodeType];
            for (const type of Object.keys(fns))
              fns[type] = wrapCheck(wrapper, fns[type]);
            if (delete visitor[nodeType], wrapper.types)
              for (const type of wrapper.types)
                visitor[type] ? mergePair(visitor[type], fns) : visitor[type] = fns;
            else
              mergePair(visitor, fns);
          }
          for (const nodeType of Object.keys(visitor)) {
            if (shouldIgnoreKey(nodeType))
              continue;
            const fns = visitor[nodeType];
            let aliases = FLIPPED_ALIAS_KEYS[nodeType];
            const deprecatedKey = DEPRECATED_KEYS[nodeType];
            if (deprecatedKey && (console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`), aliases = [deprecatedKey]), aliases) {
              delete visitor[nodeType];
              for (const alias of aliases) {
                const existing = visitor[alias];
                existing ? mergePair(existing, fns) : visitor[alias] = Object.assign({}, fns);
              }
            }
          }
          for (const nodeType of Object.keys(visitor))
            shouldIgnoreKey(nodeType) || ensureCallbackArrays(visitor[nodeType]);
          return visitor;
        }
        function verify(visitor) {
          if (!visitor._verified) {
            if (typeof visitor == "function")
              throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const nodeType of Object.keys(visitor)) {
              if (nodeType !== "enter" && nodeType !== "exit" || validateVisitorMethods(nodeType, visitor[nodeType]), shouldIgnoreKey(nodeType))
                continue;
              if (TYPES.indexOf(nodeType) < 0)
                throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
              const visitors = visitor[nodeType];
              if (typeof visitors == "object")
                for (const visitorKey of Object.keys(visitors)) {
                  if (visitorKey !== "enter" && visitorKey !== "exit")
                    throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
                  validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
                }
            }
            visitor._verified = true;
          }
        }
        function validateVisitorMethods(path, val) {
          const fns = [].concat(val);
          for (const fn of fns)
            if (typeof fn != "function")
              throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
        }
        function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
          const newVisitor = {};
          for (const key of Object.keys(oldVisitor)) {
            let fns = oldVisitor[key];
            Array.isArray(fns) && (fns = fns.map(function(fn) {
              let newFn = fn;
              return state && (newFn = function(path) {
                return fn.call(state, path, state);
              }), wrapper && (newFn = wrapper(state.key, key, newFn)), newFn !== fn && (newFn.toString = () => fn.toString()), newFn;
            }), newVisitor[key] = fns);
          }
          return newVisitor;
        }
        function ensureCallbackArrays(obj) {
          obj.enter && !Array.isArray(obj.enter) && (obj.enter = [obj.enter]), obj.exit && !Array.isArray(obj.exit) && (obj.exit = [obj.exit]);
        }
        function wrapCheck(wrapper, fn) {
          const newFn = function(path) {
            if (wrapper.checkPath(path))
              return fn.apply(this, arguments);
          };
          return newFn.toString = () => fn.toString(), newFn;
        }
        function shouldIgnoreKey(key) {
          return key[0] === "_" || (key === "enter" || key === "exit" || key === "shouldSkip" || (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist"));
        }
        function mergePair(dest, src) {
          for (const key of Object.keys(src))
            dest[key] = [].concat(dest[key] || [], src[key]);
        }
      }, "./node_modules/@babel/traverse/node_modules/globals/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        module3.exports = __webpack_require__2("./node_modules/@babel/traverse/node_modules/globals/globals.json");
      }, "./node_modules/@babel/types/lib/asserts/assertNode.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          if (!(0, _isNode.default)(node)) {
            var _node$type;
            const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
            throw new TypeError(`Not a valid node of type "${type}"`);
          }
        };
        var _isNode = __webpack_require__2("./node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/@babel/types/lib/asserts/generated/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.assertAnyTypeAnnotation = function(node, opts) {
          assert("AnyTypeAnnotation", node, opts);
        }, exports2.assertArgumentPlaceholder = function(node, opts) {
          assert("ArgumentPlaceholder", node, opts);
        }, exports2.assertArrayExpression = function(node, opts) {
          assert("ArrayExpression", node, opts);
        }, exports2.assertArrayPattern = function(node, opts) {
          assert("ArrayPattern", node, opts);
        }, exports2.assertArrayTypeAnnotation = function(node, opts) {
          assert("ArrayTypeAnnotation", node, opts);
        }, exports2.assertArrowFunctionExpression = function(node, opts) {
          assert("ArrowFunctionExpression", node, opts);
        }, exports2.assertAssignmentExpression = function(node, opts) {
          assert("AssignmentExpression", node, opts);
        }, exports2.assertAssignmentPattern = function(node, opts) {
          assert("AssignmentPattern", node, opts);
        }, exports2.assertAwaitExpression = function(node, opts) {
          assert("AwaitExpression", node, opts);
        }, exports2.assertBigIntLiteral = function(node, opts) {
          assert("BigIntLiteral", node, opts);
        }, exports2.assertBinary = function(node, opts) {
          assert("Binary", node, opts);
        }, exports2.assertBinaryExpression = function(node, opts) {
          assert("BinaryExpression", node, opts);
        }, exports2.assertBindExpression = function(node, opts) {
          assert("BindExpression", node, opts);
        }, exports2.assertBlock = function(node, opts) {
          assert("Block", node, opts);
        }, exports2.assertBlockParent = function(node, opts) {
          assert("BlockParent", node, opts);
        }, exports2.assertBlockStatement = function(node, opts) {
          assert("BlockStatement", node, opts);
        }, exports2.assertBooleanLiteral = function(node, opts) {
          assert("BooleanLiteral", node, opts);
        }, exports2.assertBooleanLiteralTypeAnnotation = function(node, opts) {
          assert("BooleanLiteralTypeAnnotation", node, opts);
        }, exports2.assertBooleanTypeAnnotation = function(node, opts) {
          assert("BooleanTypeAnnotation", node, opts);
        }, exports2.assertBreakStatement = function(node, opts) {
          assert("BreakStatement", node, opts);
        }, exports2.assertCallExpression = function(node, opts) {
          assert("CallExpression", node, opts);
        }, exports2.assertCatchClause = function(node, opts) {
          assert("CatchClause", node, opts);
        }, exports2.assertClass = function(node, opts) {
          assert("Class", node, opts);
        }, exports2.assertClassBody = function(node, opts) {
          assert("ClassBody", node, opts);
        }, exports2.assertClassDeclaration = function(node, opts) {
          assert("ClassDeclaration", node, opts);
        }, exports2.assertClassExpression = function(node, opts) {
          assert("ClassExpression", node, opts);
        }, exports2.assertClassImplements = function(node, opts) {
          assert("ClassImplements", node, opts);
        }, exports2.assertClassMethod = function(node, opts) {
          assert("ClassMethod", node, opts);
        }, exports2.assertClassPrivateMethod = function(node, opts) {
          assert("ClassPrivateMethod", node, opts);
        }, exports2.assertClassPrivateProperty = function(node, opts) {
          assert("ClassPrivateProperty", node, opts);
        }, exports2.assertClassProperty = function(node, opts) {
          assert("ClassProperty", node, opts);
        }, exports2.assertCompletionStatement = function(node, opts) {
          assert("CompletionStatement", node, opts);
        }, exports2.assertConditional = function(node, opts) {
          assert("Conditional", node, opts);
        }, exports2.assertConditionalExpression = function(node, opts) {
          assert("ConditionalExpression", node, opts);
        }, exports2.assertContinueStatement = function(node, opts) {
          assert("ContinueStatement", node, opts);
        }, exports2.assertDebuggerStatement = function(node, opts) {
          assert("DebuggerStatement", node, opts);
        }, exports2.assertDecimalLiteral = function(node, opts) {
          assert("DecimalLiteral", node, opts);
        }, exports2.assertDeclaration = function(node, opts) {
          assert("Declaration", node, opts);
        }, exports2.assertDeclareClass = function(node, opts) {
          assert("DeclareClass", node, opts);
        }, exports2.assertDeclareExportAllDeclaration = function(node, opts) {
          assert("DeclareExportAllDeclaration", node, opts);
        }, exports2.assertDeclareExportDeclaration = function(node, opts) {
          assert("DeclareExportDeclaration", node, opts);
        }, exports2.assertDeclareFunction = function(node, opts) {
          assert("DeclareFunction", node, opts);
        }, exports2.assertDeclareInterface = function(node, opts) {
          assert("DeclareInterface", node, opts);
        }, exports2.assertDeclareModule = function(node, opts) {
          assert("DeclareModule", node, opts);
        }, exports2.assertDeclareModuleExports = function(node, opts) {
          assert("DeclareModuleExports", node, opts);
        }, exports2.assertDeclareOpaqueType = function(node, opts) {
          assert("DeclareOpaqueType", node, opts);
        }, exports2.assertDeclareTypeAlias = function(node, opts) {
          assert("DeclareTypeAlias", node, opts);
        }, exports2.assertDeclareVariable = function(node, opts) {
          assert("DeclareVariable", node, opts);
        }, exports2.assertDeclaredPredicate = function(node, opts) {
          assert("DeclaredPredicate", node, opts);
        }, exports2.assertDecorator = function(node, opts) {
          assert("Decorator", node, opts);
        }, exports2.assertDirective = function(node, opts) {
          assert("Directive", node, opts);
        }, exports2.assertDirectiveLiteral = function(node, opts) {
          assert("DirectiveLiteral", node, opts);
        }, exports2.assertDoExpression = function(node, opts) {
          assert("DoExpression", node, opts);
        }, exports2.assertDoWhileStatement = function(node, opts) {
          assert("DoWhileStatement", node, opts);
        }, exports2.assertEmptyStatement = function(node, opts) {
          assert("EmptyStatement", node, opts);
        }, exports2.assertEmptyTypeAnnotation = function(node, opts) {
          assert("EmptyTypeAnnotation", node, opts);
        }, exports2.assertEnumBody = function(node, opts) {
          assert("EnumBody", node, opts);
        }, exports2.assertEnumBooleanBody = function(node, opts) {
          assert("EnumBooleanBody", node, opts);
        }, exports2.assertEnumBooleanMember = function(node, opts) {
          assert("EnumBooleanMember", node, opts);
        }, exports2.assertEnumDeclaration = function(node, opts) {
          assert("EnumDeclaration", node, opts);
        }, exports2.assertEnumDefaultedMember = function(node, opts) {
          assert("EnumDefaultedMember", node, opts);
        }, exports2.assertEnumMember = function(node, opts) {
          assert("EnumMember", node, opts);
        }, exports2.assertEnumNumberBody = function(node, opts) {
          assert("EnumNumberBody", node, opts);
        }, exports2.assertEnumNumberMember = function(node, opts) {
          assert("EnumNumberMember", node, opts);
        }, exports2.assertEnumStringBody = function(node, opts) {
          assert("EnumStringBody", node, opts);
        }, exports2.assertEnumStringMember = function(node, opts) {
          assert("EnumStringMember", node, opts);
        }, exports2.assertEnumSymbolBody = function(node, opts) {
          assert("EnumSymbolBody", node, opts);
        }, exports2.assertExistsTypeAnnotation = function(node, opts) {
          assert("ExistsTypeAnnotation", node, opts);
        }, exports2.assertExportAllDeclaration = function(node, opts) {
          assert("ExportAllDeclaration", node, opts);
        }, exports2.assertExportDeclaration = function(node, opts) {
          assert("ExportDeclaration", node, opts);
        }, exports2.assertExportDefaultDeclaration = function(node, opts) {
          assert("ExportDefaultDeclaration", node, opts);
        }, exports2.assertExportDefaultSpecifier = function(node, opts) {
          assert("ExportDefaultSpecifier", node, opts);
        }, exports2.assertExportNamedDeclaration = function(node, opts) {
          assert("ExportNamedDeclaration", node, opts);
        }, exports2.assertExportNamespaceSpecifier = function(node, opts) {
          assert("ExportNamespaceSpecifier", node, opts);
        }, exports2.assertExportSpecifier = function(node, opts) {
          assert("ExportSpecifier", node, opts);
        }, exports2.assertExpression = function(node, opts) {
          assert("Expression", node, opts);
        }, exports2.assertExpressionStatement = function(node, opts) {
          assert("ExpressionStatement", node, opts);
        }, exports2.assertExpressionWrapper = function(node, opts) {
          assert("ExpressionWrapper", node, opts);
        }, exports2.assertFile = function(node, opts) {
          assert("File", node, opts);
        }, exports2.assertFlow = function(node, opts) {
          assert("Flow", node, opts);
        }, exports2.assertFlowBaseAnnotation = function(node, opts) {
          assert("FlowBaseAnnotation", node, opts);
        }, exports2.assertFlowDeclaration = function(node, opts) {
          assert("FlowDeclaration", node, opts);
        }, exports2.assertFlowPredicate = function(node, opts) {
          assert("FlowPredicate", node, opts);
        }, exports2.assertFlowType = function(node, opts) {
          assert("FlowType", node, opts);
        }, exports2.assertFor = function(node, opts) {
          assert("For", node, opts);
        }, exports2.assertForInStatement = function(node, opts) {
          assert("ForInStatement", node, opts);
        }, exports2.assertForOfStatement = function(node, opts) {
          assert("ForOfStatement", node, opts);
        }, exports2.assertForStatement = function(node, opts) {
          assert("ForStatement", node, opts);
        }, exports2.assertForXStatement = function(node, opts) {
          assert("ForXStatement", node, opts);
        }, exports2.assertFunction = function(node, opts) {
          assert("Function", node, opts);
        }, exports2.assertFunctionDeclaration = function(node, opts) {
          assert("FunctionDeclaration", node, opts);
        }, exports2.assertFunctionExpression = function(node, opts) {
          assert("FunctionExpression", node, opts);
        }, exports2.assertFunctionParent = function(node, opts) {
          assert("FunctionParent", node, opts);
        }, exports2.assertFunctionTypeAnnotation = function(node, opts) {
          assert("FunctionTypeAnnotation", node, opts);
        }, exports2.assertFunctionTypeParam = function(node, opts) {
          assert("FunctionTypeParam", node, opts);
        }, exports2.assertGenericTypeAnnotation = function(node, opts) {
          assert("GenericTypeAnnotation", node, opts);
        }, exports2.assertIdentifier = function(node, opts) {
          assert("Identifier", node, opts);
        }, exports2.assertIfStatement = function(node, opts) {
          assert("IfStatement", node, opts);
        }, exports2.assertImmutable = function(node, opts) {
          assert("Immutable", node, opts);
        }, exports2.assertImport = function(node, opts) {
          assert("Import", node, opts);
        }, exports2.assertImportAttribute = function(node, opts) {
          assert("ImportAttribute", node, opts);
        }, exports2.assertImportDeclaration = function(node, opts) {
          assert("ImportDeclaration", node, opts);
        }, exports2.assertImportDefaultSpecifier = function(node, opts) {
          assert("ImportDefaultSpecifier", node, opts);
        }, exports2.assertImportNamespaceSpecifier = function(node, opts) {
          assert("ImportNamespaceSpecifier", node, opts);
        }, exports2.assertImportSpecifier = function(node, opts) {
          assert("ImportSpecifier", node, opts);
        }, exports2.assertIndexedAccessType = function(node, opts) {
          assert("IndexedAccessType", node, opts);
        }, exports2.assertInferredPredicate = function(node, opts) {
          assert("InferredPredicate", node, opts);
        }, exports2.assertInterfaceDeclaration = function(node, opts) {
          assert("InterfaceDeclaration", node, opts);
        }, exports2.assertInterfaceExtends = function(node, opts) {
          assert("InterfaceExtends", node, opts);
        }, exports2.assertInterfaceTypeAnnotation = function(node, opts) {
          assert("InterfaceTypeAnnotation", node, opts);
        }, exports2.assertInterpreterDirective = function(node, opts) {
          assert("InterpreterDirective", node, opts);
        }, exports2.assertIntersectionTypeAnnotation = function(node, opts) {
          assert("IntersectionTypeAnnotation", node, opts);
        }, exports2.assertJSX = function(node, opts) {
          assert("JSX", node, opts);
        }, exports2.assertJSXAttribute = function(node, opts) {
          assert("JSXAttribute", node, opts);
        }, exports2.assertJSXClosingElement = function(node, opts) {
          assert("JSXClosingElement", node, opts);
        }, exports2.assertJSXClosingFragment = function(node, opts) {
          assert("JSXClosingFragment", node, opts);
        }, exports2.assertJSXElement = function(node, opts) {
          assert("JSXElement", node, opts);
        }, exports2.assertJSXEmptyExpression = function(node, opts) {
          assert("JSXEmptyExpression", node, opts);
        }, exports2.assertJSXExpressionContainer = function(node, opts) {
          assert("JSXExpressionContainer", node, opts);
        }, exports2.assertJSXFragment = function(node, opts) {
          assert("JSXFragment", node, opts);
        }, exports2.assertJSXIdentifier = function(node, opts) {
          assert("JSXIdentifier", node, opts);
        }, exports2.assertJSXMemberExpression = function(node, opts) {
          assert("JSXMemberExpression", node, opts);
        }, exports2.assertJSXNamespacedName = function(node, opts) {
          assert("JSXNamespacedName", node, opts);
        }, exports2.assertJSXOpeningElement = function(node, opts) {
          assert("JSXOpeningElement", node, opts);
        }, exports2.assertJSXOpeningFragment = function(node, opts) {
          assert("JSXOpeningFragment", node, opts);
        }, exports2.assertJSXSpreadAttribute = function(node, opts) {
          assert("JSXSpreadAttribute", node, opts);
        }, exports2.assertJSXSpreadChild = function(node, opts) {
          assert("JSXSpreadChild", node, opts);
        }, exports2.assertJSXText = function(node, opts) {
          assert("JSXText", node, opts);
        }, exports2.assertLVal = function(node, opts) {
          assert("LVal", node, opts);
        }, exports2.assertLabeledStatement = function(node, opts) {
          assert("LabeledStatement", node, opts);
        }, exports2.assertLiteral = function(node, opts) {
          assert("Literal", node, opts);
        }, exports2.assertLogicalExpression = function(node, opts) {
          assert("LogicalExpression", node, opts);
        }, exports2.assertLoop = function(node, opts) {
          assert("Loop", node, opts);
        }, exports2.assertMemberExpression = function(node, opts) {
          assert("MemberExpression", node, opts);
        }, exports2.assertMetaProperty = function(node, opts) {
          assert("MetaProperty", node, opts);
        }, exports2.assertMethod = function(node, opts) {
          assert("Method", node, opts);
        }, exports2.assertMiscellaneous = function(node, opts) {
          assert("Miscellaneous", node, opts);
        }, exports2.assertMixedTypeAnnotation = function(node, opts) {
          assert("MixedTypeAnnotation", node, opts);
        }, exports2.assertModuleDeclaration = function(node, opts) {
          assert("ModuleDeclaration", node, opts);
        }, exports2.assertModuleExpression = function(node, opts) {
          assert("ModuleExpression", node, opts);
        }, exports2.assertModuleSpecifier = function(node, opts) {
          assert("ModuleSpecifier", node, opts);
        }, exports2.assertNewExpression = function(node, opts) {
          assert("NewExpression", node, opts);
        }, exports2.assertNoop = function(node, opts) {
          assert("Noop", node, opts);
        }, exports2.assertNullLiteral = function(node, opts) {
          assert("NullLiteral", node, opts);
        }, exports2.assertNullLiteralTypeAnnotation = function(node, opts) {
          assert("NullLiteralTypeAnnotation", node, opts);
        }, exports2.assertNullableTypeAnnotation = function(node, opts) {
          assert("NullableTypeAnnotation", node, opts);
        }, exports2.assertNumberLiteral = function(node, opts) {
          console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), assert("NumberLiteral", node, opts);
        }, exports2.assertNumberLiteralTypeAnnotation = function(node, opts) {
          assert("NumberLiteralTypeAnnotation", node, opts);
        }, exports2.assertNumberTypeAnnotation = function(node, opts) {
          assert("NumberTypeAnnotation", node, opts);
        }, exports2.assertNumericLiteral = function(node, opts) {
          assert("NumericLiteral", node, opts);
        }, exports2.assertObjectExpression = function(node, opts) {
          assert("ObjectExpression", node, opts);
        }, exports2.assertObjectMember = function(node, opts) {
          assert("ObjectMember", node, opts);
        }, exports2.assertObjectMethod = function(node, opts) {
          assert("ObjectMethod", node, opts);
        }, exports2.assertObjectPattern = function(node, opts) {
          assert("ObjectPattern", node, opts);
        }, exports2.assertObjectProperty = function(node, opts) {
          assert("ObjectProperty", node, opts);
        }, exports2.assertObjectTypeAnnotation = function(node, opts) {
          assert("ObjectTypeAnnotation", node, opts);
        }, exports2.assertObjectTypeCallProperty = function(node, opts) {
          assert("ObjectTypeCallProperty", node, opts);
        }, exports2.assertObjectTypeIndexer = function(node, opts) {
          assert("ObjectTypeIndexer", node, opts);
        }, exports2.assertObjectTypeInternalSlot = function(node, opts) {
          assert("ObjectTypeInternalSlot", node, opts);
        }, exports2.assertObjectTypeProperty = function(node, opts) {
          assert("ObjectTypeProperty", node, opts);
        }, exports2.assertObjectTypeSpreadProperty = function(node, opts) {
          assert("ObjectTypeSpreadProperty", node, opts);
        }, exports2.assertOpaqueType = function(node, opts) {
          assert("OpaqueType", node, opts);
        }, exports2.assertOptionalCallExpression = function(node, opts) {
          assert("OptionalCallExpression", node, opts);
        }, exports2.assertOptionalIndexedAccessType = function(node, opts) {
          assert("OptionalIndexedAccessType", node, opts);
        }, exports2.assertOptionalMemberExpression = function(node, opts) {
          assert("OptionalMemberExpression", node, opts);
        }, exports2.assertParenthesizedExpression = function(node, opts) {
          assert("ParenthesizedExpression", node, opts);
        }, exports2.assertPattern = function(node, opts) {
          assert("Pattern", node, opts);
        }, exports2.assertPatternLike = function(node, opts) {
          assert("PatternLike", node, opts);
        }, exports2.assertPipelineBareFunction = function(node, opts) {
          assert("PipelineBareFunction", node, opts);
        }, exports2.assertPipelinePrimaryTopicReference = function(node, opts) {
          assert("PipelinePrimaryTopicReference", node, opts);
        }, exports2.assertPipelineTopicExpression = function(node, opts) {
          assert("PipelineTopicExpression", node, opts);
        }, exports2.assertPlaceholder = function(node, opts) {
          assert("Placeholder", node, opts);
        }, exports2.assertPrivate = function(node, opts) {
          assert("Private", node, opts);
        }, exports2.assertPrivateName = function(node, opts) {
          assert("PrivateName", node, opts);
        }, exports2.assertProgram = function(node, opts) {
          assert("Program", node, opts);
        }, exports2.assertProperty = function(node, opts) {
          assert("Property", node, opts);
        }, exports2.assertPureish = function(node, opts) {
          assert("Pureish", node, opts);
        }, exports2.assertQualifiedTypeIdentifier = function(node, opts) {
          assert("QualifiedTypeIdentifier", node, opts);
        }, exports2.assertRecordExpression = function(node, opts) {
          assert("RecordExpression", node, opts);
        }, exports2.assertRegExpLiteral = function(node, opts) {
          assert("RegExpLiteral", node, opts);
        }, exports2.assertRegexLiteral = function(node, opts) {
          console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), assert("RegexLiteral", node, opts);
        }, exports2.assertRestElement = function(node, opts) {
          assert("RestElement", node, opts);
        }, exports2.assertRestProperty = function(node, opts) {
          console.trace("The node type RestProperty has been renamed to RestElement"), assert("RestProperty", node, opts);
        }, exports2.assertReturnStatement = function(node, opts) {
          assert("ReturnStatement", node, opts);
        }, exports2.assertScopable = function(node, opts) {
          assert("Scopable", node, opts);
        }, exports2.assertSequenceExpression = function(node, opts) {
          assert("SequenceExpression", node, opts);
        }, exports2.assertSpreadElement = function(node, opts) {
          assert("SpreadElement", node, opts);
        }, exports2.assertSpreadProperty = function(node, opts) {
          console.trace("The node type SpreadProperty has been renamed to SpreadElement"), assert("SpreadProperty", node, opts);
        }, exports2.assertStandardized = function(node, opts) {
          assert("Standardized", node, opts);
        }, exports2.assertStatement = function(node, opts) {
          assert("Statement", node, opts);
        }, exports2.assertStaticBlock = function(node, opts) {
          assert("StaticBlock", node, opts);
        }, exports2.assertStringLiteral = function(node, opts) {
          assert("StringLiteral", node, opts);
        }, exports2.assertStringLiteralTypeAnnotation = function(node, opts) {
          assert("StringLiteralTypeAnnotation", node, opts);
        }, exports2.assertStringTypeAnnotation = function(node, opts) {
          assert("StringTypeAnnotation", node, opts);
        }, exports2.assertSuper = function(node, opts) {
          assert("Super", node, opts);
        }, exports2.assertSwitchCase = function(node, opts) {
          assert("SwitchCase", node, opts);
        }, exports2.assertSwitchStatement = function(node, opts) {
          assert("SwitchStatement", node, opts);
        }, exports2.assertSymbolTypeAnnotation = function(node, opts) {
          assert("SymbolTypeAnnotation", node, opts);
        }, exports2.assertTSAnyKeyword = function(node, opts) {
          assert("TSAnyKeyword", node, opts);
        }, exports2.assertTSArrayType = function(node, opts) {
          assert("TSArrayType", node, opts);
        }, exports2.assertTSAsExpression = function(node, opts) {
          assert("TSAsExpression", node, opts);
        }, exports2.assertTSBaseType = function(node, opts) {
          assert("TSBaseType", node, opts);
        }, exports2.assertTSBigIntKeyword = function(node, opts) {
          assert("TSBigIntKeyword", node, opts);
        }, exports2.assertTSBooleanKeyword = function(node, opts) {
          assert("TSBooleanKeyword", node, opts);
        }, exports2.assertTSCallSignatureDeclaration = function(node, opts) {
          assert("TSCallSignatureDeclaration", node, opts);
        }, exports2.assertTSConditionalType = function(node, opts) {
          assert("TSConditionalType", node, opts);
        }, exports2.assertTSConstructSignatureDeclaration = function(node, opts) {
          assert("TSConstructSignatureDeclaration", node, opts);
        }, exports2.assertTSConstructorType = function(node, opts) {
          assert("TSConstructorType", node, opts);
        }, exports2.assertTSDeclareFunction = function(node, opts) {
          assert("TSDeclareFunction", node, opts);
        }, exports2.assertTSDeclareMethod = function(node, opts) {
          assert("TSDeclareMethod", node, opts);
        }, exports2.assertTSEntityName = function(node, opts) {
          assert("TSEntityName", node, opts);
        }, exports2.assertTSEnumDeclaration = function(node, opts) {
          assert("TSEnumDeclaration", node, opts);
        }, exports2.assertTSEnumMember = function(node, opts) {
          assert("TSEnumMember", node, opts);
        }, exports2.assertTSExportAssignment = function(node, opts) {
          assert("TSExportAssignment", node, opts);
        }, exports2.assertTSExpressionWithTypeArguments = function(node, opts) {
          assert("TSExpressionWithTypeArguments", node, opts);
        }, exports2.assertTSExternalModuleReference = function(node, opts) {
          assert("TSExternalModuleReference", node, opts);
        }, exports2.assertTSFunctionType = function(node, opts) {
          assert("TSFunctionType", node, opts);
        }, exports2.assertTSImportEqualsDeclaration = function(node, opts) {
          assert("TSImportEqualsDeclaration", node, opts);
        }, exports2.assertTSImportType = function(node, opts) {
          assert("TSImportType", node, opts);
        }, exports2.assertTSIndexSignature = function(node, opts) {
          assert("TSIndexSignature", node, opts);
        }, exports2.assertTSIndexedAccessType = function(node, opts) {
          assert("TSIndexedAccessType", node, opts);
        }, exports2.assertTSInferType = function(node, opts) {
          assert("TSInferType", node, opts);
        }, exports2.assertTSInterfaceBody = function(node, opts) {
          assert("TSInterfaceBody", node, opts);
        }, exports2.assertTSInterfaceDeclaration = function(node, opts) {
          assert("TSInterfaceDeclaration", node, opts);
        }, exports2.assertTSIntersectionType = function(node, opts) {
          assert("TSIntersectionType", node, opts);
        }, exports2.assertTSIntrinsicKeyword = function(node, opts) {
          assert("TSIntrinsicKeyword", node, opts);
        }, exports2.assertTSLiteralType = function(node, opts) {
          assert("TSLiteralType", node, opts);
        }, exports2.assertTSMappedType = function(node, opts) {
          assert("TSMappedType", node, opts);
        }, exports2.assertTSMethodSignature = function(node, opts) {
          assert("TSMethodSignature", node, opts);
        }, exports2.assertTSModuleBlock = function(node, opts) {
          assert("TSModuleBlock", node, opts);
        }, exports2.assertTSModuleDeclaration = function(node, opts) {
          assert("TSModuleDeclaration", node, opts);
        }, exports2.assertTSNamedTupleMember = function(node, opts) {
          assert("TSNamedTupleMember", node, opts);
        }, exports2.assertTSNamespaceExportDeclaration = function(node, opts) {
          assert("TSNamespaceExportDeclaration", node, opts);
        }, exports2.assertTSNeverKeyword = function(node, opts) {
          assert("TSNeverKeyword", node, opts);
        }, exports2.assertTSNonNullExpression = function(node, opts) {
          assert("TSNonNullExpression", node, opts);
        }, exports2.assertTSNullKeyword = function(node, opts) {
          assert("TSNullKeyword", node, opts);
        }, exports2.assertTSNumberKeyword = function(node, opts) {
          assert("TSNumberKeyword", node, opts);
        }, exports2.assertTSObjectKeyword = function(node, opts) {
          assert("TSObjectKeyword", node, opts);
        }, exports2.assertTSOptionalType = function(node, opts) {
          assert("TSOptionalType", node, opts);
        }, exports2.assertTSParameterProperty = function(node, opts) {
          assert("TSParameterProperty", node, opts);
        }, exports2.assertTSParenthesizedType = function(node, opts) {
          assert("TSParenthesizedType", node, opts);
        }, exports2.assertTSPropertySignature = function(node, opts) {
          assert("TSPropertySignature", node, opts);
        }, exports2.assertTSQualifiedName = function(node, opts) {
          assert("TSQualifiedName", node, opts);
        }, exports2.assertTSRestType = function(node, opts) {
          assert("TSRestType", node, opts);
        }, exports2.assertTSStringKeyword = function(node, opts) {
          assert("TSStringKeyword", node, opts);
        }, exports2.assertTSSymbolKeyword = function(node, opts) {
          assert("TSSymbolKeyword", node, opts);
        }, exports2.assertTSThisType = function(node, opts) {
          assert("TSThisType", node, opts);
        }, exports2.assertTSTupleType = function(node, opts) {
          assert("TSTupleType", node, opts);
        }, exports2.assertTSType = function(node, opts) {
          assert("TSType", node, opts);
        }, exports2.assertTSTypeAliasDeclaration = function(node, opts) {
          assert("TSTypeAliasDeclaration", node, opts);
        }, exports2.assertTSTypeAnnotation = function(node, opts) {
          assert("TSTypeAnnotation", node, opts);
        }, exports2.assertTSTypeAssertion = function(node, opts) {
          assert("TSTypeAssertion", node, opts);
        }, exports2.assertTSTypeElement = function(node, opts) {
          assert("TSTypeElement", node, opts);
        }, exports2.assertTSTypeLiteral = function(node, opts) {
          assert("TSTypeLiteral", node, opts);
        }, exports2.assertTSTypeOperator = function(node, opts) {
          assert("TSTypeOperator", node, opts);
        }, exports2.assertTSTypeParameter = function(node, opts) {
          assert("TSTypeParameter", node, opts);
        }, exports2.assertTSTypeParameterDeclaration = function(node, opts) {
          assert("TSTypeParameterDeclaration", node, opts);
        }, exports2.assertTSTypeParameterInstantiation = function(node, opts) {
          assert("TSTypeParameterInstantiation", node, opts);
        }, exports2.assertTSTypePredicate = function(node, opts) {
          assert("TSTypePredicate", node, opts);
        }, exports2.assertTSTypeQuery = function(node, opts) {
          assert("TSTypeQuery", node, opts);
        }, exports2.assertTSTypeReference = function(node, opts) {
          assert("TSTypeReference", node, opts);
        }, exports2.assertTSUndefinedKeyword = function(node, opts) {
          assert("TSUndefinedKeyword", node, opts);
        }, exports2.assertTSUnionType = function(node, opts) {
          assert("TSUnionType", node, opts);
        }, exports2.assertTSUnknownKeyword = function(node, opts) {
          assert("TSUnknownKeyword", node, opts);
        }, exports2.assertTSVoidKeyword = function(node, opts) {
          assert("TSVoidKeyword", node, opts);
        }, exports2.assertTaggedTemplateExpression = function(node, opts) {
          assert("TaggedTemplateExpression", node, opts);
        }, exports2.assertTemplateElement = function(node, opts) {
          assert("TemplateElement", node, opts);
        }, exports2.assertTemplateLiteral = function(node, opts) {
          assert("TemplateLiteral", node, opts);
        }, exports2.assertTerminatorless = function(node, opts) {
          assert("Terminatorless", node, opts);
        }, exports2.assertThisExpression = function(node, opts) {
          assert("ThisExpression", node, opts);
        }, exports2.assertThisTypeAnnotation = function(node, opts) {
          assert("ThisTypeAnnotation", node, opts);
        }, exports2.assertThrowStatement = function(node, opts) {
          assert("ThrowStatement", node, opts);
        }, exports2.assertTopicReference = function(node, opts) {
          assert("TopicReference", node, opts);
        }, exports2.assertTryStatement = function(node, opts) {
          assert("TryStatement", node, opts);
        }, exports2.assertTupleExpression = function(node, opts) {
          assert("TupleExpression", node, opts);
        }, exports2.assertTupleTypeAnnotation = function(node, opts) {
          assert("TupleTypeAnnotation", node, opts);
        }, exports2.assertTypeAlias = function(node, opts) {
          assert("TypeAlias", node, opts);
        }, exports2.assertTypeAnnotation = function(node, opts) {
          assert("TypeAnnotation", node, opts);
        }, exports2.assertTypeCastExpression = function(node, opts) {
          assert("TypeCastExpression", node, opts);
        }, exports2.assertTypeParameter = function(node, opts) {
          assert("TypeParameter", node, opts);
        }, exports2.assertTypeParameterDeclaration = function(node, opts) {
          assert("TypeParameterDeclaration", node, opts);
        }, exports2.assertTypeParameterInstantiation = function(node, opts) {
          assert("TypeParameterInstantiation", node, opts);
        }, exports2.assertTypeScript = function(node, opts) {
          assert("TypeScript", node, opts);
        }, exports2.assertTypeofTypeAnnotation = function(node, opts) {
          assert("TypeofTypeAnnotation", node, opts);
        }, exports2.assertUnaryExpression = function(node, opts) {
          assert("UnaryExpression", node, opts);
        }, exports2.assertUnaryLike = function(node, opts) {
          assert("UnaryLike", node, opts);
        }, exports2.assertUnionTypeAnnotation = function(node, opts) {
          assert("UnionTypeAnnotation", node, opts);
        }, exports2.assertUpdateExpression = function(node, opts) {
          assert("UpdateExpression", node, opts);
        }, exports2.assertUserWhitespacable = function(node, opts) {
          assert("UserWhitespacable", node, opts);
        }, exports2.assertV8IntrinsicIdentifier = function(node, opts) {
          assert("V8IntrinsicIdentifier", node, opts);
        }, exports2.assertVariableDeclaration = function(node, opts) {
          assert("VariableDeclaration", node, opts);
        }, exports2.assertVariableDeclarator = function(node, opts) {
          assert("VariableDeclarator", node, opts);
        }, exports2.assertVariance = function(node, opts) {
          assert("Variance", node, opts);
        }, exports2.assertVoidTypeAnnotation = function(node, opts) {
          assert("VoidTypeAnnotation", node, opts);
        }, exports2.assertWhile = function(node, opts) {
          assert("While", node, opts);
        }, exports2.assertWhileStatement = function(node, opts) {
          assert("WhileStatement", node, opts);
        }, exports2.assertWithStatement = function(node, opts) {
          assert("WithStatement", node, opts);
        }, exports2.assertYieldExpression = function(node, opts) {
          assert("YieldExpression", node, opts);
        };
        var _is = __webpack_require__2("./node_modules/@babel/types/lib/validators/is.js");
        function assert(type, node, opts) {
          if (!(0, _is.default)(type, node, opts))
            throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
        }
      }, "./node_modules/@babel/types/lib/ast-types/generated/index.js": () => {
      }, "./node_modules/@babel/types/lib/builders/builder.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function() {
          const type = this, keys = _definitions.BUILDER_KEYS[type], countArgs = arguments.length;
          if (countArgs > keys.length)
            throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
          const node = { type };
          for (let i = 0; i < keys.length; ++i) {
            const key = keys[i], field = _definitions.NODE_FIELDS[type][key];
            let arg;
            i < countArgs && (arg = arguments[i]), arg === void 0 && (arg = Array.isArray(field.default) ? [] : field.default), node[key] = arg;
          }
          for (const key in node)
            (0, _validate.default)(node, key, node[key]);
          return node;
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js"), _validate = __webpack_require__2("./node_modules/@babel/types/lib/validators/validate.js");
      }, "./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(types) {
          const flattened = (0, _removeTypeDuplicates.default)(types);
          return flattened.length === 1 ? flattened[0] : (0, _generated.unionTypeAnnotation)(flattened);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _default = function(type) {
          switch (type) {
            case "string":
              return (0, _generated.stringTypeAnnotation)();
            case "number":
              return (0, _generated.numberTypeAnnotation)();
            case "undefined":
              return (0, _generated.voidTypeAnnotation)();
            case "boolean":
              return (0, _generated.booleanTypeAnnotation)();
            case "function":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
            case "object":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
            case "symbol":
              return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
            case "bigint":
              return (0, _generated.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + type);
        };
        exports2.default = _default;
      }, "./node_modules/@babel/types/lib/builders/generated/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.anyTypeAnnotation = function() {
          return _builder.default.apply("AnyTypeAnnotation", arguments);
        }, exports2.argumentPlaceholder = function() {
          return _builder.default.apply("ArgumentPlaceholder", arguments);
        }, exports2.arrayExpression = function(elements) {
          return _builder.default.apply("ArrayExpression", arguments);
        }, exports2.arrayPattern = function(elements) {
          return _builder.default.apply("ArrayPattern", arguments);
        }, exports2.arrayTypeAnnotation = function(elementType) {
          return _builder.default.apply("ArrayTypeAnnotation", arguments);
        }, exports2.arrowFunctionExpression = function(params, body, async) {
          return _builder.default.apply("ArrowFunctionExpression", arguments);
        }, exports2.assignmentExpression = function(operator, left, right) {
          return _builder.default.apply("AssignmentExpression", arguments);
        }, exports2.assignmentPattern = function(left, right) {
          return _builder.default.apply("AssignmentPattern", arguments);
        }, exports2.awaitExpression = function(argument) {
          return _builder.default.apply("AwaitExpression", arguments);
        }, exports2.bigIntLiteral = function(value) {
          return _builder.default.apply("BigIntLiteral", arguments);
        }, exports2.binaryExpression = function(operator, left, right) {
          return _builder.default.apply("BinaryExpression", arguments);
        }, exports2.bindExpression = function(object, callee) {
          return _builder.default.apply("BindExpression", arguments);
        }, exports2.blockStatement = function(body, directives) {
          return _builder.default.apply("BlockStatement", arguments);
        }, exports2.booleanLiteral = function(value) {
          return _builder.default.apply("BooleanLiteral", arguments);
        }, exports2.booleanLiteralTypeAnnotation = function(value) {
          return _builder.default.apply("BooleanLiteralTypeAnnotation", arguments);
        }, exports2.booleanTypeAnnotation = function() {
          return _builder.default.apply("BooleanTypeAnnotation", arguments);
        }, exports2.breakStatement = function(label) {
          return _builder.default.apply("BreakStatement", arguments);
        }, exports2.callExpression = function(callee, _arguments) {
          return _builder.default.apply("CallExpression", arguments);
        }, exports2.catchClause = function(param, body) {
          return _builder.default.apply("CatchClause", arguments);
        }, exports2.classBody = function(body) {
          return _builder.default.apply("ClassBody", arguments);
        }, exports2.classDeclaration = function(id, superClass, body, decorators) {
          return _builder.default.apply("ClassDeclaration", arguments);
        }, exports2.classExpression = function(id, superClass, body, decorators) {
          return _builder.default.apply("ClassExpression", arguments);
        }, exports2.classImplements = function(id, typeParameters) {
          return _builder.default.apply("ClassImplements", arguments);
        }, exports2.classMethod = function(kind, key, params, body, computed, _static, generator, async) {
          return _builder.default.apply("ClassMethod", arguments);
        }, exports2.classPrivateMethod = function(kind, key, params, body, _static) {
          return _builder.default.apply("ClassPrivateMethod", arguments);
        }, exports2.classPrivateProperty = function(key, value, decorators, _static) {
          return _builder.default.apply("ClassPrivateProperty", arguments);
        }, exports2.classProperty = function(key, value, typeAnnotation, decorators, computed, _static) {
          return _builder.default.apply("ClassProperty", arguments);
        }, exports2.conditionalExpression = function(test, consequent, alternate) {
          return _builder.default.apply("ConditionalExpression", arguments);
        }, exports2.continueStatement = function(label) {
          return _builder.default.apply("ContinueStatement", arguments);
        }, exports2.debuggerStatement = function() {
          return _builder.default.apply("DebuggerStatement", arguments);
        }, exports2.decimalLiteral = function(value) {
          return _builder.default.apply("DecimalLiteral", arguments);
        }, exports2.declareClass = function(id, typeParameters, _extends, body) {
          return _builder.default.apply("DeclareClass", arguments);
        }, exports2.declareExportAllDeclaration = function(source) {
          return _builder.default.apply("DeclareExportAllDeclaration", arguments);
        }, exports2.declareExportDeclaration = function(declaration, specifiers, source) {
          return _builder.default.apply("DeclareExportDeclaration", arguments);
        }, exports2.declareFunction = function(id) {
          return _builder.default.apply("DeclareFunction", arguments);
        }, exports2.declareInterface = function(id, typeParameters, _extends, body) {
          return _builder.default.apply("DeclareInterface", arguments);
        }, exports2.declareModule = function(id, body, kind) {
          return _builder.default.apply("DeclareModule", arguments);
        }, exports2.declareModuleExports = function(typeAnnotation) {
          return _builder.default.apply("DeclareModuleExports", arguments);
        }, exports2.declareOpaqueType = function(id, typeParameters, supertype) {
          return _builder.default.apply("DeclareOpaqueType", arguments);
        }, exports2.declareTypeAlias = function(id, typeParameters, right) {
          return _builder.default.apply("DeclareTypeAlias", arguments);
        }, exports2.declareVariable = function(id) {
          return _builder.default.apply("DeclareVariable", arguments);
        }, exports2.declaredPredicate = function(value) {
          return _builder.default.apply("DeclaredPredicate", arguments);
        }, exports2.decorator = function(expression) {
          return _builder.default.apply("Decorator", arguments);
        }, exports2.directive = function(value) {
          return _builder.default.apply("Directive", arguments);
        }, exports2.directiveLiteral = function(value) {
          return _builder.default.apply("DirectiveLiteral", arguments);
        }, exports2.doExpression = function(body, async) {
          return _builder.default.apply("DoExpression", arguments);
        }, exports2.doWhileStatement = function(test, body) {
          return _builder.default.apply("DoWhileStatement", arguments);
        }, exports2.emptyStatement = function() {
          return _builder.default.apply("EmptyStatement", arguments);
        }, exports2.emptyTypeAnnotation = function() {
          return _builder.default.apply("EmptyTypeAnnotation", arguments);
        }, exports2.enumBooleanBody = function(members) {
          return _builder.default.apply("EnumBooleanBody", arguments);
        }, exports2.enumBooleanMember = function(id) {
          return _builder.default.apply("EnumBooleanMember", arguments);
        }, exports2.enumDeclaration = function(id, body) {
          return _builder.default.apply("EnumDeclaration", arguments);
        }, exports2.enumDefaultedMember = function(id) {
          return _builder.default.apply("EnumDefaultedMember", arguments);
        }, exports2.enumNumberBody = function(members) {
          return _builder.default.apply("EnumNumberBody", arguments);
        }, exports2.enumNumberMember = function(id, init) {
          return _builder.default.apply("EnumNumberMember", arguments);
        }, exports2.enumStringBody = function(members) {
          return _builder.default.apply("EnumStringBody", arguments);
        }, exports2.enumStringMember = function(id, init) {
          return _builder.default.apply("EnumStringMember", arguments);
        }, exports2.enumSymbolBody = function(members) {
          return _builder.default.apply("EnumSymbolBody", arguments);
        }, exports2.existsTypeAnnotation = function() {
          return _builder.default.apply("ExistsTypeAnnotation", arguments);
        }, exports2.exportAllDeclaration = function(source) {
          return _builder.default.apply("ExportAllDeclaration", arguments);
        }, exports2.exportDefaultDeclaration = function(declaration) {
          return _builder.default.apply("ExportDefaultDeclaration", arguments);
        }, exports2.exportDefaultSpecifier = function(exported) {
          return _builder.default.apply("ExportDefaultSpecifier", arguments);
        }, exports2.exportNamedDeclaration = function(declaration, specifiers, source) {
          return _builder.default.apply("ExportNamedDeclaration", arguments);
        }, exports2.exportNamespaceSpecifier = function(exported) {
          return _builder.default.apply("ExportNamespaceSpecifier", arguments);
        }, exports2.exportSpecifier = function(local, exported) {
          return _builder.default.apply("ExportSpecifier", arguments);
        }, exports2.expressionStatement = function(expression) {
          return _builder.default.apply("ExpressionStatement", arguments);
        }, exports2.file = function(program, comments, tokens) {
          return _builder.default.apply("File", arguments);
        }, exports2.forInStatement = function(left, right, body) {
          return _builder.default.apply("ForInStatement", arguments);
        }, exports2.forOfStatement = function(left, right, body, _await) {
          return _builder.default.apply("ForOfStatement", arguments);
        }, exports2.forStatement = function(init, test, update, body) {
          return _builder.default.apply("ForStatement", arguments);
        }, exports2.functionDeclaration = function(id, params, body, generator, async) {
          return _builder.default.apply("FunctionDeclaration", arguments);
        }, exports2.functionExpression = function(id, params, body, generator, async) {
          return _builder.default.apply("FunctionExpression", arguments);
        }, exports2.functionTypeAnnotation = function(typeParameters, params, rest, returnType) {
          return _builder.default.apply("FunctionTypeAnnotation", arguments);
        }, exports2.functionTypeParam = function(name, typeAnnotation) {
          return _builder.default.apply("FunctionTypeParam", arguments);
        }, exports2.genericTypeAnnotation = function(id, typeParameters) {
          return _builder.default.apply("GenericTypeAnnotation", arguments);
        }, exports2.identifier = function(name) {
          return _builder.default.apply("Identifier", arguments);
        }, exports2.ifStatement = function(test, consequent, alternate) {
          return _builder.default.apply("IfStatement", arguments);
        }, exports2.import = function() {
          return _builder.default.apply("Import", arguments);
        }, exports2.importAttribute = function(key, value) {
          return _builder.default.apply("ImportAttribute", arguments);
        }, exports2.importDeclaration = function(specifiers, source) {
          return _builder.default.apply("ImportDeclaration", arguments);
        }, exports2.importDefaultSpecifier = function(local) {
          return _builder.default.apply("ImportDefaultSpecifier", arguments);
        }, exports2.importNamespaceSpecifier = function(local) {
          return _builder.default.apply("ImportNamespaceSpecifier", arguments);
        }, exports2.importSpecifier = function(local, imported) {
          return _builder.default.apply("ImportSpecifier", arguments);
        }, exports2.indexedAccessType = function(objectType, indexType) {
          return _builder.default.apply("IndexedAccessType", arguments);
        }, exports2.inferredPredicate = function() {
          return _builder.default.apply("InferredPredicate", arguments);
        }, exports2.interfaceDeclaration = function(id, typeParameters, _extends, body) {
          return _builder.default.apply("InterfaceDeclaration", arguments);
        }, exports2.interfaceExtends = function(id, typeParameters) {
          return _builder.default.apply("InterfaceExtends", arguments);
        }, exports2.interfaceTypeAnnotation = function(_extends, body) {
          return _builder.default.apply("InterfaceTypeAnnotation", arguments);
        }, exports2.interpreterDirective = function(value) {
          return _builder.default.apply("InterpreterDirective", arguments);
        }, exports2.intersectionTypeAnnotation = function(types) {
          return _builder.default.apply("IntersectionTypeAnnotation", arguments);
        }, exports2.jSXAttribute = exports2.jsxAttribute = function(name, value) {
          return _builder.default.apply("JSXAttribute", arguments);
        }, exports2.jSXClosingElement = exports2.jsxClosingElement = function(name) {
          return _builder.default.apply("JSXClosingElement", arguments);
        }, exports2.jSXClosingFragment = exports2.jsxClosingFragment = function() {
          return _builder.default.apply("JSXClosingFragment", arguments);
        }, exports2.jSXElement = exports2.jsxElement = function(openingElement, closingElement, children, selfClosing) {
          return _builder.default.apply("JSXElement", arguments);
        }, exports2.jSXEmptyExpression = exports2.jsxEmptyExpression = function() {
          return _builder.default.apply("JSXEmptyExpression", arguments);
        }, exports2.jSXExpressionContainer = exports2.jsxExpressionContainer = function(expression) {
          return _builder.default.apply("JSXExpressionContainer", arguments);
        }, exports2.jSXFragment = exports2.jsxFragment = function(openingFragment, closingFragment, children) {
          return _builder.default.apply("JSXFragment", arguments);
        }, exports2.jSXIdentifier = exports2.jsxIdentifier = function(name) {
          return _builder.default.apply("JSXIdentifier", arguments);
        }, exports2.jSXMemberExpression = exports2.jsxMemberExpression = function(object, property) {
          return _builder.default.apply("JSXMemberExpression", arguments);
        }, exports2.jSXNamespacedName = exports2.jsxNamespacedName = function(namespace, name) {
          return _builder.default.apply("JSXNamespacedName", arguments);
        }, exports2.jSXOpeningElement = exports2.jsxOpeningElement = function(name, attributes, selfClosing) {
          return _builder.default.apply("JSXOpeningElement", arguments);
        }, exports2.jSXOpeningFragment = exports2.jsxOpeningFragment = function() {
          return _builder.default.apply("JSXOpeningFragment", arguments);
        }, exports2.jSXSpreadAttribute = exports2.jsxSpreadAttribute = function(argument) {
          return _builder.default.apply("JSXSpreadAttribute", arguments);
        }, exports2.jSXSpreadChild = exports2.jsxSpreadChild = function(expression) {
          return _builder.default.apply("JSXSpreadChild", arguments);
        }, exports2.jSXText = exports2.jsxText = function(value) {
          return _builder.default.apply("JSXText", arguments);
        }, exports2.labeledStatement = function(label, body) {
          return _builder.default.apply("LabeledStatement", arguments);
        }, exports2.logicalExpression = function(operator, left, right) {
          return _builder.default.apply("LogicalExpression", arguments);
        }, exports2.memberExpression = function(object, property, computed, optional) {
          return _builder.default.apply("MemberExpression", arguments);
        }, exports2.metaProperty = function(meta, property) {
          return _builder.default.apply("MetaProperty", arguments);
        }, exports2.mixedTypeAnnotation = function() {
          return _builder.default.apply("MixedTypeAnnotation", arguments);
        }, exports2.moduleExpression = function(body) {
          return _builder.default.apply("ModuleExpression", arguments);
        }, exports2.newExpression = function(callee, _arguments) {
          return _builder.default.apply("NewExpression", arguments);
        }, exports2.noop = function() {
          return _builder.default.apply("Noop", arguments);
        }, exports2.nullLiteral = function() {
          return _builder.default.apply("NullLiteral", arguments);
        }, exports2.nullLiteralTypeAnnotation = function() {
          return _builder.default.apply("NullLiteralTypeAnnotation", arguments);
        }, exports2.nullableTypeAnnotation = function(typeAnnotation) {
          return _builder.default.apply("NullableTypeAnnotation", arguments);
        }, exports2.numberLiteral = function(value) {
          return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), _builder.default.apply("NumberLiteral", arguments);
        }, exports2.numberLiteralTypeAnnotation = function(value) {
          return _builder.default.apply("NumberLiteralTypeAnnotation", arguments);
        }, exports2.numberTypeAnnotation = function() {
          return _builder.default.apply("NumberTypeAnnotation", arguments);
        }, exports2.numericLiteral = function(value) {
          return _builder.default.apply("NumericLiteral", arguments);
        }, exports2.objectExpression = function(properties) {
          return _builder.default.apply("ObjectExpression", arguments);
        }, exports2.objectMethod = function(kind, key, params, body, computed, generator, async) {
          return _builder.default.apply("ObjectMethod", arguments);
        }, exports2.objectPattern = function(properties) {
          return _builder.default.apply("ObjectPattern", arguments);
        }, exports2.objectProperty = function(key, value, computed, shorthand, decorators) {
          return _builder.default.apply("ObjectProperty", arguments);
        }, exports2.objectTypeAnnotation = function(properties, indexers, callProperties, internalSlots, exact) {
          return _builder.default.apply("ObjectTypeAnnotation", arguments);
        }, exports2.objectTypeCallProperty = function(value) {
          return _builder.default.apply("ObjectTypeCallProperty", arguments);
        }, exports2.objectTypeIndexer = function(id, key, value, variance) {
          return _builder.default.apply("ObjectTypeIndexer", arguments);
        }, exports2.objectTypeInternalSlot = function(id, value, optional, _static, method) {
          return _builder.default.apply("ObjectTypeInternalSlot", arguments);
        }, exports2.objectTypeProperty = function(key, value, variance) {
          return _builder.default.apply("ObjectTypeProperty", arguments);
        }, exports2.objectTypeSpreadProperty = function(argument) {
          return _builder.default.apply("ObjectTypeSpreadProperty", arguments);
        }, exports2.opaqueType = function(id, typeParameters, supertype, impltype) {
          return _builder.default.apply("OpaqueType", arguments);
        }, exports2.optionalCallExpression = function(callee, _arguments, optional) {
          return _builder.default.apply("OptionalCallExpression", arguments);
        }, exports2.optionalIndexedAccessType = function(objectType, indexType) {
          return _builder.default.apply("OptionalIndexedAccessType", arguments);
        }, exports2.optionalMemberExpression = function(object, property, computed, optional) {
          return _builder.default.apply("OptionalMemberExpression", arguments);
        }, exports2.parenthesizedExpression = function(expression) {
          return _builder.default.apply("ParenthesizedExpression", arguments);
        }, exports2.pipelineBareFunction = function(callee) {
          return _builder.default.apply("PipelineBareFunction", arguments);
        }, exports2.pipelinePrimaryTopicReference = function() {
          return _builder.default.apply("PipelinePrimaryTopicReference", arguments);
        }, exports2.pipelineTopicExpression = function(expression) {
          return _builder.default.apply("PipelineTopicExpression", arguments);
        }, exports2.placeholder = function(expectedNode, name) {
          return _builder.default.apply("Placeholder", arguments);
        }, exports2.privateName = function(id) {
          return _builder.default.apply("PrivateName", arguments);
        }, exports2.program = function(body, directives, sourceType, interpreter) {
          return _builder.default.apply("Program", arguments);
        }, exports2.qualifiedTypeIdentifier = function(id, qualification) {
          return _builder.default.apply("QualifiedTypeIdentifier", arguments);
        }, exports2.recordExpression = function(properties) {
          return _builder.default.apply("RecordExpression", arguments);
        }, exports2.regExpLiteral = function(pattern, flags) {
          return _builder.default.apply("RegExpLiteral", arguments);
        }, exports2.regexLiteral = function(pattern, flags) {
          return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), _builder.default.apply("RegexLiteral", arguments);
        }, exports2.restElement = function(argument) {
          return _builder.default.apply("RestElement", arguments);
        }, exports2.restProperty = function(argument) {
          return console.trace("The node type RestProperty has been renamed to RestElement"), _builder.default.apply("RestProperty", arguments);
        }, exports2.returnStatement = function(argument) {
          return _builder.default.apply("ReturnStatement", arguments);
        }, exports2.sequenceExpression = function(expressions) {
          return _builder.default.apply("SequenceExpression", arguments);
        }, exports2.spreadElement = function(argument) {
          return _builder.default.apply("SpreadElement", arguments);
        }, exports2.spreadProperty = function(argument) {
          return console.trace("The node type SpreadProperty has been renamed to SpreadElement"), _builder.default.apply("SpreadProperty", arguments);
        }, exports2.staticBlock = function(body) {
          return _builder.default.apply("StaticBlock", arguments);
        }, exports2.stringLiteral = function(value) {
          return _builder.default.apply("StringLiteral", arguments);
        }, exports2.stringLiteralTypeAnnotation = function(value) {
          return _builder.default.apply("StringLiteralTypeAnnotation", arguments);
        }, exports2.stringTypeAnnotation = function() {
          return _builder.default.apply("StringTypeAnnotation", arguments);
        }, exports2.super = function() {
          return _builder.default.apply("Super", arguments);
        }, exports2.switchCase = function(test, consequent) {
          return _builder.default.apply("SwitchCase", arguments);
        }, exports2.switchStatement = function(discriminant, cases) {
          return _builder.default.apply("SwitchStatement", arguments);
        }, exports2.symbolTypeAnnotation = function() {
          return _builder.default.apply("SymbolTypeAnnotation", arguments);
        }, exports2.taggedTemplateExpression = function(tag, quasi) {
          return _builder.default.apply("TaggedTemplateExpression", arguments);
        }, exports2.templateElement = function(value, tail) {
          return _builder.default.apply("TemplateElement", arguments);
        }, exports2.templateLiteral = function(quasis, expressions) {
          return _builder.default.apply("TemplateLiteral", arguments);
        }, exports2.thisExpression = function() {
          return _builder.default.apply("ThisExpression", arguments);
        }, exports2.thisTypeAnnotation = function() {
          return _builder.default.apply("ThisTypeAnnotation", arguments);
        }, exports2.throwStatement = function(argument) {
          return _builder.default.apply("ThrowStatement", arguments);
        }, exports2.topicReference = function() {
          return _builder.default.apply("TopicReference", arguments);
        }, exports2.tryStatement = function(block, handler, finalizer) {
          return _builder.default.apply("TryStatement", arguments);
        }, exports2.tSAnyKeyword = exports2.tsAnyKeyword = function() {
          return _builder.default.apply("TSAnyKeyword", arguments);
        }, exports2.tSArrayType = exports2.tsArrayType = function(elementType) {
          return _builder.default.apply("TSArrayType", arguments);
        }, exports2.tSAsExpression = exports2.tsAsExpression = function(expression, typeAnnotation) {
          return _builder.default.apply("TSAsExpression", arguments);
        }, exports2.tSBigIntKeyword = exports2.tsBigIntKeyword = function() {
          return _builder.default.apply("TSBigIntKeyword", arguments);
        }, exports2.tSBooleanKeyword = exports2.tsBooleanKeyword = function() {
          return _builder.default.apply("TSBooleanKeyword", arguments);
        }, exports2.tSCallSignatureDeclaration = exports2.tsCallSignatureDeclaration = function(typeParameters, parameters, typeAnnotation) {
          return _builder.default.apply("TSCallSignatureDeclaration", arguments);
        }, exports2.tSConditionalType = exports2.tsConditionalType = function(checkType, extendsType, trueType, falseType) {
          return _builder.default.apply("TSConditionalType", arguments);
        }, exports2.tSConstructSignatureDeclaration = exports2.tsConstructSignatureDeclaration = function(typeParameters, parameters, typeAnnotation) {
          return _builder.default.apply("TSConstructSignatureDeclaration", arguments);
        }, exports2.tSConstructorType = exports2.tsConstructorType = function(typeParameters, parameters, typeAnnotation) {
          return _builder.default.apply("TSConstructorType", arguments);
        }, exports2.tSDeclareFunction = exports2.tsDeclareFunction = function(id, typeParameters, params, returnType) {
          return _builder.default.apply("TSDeclareFunction", arguments);
        }, exports2.tSDeclareMethod = exports2.tsDeclareMethod = function(decorators, key, typeParameters, params, returnType) {
          return _builder.default.apply("TSDeclareMethod", arguments);
        }, exports2.tSEnumDeclaration = exports2.tsEnumDeclaration = function(id, members) {
          return _builder.default.apply("TSEnumDeclaration", arguments);
        }, exports2.tSEnumMember = exports2.tsEnumMember = function(id, initializer) {
          return _builder.default.apply("TSEnumMember", arguments);
        }, exports2.tSExportAssignment = exports2.tsExportAssignment = function(expression) {
          return _builder.default.apply("TSExportAssignment", arguments);
        }, exports2.tSExpressionWithTypeArguments = exports2.tsExpressionWithTypeArguments = function(expression, typeParameters) {
          return _builder.default.apply("TSExpressionWithTypeArguments", arguments);
        }, exports2.tSExternalModuleReference = exports2.tsExternalModuleReference = function(expression) {
          return _builder.default.apply("TSExternalModuleReference", arguments);
        }, exports2.tSFunctionType = exports2.tsFunctionType = function(typeParameters, parameters, typeAnnotation) {
          return _builder.default.apply("TSFunctionType", arguments);
        }, exports2.tSImportEqualsDeclaration = exports2.tsImportEqualsDeclaration = function(id, moduleReference) {
          return _builder.default.apply("TSImportEqualsDeclaration", arguments);
        }, exports2.tSImportType = exports2.tsImportType = function(argument, qualifier, typeParameters) {
          return _builder.default.apply("TSImportType", arguments);
        }, exports2.tSIndexSignature = exports2.tsIndexSignature = function(parameters, typeAnnotation) {
          return _builder.default.apply("TSIndexSignature", arguments);
        }, exports2.tSIndexedAccessType = exports2.tsIndexedAccessType = function(objectType, indexType) {
          return _builder.default.apply("TSIndexedAccessType", arguments);
        }, exports2.tSInferType = exports2.tsInferType = function(typeParameter) {
          return _builder.default.apply("TSInferType", arguments);
        }, exports2.tSInterfaceBody = exports2.tsInterfaceBody = function(body) {
          return _builder.default.apply("TSInterfaceBody", arguments);
        }, exports2.tSInterfaceDeclaration = exports2.tsInterfaceDeclaration = function(id, typeParameters, _extends, body) {
          return _builder.default.apply("TSInterfaceDeclaration", arguments);
        }, exports2.tSIntersectionType = exports2.tsIntersectionType = function(types) {
          return _builder.default.apply("TSIntersectionType", arguments);
        }, exports2.tSIntrinsicKeyword = exports2.tsIntrinsicKeyword = function() {
          return _builder.default.apply("TSIntrinsicKeyword", arguments);
        }, exports2.tSLiteralType = exports2.tsLiteralType = function(literal) {
          return _builder.default.apply("TSLiteralType", arguments);
        }, exports2.tSMappedType = exports2.tsMappedType = function(typeParameter, typeAnnotation, nameType) {
          return _builder.default.apply("TSMappedType", arguments);
        }, exports2.tSMethodSignature = exports2.tsMethodSignature = function(key, typeParameters, parameters, typeAnnotation) {
          return _builder.default.apply("TSMethodSignature", arguments);
        }, exports2.tSModuleBlock = exports2.tsModuleBlock = function(body) {
          return _builder.default.apply("TSModuleBlock", arguments);
        }, exports2.tSModuleDeclaration = exports2.tsModuleDeclaration = function(id, body) {
          return _builder.default.apply("TSModuleDeclaration", arguments);
        }, exports2.tSNamedTupleMember = exports2.tsNamedTupleMember = function(label, elementType, optional) {
          return _builder.default.apply("TSNamedTupleMember", arguments);
        }, exports2.tSNamespaceExportDeclaration = exports2.tsNamespaceExportDeclaration = function(id) {
          return _builder.default.apply("TSNamespaceExportDeclaration", arguments);
        }, exports2.tSNeverKeyword = exports2.tsNeverKeyword = function() {
          return _builder.default.apply("TSNeverKeyword", arguments);
        }, exports2.tSNonNullExpression = exports2.tsNonNullExpression = function(expression) {
          return _builder.default.apply("TSNonNullExpression", arguments);
        }, exports2.tSNullKeyword = exports2.tsNullKeyword = function() {
          return _builder.default.apply("TSNullKeyword", arguments);
        }, exports2.tSNumberKeyword = exports2.tsNumberKeyword = function() {
          return _builder.default.apply("TSNumberKeyword", arguments);
        }, exports2.tSObjectKeyword = exports2.tsObjectKeyword = function() {
          return _builder.default.apply("TSObjectKeyword", arguments);
        }, exports2.tSOptionalType = exports2.tsOptionalType = function(typeAnnotation) {
          return _builder.default.apply("TSOptionalType", arguments);
        }, exports2.tSParameterProperty = exports2.tsParameterProperty = function(parameter) {
          return _builder.default.apply("TSParameterProperty", arguments);
        }, exports2.tSParenthesizedType = exports2.tsParenthesizedType = function(typeAnnotation) {
          return _builder.default.apply("TSParenthesizedType", arguments);
        }, exports2.tSPropertySignature = exports2.tsPropertySignature = function(key, typeAnnotation, initializer) {
          return _builder.default.apply("TSPropertySignature", arguments);
        }, exports2.tSQualifiedName = exports2.tsQualifiedName = function(left, right) {
          return _builder.default.apply("TSQualifiedName", arguments);
        }, exports2.tSRestType = exports2.tsRestType = function(typeAnnotation) {
          return _builder.default.apply("TSRestType", arguments);
        }, exports2.tSStringKeyword = exports2.tsStringKeyword = function() {
          return _builder.default.apply("TSStringKeyword", arguments);
        }, exports2.tSSymbolKeyword = exports2.tsSymbolKeyword = function() {
          return _builder.default.apply("TSSymbolKeyword", arguments);
        }, exports2.tSThisType = exports2.tsThisType = function() {
          return _builder.default.apply("TSThisType", arguments);
        }, exports2.tSTupleType = exports2.tsTupleType = function(elementTypes) {
          return _builder.default.apply("TSTupleType", arguments);
        }, exports2.tSTypeAliasDeclaration = exports2.tsTypeAliasDeclaration = function(id, typeParameters, typeAnnotation) {
          return _builder.default.apply("TSTypeAliasDeclaration", arguments);
        }, exports2.tSTypeAnnotation = exports2.tsTypeAnnotation = function(typeAnnotation) {
          return _builder.default.apply("TSTypeAnnotation", arguments);
        }, exports2.tSTypeAssertion = exports2.tsTypeAssertion = function(typeAnnotation, expression) {
          return _builder.default.apply("TSTypeAssertion", arguments);
        }, exports2.tSTypeLiteral = exports2.tsTypeLiteral = function(members) {
          return _builder.default.apply("TSTypeLiteral", arguments);
        }, exports2.tSTypeOperator = exports2.tsTypeOperator = function(typeAnnotation) {
          return _builder.default.apply("TSTypeOperator", arguments);
        }, exports2.tSTypeParameter = exports2.tsTypeParameter = function(constraint, _default, name) {
          return _builder.default.apply("TSTypeParameter", arguments);
        }, exports2.tSTypeParameterDeclaration = exports2.tsTypeParameterDeclaration = function(params) {
          return _builder.default.apply("TSTypeParameterDeclaration", arguments);
        }, exports2.tSTypeParameterInstantiation = exports2.tsTypeParameterInstantiation = function(params) {
          return _builder.default.apply("TSTypeParameterInstantiation", arguments);
        }, exports2.tSTypePredicate = exports2.tsTypePredicate = function(parameterName, typeAnnotation, asserts) {
          return _builder.default.apply("TSTypePredicate", arguments);
        }, exports2.tSTypeQuery = exports2.tsTypeQuery = function(exprName) {
          return _builder.default.apply("TSTypeQuery", arguments);
        }, exports2.tSTypeReference = exports2.tsTypeReference = function(typeName, typeParameters) {
          return _builder.default.apply("TSTypeReference", arguments);
        }, exports2.tSUndefinedKeyword = exports2.tsUndefinedKeyword = function() {
          return _builder.default.apply("TSUndefinedKeyword", arguments);
        }, exports2.tSUnionType = exports2.tsUnionType = function(types) {
          return _builder.default.apply("TSUnionType", arguments);
        }, exports2.tSUnknownKeyword = exports2.tsUnknownKeyword = function() {
          return _builder.default.apply("TSUnknownKeyword", arguments);
        }, exports2.tSVoidKeyword = exports2.tsVoidKeyword = function() {
          return _builder.default.apply("TSVoidKeyword", arguments);
        }, exports2.tupleExpression = function(elements) {
          return _builder.default.apply("TupleExpression", arguments);
        }, exports2.tupleTypeAnnotation = function(types) {
          return _builder.default.apply("TupleTypeAnnotation", arguments);
        }, exports2.typeAlias = function(id, typeParameters, right) {
          return _builder.default.apply("TypeAlias", arguments);
        }, exports2.typeAnnotation = function(typeAnnotation) {
          return _builder.default.apply("TypeAnnotation", arguments);
        }, exports2.typeCastExpression = function(expression, typeAnnotation) {
          return _builder.default.apply("TypeCastExpression", arguments);
        }, exports2.typeParameter = function(bound, _default, variance) {
          return _builder.default.apply("TypeParameter", arguments);
        }, exports2.typeParameterDeclaration = function(params) {
          return _builder.default.apply("TypeParameterDeclaration", arguments);
        }, exports2.typeParameterInstantiation = function(params) {
          return _builder.default.apply("TypeParameterInstantiation", arguments);
        }, exports2.typeofTypeAnnotation = function(argument) {
          return _builder.default.apply("TypeofTypeAnnotation", arguments);
        }, exports2.unaryExpression = function(operator, argument, prefix) {
          return _builder.default.apply("UnaryExpression", arguments);
        }, exports2.unionTypeAnnotation = function(types) {
          return _builder.default.apply("UnionTypeAnnotation", arguments);
        }, exports2.updateExpression = function(operator, argument, prefix) {
          return _builder.default.apply("UpdateExpression", arguments);
        }, exports2.v8IntrinsicIdentifier = function(name) {
          return _builder.default.apply("V8IntrinsicIdentifier", arguments);
        }, exports2.variableDeclaration = function(kind, declarations) {
          return _builder.default.apply("VariableDeclaration", arguments);
        }, exports2.variableDeclarator = function(id, init) {
          return _builder.default.apply("VariableDeclarator", arguments);
        }, exports2.variance = function(kind) {
          return _builder.default.apply("Variance", arguments);
        }, exports2.voidTypeAnnotation = function() {
          return _builder.default.apply("VoidTypeAnnotation", arguments);
        }, exports2.whileStatement = function(test, body) {
          return _builder.default.apply("WhileStatement", arguments);
        }, exports2.withStatement = function(object, body) {
          return _builder.default.apply("WithStatement", arguments);
        }, exports2.yieldExpression = function(argument, delegate) {
          return _builder.default.apply("YieldExpression", arguments);
        };
        var _builder = __webpack_require__2("./node_modules/@babel/types/lib/builders/builder.js");
      }, "./node_modules/@babel/types/lib/builders/generated/uppercase.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "AnyTypeAnnotation", { enumerable: true, get: function() {
          return _index.anyTypeAnnotation;
        } }), Object.defineProperty(exports2, "ArgumentPlaceholder", { enumerable: true, get: function() {
          return _index.argumentPlaceholder;
        } }), Object.defineProperty(exports2, "ArrayExpression", { enumerable: true, get: function() {
          return _index.arrayExpression;
        } }), Object.defineProperty(exports2, "ArrayPattern", { enumerable: true, get: function() {
          return _index.arrayPattern;
        } }), Object.defineProperty(exports2, "ArrayTypeAnnotation", { enumerable: true, get: function() {
          return _index.arrayTypeAnnotation;
        } }), Object.defineProperty(exports2, "ArrowFunctionExpression", { enumerable: true, get: function() {
          return _index.arrowFunctionExpression;
        } }), Object.defineProperty(exports2, "AssignmentExpression", { enumerable: true, get: function() {
          return _index.assignmentExpression;
        } }), Object.defineProperty(exports2, "AssignmentPattern", { enumerable: true, get: function() {
          return _index.assignmentPattern;
        } }), Object.defineProperty(exports2, "AwaitExpression", { enumerable: true, get: function() {
          return _index.awaitExpression;
        } }), Object.defineProperty(exports2, "BigIntLiteral", { enumerable: true, get: function() {
          return _index.bigIntLiteral;
        } }), Object.defineProperty(exports2, "BinaryExpression", { enumerable: true, get: function() {
          return _index.binaryExpression;
        } }), Object.defineProperty(exports2, "BindExpression", { enumerable: true, get: function() {
          return _index.bindExpression;
        } }), Object.defineProperty(exports2, "BlockStatement", { enumerable: true, get: function() {
          return _index.blockStatement;
        } }), Object.defineProperty(exports2, "BooleanLiteral", { enumerable: true, get: function() {
          return _index.booleanLiteral;
        } }), Object.defineProperty(exports2, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(exports2, "BooleanTypeAnnotation", { enumerable: true, get: function() {
          return _index.booleanTypeAnnotation;
        } }), Object.defineProperty(exports2, "BreakStatement", { enumerable: true, get: function() {
          return _index.breakStatement;
        } }), Object.defineProperty(exports2, "CallExpression", { enumerable: true, get: function() {
          return _index.callExpression;
        } }), Object.defineProperty(exports2, "CatchClause", { enumerable: true, get: function() {
          return _index.catchClause;
        } }), Object.defineProperty(exports2, "ClassBody", { enumerable: true, get: function() {
          return _index.classBody;
        } }), Object.defineProperty(exports2, "ClassDeclaration", { enumerable: true, get: function() {
          return _index.classDeclaration;
        } }), Object.defineProperty(exports2, "ClassExpression", { enumerable: true, get: function() {
          return _index.classExpression;
        } }), Object.defineProperty(exports2, "ClassImplements", { enumerable: true, get: function() {
          return _index.classImplements;
        } }), Object.defineProperty(exports2, "ClassMethod", { enumerable: true, get: function() {
          return _index.classMethod;
        } }), Object.defineProperty(exports2, "ClassPrivateMethod", { enumerable: true, get: function() {
          return _index.classPrivateMethod;
        } }), Object.defineProperty(exports2, "ClassPrivateProperty", { enumerable: true, get: function() {
          return _index.classPrivateProperty;
        } }), Object.defineProperty(exports2, "ClassProperty", { enumerable: true, get: function() {
          return _index.classProperty;
        } }), Object.defineProperty(exports2, "ConditionalExpression", { enumerable: true, get: function() {
          return _index.conditionalExpression;
        } }), Object.defineProperty(exports2, "ContinueStatement", { enumerable: true, get: function() {
          return _index.continueStatement;
        } }), Object.defineProperty(exports2, "DebuggerStatement", { enumerable: true, get: function() {
          return _index.debuggerStatement;
        } }), Object.defineProperty(exports2, "DecimalLiteral", { enumerable: true, get: function() {
          return _index.decimalLiteral;
        } }), Object.defineProperty(exports2, "DeclareClass", { enumerable: true, get: function() {
          return _index.declareClass;
        } }), Object.defineProperty(exports2, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
          return _index.declareExportAllDeclaration;
        } }), Object.defineProperty(exports2, "DeclareExportDeclaration", { enumerable: true, get: function() {
          return _index.declareExportDeclaration;
        } }), Object.defineProperty(exports2, "DeclareFunction", { enumerable: true, get: function() {
          return _index.declareFunction;
        } }), Object.defineProperty(exports2, "DeclareInterface", { enumerable: true, get: function() {
          return _index.declareInterface;
        } }), Object.defineProperty(exports2, "DeclareModule", { enumerable: true, get: function() {
          return _index.declareModule;
        } }), Object.defineProperty(exports2, "DeclareModuleExports", { enumerable: true, get: function() {
          return _index.declareModuleExports;
        } }), Object.defineProperty(exports2, "DeclareOpaqueType", { enumerable: true, get: function() {
          return _index.declareOpaqueType;
        } }), Object.defineProperty(exports2, "DeclareTypeAlias", { enumerable: true, get: function() {
          return _index.declareTypeAlias;
        } }), Object.defineProperty(exports2, "DeclareVariable", { enumerable: true, get: function() {
          return _index.declareVariable;
        } }), Object.defineProperty(exports2, "DeclaredPredicate", { enumerable: true, get: function() {
          return _index.declaredPredicate;
        } }), Object.defineProperty(exports2, "Decorator", { enumerable: true, get: function() {
          return _index.decorator;
        } }), Object.defineProperty(exports2, "Directive", { enumerable: true, get: function() {
          return _index.directive;
        } }), Object.defineProperty(exports2, "DirectiveLiteral", { enumerable: true, get: function() {
          return _index.directiveLiteral;
        } }), Object.defineProperty(exports2, "DoExpression", { enumerable: true, get: function() {
          return _index.doExpression;
        } }), Object.defineProperty(exports2, "DoWhileStatement", { enumerable: true, get: function() {
          return _index.doWhileStatement;
        } }), Object.defineProperty(exports2, "EmptyStatement", { enumerable: true, get: function() {
          return _index.emptyStatement;
        } }), Object.defineProperty(exports2, "EmptyTypeAnnotation", { enumerable: true, get: function() {
          return _index.emptyTypeAnnotation;
        } }), Object.defineProperty(exports2, "EnumBooleanBody", { enumerable: true, get: function() {
          return _index.enumBooleanBody;
        } }), Object.defineProperty(exports2, "EnumBooleanMember", { enumerable: true, get: function() {
          return _index.enumBooleanMember;
        } }), Object.defineProperty(exports2, "EnumDeclaration", { enumerable: true, get: function() {
          return _index.enumDeclaration;
        } }), Object.defineProperty(exports2, "EnumDefaultedMember", { enumerable: true, get: function() {
          return _index.enumDefaultedMember;
        } }), Object.defineProperty(exports2, "EnumNumberBody", { enumerable: true, get: function() {
          return _index.enumNumberBody;
        } }), Object.defineProperty(exports2, "EnumNumberMember", { enumerable: true, get: function() {
          return _index.enumNumberMember;
        } }), Object.defineProperty(exports2, "EnumStringBody", { enumerable: true, get: function() {
          return _index.enumStringBody;
        } }), Object.defineProperty(exports2, "EnumStringMember", { enumerable: true, get: function() {
          return _index.enumStringMember;
        } }), Object.defineProperty(exports2, "EnumSymbolBody", { enumerable: true, get: function() {
          return _index.enumSymbolBody;
        } }), Object.defineProperty(exports2, "ExistsTypeAnnotation", { enumerable: true, get: function() {
          return _index.existsTypeAnnotation;
        } }), Object.defineProperty(exports2, "ExportAllDeclaration", { enumerable: true, get: function() {
          return _index.exportAllDeclaration;
        } }), Object.defineProperty(exports2, "ExportDefaultDeclaration", { enumerable: true, get: function() {
          return _index.exportDefaultDeclaration;
        } }), Object.defineProperty(exports2, "ExportDefaultSpecifier", { enumerable: true, get: function() {
          return _index.exportDefaultSpecifier;
        } }), Object.defineProperty(exports2, "ExportNamedDeclaration", { enumerable: true, get: function() {
          return _index.exportNamedDeclaration;
        } }), Object.defineProperty(exports2, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
          return _index.exportNamespaceSpecifier;
        } }), Object.defineProperty(exports2, "ExportSpecifier", { enumerable: true, get: function() {
          return _index.exportSpecifier;
        } }), Object.defineProperty(exports2, "ExpressionStatement", { enumerable: true, get: function() {
          return _index.expressionStatement;
        } }), Object.defineProperty(exports2, "File", { enumerable: true, get: function() {
          return _index.file;
        } }), Object.defineProperty(exports2, "ForInStatement", { enumerable: true, get: function() {
          return _index.forInStatement;
        } }), Object.defineProperty(exports2, "ForOfStatement", { enumerable: true, get: function() {
          return _index.forOfStatement;
        } }), Object.defineProperty(exports2, "ForStatement", { enumerable: true, get: function() {
          return _index.forStatement;
        } }), Object.defineProperty(exports2, "FunctionDeclaration", { enumerable: true, get: function() {
          return _index.functionDeclaration;
        } }), Object.defineProperty(exports2, "FunctionExpression", { enumerable: true, get: function() {
          return _index.functionExpression;
        } }), Object.defineProperty(exports2, "FunctionTypeAnnotation", { enumerable: true, get: function() {
          return _index.functionTypeAnnotation;
        } }), Object.defineProperty(exports2, "FunctionTypeParam", { enumerable: true, get: function() {
          return _index.functionTypeParam;
        } }), Object.defineProperty(exports2, "GenericTypeAnnotation", { enumerable: true, get: function() {
          return _index.genericTypeAnnotation;
        } }), Object.defineProperty(exports2, "Identifier", { enumerable: true, get: function() {
          return _index.identifier;
        } }), Object.defineProperty(exports2, "IfStatement", { enumerable: true, get: function() {
          return _index.ifStatement;
        } }), Object.defineProperty(exports2, "Import", { enumerable: true, get: function() {
          return _index.import;
        } }), Object.defineProperty(exports2, "ImportAttribute", { enumerable: true, get: function() {
          return _index.importAttribute;
        } }), Object.defineProperty(exports2, "ImportDeclaration", { enumerable: true, get: function() {
          return _index.importDeclaration;
        } }), Object.defineProperty(exports2, "ImportDefaultSpecifier", { enumerable: true, get: function() {
          return _index.importDefaultSpecifier;
        } }), Object.defineProperty(exports2, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
          return _index.importNamespaceSpecifier;
        } }), Object.defineProperty(exports2, "ImportSpecifier", { enumerable: true, get: function() {
          return _index.importSpecifier;
        } }), Object.defineProperty(exports2, "IndexedAccessType", { enumerable: true, get: function() {
          return _index.indexedAccessType;
        } }), Object.defineProperty(exports2, "InferredPredicate", { enumerable: true, get: function() {
          return _index.inferredPredicate;
        } }), Object.defineProperty(exports2, "InterfaceDeclaration", { enumerable: true, get: function() {
          return _index.interfaceDeclaration;
        } }), Object.defineProperty(exports2, "InterfaceExtends", { enumerable: true, get: function() {
          return _index.interfaceExtends;
        } }), Object.defineProperty(exports2, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
          return _index.interfaceTypeAnnotation;
        } }), Object.defineProperty(exports2, "InterpreterDirective", { enumerable: true, get: function() {
          return _index.interpreterDirective;
        } }), Object.defineProperty(exports2, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
          return _index.intersectionTypeAnnotation;
        } }), Object.defineProperty(exports2, "JSXAttribute", { enumerable: true, get: function() {
          return _index.jsxAttribute;
        } }), Object.defineProperty(exports2, "JSXClosingElement", { enumerable: true, get: function() {
          return _index.jsxClosingElement;
        } }), Object.defineProperty(exports2, "JSXClosingFragment", { enumerable: true, get: function() {
          return _index.jsxClosingFragment;
        } }), Object.defineProperty(exports2, "JSXElement", { enumerable: true, get: function() {
          return _index.jsxElement;
        } }), Object.defineProperty(exports2, "JSXEmptyExpression", { enumerable: true, get: function() {
          return _index.jsxEmptyExpression;
        } }), Object.defineProperty(exports2, "JSXExpressionContainer", { enumerable: true, get: function() {
          return _index.jsxExpressionContainer;
        } }), Object.defineProperty(exports2, "JSXFragment", { enumerable: true, get: function() {
          return _index.jsxFragment;
        } }), Object.defineProperty(exports2, "JSXIdentifier", { enumerable: true, get: function() {
          return _index.jsxIdentifier;
        } }), Object.defineProperty(exports2, "JSXMemberExpression", { enumerable: true, get: function() {
          return _index.jsxMemberExpression;
        } }), Object.defineProperty(exports2, "JSXNamespacedName", { enumerable: true, get: function() {
          return _index.jsxNamespacedName;
        } }), Object.defineProperty(exports2, "JSXOpeningElement", { enumerable: true, get: function() {
          return _index.jsxOpeningElement;
        } }), Object.defineProperty(exports2, "JSXOpeningFragment", { enumerable: true, get: function() {
          return _index.jsxOpeningFragment;
        } }), Object.defineProperty(exports2, "JSXSpreadAttribute", { enumerable: true, get: function() {
          return _index.jsxSpreadAttribute;
        } }), Object.defineProperty(exports2, "JSXSpreadChild", { enumerable: true, get: function() {
          return _index.jsxSpreadChild;
        } }), Object.defineProperty(exports2, "JSXText", { enumerable: true, get: function() {
          return _index.jsxText;
        } }), Object.defineProperty(exports2, "LabeledStatement", { enumerable: true, get: function() {
          return _index.labeledStatement;
        } }), Object.defineProperty(exports2, "LogicalExpression", { enumerable: true, get: function() {
          return _index.logicalExpression;
        } }), Object.defineProperty(exports2, "MemberExpression", { enumerable: true, get: function() {
          return _index.memberExpression;
        } }), Object.defineProperty(exports2, "MetaProperty", { enumerable: true, get: function() {
          return _index.metaProperty;
        } }), Object.defineProperty(exports2, "MixedTypeAnnotation", { enumerable: true, get: function() {
          return _index.mixedTypeAnnotation;
        } }), Object.defineProperty(exports2, "ModuleExpression", { enumerable: true, get: function() {
          return _index.moduleExpression;
        } }), Object.defineProperty(exports2, "NewExpression", { enumerable: true, get: function() {
          return _index.newExpression;
        } }), Object.defineProperty(exports2, "Noop", { enumerable: true, get: function() {
          return _index.noop;
        } }), Object.defineProperty(exports2, "NullLiteral", { enumerable: true, get: function() {
          return _index.nullLiteral;
        } }), Object.defineProperty(exports2, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(exports2, "NullableTypeAnnotation", { enumerable: true, get: function() {
          return _index.nullableTypeAnnotation;
        } }), Object.defineProperty(exports2, "NumberLiteral", { enumerable: true, get: function() {
          return _index.numberLiteral;
        } }), Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(exports2, "NumberTypeAnnotation", { enumerable: true, get: function() {
          return _index.numberTypeAnnotation;
        } }), Object.defineProperty(exports2, "NumericLiteral", { enumerable: true, get: function() {
          return _index.numericLiteral;
        } }), Object.defineProperty(exports2, "ObjectExpression", { enumerable: true, get: function() {
          return _index.objectExpression;
        } }), Object.defineProperty(exports2, "ObjectMethod", { enumerable: true, get: function() {
          return _index.objectMethod;
        } }), Object.defineProperty(exports2, "ObjectPattern", { enumerable: true, get: function() {
          return _index.objectPattern;
        } }), Object.defineProperty(exports2, "ObjectProperty", { enumerable: true, get: function() {
          return _index.objectProperty;
        } }), Object.defineProperty(exports2, "ObjectTypeAnnotation", { enumerable: true, get: function() {
          return _index.objectTypeAnnotation;
        } }), Object.defineProperty(exports2, "ObjectTypeCallProperty", { enumerable: true, get: function() {
          return _index.objectTypeCallProperty;
        } }), Object.defineProperty(exports2, "ObjectTypeIndexer", { enumerable: true, get: function() {
          return _index.objectTypeIndexer;
        } }), Object.defineProperty(exports2, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
          return _index.objectTypeInternalSlot;
        } }), Object.defineProperty(exports2, "ObjectTypeProperty", { enumerable: true, get: function() {
          return _index.objectTypeProperty;
        } }), Object.defineProperty(exports2, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
          return _index.objectTypeSpreadProperty;
        } }), Object.defineProperty(exports2, "OpaqueType", { enumerable: true, get: function() {
          return _index.opaqueType;
        } }), Object.defineProperty(exports2, "OptionalCallExpression", { enumerable: true, get: function() {
          return _index.optionalCallExpression;
        } }), Object.defineProperty(exports2, "OptionalIndexedAccessType", { enumerable: true, get: function() {
          return _index.optionalIndexedAccessType;
        } }), Object.defineProperty(exports2, "OptionalMemberExpression", { enumerable: true, get: function() {
          return _index.optionalMemberExpression;
        } }), Object.defineProperty(exports2, "ParenthesizedExpression", { enumerable: true, get: function() {
          return _index.parenthesizedExpression;
        } }), Object.defineProperty(exports2, "PipelineBareFunction", { enumerable: true, get: function() {
          return _index.pipelineBareFunction;
        } }), Object.defineProperty(exports2, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
          return _index.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(exports2, "PipelineTopicExpression", { enumerable: true, get: function() {
          return _index.pipelineTopicExpression;
        } }), Object.defineProperty(exports2, "Placeholder", { enumerable: true, get: function() {
          return _index.placeholder;
        } }), Object.defineProperty(exports2, "PrivateName", { enumerable: true, get: function() {
          return _index.privateName;
        } }), Object.defineProperty(exports2, "Program", { enumerable: true, get: function() {
          return _index.program;
        } }), Object.defineProperty(exports2, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
          return _index.qualifiedTypeIdentifier;
        } }), Object.defineProperty(exports2, "RecordExpression", { enumerable: true, get: function() {
          return _index.recordExpression;
        } }), Object.defineProperty(exports2, "RegExpLiteral", { enumerable: true, get: function() {
          return _index.regExpLiteral;
        } }), Object.defineProperty(exports2, "RegexLiteral", { enumerable: true, get: function() {
          return _index.regexLiteral;
        } }), Object.defineProperty(exports2, "RestElement", { enumerable: true, get: function() {
          return _index.restElement;
        } }), Object.defineProperty(exports2, "RestProperty", { enumerable: true, get: function() {
          return _index.restProperty;
        } }), Object.defineProperty(exports2, "ReturnStatement", { enumerable: true, get: function() {
          return _index.returnStatement;
        } }), Object.defineProperty(exports2, "SequenceExpression", { enumerable: true, get: function() {
          return _index.sequenceExpression;
        } }), Object.defineProperty(exports2, "SpreadElement", { enumerable: true, get: function() {
          return _index.spreadElement;
        } }), Object.defineProperty(exports2, "SpreadProperty", { enumerable: true, get: function() {
          return _index.spreadProperty;
        } }), Object.defineProperty(exports2, "StaticBlock", { enumerable: true, get: function() {
          return _index.staticBlock;
        } }), Object.defineProperty(exports2, "StringLiteral", { enumerable: true, get: function() {
          return _index.stringLiteral;
        } }), Object.defineProperty(exports2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return _index.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(exports2, "StringTypeAnnotation", { enumerable: true, get: function() {
          return _index.stringTypeAnnotation;
        } }), Object.defineProperty(exports2, "Super", { enumerable: true, get: function() {
          return _index.super;
        } }), Object.defineProperty(exports2, "SwitchCase", { enumerable: true, get: function() {
          return _index.switchCase;
        } }), Object.defineProperty(exports2, "SwitchStatement", { enumerable: true, get: function() {
          return _index.switchStatement;
        } }), Object.defineProperty(exports2, "SymbolTypeAnnotation", { enumerable: true, get: function() {
          return _index.symbolTypeAnnotation;
        } }), Object.defineProperty(exports2, "TSAnyKeyword", { enumerable: true, get: function() {
          return _index.tsAnyKeyword;
        } }), Object.defineProperty(exports2, "TSArrayType", { enumerable: true, get: function() {
          return _index.tsArrayType;
        } }), Object.defineProperty(exports2, "TSAsExpression", { enumerable: true, get: function() {
          return _index.tsAsExpression;
        } }), Object.defineProperty(exports2, "TSBigIntKeyword", { enumerable: true, get: function() {
          return _index.tsBigIntKeyword;
        } }), Object.defineProperty(exports2, "TSBooleanKeyword", { enumerable: true, get: function() {
          return _index.tsBooleanKeyword;
        } }), Object.defineProperty(exports2, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
          return _index.tsCallSignatureDeclaration;
        } }), Object.defineProperty(exports2, "TSConditionalType", { enumerable: true, get: function() {
          return _index.tsConditionalType;
        } }), Object.defineProperty(exports2, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
          return _index.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(exports2, "TSConstructorType", { enumerable: true, get: function() {
          return _index.tsConstructorType;
        } }), Object.defineProperty(exports2, "TSDeclareFunction", { enumerable: true, get: function() {
          return _index.tsDeclareFunction;
        } }), Object.defineProperty(exports2, "TSDeclareMethod", { enumerable: true, get: function() {
          return _index.tsDeclareMethod;
        } }), Object.defineProperty(exports2, "TSEnumDeclaration", { enumerable: true, get: function() {
          return _index.tsEnumDeclaration;
        } }), Object.defineProperty(exports2, "TSEnumMember", { enumerable: true, get: function() {
          return _index.tsEnumMember;
        } }), Object.defineProperty(exports2, "TSExportAssignment", { enumerable: true, get: function() {
          return _index.tsExportAssignment;
        } }), Object.defineProperty(exports2, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
          return _index.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(exports2, "TSExternalModuleReference", { enumerable: true, get: function() {
          return _index.tsExternalModuleReference;
        } }), Object.defineProperty(exports2, "TSFunctionType", { enumerable: true, get: function() {
          return _index.tsFunctionType;
        } }), Object.defineProperty(exports2, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
          return _index.tsImportEqualsDeclaration;
        } }), Object.defineProperty(exports2, "TSImportType", { enumerable: true, get: function() {
          return _index.tsImportType;
        } }), Object.defineProperty(exports2, "TSIndexSignature", { enumerable: true, get: function() {
          return _index.tsIndexSignature;
        } }), Object.defineProperty(exports2, "TSIndexedAccessType", { enumerable: true, get: function() {
          return _index.tsIndexedAccessType;
        } }), Object.defineProperty(exports2, "TSInferType", { enumerable: true, get: function() {
          return _index.tsInferType;
        } }), Object.defineProperty(exports2, "TSInterfaceBody", { enumerable: true, get: function() {
          return _index.tsInterfaceBody;
        } }), Object.defineProperty(exports2, "TSInterfaceDeclaration", { enumerable: true, get: function() {
          return _index.tsInterfaceDeclaration;
        } }), Object.defineProperty(exports2, "TSIntersectionType", { enumerable: true, get: function() {
          return _index.tsIntersectionType;
        } }), Object.defineProperty(exports2, "TSIntrinsicKeyword", { enumerable: true, get: function() {
          return _index.tsIntrinsicKeyword;
        } }), Object.defineProperty(exports2, "TSLiteralType", { enumerable: true, get: function() {
          return _index.tsLiteralType;
        } }), Object.defineProperty(exports2, "TSMappedType", { enumerable: true, get: function() {
          return _index.tsMappedType;
        } }), Object.defineProperty(exports2, "TSMethodSignature", { enumerable: true, get: function() {
          return _index.tsMethodSignature;
        } }), Object.defineProperty(exports2, "TSModuleBlock", { enumerable: true, get: function() {
          return _index.tsModuleBlock;
        } }), Object.defineProperty(exports2, "TSModuleDeclaration", { enumerable: true, get: function() {
          return _index.tsModuleDeclaration;
        } }), Object.defineProperty(exports2, "TSNamedTupleMember", { enumerable: true, get: function() {
          return _index.tsNamedTupleMember;
        } }), Object.defineProperty(exports2, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
          return _index.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(exports2, "TSNeverKeyword", { enumerable: true, get: function() {
          return _index.tsNeverKeyword;
        } }), Object.defineProperty(exports2, "TSNonNullExpression", { enumerable: true, get: function() {
          return _index.tsNonNullExpression;
        } }), Object.defineProperty(exports2, "TSNullKeyword", { enumerable: true, get: function() {
          return _index.tsNullKeyword;
        } }), Object.defineProperty(exports2, "TSNumberKeyword", { enumerable: true, get: function() {
          return _index.tsNumberKeyword;
        } }), Object.defineProperty(exports2, "TSObjectKeyword", { enumerable: true, get: function() {
          return _index.tsObjectKeyword;
        } }), Object.defineProperty(exports2, "TSOptionalType", { enumerable: true, get: function() {
          return _index.tsOptionalType;
        } }), Object.defineProperty(exports2, "TSParameterProperty", { enumerable: true, get: function() {
          return _index.tsParameterProperty;
        } }), Object.defineProperty(exports2, "TSParenthesizedType", { enumerable: true, get: function() {
          return _index.tsParenthesizedType;
        } }), Object.defineProperty(exports2, "TSPropertySignature", { enumerable: true, get: function() {
          return _index.tsPropertySignature;
        } }), Object.defineProperty(exports2, "TSQualifiedName", { enumerable: true, get: function() {
          return _index.tsQualifiedName;
        } }), Object.defineProperty(exports2, "TSRestType", { enumerable: true, get: function() {
          return _index.tsRestType;
        } }), Object.defineProperty(exports2, "TSStringKeyword", { enumerable: true, get: function() {
          return _index.tsStringKeyword;
        } }), Object.defineProperty(exports2, "TSSymbolKeyword", { enumerable: true, get: function() {
          return _index.tsSymbolKeyword;
        } }), Object.defineProperty(exports2, "TSThisType", { enumerable: true, get: function() {
          return _index.tsThisType;
        } }), Object.defineProperty(exports2, "TSTupleType", { enumerable: true, get: function() {
          return _index.tsTupleType;
        } }), Object.defineProperty(exports2, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
          return _index.tsTypeAliasDeclaration;
        } }), Object.defineProperty(exports2, "TSTypeAnnotation", { enumerable: true, get: function() {
          return _index.tsTypeAnnotation;
        } }), Object.defineProperty(exports2, "TSTypeAssertion", { enumerable: true, get: function() {
          return _index.tsTypeAssertion;
        } }), Object.defineProperty(exports2, "TSTypeLiteral", { enumerable: true, get: function() {
          return _index.tsTypeLiteral;
        } }), Object.defineProperty(exports2, "TSTypeOperator", { enumerable: true, get: function() {
          return _index.tsTypeOperator;
        } }), Object.defineProperty(exports2, "TSTypeParameter", { enumerable: true, get: function() {
          return _index.tsTypeParameter;
        } }), Object.defineProperty(exports2, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
          return _index.tsTypeParameterDeclaration;
        } }), Object.defineProperty(exports2, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
          return _index.tsTypeParameterInstantiation;
        } }), Object.defineProperty(exports2, "TSTypePredicate", { enumerable: true, get: function() {
          return _index.tsTypePredicate;
        } }), Object.defineProperty(exports2, "TSTypeQuery", { enumerable: true, get: function() {
          return _index.tsTypeQuery;
        } }), Object.defineProperty(exports2, "TSTypeReference", { enumerable: true, get: function() {
          return _index.tsTypeReference;
        } }), Object.defineProperty(exports2, "TSUndefinedKeyword", { enumerable: true, get: function() {
          return _index.tsUndefinedKeyword;
        } }), Object.defineProperty(exports2, "TSUnionType", { enumerable: true, get: function() {
          return _index.tsUnionType;
        } }), Object.defineProperty(exports2, "TSUnknownKeyword", { enumerable: true, get: function() {
          return _index.tsUnknownKeyword;
        } }), Object.defineProperty(exports2, "TSVoidKeyword", { enumerable: true, get: function() {
          return _index.tsVoidKeyword;
        } }), Object.defineProperty(exports2, "TaggedTemplateExpression", { enumerable: true, get: function() {
          return _index.taggedTemplateExpression;
        } }), Object.defineProperty(exports2, "TemplateElement", { enumerable: true, get: function() {
          return _index.templateElement;
        } }), Object.defineProperty(exports2, "TemplateLiteral", { enumerable: true, get: function() {
          return _index.templateLiteral;
        } }), Object.defineProperty(exports2, "ThisExpression", { enumerable: true, get: function() {
          return _index.thisExpression;
        } }), Object.defineProperty(exports2, "ThisTypeAnnotation", { enumerable: true, get: function() {
          return _index.thisTypeAnnotation;
        } }), Object.defineProperty(exports2, "ThrowStatement", { enumerable: true, get: function() {
          return _index.throwStatement;
        } }), Object.defineProperty(exports2, "TopicReference", { enumerable: true, get: function() {
          return _index.topicReference;
        } }), Object.defineProperty(exports2, "TryStatement", { enumerable: true, get: function() {
          return _index.tryStatement;
        } }), Object.defineProperty(exports2, "TupleExpression", { enumerable: true, get: function() {
          return _index.tupleExpression;
        } }), Object.defineProperty(exports2, "TupleTypeAnnotation", { enumerable: true, get: function() {
          return _index.tupleTypeAnnotation;
        } }), Object.defineProperty(exports2, "TypeAlias", { enumerable: true, get: function() {
          return _index.typeAlias;
        } }), Object.defineProperty(exports2, "TypeAnnotation", { enumerable: true, get: function() {
          return _index.typeAnnotation;
        } }), Object.defineProperty(exports2, "TypeCastExpression", { enumerable: true, get: function() {
          return _index.typeCastExpression;
        } }), Object.defineProperty(exports2, "TypeParameter", { enumerable: true, get: function() {
          return _index.typeParameter;
        } }), Object.defineProperty(exports2, "TypeParameterDeclaration", { enumerable: true, get: function() {
          return _index.typeParameterDeclaration;
        } }), Object.defineProperty(exports2, "TypeParameterInstantiation", { enumerable: true, get: function() {
          return _index.typeParameterInstantiation;
        } }), Object.defineProperty(exports2, "TypeofTypeAnnotation", { enumerable: true, get: function() {
          return _index.typeofTypeAnnotation;
        } }), Object.defineProperty(exports2, "UnaryExpression", { enumerable: true, get: function() {
          return _index.unaryExpression;
        } }), Object.defineProperty(exports2, "UnionTypeAnnotation", { enumerable: true, get: function() {
          return _index.unionTypeAnnotation;
        } }), Object.defineProperty(exports2, "UpdateExpression", { enumerable: true, get: function() {
          return _index.updateExpression;
        } }), Object.defineProperty(exports2, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
          return _index.v8IntrinsicIdentifier;
        } }), Object.defineProperty(exports2, "VariableDeclaration", { enumerable: true, get: function() {
          return _index.variableDeclaration;
        } }), Object.defineProperty(exports2, "VariableDeclarator", { enumerable: true, get: function() {
          return _index.variableDeclarator;
        } }), Object.defineProperty(exports2, "Variance", { enumerable: true, get: function() {
          return _index.variance;
        } }), Object.defineProperty(exports2, "VoidTypeAnnotation", { enumerable: true, get: function() {
          return _index.voidTypeAnnotation;
        } }), Object.defineProperty(exports2, "WhileStatement", { enumerable: true, get: function() {
          return _index.whileStatement;
        } }), Object.defineProperty(exports2, "WithStatement", { enumerable: true, get: function() {
          return _index.withStatement;
        } }), Object.defineProperty(exports2, "YieldExpression", { enumerable: true, get: function() {
          return _index.yieldExpression;
        } });
        var _index = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/builders/react/buildChildren.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          const elements = [];
          for (let i = 0; i < node.children.length; i++) {
            let child = node.children[i];
            (0, _generated.isJSXText)(child) ? (0, _cleanJSXElementLiteralChild.default)(child, elements) : ((0, _generated.isJSXExpressionContainer)(child) && (child = child.expression), (0, _generated.isJSXEmptyExpression)(child) || elements.push(child));
          }
          return elements;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _cleanJSXElementLiteralChild = __webpack_require__2("./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(typeAnnotations) {
          const types = typeAnnotations.map((type) => type.typeAnnotation), flattened = (0, _removeTypeDuplicates.default)(types);
          return flattened.length === 1 ? flattened[0] : (0, _generated.tsUnionType)(flattened);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js");
      }, "./node_modules/@babel/types/lib/clone/clone.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _cloneNode.default)(node, false);
        };
        var _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/@babel/types/lib/clone/cloneDeep.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _cloneNode.default)(node);
        };
        var _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _cloneNode.default)(node, true, true);
        };
        var _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/@babel/types/lib/clone/cloneNode.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = cloneNode;
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js"), _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
        const has = Function.call.bind(Object.prototype.hasOwnProperty);
        function cloneIfNode(obj, deep, withoutLoc) {
          return obj && typeof obj.type == "string" ? cloneNode(obj, deep, withoutLoc) : obj;
        }
        function cloneIfNodeOrArray(obj, deep, withoutLoc) {
          return Array.isArray(obj) ? obj.map((node) => cloneIfNode(node, deep, withoutLoc)) : cloneIfNode(obj, deep, withoutLoc);
        }
        function cloneNode(node, deep = true, withoutLoc = false) {
          if (!node)
            return node;
          const { type } = node, newNode = { type: node.type };
          if ((0, _generated.isIdentifier)(node))
            newNode.name = node.name, has(node, "optional") && typeof node.optional == "boolean" && (newNode.optional = node.optional), has(node, "typeAnnotation") && (newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation);
          else {
            if (!has(_definitions.NODE_FIELDS, type))
              throw new Error(`Unknown node type: "${type}"`);
            for (const field of Object.keys(_definitions.NODE_FIELDS[type]))
              has(node, field) && (newNode[field] = deep ? (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc) : node[field]);
          }
          return has(node, "loc") && (newNode.loc = withoutLoc ? null : node.loc), has(node, "leadingComments") && (newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc)), has(node, "innerComments") && (newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc)), has(node, "trailingComments") && (newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc)), has(node, "extra") && (newNode.extra = Object.assign({}, node.extra)), newNode;
        }
        function maybeCloneComments(comments, deep, withoutLoc) {
          return comments && deep ? comments.map(({ type, value, loc }) => withoutLoc ? { type, value, loc: null } : { type, value, loc }) : comments;
        }
      }, "./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _cloneNode.default)(node, false, true);
        };
        var _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/@babel/types/lib/comments/addComment.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, type, content, line) {
          return (0, _addComments.default)(node, type, [{ type: line ? "CommentLine" : "CommentBlock", value: content }]);
        };
        var _addComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/@babel/types/lib/comments/addComments.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, type, comments) {
          if (!comments || !node)
            return node;
          const key = `${type}Comments`;
          node[key] ? type === "leading" ? node[key] = comments.concat(node[key]) : node[key].push(...comments) : node[key] = comments;
          return node;
        };
      }, "./node_modules/@babel/types/lib/comments/inheritInnerComments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, parent) {
          (0, _inherit.default)("innerComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/@babel/types/lib/comments/inheritLeadingComments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, parent) {
          (0, _inherit.default)("leadingComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/@babel/types/lib/comments/inheritTrailingComments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, parent) {
          (0, _inherit.default)("trailingComments", child, parent);
        };
        var _inherit = __webpack_require__2("./node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/@babel/types/lib/comments/inheritsComments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, parent) {
          return (0, _inheritTrailingComments.default)(child, parent), (0, _inheritLeadingComments.default)(child, parent), (0, _inheritInnerComments.default)(child, parent), child;
        };
        var _inheritTrailingComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), _inheritLeadingComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), _inheritInnerComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/@babel/types/lib/comments/removeComments.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return _constants.COMMENT_KEYS.forEach((key) => {
            node[key] = null;
          }), node;
        };
        var _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/@babel/types/lib/constants/generated/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.WHILE_TYPES = exports2.USERWHITESPACABLE_TYPES = exports2.UNARYLIKE_TYPES = exports2.TYPESCRIPT_TYPES = exports2.TSTYPE_TYPES = exports2.TSTYPEELEMENT_TYPES = exports2.TSENTITYNAME_TYPES = exports2.TSBASETYPE_TYPES = exports2.TERMINATORLESS_TYPES = exports2.STATEMENT_TYPES = exports2.STANDARDIZED_TYPES = exports2.SCOPABLE_TYPES = exports2.PUREISH_TYPES = exports2.PROPERTY_TYPES = exports2.PRIVATE_TYPES = exports2.PATTERN_TYPES = exports2.PATTERNLIKE_TYPES = exports2.OBJECTMEMBER_TYPES = exports2.MODULESPECIFIER_TYPES = exports2.MODULEDECLARATION_TYPES = exports2.MISCELLANEOUS_TYPES = exports2.METHOD_TYPES = exports2.LVAL_TYPES = exports2.LOOP_TYPES = exports2.LITERAL_TYPES = exports2.JSX_TYPES = exports2.IMMUTABLE_TYPES = exports2.FUNCTION_TYPES = exports2.FUNCTIONPARENT_TYPES = exports2.FOR_TYPES = exports2.FORXSTATEMENT_TYPES = exports2.FLOW_TYPES = exports2.FLOWTYPE_TYPES = exports2.FLOWPREDICATE_TYPES = exports2.FLOWDECLARATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = exports2.EXPRESSION_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = exports2.EXPORTDECLARATION_TYPES = exports2.ENUMMEMBER_TYPES = exports2.ENUMBODY_TYPES = exports2.DECLARATION_TYPES = exports2.CONDITIONAL_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = exports2.CLASS_TYPES = exports2.BLOCK_TYPES = exports2.BLOCKPARENT_TYPES = exports2.BINARY_TYPES = void 0;
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
        const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Standardized;
        exports2.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
        const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Expression;
        exports2.EXPRESSION_TYPES = EXPRESSION_TYPES;
        const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Binary;
        exports2.BINARY_TYPES = BINARY_TYPES;
        const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Scopable;
        exports2.SCOPABLE_TYPES = SCOPABLE_TYPES;
        const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.BlockParent;
        exports2.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
        const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Block;
        exports2.BLOCK_TYPES = BLOCK_TYPES;
        const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Statement;
        exports2.STATEMENT_TYPES = STATEMENT_TYPES;
        const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Terminatorless;
        exports2.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
        const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.CompletionStatement;
        exports2.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
        const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Conditional;
        exports2.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
        const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Loop;
        exports2.LOOP_TYPES = LOOP_TYPES;
        const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.While;
        exports2.WHILE_TYPES = WHILE_TYPES;
        const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
        exports2.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
        const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.For;
        exports2.FOR_TYPES = FOR_TYPES;
        const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ForXStatement;
        exports2.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
        const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Function;
        exports2.FUNCTION_TYPES = FUNCTION_TYPES;
        const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FunctionParent;
        exports2.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
        const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pureish;
        exports2.PUREISH_TYPES = PUREISH_TYPES;
        const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Declaration;
        exports2.DECLARATION_TYPES = DECLARATION_TYPES;
        const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.PatternLike;
        exports2.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
        const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.LVal;
        exports2.LVAL_TYPES = LVAL_TYPES;
        const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSEntityName;
        exports2.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
        const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Literal;
        exports2.LITERAL_TYPES = LITERAL_TYPES;
        const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Immutable;
        exports2.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
        const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UserWhitespacable;
        exports2.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
        const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Method;
        exports2.METHOD_TYPES = METHOD_TYPES;
        const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ObjectMember;
        exports2.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
        const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Property;
        exports2.PROPERTY_TYPES = PROPERTY_TYPES;
        const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UnaryLike;
        exports2.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
        const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pattern;
        exports2.PATTERN_TYPES = PATTERN_TYPES;
        const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Class;
        exports2.CLASS_TYPES = CLASS_TYPES;
        const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
        exports2.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
        const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExportDeclaration;
        exports2.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
        const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
        exports2.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
        const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Private;
        exports2.PRIVATE_TYPES = PRIVATE_TYPES;
        const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Flow;
        exports2.FLOW_TYPES = FLOW_TYPES;
        const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowType;
        exports2.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
        const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
        exports2.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
        const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowDeclaration;
        exports2.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
        const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowPredicate;
        exports2.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
        const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumBody;
        exports2.ENUMBODY_TYPES = ENUMBODY_TYPES;
        const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumMember;
        exports2.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
        const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS.JSX;
        exports2.JSX_TYPES = JSX_TYPES;
        const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Miscellaneous;
        exports2.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
        const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TypeScript;
        exports2.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
        const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSTypeElement;
        exports2.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
        const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSType;
        exports2.TSTYPE_TYPES = TSTYPE_TYPES;
        const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSBaseType;
        exports2.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
      }, "./node_modules/@babel/types/lib/constants/index.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.UPDATE_OPERATORS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.STATEMENT_OR_BLOCK_KEYS = exports2.NUMBER_UNARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.NOT_LOCAL_BINDING = exports2.LOGICAL_OPERATORS = exports2.INHERIT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.EQUALITY_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.COMMENT_KEYS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.BLOCK_SCOPED_SYMBOL = exports2.BINARY_OPERATORS = exports2.ASSIGNMENT_OPERATORS = void 0;
        exports2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
        exports2.FLATTENABLE_KEYS = ["body", "expressions"];
        exports2.FOR_INIT_KEYS = ["left", "init"];
        exports2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const LOGICAL_OPERATORS = ["||", "&&", "??"];
        exports2.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
        exports2.UPDATE_OPERATORS = ["++", "--"];
        const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
        exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
        const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
        exports2.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
        const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
        exports2.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
        const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
        exports2.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
        const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
        exports2.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
        const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
        exports2.BINARY_OPERATORS = BINARY_OPERATORS;
        const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
        exports2.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
        const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
        exports2.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
        const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
        exports2.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
        const STRING_UNARY_OPERATORS = ["typeof"];
        exports2.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
        const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
        exports2.UNARY_OPERATORS = UNARY_OPERATORS;
        exports2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
        const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
        exports2.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
        const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
        exports2.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
      }, "./node_modules/@babel/types/lib/converters/ensureBlock.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, key = "body") {
          return node[key] = (0, _toBlock.default)(node[key], node);
        };
        var _toBlock = __webpack_require__2("./node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function gatherSequenceExpressions(nodes, scope, declars) {
          const exprs = [];
          let ensureLastUndefined = true;
          for (const node of nodes)
            if ((0, _generated.isEmptyStatement)(node) || (ensureLastUndefined = false), (0, _generated.isExpression)(node))
              exprs.push(node);
            else if ((0, _generated.isExpressionStatement)(node))
              exprs.push(node.expression);
            else if ((0, _generated.isVariableDeclaration)(node)) {
              if (node.kind !== "var")
                return;
              for (const declar of node.declarations) {
                const bindings = (0, _getBindingIdentifiers.default)(declar);
                for (const key of Object.keys(bindings))
                  declars.push({ kind: node.kind, id: (0, _cloneNode.default)(bindings[key]) });
                declar.init && exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
              }
              ensureLastUndefined = true;
            } else if ((0, _generated.isIfStatement)(node)) {
              const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode(), alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
              if (!consequent || !alternate)
                return;
              exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
            } else if ((0, _generated.isBlockStatement)(node)) {
              const body = gatherSequenceExpressions(node.body, scope, declars);
              if (!body)
                return;
              exprs.push(body);
            } else {
              if (!(0, _generated.isEmptyStatement)(node))
                return;
              nodes.indexOf(node) === 0 && (ensureLastUndefined = true);
            }
          ensureLastUndefined && exprs.push(scope.buildUndefinedNode());
          return exprs.length === 1 ? exprs[0] : (0, _generated2.sequenceExpression)(exprs);
        };
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(name) {
          (name = (0, _toIdentifier.default)(name)) !== "eval" && name !== "arguments" || (name = "_" + name);
          return name;
        };
        var _toIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/@babel/types/lib/converters/toBlock.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, parent) {
          if ((0, _generated.isBlockStatement)(node))
            return node;
          let blockNodes = [];
          (0, _generated.isEmptyStatement)(node) ? blockNodes = [] : ((0, _generated.isStatement)(node) || (node = (0, _generated.isFunction)(parent) ? (0, _generated2.returnStatement)(node) : (0, _generated2.expressionStatement)(node)), blockNodes = [node]);
          return (0, _generated2.blockStatement)(blockNodes);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/converters/toComputedKey.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, key = node.key || node.property) {
          !node.computed && (0, _generated.isIdentifier)(key) && (key = (0, _generated2.stringLiteral)(key.name));
          return key;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/converters/toExpression.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _default = function(node) {
          (0, _generated.isExpressionStatement)(node) && (node = node.expression);
          if ((0, _generated.isExpression)(node))
            return node;
          (0, _generated.isClass)(node) ? node.type = "ClassExpression" : (0, _generated.isFunction)(node) && (node.type = "FunctionExpression");
          if (!(0, _generated.isExpression)(node))
            throw new Error(`cannot turn ${node.type} to an expression`);
          return node;
        };
        exports2.default = _default;
      }, "./node_modules/@babel/types/lib/converters/toIdentifier.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(input) {
          input += "";
          let name = "";
          for (const c of input)
            name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
          name = name.replace(/^[-0-9]+/, ""), name = name.replace(/[-\s]+(.)?/g, function(match, c) {
            return c ? c.toUpperCase() : "";
          }), (0, _isValidIdentifier.default)(name) || (name = `_${name}`);
          return name || "_";
        };
        var _isValidIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/@babel/types/lib/converters/toKeyAlias.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = toKeyAlias;
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js"), _removePropertiesDeep = __webpack_require__2("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function toKeyAlias(node, key = node.key) {
          let alias;
          return node.kind === "method" ? toKeyAlias.increment() + "" : (alias = (0, _generated.isIdentifier)(key) ? key.name : (0, _generated.isStringLiteral)(key) ? JSON.stringify(key.value) : JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key))), node.computed && (alias = `[${alias}]`), node.static && (alias = `static:${alias}`), alias);
        }
        toKeyAlias.uid = 0, toKeyAlias.increment = function() {
          return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
        };
      }, "./node_modules/@babel/types/lib/converters/toSequenceExpression.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(nodes, scope) {
          if (nodes == null || !nodes.length)
            return;
          const declars = [], result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
          if (!result)
            return;
          for (const declar of declars)
            scope.push(declar);
          return result;
        };
        var _gatherSequenceExpressions = __webpack_require__2("./node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/@babel/types/lib/converters/toStatement.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _generated2 = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _default = function(node, ignore) {
          if ((0, _generated.isStatement)(node))
            return node;
          let newType, mustHaveId = false;
          if ((0, _generated.isClass)(node))
            mustHaveId = true, newType = "ClassDeclaration";
          else if ((0, _generated.isFunction)(node))
            mustHaveId = true, newType = "FunctionDeclaration";
          else if ((0, _generated.isAssignmentExpression)(node))
            return (0, _generated2.expressionStatement)(node);
          mustHaveId && !node.id && (newType = false);
          if (!newType) {
            if (ignore)
              return false;
            throw new Error(`cannot turn ${node.type} to a statement`);
          }
          return node.type = newType, node;
        };
        exports2.default = _default;
      }, "./node_modules/@babel/types/lib/converters/valueToNode.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _isValidIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js"), _default = function valueToNode(value) {
          if (value === void 0)
            return (0, _generated.identifier)("undefined");
          if (value === true || value === false)
            return (0, _generated.booleanLiteral)(value);
          if (value === null)
            return (0, _generated.nullLiteral)();
          if (typeof value == "string")
            return (0, _generated.stringLiteral)(value);
          if (typeof value == "number") {
            let result;
            if (Number.isFinite(value))
              result = (0, _generated.numericLiteral)(Math.abs(value));
            else {
              let numerator;
              numerator = Number.isNaN(value) ? (0, _generated.numericLiteral)(0) : (0, _generated.numericLiteral)(1), result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
            }
            return (value < 0 || Object.is(value, -0)) && (result = (0, _generated.unaryExpression)("-", result)), result;
          }
          if (function(value2) {
            return objectToString(value2) === "[object RegExp]";
          }(value)) {
            const pattern = value.source, flags = value.toString().match(/\/([a-z]+|)$/)[1];
            return (0, _generated.regExpLiteral)(pattern, flags);
          }
          if (Array.isArray(value))
            return (0, _generated.arrayExpression)(value.map(valueToNode));
          if (function(value2) {
            if (typeof value2 != "object" || value2 === null || Object.prototype.toString.call(value2) !== "[object Object]")
              return false;
            const proto = Object.getPrototypeOf(value2);
            return proto === null || Object.getPrototypeOf(proto) === null;
          }(value)) {
            const props = [];
            for (const key of Object.keys(value)) {
              let nodeKey;
              nodeKey = (0, _isValidIdentifier.default)(key) ? (0, _generated.identifier)(key) : (0, _generated.stringLiteral)(key), props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
            }
            return (0, _generated.objectExpression)(props);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        exports2.default = _default;
        const objectToString = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/@babel/types/lib/definitions/core.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.patternLikeCommon = exports2.functionTypeAnnotationCommon = exports2.functionDeclarationCommon = exports2.functionCommon = exports2.classMethodOrPropertyCommon = exports2.classMethodOrDeclareMethodCommon = void 0;
        var _is = __webpack_require__2("./node_modules/@babel/types/lib/validators/is.js"), _isValidIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _helperValidatorIdentifier = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/index.js"), _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js"), _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("Standardized");
        defineType("ArrayExpression", { fields: { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), defineType("AssignmentExpression", { fields: { operator: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertValueType)("string");
          const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS), pattern = (0, _utils.assertOneOf)("=");
          return function(node, key, val) {
            ((0, _is.default)("Pattern", node.left) ? pattern : identifier)(node, key, val);
          };
        }() }, left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, _utils.assertNodeType)("LVal") }, right: { validate: (0, _utils.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), defineType("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS) }, left: { validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression"), inOp = (0, _utils.assertNodeType)("Expression", "PrivateName"), validator = function(node, key, val) {
            (node.operator === "in" ? inOp : expression)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "PrivateName"], validator;
        }() }, right: { validate: (0, _utils.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), defineType("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("Directive", { visitor: ["value"], fields: { value: { validate: (0, _utils.assertNodeType)("DirectiveLiteral") } } }), defineType("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), defineType("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), defineType("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier") }, arguments: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, _utils.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), defineType("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), defineType("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, consequent: { validate: (0, _utils.assertNodeType)("Expression") }, alternate: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), defineType("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), defineType("DebuggerStatement", { aliases: ["Statement"] }), defineType("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), defineType("EmptyStatement", { aliases: ["Statement"] }), defineType("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), defineType("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, _utils.assertNodeType)("Program") }, comments: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, _utils.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: true } } }), defineType("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, _utils.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, update: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, body: { validate: (0, _utils.assertNodeType)("Statement") } } });
        const functionCommon = { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } };
        exports2.functionCommon = functionCommon;
        const functionTypeAnnotationCommon = { returnType: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } };
        exports2.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
        const functionDeclarationCommon = Object.assign({}, functionCommon, { declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true } });
        exports2.functionDeclarationCommon = functionDeclarationCommon, defineType("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return () => {
            };
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
          };
        }() }), defineType("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, { id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }) });
        const patternLikeCommon = { typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))) } };
        exports2.patternLikeCommon = patternLikeCommon, defineType("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, patternLikeCommon, { name: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, _isValidIdentifier.default)(val, false))
            throw new TypeError(`"${val}" is not a valid identifier name`);
        }, { type: "string" })) }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }), validate(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /\.(\w+)$/.exec(key);
          if (!match)
            return;
          const [, parentKey] = match, nonComp = { computed: false };
          if (parentKey === "property") {
            if ((0, _is.default)("MemberExpression", parent, nonComp))
              return;
            if ((0, _is.default)("OptionalMemberExpression", parent, nonComp))
              return;
          } else if (parentKey === "key") {
            if ((0, _is.default)("Property", parent, nonComp))
              return;
            if ((0, _is.default)("Method", parent, nonComp))
              return;
          } else if (parentKey === "exported") {
            if ((0, _is.default)("ExportSpecifier", parent))
              return;
          } else if (parentKey === "imported") {
            if ((0, _is.default)("ImportSpecifier", parent, { imported: node }))
              return;
          } else if (parentKey === "meta" && (0, _is.default)("MetaProperty", parent, { meta: node }))
            return;
          if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this")
            throw new TypeError(`"${node.name}" is not a valid identifier`);
        } }), defineType("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, consequent: { validate: (0, _utils.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, _utils.assertNodeType)("Identifier") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, _utils.assertValueType)("number") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, _utils.assertValueType)("string") }, flags: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid)
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }, { type: "string" })), default: "" } } }), defineType("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS) }, left: { validate: (0, _utils.assertNodeType)("Expression") }, right: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("MemberExpression", { builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, _utils.assertNodeType)("Expression") }, property: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], validator;
        }() }, computed: { default: false } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, _utils.assertOneOf)(true, false), optional: true } }) }), defineType("NewExpression", { inherits: "CallExpression" }), defineType("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, _utils.assertValueType)("string") }, sourceType: { validate: (0, _utils.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, _utils.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), defineType("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), defineType("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, { kind: Object.assign({ validate: (0, _utils.assertOneOf)("method", "get", "set") }, process.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"], validator;
        }() }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), defineType("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"], validator;
        }() }, value: { validate: (0, _utils.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, { type: "boolean" }), function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !(0, _is.default)("Identifier", node.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }), default: false }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
          const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern"), expression = (0, _utils.assertNodeType)("Expression");
          return function(parent, key, node) {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return;
            ((0, _is.default)("ObjectPattern", parent) ? pattern : expression)(node, "value", node.value);
          };
        }() }), defineType("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, patternLikeCommon, { argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression") : (0, _utils.assertNodeType)("LVal") }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }), validate(parent, key) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const match = /(\w+)\[(\d+)\]/.exec(key);
          if (!match)
            throw new Error("Internal Babel error: malformed key.");
          const [, listKey, index] = match;
          if (parent[listKey].length > index + 1)
            throw new TypeError(`RestElement must be last element of ${listKey}`);
        } }), defineType("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression"), optional: true } } }), defineType("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), defineType("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } } }), defineType("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, _utils.assertNodeType)("Expression") }, cases: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase"))) } } }), defineType("ThisExpression", { aliases: ["Expression"] }), defineType("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node) {
          if (process.env.BABEL_TYPES_8_BREAKING && !node.handler && !node.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, _utils.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, _utils.assertNodeType)("BlockStatement") } } }), defineType("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, _utils.assertNodeType)("Expression") }, operator: { validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), defineType("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression") : (0, _utils.assertNodeType)("Expression") }, operator: { validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), defineType("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, kind: { validate: (0, _utils.assertOneOf)("var", "let", "const") }, declarations: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator"))) } }, validate(parent, key, node) {
          if (process.env.BABEL_TYPES_8_BREAKING && (0, _is.default)("ForXStatement", parent, { left: node }) && node.declarations.length !== 1)
            throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        } }), defineType("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertNodeType)("LVal");
          const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), without = (0, _utils.assertNodeType)("Identifier");
          return function(node, key, val) {
            (node.init ? normal : without)(node, key, val);
          };
        }() }, definite: { optional: true, validate: (0, _utils.assertValueType)("boolean") }, init: { optional: true, validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") } } }), defineType("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon, { left: { validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression") }, right: { validate: (0, _utils.assertNodeType)("Expression") }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } }) }), defineType("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon, { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike"))) }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }) }), defineType("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, { expression: { validate: (0, _utils.assertValueType)("boolean") }, body: { validate: (0, _utils.assertNodeType)("BlockStatement", "Expression") } }) }), defineType("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature"))) } } }), defineType("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, _utils.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, _utils.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, _utils.assertNodeType)("InterfaceExtends"), optional: true } } }), defineType("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, _utils.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, _utils.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, _utils.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, _utils.assertValueType)("boolean"), optional: true } }, validate: function() {
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            process.env.BABEL_TYPES_8_BREAKING && ((0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id));
          };
        }() }), defineType("ExportAllDeclaration", { visitor: ["source"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, _utils.assertNodeType)("StringLiteral") }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")), assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) } } }), defineType("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression") }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value")) } }), defineType("ExportNamedDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, { oneOfNodeTypes: ["Declaration"] }), function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.source)
            throw new TypeError("Cannot export a declaration from a source");
        }) }, assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(node, key, val) {
            (node.source ? sourced : sourceless)(node, key, val);
          } : sourced;
        }())) }, source: { validate: (0, _utils.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")) } }), defineType("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") }, exported: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, _utils.assertOneOf)("type", "value"), optional: true } } }), defineType("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration"), lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function(node, key, val) {
            (0, _is.default)("VariableDeclaration", val) ? declaration(node, key, val) : lval(node, key, val);
          };
        }() }, right: { validate: (0, _utils.assertNodeType)("Expression") }, body: { validate: (0, _utils.assertNodeType)("Statement") }, await: { default: false } } }), defineType("ImportDeclaration", { visitor: ["specifiers", "source"], aliases: ["Statement", "Declaration", "ModuleDeclaration"], fields: { assertions: { optional: true, validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute"))) }, specifiers: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, _utils.assertNodeType)("StringLiteral") }, importKind: { validate: (0, _utils.assertOneOf)("type", "typeof", "value"), optional: true } } }), defineType("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, _utils.assertNodeType)("Identifier") }, imported: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, _utils.assertOneOf)("type", "typeof", "value"), optional: true } } }), defineType("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
          }
          if (!(0, _is.default)("Identifier", node.property, { name: property }))
            throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, _utils.assertNodeType)("Identifier") } } });
        const classMethodOrPropertyCommon = { abstract: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, _utils.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, key: { validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, _utils.assertNodeType)("Expression");
          return function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression")) } };
        exports2.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
        const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } });
        exports2.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon, defineType("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, { body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }) }), defineType("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon, { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), defineType("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("Super", { aliases: ["Expression"] }), defineType("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, _utils.assertNodeType)("Expression") }, quasi: { validate: (0, _utils.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), defineType("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, _utils.assertShape)({ raw: { validate: (0, _utils.assertValueType)("string") }, cooked: { validate: (0, _utils.assertValueType)("string"), optional: true } }) }, tail: { default: false } } }), defineType("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node, key, val) {
          if (node.quasis.length !== val.length + 1)
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }) } } }), defineType("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !node.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("Import", { aliases: ["Expression"] }), defineType("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), defineType("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, _utils.assertNodeType)("Expression") }, property: { validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier"], validator;
        }() }, computed: { default: false }, optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean") } } }), defineType("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") }, arguments: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean") }, typeArguments: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), defineType("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, classMethodOrPropertyCommon, { value: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, declare: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, variance: { validate: (0, _utils.assertNodeType)("Variance"), optional: true } }) }), defineType("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, _utils.assertNodeType)("PrivateName") }, value: { validate: (0, _utils.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, definite: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, variance: { validate: (0, _utils.assertNodeType)("Variance"), optional: true } } }), defineType("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, { key: { validate: (0, _utils.assertNodeType)("PrivateName") }, body: { validate: (0, _utils.assertNodeType)("BlockStatement") } }) }), defineType("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, _utils.assertNodeType)("Identifier") } } }), defineType("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, "./node_modules/@babel/types/lib/definitions/experimental.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js");
        (0, _utils.default)("ArgumentPlaceholder", {}), (0, _utils.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: process.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, _utils.assertNodeType)("Expression") }, callee: { validate: (0, _utils.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, _utils.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, _utils.assertNodeType)("StringLiteral") } } }), (0, _utils.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), (0, _utils.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, _utils.assertNodeType)("BlockStatement") }, async: { validate: (0, _utils.assertValueType)("boolean"), default: false } } }), (0, _utils.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, _utils.assertNodeType)("Identifier") } } }), (0, _utils.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, _utils.default)("TupleExpression", { fields: { elements: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, _utils.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, _utils.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, _utils.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, _utils.default)("TopicReference", { aliases: ["Expression"] }), (0, _utils.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, _utils.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, _utils.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, _utils.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, "./node_modules/@babel/types/lib/definitions/flow.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("Flow"), defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
          defineType(name, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)(typeParameterType), extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")), mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")), implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")), body: (0, _utils.validateType)("ObjectTypeAnnotation") } });
        };
        defineType("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, _utils.validateType)("FlowType") } }), defineType("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("DeclareClass"), defineType("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), predicate: (0, _utils.validateOptionalType)("DeclaredPredicate") } }), defineInterfaceishType("DeclareInterface"), defineType("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), body: (0, _utils.validateType)("BlockStatement"), kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES")) } }), defineType("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, _utils.validateType)("TypeAnnotation") } }), defineType("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), right: (0, _utils.validateType)("FlowType") } }), defineType("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, _utils.validateOptionalType)("FlowType"), impltype: (0, _utils.validateOptionalType)("FlowType") } }), defineType("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, _utils.validateOptionalType)("Flow"), specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, _utils.validateOptionalType)("StringLiteral"), default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, _utils.validateType)("StringLiteral"), exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")) } }), defineType("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, _utils.validateType)("Flow") } }), defineType("ExistsTypeAnnotation", { aliases: ["FlowType"] }), defineType("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")), rest: (0, _utils.validateOptionalType)("FunctionTypeParam"), this: (0, _utils.validateOptionalType)("FunctionTypeParam"), returnType: (0, _utils.validateType)("FlowType") } }), defineType("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, _utils.validateOptionalType)("Identifier"), typeAnnotation: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineType("InferredPredicate", { aliases: ["FlowPredicate"] }), defineType("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("InterfaceDeclaration"), defineType("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")), body: (0, _utils.validateType)("ObjectTypeAnnotation") } }), defineType("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, _utils.validateType)("FlowType") } }), defineType("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("number")) } }), defineType("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")), callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")), internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")), exact: { validate: (0, _utils.assertValueType)("boolean"), default: false }, inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, _utils.validateType)("Identifier"), value: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, _utils.validateType)("FlowType"), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, _utils.validateOptionalType)("Identifier"), key: (0, _utils.validateType)("FlowType"), value: (0, _utils.validateType)("FlowType"), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), variance: (0, _utils.validateOptionalType)("Variance") } }), defineType("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, _utils.validateType)(["Identifier", "StringLiteral"]), value: (0, _utils.validateType)("FlowType"), kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")), static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), variance: (0, _utils.validateOptionalType)("Variance"), method: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, _utils.validateType)("FlowType") } }), defineType("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, _utils.validateOptionalType)("FlowType"), impltype: (0, _utils.validateType)("FlowType") } }), defineType("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, _utils.validateType)("Identifier"), qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), defineType("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, _utils.validate)((0, _utils.assertValueType)("string")) } }), defineType("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, _utils.validateType)("FlowType") } }), defineType("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"), right: (0, _utils.validateType)("FlowType") } }), defineType("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("FlowType") } }), defineType("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, _utils.validateType)("Expression"), typeAnnotation: (0, _utils.validateType)("TypeAnnotation") } }), defineType("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, _utils.validate)((0, _utils.assertValueType)("string")), bound: (0, _utils.validateOptionalType)("TypeAnnotation"), default: (0, _utils.validateOptionalType)("FlowType"), variance: (0, _utils.validateOptionalType)("Variance") } }), defineType("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter")) } }), defineType("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType")) } }), defineType("Variance", { builder: ["kind"], fields: { kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus")) } }), defineType("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), defineType("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, _utils.validateType)("Identifier"), body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), defineType("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")), members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } }), defineType("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("BooleanLiteral") } }), defineType("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("NumericLiteral") } }), defineType("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, _utils.validateType)("Identifier"), init: (0, _utils.validateType)("StringLiteral") } }), defineType("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, _utils.validateType)("FlowType"), indexType: (0, _utils.validateType)("FlowType") } }), defineType("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, _utils.validateType)("FlowType"), indexType: (0, _utils.validateType)("FlowType"), optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")) } });
      }, "./node_modules/@babel/types/lib/definitions/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), Object.defineProperty(exports2, "ALIAS_KEYS", { enumerable: true, get: function() {
          return _utils.ALIAS_KEYS;
        } }), Object.defineProperty(exports2, "BUILDER_KEYS", { enumerable: true, get: function() {
          return _utils.BUILDER_KEYS;
        } }), Object.defineProperty(exports2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
          return _utils.DEPRECATED_KEYS;
        } }), Object.defineProperty(exports2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
          return _utils.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(exports2, "NODE_FIELDS", { enumerable: true, get: function() {
          return _utils.NODE_FIELDS;
        } }), Object.defineProperty(exports2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
          return _utils.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(exports2, "PLACEHOLDERS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS;
        } }), Object.defineProperty(exports2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(exports2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
          return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), exports2.TYPES = void 0, Object.defineProperty(exports2, "VISITOR_KEYS", { enumerable: true, get: function() {
          return _utils.VISITOR_KEYS;
        } });
        var _toFastProperties = __webpack_require__2("./node_modules/to-fast-properties/index.js");
        __webpack_require__2("./node_modules/@babel/types/lib/definitions/core.js"), __webpack_require__2("./node_modules/@babel/types/lib/definitions/flow.js"), __webpack_require__2("./node_modules/@babel/types/lib/definitions/jsx.js"), __webpack_require__2("./node_modules/@babel/types/lib/definitions/misc.js"), __webpack_require__2("./node_modules/@babel/types/lib/definitions/experimental.js"), __webpack_require__2("./node_modules/@babel/types/lib/definitions/typescript.js");
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js"), _placeholders = __webpack_require__2("./node_modules/@babel/types/lib/definitions/placeholders.js");
        _toFastProperties(_utils.VISITOR_KEYS), _toFastProperties(_utils.ALIAS_KEYS), _toFastProperties(_utils.FLIPPED_ALIAS_KEYS), _toFastProperties(_utils.NODE_FIELDS), _toFastProperties(_utils.BUILDER_KEYS), _toFastProperties(_utils.DEPRECATED_KEYS), _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS), _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
        const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
        exports2.TYPES = TYPES;
      }, "./node_modules/@babel/types/lib/definitions/jsx.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js");
        const defineType = (0, _utils.defineAliasedType)("JSX");
        defineType("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), defineType("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), defineType("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: { openingElement: { validate: (0, _utils.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, _utils.assertNodeType)("JSXClosingElement") }, children: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) }, selfClosing: { validate: (0, _utils.assertValueType)("boolean"), optional: true } } }), defineType("JSXEmptyExpression", {}), defineType("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression") } } }), defineType("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, _utils.assertValueType)("string") } } }), defineType("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, _utils.assertNodeType)("JSXIdentifier") } } }), defineType("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, _utils.assertNodeType)("JSXIdentifier") }, name: { validate: (0, _utils.assertNodeType)("JSXIdentifier") } } }), defineType("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), defineType("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, _utils.assertNodeType)("Expression") } } }), defineType("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, _utils.assertValueType)("string") } } }), defineType("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, _utils.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, _utils.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), defineType("JSXOpeningFragment", { aliases: ["Immutable"] }), defineType("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/@babel/types/lib/definitions/misc.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js"), _placeholders = __webpack_require__2("./node_modules/@babel/types/lib/definitions/placeholders.js");
        const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
        defineType("Noop", { visitor: [] }), defineType("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, _utils.assertNodeType)("Identifier") }, expectedNode: { validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS) } } }), defineType("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, _utils.assertValueType)("string") } } });
      }, "./node_modules/@babel/types/lib/definitions/placeholders.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS = void 0;
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js");
        const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
        exports2.PLACEHOLDERS = PLACEHOLDERS;
        const PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        exports2.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
        for (const type of PLACEHOLDERS) {
          const alias = _utils.ALIAS_KEYS[type];
          alias != null && alias.length && (PLACEHOLDERS_ALIAS[type] = alias);
        }
        const PLACEHOLDERS_FLIPPED_ALIAS = {};
        exports2.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS, Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
          PLACEHOLDERS_ALIAS[type].forEach((alias) => {
            Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias) || (PLACEHOLDERS_FLIPPED_ALIAS[alias] = []), PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
          });
        });
      }, "./node_modules/@babel/types/lib/definitions/typescript.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _utils = __webpack_require__2("./node_modules/@babel/types/lib/definitions/utils.js"), _core = __webpack_require__2("./node_modules/@babel/types/lib/definitions/core.js"), _is = __webpack_require__2("./node_modules/@babel/types/lib/validators/is.js");
        const defineType = (0, _utils.defineAliasedType)("TypeScript"), bool = (0, _utils.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = { returnType: { validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } };
        defineType("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, _utils.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, _utils.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))), optional: true } } }), defineType("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon) }), defineType("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon) }), defineType("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, _utils.validateType)("TSEntityName"), right: (0, _utils.validateType)("Identifier") } });
        const signatureDeclarationCommon = { typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation") }, callConstructSignatureDeclaration = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: signatureDeclarationCommon };
        defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration), defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
        const namedTypeElementCommon = { key: (0, _utils.validateType)("Expression"), computed: (0, _utils.validate)(bool), optional: (0, _utils.validateOptional)(bool) };
        defineType("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation", "initializer"], fields: Object.assign({}, namedTypeElementCommon, { readonly: (0, _utils.validateOptional)(bool), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"), initializer: (0, _utils.validateOptionalType)("Expression"), kind: { validate: (0, _utils.assertOneOf)("get", "set") } }) }), defineType("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, { kind: { validate: (0, _utils.assertOneOf)("method", "get", "set") } }) }), defineType("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, _utils.validateOptional)(bool), static: (0, _utils.validateOptional)(bool), parameters: (0, _utils.validateArrayOfType)("Identifier"), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation") } });
        const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const type of tsKeywordTypes)
          defineType(type, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        defineType("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const fnOrCtrBase = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, { fields: signatureDeclarationCommon })), defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, { fields: Object.assign({}, signatureDeclarationCommon, { abstract: (0, _utils.validateOptional)(bool) }) })), defineType("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, _utils.validateType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"), asserts: (0, _utils.validateOptional)(bool) } }), defineType("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName"], fields: { exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"]) } }), defineType("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, _utils.validateArrayOfType)("TSTypeElement") } }), defineType("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, _utils.validateType)("TSType") } }), defineType("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), defineType("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, _utils.validateType)("Identifier"), optional: { validate: bool, default: false }, elementType: (0, _utils.validateType)("TSType") } });
        const unionOrIntersection = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, _utils.validateArrayOfType)("TSType") } };
        defineType("TSUnionType", unionOrIntersection), defineType("TSIntersectionType", unionOrIntersection), defineType("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, _utils.validateType)("TSType"), extendsType: (0, _utils.validateType)("TSType"), trueType: (0, _utils.validateType)("TSType"), falseType: (0, _utils.validateType)("TSType") } }), defineType("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, _utils.validateType)("TSTypeParameter") } }), defineType("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, _utils.validate)((0, _utils.assertValueType)("string")), typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, _utils.validateType)("TSType"), indexType: (0, _utils.validateType)("TSType") } }), defineType("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, _utils.validateOptional)(bool), typeParameter: (0, _utils.validateType)("TSTypeParameter"), optional: (0, _utils.validateOptional)(bool), typeAnnotation: (0, _utils.validateOptionalType)("TSType"), nameType: (0, _utils.validateOptionalType)("TSType") } }), defineType("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral"), unaryOperator = (0, _utils.assertOneOf)("-"), literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
          function validator(parent, key, node) {
            (0, _is.default)("UnaryExpression", node) ? (unaryOperator(node, "operator", node.operator), unaryExpression(node, "argument", node.argument)) : literal(parent, key, node);
          }
          return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression"], validator;
        }() } } }), defineType("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, _utils.validateType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, _utils.validateType)("TSInterfaceBody") } }), defineType("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, _utils.validateArrayOfType)("TSTypeElement") } }), defineType("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSAsExpression", { aliases: ["Expression"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, _utils.validateType)("Expression"), typeAnnotation: (0, _utils.validateType)("TSType") } }), defineType("TSTypeAssertion", { aliases: ["Expression"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, _utils.validateType)("TSType"), expression: (0, _utils.validateType)("Expression") } }), defineType("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, _utils.validateOptional)(bool), const: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)("Identifier"), members: (0, _utils.validateArrayOfType)("TSEnumMember"), initializer: (0, _utils.validateOptionalType)("Expression") } }), defineType("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), initializer: (0, _utils.validateOptionalType)("Expression") } }), defineType("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, _utils.validateOptional)(bool), global: (0, _utils.validateOptional)(bool), id: (0, _utils.validateType)(["Identifier", "StringLiteral"]), body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), defineType("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent"], visitor: ["body"], fields: { body: (0, _utils.validateArrayOfType)("Statement") } }), defineType("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, _utils.validateType)("StringLiteral"), qualifier: (0, _utils.validateOptionalType)("TSEntityName"), typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation") } }), defineType("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, _utils.validate)(bool), id: (0, _utils.validateType)("Identifier"), moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, _utils.assertOneOf)("type", "value"), optional: true } } }), defineType("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, _utils.validateType)("StringLiteral") } }), defineType("TSNonNullExpression", { aliases: ["Expression"], visitor: ["expression"], fields: { expression: (0, _utils.validateType)("Expression") } }), defineType("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, _utils.validateType)("Expression") } }), defineType("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, _utils.validateType)("Identifier") } }), defineType("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, _utils.assertNodeType)("TSType") } } }), defineType("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType"))) } } }), defineType("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter"))) } } }), defineType("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, _utils.assertValueType)("string") }, constraint: { validate: (0, _utils.assertNodeType)("TSType"), optional: true }, default: { validate: (0, _utils.assertNodeType)("TSType"), optional: true } } });
      }, "./node_modules/@babel/types/lib/definitions/utils.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.VISITOR_KEYS = exports2.NODE_PARENT_VALIDATIONS = exports2.NODE_FIELDS = exports2.FLIPPED_ALIAS_KEYS = exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.ALIAS_KEYS = void 0, exports2.arrayOf = arrayOf, exports2.arrayOfType = arrayOfType, exports2.assertEach = assertEach, exports2.assertNodeOrValueType = function(...types) {
          function validate2(node, key, val) {
            for (const type of types)
              if (getType(val) === type || (0, _is.default)(type, val))
                return void (0, _validate.validateChild)(node, key, val);
            throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
          }
          return validate2.oneOfNodeOrValueTypes = types, validate2;
        }, exports2.assertNodeType = assertNodeType, exports2.assertOneOf = function(...values) {
          function validate2(node, key, val) {
            if (values.indexOf(val) < 0)
              throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
          }
          return validate2.oneOf = values, validate2;
        }, exports2.assertOptionalChainStart = function() {
          return function(node) {
            var _current;
            let current = node;
            for (; node; ) {
              const { type } = current;
              if (type !== "OptionalCallExpression") {
                if (type !== "OptionalMemberExpression")
                  break;
                if (current.optional)
                  return;
                current = current.object;
              } else {
                if (current.optional)
                  return;
                current = current.callee;
              }
            }
            throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
          };
        }, exports2.assertShape = function(shape) {
          function validate2(node, key, val) {
            const errors = [];
            for (const property of Object.keys(shape))
              try {
                (0, _validate.validateField)(node, property, val[property], shape[property]);
              } catch (error) {
                if (error instanceof TypeError) {
                  errors.push(error.message);
                  continue;
                }
                throw error;
              }
            if (errors.length)
              throw new TypeError(`Property ${key} of ${node.type} expected to have the following:
${errors.join("\n")}`);
          }
          return validate2.shapeOf = shape, validate2;
        }, exports2.assertValueType = assertValueType, exports2.chain = chain, exports2.default = defineType, exports2.defineAliasedType = function(...aliases) {
          return (type, opts = {}) => {
            let defined = opts.aliases;
            var _store$opts$inherits$;
            defined || (opts.inherits && (defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice()), defined != null || (defined = []), opts.aliases = defined);
            const additional = aliases.filter((a) => !defined.includes(a));
            return defined.unshift(...additional), defineType(type, opts);
          };
        }, exports2.typeIs = typeIs, exports2.validate = validate, exports2.validateArrayOfType = function(typeName) {
          return validate(arrayOfType(typeName));
        }, exports2.validateOptional = function(validate2) {
          return { validate: validate2, optional: true };
        }, exports2.validateOptionalType = function(typeName) {
          return { validate: typeIs(typeName), optional: true };
        }, exports2.validateType = function(typeName) {
          return validate(typeIs(typeName));
        };
        var _is = __webpack_require__2("./node_modules/@babel/types/lib/validators/is.js"), _validate = __webpack_require__2("./node_modules/@babel/types/lib/validators/validate.js");
        const VISITOR_KEYS = {};
        exports2.VISITOR_KEYS = VISITOR_KEYS;
        const ALIAS_KEYS = {};
        exports2.ALIAS_KEYS = ALIAS_KEYS;
        const FLIPPED_ALIAS_KEYS = {};
        exports2.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
        const NODE_FIELDS = {};
        exports2.NODE_FIELDS = NODE_FIELDS;
        const BUILDER_KEYS = {};
        exports2.BUILDER_KEYS = BUILDER_KEYS;
        const DEPRECATED_KEYS = {};
        exports2.DEPRECATED_KEYS = DEPRECATED_KEYS;
        const NODE_PARENT_VALIDATIONS = {};
        function getType(val) {
          return Array.isArray(val) ? "array" : val === null ? "null" : typeof val;
        }
        function validate(validate2) {
          return { validate: validate2 };
        }
        function typeIs(typeName) {
          return typeof typeName == "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
        }
        function arrayOf(elementType) {
          return chain(assertValueType("array"), assertEach(elementType));
        }
        function arrayOfType(typeName) {
          return arrayOf(typeIs(typeName));
        }
        function assertEach(callback) {
          function validator(node, key, val) {
            if (Array.isArray(val))
              for (let i = 0; i < val.length; i++) {
                const subkey = `${key}[${i}]`, v = val[i];
                callback(node, subkey, v), process.env.BABEL_TYPES_8_BREAKING && (0, _validate.validateChild)(node, subkey, v);
              }
          }
          return validator.each = callback, validator;
        }
        function assertNodeType(...types) {
          function validate2(node, key, val) {
            for (const type of types)
              if ((0, _is.default)(type, val))
                return void (0, _validate.validateChild)(node, key, val);
            throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
          }
          return validate2.oneOfNodeTypes = types, validate2;
        }
        function assertValueType(type) {
          function validate2(node, key, val) {
            if (!(getType(val) === type))
              throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
          }
          return validate2.type = type, validate2;
        }
        function chain(...fns) {
          function validate2(...args) {
            for (const fn of fns)
              fn(...args);
          }
          if (validate2.chainOf = fns, fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1]))
            throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return validate2;
        }
        exports2.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
        const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], validFieldKeys = ["default", "optional", "validate"];
        function defineType(type, opts = {}) {
          const inherits = opts.inherits && store[opts.inherits] || {};
          let fields = opts.fields;
          if (!fields && (fields = {}, inherits.fields)) {
            const keys = Object.getOwnPropertyNames(inherits.fields);
            for (const key of keys) {
              const field = inherits.fields[key], def = field.default;
              if (Array.isArray(def) ? def.length > 0 : def && typeof def == "object")
                throw new Error("field defaults can only be primitives or empty arrays currently");
              fields[key] = { default: Array.isArray(def) ? [] : def, optional: field.optional, validate: field.validate };
            }
          }
          const visitor = opts.visitor || inherits.visitor || [], aliases = opts.aliases || inherits.aliases || [], builder = opts.builder || inherits.builder || opts.visitor || [];
          for (const k of Object.keys(opts))
            if (validTypeOpts.indexOf(k) === -1)
              throw new Error(`Unknown type option "${k}" on ${type}`);
          opts.deprecatedAlias && (DEPRECATED_KEYS[opts.deprecatedAlias] = type);
          for (const key of visitor.concat(builder))
            fields[key] = fields[key] || {};
          for (const key of Object.keys(fields)) {
            const field = fields[key];
            field.default !== void 0 && builder.indexOf(key) === -1 && (field.optional = true), field.default === void 0 ? field.default = null : field.validate || field.default == null || (field.validate = assertValueType(getType(field.default)));
            for (const k of Object.keys(field))
              if (validFieldKeys.indexOf(k) === -1)
                throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
          VISITOR_KEYS[type] = opts.visitor = visitor, BUILDER_KEYS[type] = opts.builder = builder, NODE_FIELDS[type] = opts.fields = fields, ALIAS_KEYS[type] = opts.aliases = aliases, aliases.forEach((alias) => {
            FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [], FLIPPED_ALIAS_KEYS[alias].push(type);
          }), opts.validate && (NODE_PARENT_VALIDATIONS[type] = opts.validate), store[type] = opts;
        }
        const store = {};
      }, "./node_modules/@babel/types/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var _exportNames = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toSequenceExpression: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true };
        Object.defineProperty(exports2, "addComment", { enumerable: true, get: function() {
          return _addComment.default;
        } }), Object.defineProperty(exports2, "addComments", { enumerable: true, get: function() {
          return _addComments.default;
        } }), Object.defineProperty(exports2, "appendToMemberExpression", { enumerable: true, get: function() {
          return _appendToMemberExpression.default;
        } }), Object.defineProperty(exports2, "assertNode", { enumerable: true, get: function() {
          return _assertNode.default;
        } }), Object.defineProperty(exports2, "buildMatchMemberExpression", { enumerable: true, get: function() {
          return _buildMatchMemberExpression.default;
        } }), Object.defineProperty(exports2, "clone", { enumerable: true, get: function() {
          return _clone.default;
        } }), Object.defineProperty(exports2, "cloneDeep", { enumerable: true, get: function() {
          return _cloneDeep.default;
        } }), Object.defineProperty(exports2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
          return _cloneDeepWithoutLoc.default;
        } }), Object.defineProperty(exports2, "cloneNode", { enumerable: true, get: function() {
          return _cloneNode.default;
        } }), Object.defineProperty(exports2, "cloneWithoutLoc", { enumerable: true, get: function() {
          return _cloneWithoutLoc.default;
        } }), Object.defineProperty(exports2, "createFlowUnionType", { enumerable: true, get: function() {
          return _createFlowUnionType.default;
        } }), Object.defineProperty(exports2, "createTSUnionType", { enumerable: true, get: function() {
          return _createTSUnionType.default;
        } }), Object.defineProperty(exports2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
          return _createTypeAnnotationBasedOnTypeof.default;
        } }), Object.defineProperty(exports2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
          return _createFlowUnionType.default;
        } }), Object.defineProperty(exports2, "ensureBlock", { enumerable: true, get: function() {
          return _ensureBlock.default;
        } }), Object.defineProperty(exports2, "getBindingIdentifiers", { enumerable: true, get: function() {
          return _getBindingIdentifiers.default;
        } }), Object.defineProperty(exports2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
          return _getOuterBindingIdentifiers.default;
        } }), Object.defineProperty(exports2, "inheritInnerComments", { enumerable: true, get: function() {
          return _inheritInnerComments.default;
        } }), Object.defineProperty(exports2, "inheritLeadingComments", { enumerable: true, get: function() {
          return _inheritLeadingComments.default;
        } }), Object.defineProperty(exports2, "inheritTrailingComments", { enumerable: true, get: function() {
          return _inheritTrailingComments.default;
        } }), Object.defineProperty(exports2, "inherits", { enumerable: true, get: function() {
          return _inherits.default;
        } }), Object.defineProperty(exports2, "inheritsComments", { enumerable: true, get: function() {
          return _inheritsComments.default;
        } }), Object.defineProperty(exports2, "is", { enumerable: true, get: function() {
          return _is.default;
        } }), Object.defineProperty(exports2, "isBinding", { enumerable: true, get: function() {
          return _isBinding.default;
        } }), Object.defineProperty(exports2, "isBlockScoped", { enumerable: true, get: function() {
          return _isBlockScoped.default;
        } }), Object.defineProperty(exports2, "isImmutable", { enumerable: true, get: function() {
          return _isImmutable.default;
        } }), Object.defineProperty(exports2, "isLet", { enumerable: true, get: function() {
          return _isLet.default;
        } }), Object.defineProperty(exports2, "isNode", { enumerable: true, get: function() {
          return _isNode.default;
        } }), Object.defineProperty(exports2, "isNodesEquivalent", { enumerable: true, get: function() {
          return _isNodesEquivalent.default;
        } }), Object.defineProperty(exports2, "isPlaceholderType", { enumerable: true, get: function() {
          return _isPlaceholderType.default;
        } }), Object.defineProperty(exports2, "isReferenced", { enumerable: true, get: function() {
          return _isReferenced.default;
        } }), Object.defineProperty(exports2, "isScope", { enumerable: true, get: function() {
          return _isScope.default;
        } }), Object.defineProperty(exports2, "isSpecifierDefault", { enumerable: true, get: function() {
          return _isSpecifierDefault.default;
        } }), Object.defineProperty(exports2, "isType", { enumerable: true, get: function() {
          return _isType.default;
        } }), Object.defineProperty(exports2, "isValidES3Identifier", { enumerable: true, get: function() {
          return _isValidES3Identifier.default;
        } }), Object.defineProperty(exports2, "isValidIdentifier", { enumerable: true, get: function() {
          return _isValidIdentifier.default;
        } }), Object.defineProperty(exports2, "isVar", { enumerable: true, get: function() {
          return _isVar.default;
        } }), Object.defineProperty(exports2, "matchesPattern", { enumerable: true, get: function() {
          return _matchesPattern.default;
        } }), Object.defineProperty(exports2, "prependToMemberExpression", { enumerable: true, get: function() {
          return _prependToMemberExpression.default;
        } }), exports2.react = void 0, Object.defineProperty(exports2, "removeComments", { enumerable: true, get: function() {
          return _removeComments.default;
        } }), Object.defineProperty(exports2, "removeProperties", { enumerable: true, get: function() {
          return _removeProperties.default;
        } }), Object.defineProperty(exports2, "removePropertiesDeep", { enumerable: true, get: function() {
          return _removePropertiesDeep.default;
        } }), Object.defineProperty(exports2, "removeTypeDuplicates", { enumerable: true, get: function() {
          return _removeTypeDuplicates.default;
        } }), Object.defineProperty(exports2, "shallowEqual", { enumerable: true, get: function() {
          return _shallowEqual.default;
        } }), Object.defineProperty(exports2, "toBindingIdentifierName", { enumerable: true, get: function() {
          return _toBindingIdentifierName.default;
        } }), Object.defineProperty(exports2, "toBlock", { enumerable: true, get: function() {
          return _toBlock.default;
        } }), Object.defineProperty(exports2, "toComputedKey", { enumerable: true, get: function() {
          return _toComputedKey.default;
        } }), Object.defineProperty(exports2, "toExpression", { enumerable: true, get: function() {
          return _toExpression.default;
        } }), Object.defineProperty(exports2, "toIdentifier", { enumerable: true, get: function() {
          return _toIdentifier.default;
        } }), Object.defineProperty(exports2, "toKeyAlias", { enumerable: true, get: function() {
          return _toKeyAlias.default;
        } }), Object.defineProperty(exports2, "toSequenceExpression", { enumerable: true, get: function() {
          return _toSequenceExpression.default;
        } }), Object.defineProperty(exports2, "toStatement", { enumerable: true, get: function() {
          return _toStatement.default;
        } }), Object.defineProperty(exports2, "traverse", { enumerable: true, get: function() {
          return _traverse.default;
        } }), Object.defineProperty(exports2, "traverseFast", { enumerable: true, get: function() {
          return _traverseFast.default;
        } }), Object.defineProperty(exports2, "validate", { enumerable: true, get: function() {
          return _validate.default;
        } }), Object.defineProperty(exports2, "valueToNode", { enumerable: true, get: function() {
          return _valueToNode.default;
        } });
        var _isReactComponent = __webpack_require__2("./node_modules/@babel/types/lib/validators/react/isReactComponent.js"), _isCompatTag = __webpack_require__2("./node_modules/@babel/types/lib/validators/react/isCompatTag.js"), _buildChildren = __webpack_require__2("./node_modules/@babel/types/lib/builders/react/buildChildren.js"), _assertNode = __webpack_require__2("./node_modules/@babel/types/lib/asserts/assertNode.js"), _generated = __webpack_require__2("./node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(_generated).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _generated[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _generated[key];
          } }));
        });
        var _createTypeAnnotationBasedOnTypeof = __webpack_require__2("./node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), _createFlowUnionType = __webpack_require__2("./node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), _createTSUnionType = __webpack_require__2("./node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), _generated2 = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(_generated2).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _generated2[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _generated2[key];
          } }));
        });
        var _uppercase = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(_uppercase).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _uppercase[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _uppercase[key];
          } }));
        });
        var _cloneNode = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneNode.js"), _clone = __webpack_require__2("./node_modules/@babel/types/lib/clone/clone.js"), _cloneDeep = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneDeep.js"), _cloneDeepWithoutLoc = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), _cloneWithoutLoc = __webpack_require__2("./node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), _addComment = __webpack_require__2("./node_modules/@babel/types/lib/comments/addComment.js"), _addComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/addComments.js"), _inheritInnerComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritInnerComments.js"), _inheritLeadingComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), _inheritsComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritsComments.js"), _inheritTrailingComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), _removeComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/removeComments.js"), _generated3 = __webpack_require__2("./node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(_generated3).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _generated3[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _generated3[key];
          } }));
        });
        var _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js");
        Object.keys(_constants).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _constants[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _constants[key];
          } }));
        });
        var _ensureBlock = __webpack_require__2("./node_modules/@babel/types/lib/converters/ensureBlock.js"), _toBindingIdentifierName = __webpack_require__2("./node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), _toBlock = __webpack_require__2("./node_modules/@babel/types/lib/converters/toBlock.js"), _toComputedKey = __webpack_require__2("./node_modules/@babel/types/lib/converters/toComputedKey.js"), _toExpression = __webpack_require__2("./node_modules/@babel/types/lib/converters/toExpression.js"), _toIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/converters/toIdentifier.js"), _toKeyAlias = __webpack_require__2("./node_modules/@babel/types/lib/converters/toKeyAlias.js"), _toSequenceExpression = __webpack_require__2("./node_modules/@babel/types/lib/converters/toSequenceExpression.js"), _toStatement = __webpack_require__2("./node_modules/@babel/types/lib/converters/toStatement.js"), _valueToNode = __webpack_require__2("./node_modules/@babel/types/lib/converters/valueToNode.js"), _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
        Object.keys(_definitions).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _definitions[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _definitions[key];
          } }));
        });
        var _appendToMemberExpression = __webpack_require__2("./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), _inherits = __webpack_require__2("./node_modules/@babel/types/lib/modifications/inherits.js"), _prependToMemberExpression = __webpack_require__2("./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), _removeProperties = __webpack_require__2("./node_modules/@babel/types/lib/modifications/removeProperties.js"), _removePropertiesDeep = __webpack_require__2("./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), _removeTypeDuplicates = __webpack_require__2("./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), _getBindingIdentifiers = __webpack_require__2("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _getOuterBindingIdentifiers = __webpack_require__2("./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), _traverse = __webpack_require__2("./node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(_traverse).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _traverse[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _traverse[key];
          } }));
        });
        var _traverseFast = __webpack_require__2("./node_modules/@babel/types/lib/traverse/traverseFast.js"), _shallowEqual = __webpack_require__2("./node_modules/@babel/types/lib/utils/shallowEqual.js"), _is = __webpack_require__2("./node_modules/@babel/types/lib/validators/is.js"), _isBinding = __webpack_require__2("./node_modules/@babel/types/lib/validators/isBinding.js"), _isBlockScoped = __webpack_require__2("./node_modules/@babel/types/lib/validators/isBlockScoped.js"), _isImmutable = __webpack_require__2("./node_modules/@babel/types/lib/validators/isImmutable.js"), _isLet = __webpack_require__2("./node_modules/@babel/types/lib/validators/isLet.js"), _isNode = __webpack_require__2("./node_modules/@babel/types/lib/validators/isNode.js"), _isNodesEquivalent = __webpack_require__2("./node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), _isPlaceholderType = __webpack_require__2("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"), _isReferenced = __webpack_require__2("./node_modules/@babel/types/lib/validators/isReferenced.js"), _isScope = __webpack_require__2("./node_modules/@babel/types/lib/validators/isScope.js"), _isSpecifierDefault = __webpack_require__2("./node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), _isType = __webpack_require__2("./node_modules/@babel/types/lib/validators/isType.js"), _isValidES3Identifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), _isValidIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _isVar = __webpack_require__2("./node_modules/@babel/types/lib/validators/isVar.js"), _matchesPattern = __webpack_require__2("./node_modules/@babel/types/lib/validators/matchesPattern.js"), _validate = __webpack_require__2("./node_modules/@babel/types/lib/validators/validate.js"), _buildMatchMemberExpression = __webpack_require__2("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), _generated4 = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(_generated4).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _generated4[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _generated4[key];
          } }));
        });
        var _generated5 = __webpack_require__2("./node_modules/@babel/types/lib/ast-types/generated/index.js");
        Object.keys(_generated5).forEach(function(key) {
          key !== "default" && key !== "__esModule" && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports2 && exports2[key] === _generated5[key] || Object.defineProperty(exports2, key, { enumerable: true, get: function() {
            return _generated5[key];
          } }));
        });
        const react = { isReactComponent: _isReactComponent.default, isCompatTag: _isCompatTag.default, buildChildren: _buildChildren.default };
        exports2.react = react;
      }, "./node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(member, append, computed = false) {
          return member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed), member.property = append, member.computed = !!computed, member;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function removeTypeDuplicates(nodes) {
          const generics = {}, bases = {}, typeGroups = /* @__PURE__ */ new Set(), types = [];
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node && !(types.indexOf(node) >= 0)) {
              if ((0, _generated.isAnyTypeAnnotation)(node))
                return [node];
              if ((0, _generated.isFlowBaseAnnotation)(node))
                bases[node.type] = node;
              else if ((0, _generated.isUnionTypeAnnotation)(node))
                typeGroups.has(node.types) || (nodes = nodes.concat(node.types), typeGroups.add(node.types));
              else if ((0, _generated.isGenericTypeAnnotation)(node)) {
                const name = getQualifiedName(node.id);
                if (generics[name]) {
                  let existing = generics[name];
                  existing.typeParameters ? node.typeParameters && (existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params))) : existing = node.typeParameters;
                } else
                  generics[name] = node;
              } else
                types.push(node);
            }
          }
          for (const type of Object.keys(bases))
            types.push(bases[type]);
          for (const name of Object.keys(generics))
            types.push(generics[name]);
          return types;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
        function getQualifiedName(node) {
          return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
        }
      }, "./node_modules/@babel/types/lib/modifications/inherits.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, parent) {
          if (!child || !parent)
            return child;
          for (const key of _constants.INHERIT_KEYS.optional)
            child[key] == null && (child[key] = parent[key]);
          for (const key of Object.keys(parent))
            key[0] === "_" && key !== "__clone" && (child[key] = parent[key]);
          for (const key of _constants.INHERIT_KEYS.force)
            child[key] = parent[key];
          return (0, _inheritsComments.default)(child, parent), child;
        };
        var _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js"), _inheritsComments = __webpack_require__2("./node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(member, prepend) {
          return member.object = (0, _generated.memberExpression)(prepend, member.object), member;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/modifications/removeProperties.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, opts = {}) {
          const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
          for (const key of map)
            node[key] != null && (node[key] = void 0);
          for (const key of Object.keys(node))
            key[0] === "_" && node[key] != null && (node[key] = void 0);
          const symbols = Object.getOwnPropertySymbols(node);
          for (const sym of symbols)
            node[sym] = null;
        };
        var _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js");
        const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"], CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
      }, "./node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(tree, opts) {
          return (0, _traverseFast.default)(tree, _removeProperties.default, opts), tree;
        };
        var _traverseFast = __webpack_require__2("./node_modules/@babel/types/lib/traverse/traverseFast.js"), _removeProperties = __webpack_require__2("./node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(nodes) {
          const generics = {}, bases = {}, typeGroups = /* @__PURE__ */ new Set(), types = [];
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node && !(types.indexOf(node) >= 0)) {
              if ((0, _generated.isTSAnyKeyword)(node))
                return [node];
              (0, _generated.isTSBaseType)(node) ? bases[node.type] = node : (0, _generated.isTSUnionType)(node) ? typeGroups.has(node.types) || (nodes.push(...node.types), typeGroups.add(node.types)) : types.push(node);
            }
          }
          for (const type of Object.keys(bases))
            types.push(bases[type]);
          for (const name of Object.keys(generics))
            types.push(generics[name]);
          return types;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = getBindingIdentifiers;
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
        function getBindingIdentifiers(node, duplicates, outerOnly) {
          let search = [].concat(node);
          const ids = /* @__PURE__ */ Object.create(null);
          for (; search.length; ) {
            const id = search.shift();
            if (!id)
              continue;
            const keys = getBindingIdentifiers.keys[id.type];
            if ((0, _generated.isIdentifier)(id))
              if (duplicates) {
                (ids[id.name] = ids[id.name] || []).push(id);
              } else
                ids[id.name] = id;
            else if (!(0, _generated.isExportDeclaration)(id) || (0, _generated.isExportAllDeclaration)(id)) {
              if (outerOnly) {
                if ((0, _generated.isFunctionDeclaration)(id)) {
                  search.push(id.id);
                  continue;
                }
                if ((0, _generated.isFunctionExpression)(id))
                  continue;
              }
              if (keys)
                for (let i = 0; i < keys.length; i++) {
                  const key = keys[i];
                  id[key] && (search = search.concat(id[key]));
                }
            } else
              (0, _generated.isDeclaration)(id.declaration) && search.push(id.declaration);
          }
          return ids;
        }
        getBindingIdentifiers.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), _default = function(node, duplicates) {
          return (0, _getBindingIdentifiers.default)(node, duplicates, true);
        };
        exports2.default = _default;
      }, "./node_modules/@babel/types/lib/traverse/traverse.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, handlers, state) {
          typeof handlers == "function" && (handlers = { enter: handlers });
          const { enter, exit } = handlers;
          traverseSimpleImpl(node, enter, exit, state, []);
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
        function traverseSimpleImpl(node, enter, exit, state, ancestors) {
          const keys = _definitions.VISITOR_KEYS[node.type];
          if (keys) {
            enter && enter(node, ancestors, state);
            for (const key of keys) {
              const subNode = node[key];
              if (Array.isArray(subNode))
                for (let i = 0; i < subNode.length; i++) {
                  const child = subNode[i];
                  child && (ancestors.push({ node, key, index: i }), traverseSimpleImpl(child, enter, exit, state, ancestors), ancestors.pop());
                }
              else
                subNode && (ancestors.push({ node, key }), traverseSimpleImpl(subNode, enter, exit, state, ancestors), ancestors.pop());
            }
            exit && exit(node, ancestors, state);
          }
        }
      }, "./node_modules/@babel/types/lib/traverse/traverseFast.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function traverseFast(node, enter, opts) {
          if (!node)
            return;
          const keys = _definitions.VISITOR_KEYS[node.type];
          if (!keys)
            return;
          enter(node, opts = opts || {});
          for (const key of keys) {
            const subNode = node[key];
            if (Array.isArray(subNode))
              for (const node2 of subNode)
                traverseFast(node2, enter, opts);
            else
              traverseFast(subNode, enter, opts);
          }
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/utils/inherit.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(key, child, parent) {
          child && parent && (child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean))));
        };
      }, "./node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(child, args) {
          const lines = child.value.split(/\r\n|\n|\r/);
          let lastNonEmptyLine = 0;
          for (let i = 0; i < lines.length; i++)
            lines[i].match(/[^ \t]/) && (lastNonEmptyLine = i);
          let str = "";
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i], isFirstLine = i === 0, isLastLine = i === lines.length - 1, isLastNonEmptyLine = i === lastNonEmptyLine;
            let trimmedLine = line.replace(/\t/g, " ");
            isFirstLine || (trimmedLine = trimmedLine.replace(/^[ ]+/, "")), isLastLine || (trimmedLine = trimmedLine.replace(/[ ]+$/, "")), trimmedLine && (isLastNonEmptyLine || (trimmedLine += " "), str += trimmedLine);
          }
          str && args.push((0, _generated.stringLiteral)(str));
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/@babel/types/lib/utils/shallowEqual.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(actual, expected) {
          const keys = Object.keys(expected);
          for (const key of keys)
            if (actual[key] !== expected[key])
              return false;
          return true;
        };
      }, "./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(match, allowPartial) {
          const parts = match.split(".");
          return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
        };
        var _matchesPattern = __webpack_require__2("./node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/@babel/types/lib/validators/generated/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.isAnyTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "AnyTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isArgumentPlaceholder = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ArgumentPlaceholder")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isArrayExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ArrayExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isArrayPattern = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ArrayPattern")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isArrayTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ArrayTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isArrowFunctionExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ArrowFunctionExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isAssignmentExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "AssignmentExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isAssignmentPattern = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "AssignmentPattern")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isAwaitExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "AwaitExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBigIntLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BigIntLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBinary = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBinaryExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BinaryExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBindExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BindExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBlock = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BlockStatement" || nodeType === "Program" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBlockParent = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BlockStatement" || nodeType === "CatchClause" || nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "Program" || nodeType === "ObjectMethod" || nodeType === "SwitchStatement" || nodeType === "WhileStatement" || nodeType === "ArrowFunctionExpression" || nodeType === "ForOfStatement" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod" || nodeType === "StaticBlock" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBlockStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BlockStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBooleanLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BooleanLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBooleanLiteralTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BooleanLiteralTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBooleanTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BooleanTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isBreakStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "BreakStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isCallExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "CallExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isCatchClause = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "CatchClause")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClass = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ClassExpression" || nodeType === "ClassDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassImplements = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassImplements")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassMethod = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassPrivateMethod = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassPrivateMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassPrivateProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassPrivateProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isClassProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ClassProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isCompletionStatement = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "ReturnStatement" || nodeType === "ThrowStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isConditional = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ConditionalExpression" || nodeType === "IfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isConditionalExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ConditionalExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isContinueStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ContinueStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDebuggerStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DebuggerStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDecimalLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DecimalLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclaration = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "FunctionDeclaration" || nodeType === "VariableDeclaration" || nodeType === "ClassDeclaration" || nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ImportDeclaration" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias" || nodeType === "EnumDeclaration" || nodeType === "TSDeclareFunction" || nodeType === "TSInterfaceDeclaration" || nodeType === "TSTypeAliasDeclaration" || nodeType === "TSEnumDeclaration" || nodeType === "TSModuleDeclaration" || nodeType === "Placeholder" && node.expectedNode === "Declaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareClass = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareClass")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareExportAllDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareExportAllDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareExportDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareExportDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareFunction = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareFunction")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareInterface = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareInterface")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareModule = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareModule")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareModuleExports = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareModuleExports")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareOpaqueType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareOpaqueType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareTypeAlias = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareTypeAlias")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclareVariable = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclareVariable")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDeclaredPredicate = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DeclaredPredicate")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDecorator = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Decorator")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDirective = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Directive")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDirectiveLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DirectiveLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDoExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DoExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isDoWhileStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "DoWhileStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEmptyStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EmptyStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEmptyTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EmptyTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumBody = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "EnumBooleanBody" || nodeType === "EnumNumberBody" || nodeType === "EnumStringBody" || nodeType === "EnumSymbolBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumBooleanBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumBooleanBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumBooleanMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumBooleanMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumDefaultedMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumDefaultedMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumMember = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "EnumBooleanMember" || nodeType === "EnumNumberMember" || nodeType === "EnumStringMember" || nodeType === "EnumDefaultedMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumNumberBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumNumberBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumNumberMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumNumberMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumStringBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumStringBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumStringMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumStringMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isEnumSymbolBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "EnumSymbolBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExistsTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExistsTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportAllDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportAllDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportDeclaration = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportDefaultDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportDefaultDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportDefaultSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportDefaultSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportNamedDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportNamedDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportNamespaceSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportNamespaceSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExportSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExportSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExpression = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ArrayExpression" || nodeType === "AssignmentExpression" || nodeType === "BinaryExpression" || nodeType === "CallExpression" || nodeType === "ConditionalExpression" || nodeType === "FunctionExpression" || nodeType === "Identifier" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "LogicalExpression" || nodeType === "MemberExpression" || nodeType === "NewExpression" || nodeType === "ObjectExpression" || nodeType === "SequenceExpression" || nodeType === "ParenthesizedExpression" || nodeType === "ThisExpression" || nodeType === "UnaryExpression" || nodeType === "UpdateExpression" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassExpression" || nodeType === "MetaProperty" || nodeType === "Super" || nodeType === "TaggedTemplateExpression" || nodeType === "TemplateLiteral" || nodeType === "YieldExpression" || nodeType === "AwaitExpression" || nodeType === "Import" || nodeType === "BigIntLiteral" || nodeType === "OptionalMemberExpression" || nodeType === "OptionalCallExpression" || nodeType === "TypeCastExpression" || nodeType === "JSXElement" || nodeType === "JSXFragment" || nodeType === "BindExpression" || nodeType === "DoExpression" || nodeType === "RecordExpression" || nodeType === "TupleExpression" || nodeType === "DecimalLiteral" || nodeType === "ModuleExpression" || nodeType === "TopicReference" || nodeType === "PipelineTopicExpression" || nodeType === "PipelineBareFunction" || nodeType === "PipelinePrimaryTopicReference" || nodeType === "TSAsExpression" || nodeType === "TSTypeAssertion" || nodeType === "TSNonNullExpression" || nodeType === "Placeholder" && (node.expectedNode === "Expression" || node.expectedNode === "Identifier" || node.expectedNode === "StringLiteral"))
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExpressionStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ExpressionStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isExpressionWrapper = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ExpressionStatement" || nodeType === "ParenthesizedExpression" || nodeType === "TypeCastExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFile = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "File")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFlow = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "AnyTypeAnnotation" || nodeType === "ArrayTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "BooleanLiteralTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "ClassImplements" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "DeclaredPredicate" || nodeType === "ExistsTypeAnnotation" || nodeType === "FunctionTypeAnnotation" || nodeType === "FunctionTypeParam" || nodeType === "GenericTypeAnnotation" || nodeType === "InferredPredicate" || nodeType === "InterfaceExtends" || nodeType === "InterfaceDeclaration" || nodeType === "InterfaceTypeAnnotation" || nodeType === "IntersectionTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NullableTypeAnnotation" || nodeType === "NumberLiteralTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "ObjectTypeAnnotation" || nodeType === "ObjectTypeInternalSlot" || nodeType === "ObjectTypeCallProperty" || nodeType === "ObjectTypeIndexer" || nodeType === "ObjectTypeProperty" || nodeType === "ObjectTypeSpreadProperty" || nodeType === "OpaqueType" || nodeType === "QualifiedTypeIdentifier" || nodeType === "StringLiteralTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "TupleTypeAnnotation" || nodeType === "TypeofTypeAnnotation" || nodeType === "TypeAlias" || nodeType === "TypeAnnotation" || nodeType === "TypeCastExpression" || nodeType === "TypeParameter" || nodeType === "TypeParameterDeclaration" || nodeType === "TypeParameterInstantiation" || nodeType === "UnionTypeAnnotation" || nodeType === "Variance" || nodeType === "VoidTypeAnnotation" || nodeType === "EnumDeclaration" || nodeType === "EnumBooleanBody" || nodeType === "EnumNumberBody" || nodeType === "EnumStringBody" || nodeType === "EnumSymbolBody" || nodeType === "EnumBooleanMember" || nodeType === "EnumNumberMember" || nodeType === "EnumStringMember" || nodeType === "EnumDefaultedMember" || nodeType === "IndexedAccessType" || nodeType === "OptionalIndexedAccessType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFlowBaseAnnotation = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "AnyTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "VoidTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFlowDeclaration = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFlowPredicate = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "DeclaredPredicate" || nodeType === "InferredPredicate")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFlowType = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "AnyTypeAnnotation" || nodeType === "ArrayTypeAnnotation" || nodeType === "BooleanTypeAnnotation" || nodeType === "BooleanLiteralTypeAnnotation" || nodeType === "NullLiteralTypeAnnotation" || nodeType === "ExistsTypeAnnotation" || nodeType === "FunctionTypeAnnotation" || nodeType === "GenericTypeAnnotation" || nodeType === "InterfaceTypeAnnotation" || nodeType === "IntersectionTypeAnnotation" || nodeType === "MixedTypeAnnotation" || nodeType === "EmptyTypeAnnotation" || nodeType === "NullableTypeAnnotation" || nodeType === "NumberLiteralTypeAnnotation" || nodeType === "NumberTypeAnnotation" || nodeType === "ObjectTypeAnnotation" || nodeType === "StringLiteralTypeAnnotation" || nodeType === "StringTypeAnnotation" || nodeType === "SymbolTypeAnnotation" || nodeType === "ThisTypeAnnotation" || nodeType === "TupleTypeAnnotation" || nodeType === "TypeofTypeAnnotation" || nodeType === "UnionTypeAnnotation" || nodeType === "VoidTypeAnnotation" || nodeType === "IndexedAccessType" || nodeType === "OptionalIndexedAccessType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFor = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "ForOfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isForInStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ForInStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isForOfStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ForOfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isForStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ForStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isForXStatement = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ForInStatement" || nodeType === "ForOfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunction = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "ObjectMethod" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunctionDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "FunctionDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunctionExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "FunctionExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunctionParent = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "ObjectMethod" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod" || nodeType === "StaticBlock")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunctionTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "FunctionTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isFunctionTypeParam = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "FunctionTypeParam")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isGenericTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "GenericTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isIdentifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Identifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isIfStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "IfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImmutable = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "BigIntLiteral" || nodeType === "JSXAttribute" || nodeType === "JSXClosingElement" || nodeType === "JSXElement" || nodeType === "JSXExpressionContainer" || nodeType === "JSXSpreadChild" || nodeType === "JSXOpeningElement" || nodeType === "JSXText" || nodeType === "JSXFragment" || nodeType === "JSXOpeningFragment" || nodeType === "JSXClosingFragment" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImport = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Import")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImportAttribute = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ImportAttribute")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImportDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ImportDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImportDefaultSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ImportDefaultSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImportNamespaceSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ImportNamespaceSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isImportSpecifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ImportSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isIndexedAccessType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "IndexedAccessType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isInferredPredicate = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "InferredPredicate")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isInterfaceDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "InterfaceDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isInterfaceExtends = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "InterfaceExtends")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isInterfaceTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "InterfaceTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isInterpreterDirective = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "InterpreterDirective")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isIntersectionTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "IntersectionTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSX = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "JSXAttribute" || nodeType === "JSXClosingElement" || nodeType === "JSXElement" || nodeType === "JSXEmptyExpression" || nodeType === "JSXExpressionContainer" || nodeType === "JSXSpreadChild" || nodeType === "JSXIdentifier" || nodeType === "JSXMemberExpression" || nodeType === "JSXNamespacedName" || nodeType === "JSXOpeningElement" || nodeType === "JSXSpreadAttribute" || nodeType === "JSXText" || nodeType === "JSXFragment" || nodeType === "JSXOpeningFragment" || nodeType === "JSXClosingFragment")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXAttribute = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXAttribute")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXClosingElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXClosingElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXClosingFragment = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXClosingFragment")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXEmptyExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXEmptyExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXExpressionContainer = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXExpressionContainer")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXFragment = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXFragment")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXIdentifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXIdentifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXMemberExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXMemberExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXNamespacedName = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXNamespacedName")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXOpeningElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXOpeningElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXOpeningFragment = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXOpeningFragment")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXSpreadAttribute = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXSpreadAttribute")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXSpreadChild = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXSpreadChild")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isJSXText = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "JSXText")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isLVal = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "Identifier" || nodeType === "MemberExpression" || nodeType === "RestElement" || nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "TSParameterProperty" || nodeType === "Placeholder" && (node.expectedNode === "Pattern" || node.expectedNode === "Identifier"))
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isLabeledStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "LabeledStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isLiteral = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "TemplateLiteral" || nodeType === "BigIntLiteral" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isLogicalExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "LogicalExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isLoop = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "WhileStatement" || nodeType === "ForOfStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isMemberExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "MemberExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isMetaProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "MetaProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isMethod = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ObjectMethod" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isMiscellaneous = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "Noop" || nodeType === "Placeholder" || nodeType === "V8IntrinsicIdentifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isMixedTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "MixedTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isModuleDeclaration = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ImportDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isModuleExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ModuleExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isModuleSpecifier = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ExportSpecifier" || nodeType === "ImportDefaultSpecifier" || nodeType === "ImportNamespaceSpecifier" || nodeType === "ImportSpecifier" || nodeType === "ExportNamespaceSpecifier" || nodeType === "ExportDefaultSpecifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNewExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NewExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNoop = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Noop")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNullLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NullLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNullLiteralTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NullLiteralTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNullableTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NullableTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNumberLiteral = function(node, opts) {
          if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), !node)
            return false;
          if (node.type === "NumberLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNumberLiteralTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NumberLiteralTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNumberTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NumberTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isNumericLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "NumericLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectMember = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ObjectMethod" || nodeType === "ObjectProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectMethod = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectPattern = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectPattern")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeCallProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeCallProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeIndexer = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeIndexer")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeInternalSlot = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeInternalSlot")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isObjectTypeSpreadProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ObjectTypeSpreadProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isOpaqueType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "OpaqueType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isOptionalCallExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "OptionalCallExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isOptionalIndexedAccessType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "OptionalIndexedAccessType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isOptionalMemberExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "OptionalMemberExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isParenthesizedExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ParenthesizedExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPattern = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "Placeholder" && node.expectedNode === "Pattern")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPatternLike = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "Identifier" || nodeType === "RestElement" || nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ObjectPattern" || nodeType === "Placeholder" && (node.expectedNode === "Pattern" || node.expectedNode === "Identifier"))
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPipelineBareFunction = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "PipelineBareFunction")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPipelinePrimaryTopicReference = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "PipelinePrimaryTopicReference")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPipelineTopicExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "PipelineTopicExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPlaceholder = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Placeholder")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPrivate = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ClassPrivateProperty" || nodeType === "ClassPrivateMethod" || nodeType === "PrivateName")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPrivateName = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "PrivateName")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isProgram = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Program")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isProperty = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ObjectProperty" || nodeType === "ClassProperty" || nodeType === "ClassPrivateProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isPureish = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "ArrowFunctionExpression" || nodeType === "BigIntLiteral" || nodeType === "DecimalLiteral" || nodeType === "Placeholder" && node.expectedNode === "StringLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isQualifiedTypeIdentifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "QualifiedTypeIdentifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isRecordExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "RecordExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isRegExpLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "RegExpLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isRegexLiteral = function(node, opts) {
          if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), !node)
            return false;
          if (node.type === "RegexLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isRestElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "RestElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isRestProperty = function(node, opts) {
          if (console.trace("The node type RestProperty has been renamed to RestElement"), !node)
            return false;
          if (node.type === "RestProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isReturnStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ReturnStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isScopable = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BlockStatement" || nodeType === "CatchClause" || nodeType === "DoWhileStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "Program" || nodeType === "ObjectMethod" || nodeType === "SwitchStatement" || nodeType === "WhileStatement" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassExpression" || nodeType === "ClassDeclaration" || nodeType === "ForOfStatement" || nodeType === "ClassMethod" || nodeType === "ClassPrivateMethod" || nodeType === "StaticBlock" || nodeType === "TSModuleBlock" || nodeType === "Placeholder" && node.expectedNode === "BlockStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSequenceExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "SequenceExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSpreadElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "SpreadElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSpreadProperty = function(node, opts) {
          if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"), !node)
            return false;
          if (node.type === "SpreadProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStandardized = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ArrayExpression" || nodeType === "AssignmentExpression" || nodeType === "BinaryExpression" || nodeType === "InterpreterDirective" || nodeType === "Directive" || nodeType === "DirectiveLiteral" || nodeType === "BlockStatement" || nodeType === "BreakStatement" || nodeType === "CallExpression" || nodeType === "CatchClause" || nodeType === "ConditionalExpression" || nodeType === "ContinueStatement" || nodeType === "DebuggerStatement" || nodeType === "DoWhileStatement" || nodeType === "EmptyStatement" || nodeType === "ExpressionStatement" || nodeType === "File" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "FunctionExpression" || nodeType === "Identifier" || nodeType === "IfStatement" || nodeType === "LabeledStatement" || nodeType === "StringLiteral" || nodeType === "NumericLiteral" || nodeType === "NullLiteral" || nodeType === "BooleanLiteral" || nodeType === "RegExpLiteral" || nodeType === "LogicalExpression" || nodeType === "MemberExpression" || nodeType === "NewExpression" || nodeType === "Program" || nodeType === "ObjectExpression" || nodeType === "ObjectMethod" || nodeType === "ObjectProperty" || nodeType === "RestElement" || nodeType === "ReturnStatement" || nodeType === "SequenceExpression" || nodeType === "ParenthesizedExpression" || nodeType === "SwitchCase" || nodeType === "SwitchStatement" || nodeType === "ThisExpression" || nodeType === "ThrowStatement" || nodeType === "TryStatement" || nodeType === "UnaryExpression" || nodeType === "UpdateExpression" || nodeType === "VariableDeclaration" || nodeType === "VariableDeclarator" || nodeType === "WhileStatement" || nodeType === "WithStatement" || nodeType === "AssignmentPattern" || nodeType === "ArrayPattern" || nodeType === "ArrowFunctionExpression" || nodeType === "ClassBody" || nodeType === "ClassExpression" || nodeType === "ClassDeclaration" || nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ForOfStatement" || nodeType === "ImportDeclaration" || nodeType === "ImportDefaultSpecifier" || nodeType === "ImportNamespaceSpecifier" || nodeType === "ImportSpecifier" || nodeType === "MetaProperty" || nodeType === "ClassMethod" || nodeType === "ObjectPattern" || nodeType === "SpreadElement" || nodeType === "Super" || nodeType === "TaggedTemplateExpression" || nodeType === "TemplateElement" || nodeType === "TemplateLiteral" || nodeType === "YieldExpression" || nodeType === "AwaitExpression" || nodeType === "Import" || nodeType === "BigIntLiteral" || nodeType === "ExportNamespaceSpecifier" || nodeType === "OptionalMemberExpression" || nodeType === "OptionalCallExpression" || nodeType === "ClassProperty" || nodeType === "ClassPrivateProperty" || nodeType === "ClassPrivateMethod" || nodeType === "PrivateName" || nodeType === "StaticBlock" || nodeType === "Placeholder" && (node.expectedNode === "Identifier" || node.expectedNode === "StringLiteral" || node.expectedNode === "BlockStatement" || node.expectedNode === "ClassBody"))
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStatement = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BlockStatement" || nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "DebuggerStatement" || nodeType === "DoWhileStatement" || nodeType === "EmptyStatement" || nodeType === "ExpressionStatement" || nodeType === "ForInStatement" || nodeType === "ForStatement" || nodeType === "FunctionDeclaration" || nodeType === "IfStatement" || nodeType === "LabeledStatement" || nodeType === "ReturnStatement" || nodeType === "SwitchStatement" || nodeType === "ThrowStatement" || nodeType === "TryStatement" || nodeType === "VariableDeclaration" || nodeType === "WhileStatement" || nodeType === "WithStatement" || nodeType === "ClassDeclaration" || nodeType === "ExportAllDeclaration" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportNamedDeclaration" || nodeType === "ForOfStatement" || nodeType === "ImportDeclaration" || nodeType === "DeclareClass" || nodeType === "DeclareFunction" || nodeType === "DeclareInterface" || nodeType === "DeclareModule" || nodeType === "DeclareModuleExports" || nodeType === "DeclareTypeAlias" || nodeType === "DeclareOpaqueType" || nodeType === "DeclareVariable" || nodeType === "DeclareExportDeclaration" || nodeType === "DeclareExportAllDeclaration" || nodeType === "InterfaceDeclaration" || nodeType === "OpaqueType" || nodeType === "TypeAlias" || nodeType === "EnumDeclaration" || nodeType === "TSDeclareFunction" || nodeType === "TSInterfaceDeclaration" || nodeType === "TSTypeAliasDeclaration" || nodeType === "TSEnumDeclaration" || nodeType === "TSModuleDeclaration" || nodeType === "TSImportEqualsDeclaration" || nodeType === "TSExportAssignment" || nodeType === "TSNamespaceExportDeclaration" || nodeType === "Placeholder" && (node.expectedNode === "Statement" || node.expectedNode === "Declaration" || node.expectedNode === "BlockStatement"))
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStaticBlock = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "StaticBlock")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStringLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "StringLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStringLiteralTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "StringLiteralTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isStringTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "StringTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSuper = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Super")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSwitchCase = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "SwitchCase")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSwitchStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "SwitchStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isSymbolTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "SymbolTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSAnyKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSAnyKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSArrayType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSArrayType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSAsExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSAsExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSBaseType = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "TSAnyKeyword" || nodeType === "TSBooleanKeyword" || nodeType === "TSBigIntKeyword" || nodeType === "TSIntrinsicKeyword" || nodeType === "TSNeverKeyword" || nodeType === "TSNullKeyword" || nodeType === "TSNumberKeyword" || nodeType === "TSObjectKeyword" || nodeType === "TSStringKeyword" || nodeType === "TSSymbolKeyword" || nodeType === "TSUndefinedKeyword" || nodeType === "TSUnknownKeyword" || nodeType === "TSVoidKeyword" || nodeType === "TSThisType" || nodeType === "TSLiteralType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSBigIntKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSBigIntKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSBooleanKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSBooleanKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSCallSignatureDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSCallSignatureDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSConditionalType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSConditionalType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSConstructSignatureDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSConstructSignatureDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSConstructorType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSConstructorType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSDeclareFunction = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSDeclareFunction")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSDeclareMethod = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSDeclareMethod")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSEntityName = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "Identifier" || nodeType === "TSQualifiedName" || nodeType === "Placeholder" && node.expectedNode === "Identifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSEnumDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSEnumDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSEnumMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSEnumMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSExportAssignment = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSExportAssignment")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSExpressionWithTypeArguments = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSExpressionWithTypeArguments")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSExternalModuleReference = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSExternalModuleReference")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSFunctionType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSFunctionType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSImportEqualsDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSImportEqualsDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSImportType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSImportType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSIndexSignature = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSIndexSignature")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSIndexedAccessType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSIndexedAccessType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSInferType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSInferType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSInterfaceBody = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSInterfaceBody")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSInterfaceDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSInterfaceDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSIntersectionType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSIntersectionType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSIntrinsicKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSIntrinsicKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSLiteralType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSLiteralType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSMappedType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSMappedType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSMethodSignature = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSMethodSignature")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSModuleBlock = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSModuleBlock")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSModuleDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSModuleDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNamedTupleMember = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNamedTupleMember")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNamespaceExportDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNamespaceExportDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNeverKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNeverKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNonNullExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNonNullExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNullKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNullKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSNumberKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSNumberKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSObjectKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSObjectKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSOptionalType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSOptionalType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSParameterProperty = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSParameterProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSParenthesizedType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSParenthesizedType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSPropertySignature = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSPropertySignature")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSQualifiedName = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSQualifiedName")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSRestType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSRestType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSStringKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSStringKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSSymbolKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSSymbolKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSThisType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSThisType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTupleType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTupleType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSType = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "TSAnyKeyword" || nodeType === "TSBooleanKeyword" || nodeType === "TSBigIntKeyword" || nodeType === "TSIntrinsicKeyword" || nodeType === "TSNeverKeyword" || nodeType === "TSNullKeyword" || nodeType === "TSNumberKeyword" || nodeType === "TSObjectKeyword" || nodeType === "TSStringKeyword" || nodeType === "TSSymbolKeyword" || nodeType === "TSUndefinedKeyword" || nodeType === "TSUnknownKeyword" || nodeType === "TSVoidKeyword" || nodeType === "TSThisType" || nodeType === "TSFunctionType" || nodeType === "TSConstructorType" || nodeType === "TSTypeReference" || nodeType === "TSTypePredicate" || nodeType === "TSTypeQuery" || nodeType === "TSTypeLiteral" || nodeType === "TSArrayType" || nodeType === "TSTupleType" || nodeType === "TSOptionalType" || nodeType === "TSRestType" || nodeType === "TSUnionType" || nodeType === "TSIntersectionType" || nodeType === "TSConditionalType" || nodeType === "TSInferType" || nodeType === "TSParenthesizedType" || nodeType === "TSTypeOperator" || nodeType === "TSIndexedAccessType" || nodeType === "TSMappedType" || nodeType === "TSLiteralType" || nodeType === "TSExpressionWithTypeArguments" || nodeType === "TSImportType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeAliasDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeAliasDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeAssertion = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeAssertion")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeElement = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "TSCallSignatureDeclaration" || nodeType === "TSConstructSignatureDeclaration" || nodeType === "TSPropertySignature" || nodeType === "TSMethodSignature" || nodeType === "TSIndexSignature")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeOperator = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeOperator")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeParameter = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeParameter")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeParameterDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeParameterDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeParameterInstantiation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeParameterInstantiation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypePredicate = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypePredicate")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeQuery = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeQuery")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSTypeReference = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSTypeReference")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSUndefinedKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSUndefinedKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSUnionType = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSUnionType")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSUnknownKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSUnknownKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTSVoidKeyword = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TSVoidKeyword")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTaggedTemplateExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TaggedTemplateExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTemplateElement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TemplateElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTemplateLiteral = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TemplateLiteral")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTerminatorless = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "BreakStatement" || nodeType === "ContinueStatement" || nodeType === "ReturnStatement" || nodeType === "ThrowStatement" || nodeType === "YieldExpression" || nodeType === "AwaitExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isThisExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ThisExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isThisTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ThisTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isThrowStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "ThrowStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTopicReference = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TopicReference")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTryStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TryStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTupleExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TupleExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTupleTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TupleTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeAlias = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeAlias")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeCastExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeCastExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeParameter = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeParameter")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeParameterDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeParameterDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeParameterInstantiation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeParameterInstantiation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeScript = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "TSParameterProperty" || nodeType === "TSDeclareFunction" || nodeType === "TSDeclareMethod" || nodeType === "TSQualifiedName" || nodeType === "TSCallSignatureDeclaration" || nodeType === "TSConstructSignatureDeclaration" || nodeType === "TSPropertySignature" || nodeType === "TSMethodSignature" || nodeType === "TSIndexSignature" || nodeType === "TSAnyKeyword" || nodeType === "TSBooleanKeyword" || nodeType === "TSBigIntKeyword" || nodeType === "TSIntrinsicKeyword" || nodeType === "TSNeverKeyword" || nodeType === "TSNullKeyword" || nodeType === "TSNumberKeyword" || nodeType === "TSObjectKeyword" || nodeType === "TSStringKeyword" || nodeType === "TSSymbolKeyword" || nodeType === "TSUndefinedKeyword" || nodeType === "TSUnknownKeyword" || nodeType === "TSVoidKeyword" || nodeType === "TSThisType" || nodeType === "TSFunctionType" || nodeType === "TSConstructorType" || nodeType === "TSTypeReference" || nodeType === "TSTypePredicate" || nodeType === "TSTypeQuery" || nodeType === "TSTypeLiteral" || nodeType === "TSArrayType" || nodeType === "TSTupleType" || nodeType === "TSOptionalType" || nodeType === "TSRestType" || nodeType === "TSNamedTupleMember" || nodeType === "TSUnionType" || nodeType === "TSIntersectionType" || nodeType === "TSConditionalType" || nodeType === "TSInferType" || nodeType === "TSParenthesizedType" || nodeType === "TSTypeOperator" || nodeType === "TSIndexedAccessType" || nodeType === "TSMappedType" || nodeType === "TSLiteralType" || nodeType === "TSExpressionWithTypeArguments" || nodeType === "TSInterfaceDeclaration" || nodeType === "TSInterfaceBody" || nodeType === "TSTypeAliasDeclaration" || nodeType === "TSAsExpression" || nodeType === "TSTypeAssertion" || nodeType === "TSEnumDeclaration" || nodeType === "TSEnumMember" || nodeType === "TSModuleDeclaration" || nodeType === "TSModuleBlock" || nodeType === "TSImportType" || nodeType === "TSImportEqualsDeclaration" || nodeType === "TSExternalModuleReference" || nodeType === "TSNonNullExpression" || nodeType === "TSExportAssignment" || nodeType === "TSNamespaceExportDeclaration" || nodeType === "TSTypeAnnotation" || nodeType === "TSTypeParameterInstantiation" || nodeType === "TSTypeParameterDeclaration" || nodeType === "TSTypeParameter")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isTypeofTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "TypeofTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isUnaryExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "UnaryExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isUnaryLike = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "UnaryExpression" || nodeType === "SpreadElement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isUnionTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "UnionTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isUpdateExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "UpdateExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isUserWhitespacable = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "ObjectMethod" || nodeType === "ObjectProperty" || nodeType === "ObjectTypeInternalSlot" || nodeType === "ObjectTypeCallProperty" || nodeType === "ObjectTypeIndexer" || nodeType === "ObjectTypeProperty" || nodeType === "ObjectTypeSpreadProperty")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isV8IntrinsicIdentifier = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "V8IntrinsicIdentifier")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isVariableDeclaration = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "VariableDeclaration")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isVariableDeclarator = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "VariableDeclarator")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isVariance = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "Variance")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isVoidTypeAnnotation = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "VoidTypeAnnotation")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isWhile = function(node, opts) {
          if (!node)
            return false;
          const nodeType = node.type;
          if (nodeType === "DoWhileStatement" || nodeType === "WhileStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isWhileStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "WhileStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isWithStatement = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "WithStatement")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        }, exports2.isYieldExpression = function(node, opts) {
          if (!node)
            return false;
          if (node.type === "YieldExpression")
            return opts === void 0 || (0, _shallowEqual.default)(node, opts);
          return false;
        };
        var _shallowEqual = __webpack_require__2("./node_modules/@babel/types/lib/utils/shallowEqual.js");
      }, "./node_modules/@babel/types/lib/validators/is.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(type, node, opts) {
          if (!node)
            return false;
          if (!(0, _isType.default)(node.type, type))
            return !opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS && (0, _isPlaceholderType.default)(node.expectedNode, type);
          return opts === void 0 || (0, _shallowEqual.default)(node, opts);
        };
        var _shallowEqual = __webpack_require__2("./node_modules/@babel/types/lib/utils/shallowEqual.js"), _isType = __webpack_require__2("./node_modules/@babel/types/lib/validators/isType.js"), _isPlaceholderType = __webpack_require__2("./node_modules/@babel/types/lib/validators/isPlaceholderType.js"), _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/validators/isBinding.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, parent, grandparent) {
          if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression")
            return false;
          const keys = _getBindingIdentifiers.default.keys[parent.type];
          if (keys)
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i], val = parent[key];
              if (Array.isArray(val)) {
                if (val.indexOf(node) >= 0)
                  return true;
              } else if (val === node)
                return true;
            }
          return false;
        };
        var _getBindingIdentifiers = __webpack_require__2("./node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/@babel/types/lib/validators/isBlockScoped.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _isLet = __webpack_require__2("./node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/@babel/types/lib/validators/isImmutable.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          if ((0, _isType.default)(node.type, "Immutable"))
            return true;
          if ((0, _generated.isIdentifier)(node))
            return node.name === "undefined";
          return false;
        };
        var _isType = __webpack_require__2("./node_modules/@babel/types/lib/validators/isType.js"), _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/@babel/types/lib/validators/isLet.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/@babel/types/lib/validators/isNode.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return !(!node || !_definitions.VISITOR_KEYS[node.type]);
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/validators/isNodesEquivalent.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function isNodesEquivalent(a, b) {
          if (typeof a != "object" || typeof b != "object" || a == null || b == null)
            return a === b;
          if (a.type !== b.type)
            return false;
          const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type), visitorKeys = _definitions.VISITOR_KEYS[a.type];
          for (const field of fields) {
            if (typeof a[field] != typeof b[field])
              return false;
            if (a[field] != null || b[field] != null) {
              if (a[field] == null || b[field] == null)
                return false;
              if (Array.isArray(a[field])) {
                if (!Array.isArray(b[field]))
                  return false;
                if (a[field].length !== b[field].length)
                  return false;
                for (let i = 0; i < a[field].length; i++)
                  if (!isNodesEquivalent(a[field][i], b[field][i]))
                    return false;
              } else if (typeof a[field] != "object" || visitorKeys != null && visitorKeys.includes(field)) {
                if (!isNodesEquivalent(a[field], b[field]))
                  return false;
              } else
                for (const key of Object.keys(a[field]))
                  if (a[field][key] !== b[field][key])
                    return false;
            }
          }
          return true;
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/validators/isPlaceholderType.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(placeholderType, targetType) {
          if (placeholderType === targetType)
            return true;
          const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
          if (aliases) {
            for (const alias of aliases)
              if (targetType === alias)
                return true;
          }
          return false;
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/validators/isReferenced.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, parent, grandparent) {
          switch (parent.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return parent.property === node ? !!parent.computed : parent.object === node;
            case "JSXMemberExpression":
              return parent.object === node;
            case "VariableDeclarator":
              return parent.init === node;
            case "ArrowFunctionExpression":
              return parent.body === node;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return false;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return parent.key === node && !!parent.computed;
            case "ObjectProperty":
              return parent.key === node ? !!parent.computed : !grandparent || grandparent.type !== "ObjectPattern";
            case "ClassProperty":
            case "TSPropertySignature":
              return parent.key !== node || !!parent.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return parent.key !== node;
            case "ClassDeclaration":
            case "ClassExpression":
              return parent.superClass === node;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return parent.right === node;
            case "ExportSpecifier":
              return (grandparent == null || !grandparent.source) && parent.local === node;
            case "TSEnumMember":
              return parent.id !== node;
          }
          return true;
        };
      }, "./node_modules/@babel/types/lib/validators/isScope.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, parent) {
          if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent)))
            return false;
          if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, _generated.isCatchClause)(parent)))
            return true;
          return (0, _generated.isScopable)(node);
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/@babel/types/lib/validators/isSpecifierDefault.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(specifier) {
          return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, { name: "default" });
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/@babel/types/lib/validators/isType.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(nodeType, targetType) {
          if (nodeType === targetType)
            return true;
          if (_definitions.ALIAS_KEYS[targetType])
            return false;
          const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
          if (aliases) {
            if (aliases[0] === nodeType)
              return true;
            for (const alias of aliases)
              if (nodeType === alias)
                return true;
          }
          return false;
        };
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/@babel/types/lib/validators/isValidES3Identifier.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(name) {
          return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
        };
        var _isValidIdentifier = __webpack_require__2("./node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/@babel/types/lib/validators/isValidIdentifier.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(name, reserved = true) {
          if (typeof name != "string")
            return false;
          if (reserved && ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)))
            return false;
          return (0, _helperValidatorIdentifier.isIdentifierName)(name);
        };
        var _helperValidatorIdentifier = __webpack_require__2("./node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/@babel/types/lib/validators/isVar.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node) {
          return (0, _generated.isVariableDeclaration)(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js"), _constants = __webpack_require__2("./node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/@babel/types/lib/validators/matchesPattern.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(member, match, allowPartial) {
          if (!(0, _generated.isMemberExpression)(member))
            return false;
          const parts = Array.isArray(match) ? match : match.split("."), nodes = [];
          let node;
          for (node = member; (0, _generated.isMemberExpression)(node); node = node.object)
            nodes.push(node.property);
          if (nodes.push(node), nodes.length < parts.length)
            return false;
          if (!allowPartial && nodes.length > parts.length)
            return false;
          for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
            const node2 = nodes[j];
            let value;
            if ((0, _generated.isIdentifier)(node2))
              value = node2.name;
            else if ((0, _generated.isStringLiteral)(node2))
              value = node2.value;
            else {
              if (!(0, _generated.isThisExpression)(node2))
                return false;
              value = "this";
            }
            if (parts[i] !== value)
              return false;
          }
          return true;
        };
        var _generated = __webpack_require__2("./node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/@babel/types/lib/validators/react/isCompatTag.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(tagName) {
          return !!tagName && /^[a-z]/.test(tagName);
        };
      }, "./node_modules/@babel/types/lib/validators/react/isReactComponent.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = void 0;
        var _default = (0, __webpack_require__2("./node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        exports2.default = _default;
      }, "./node_modules/@babel/types/lib/validators/validate.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(node, key, val) {
          if (!node)
            return;
          const fields = _definitions.NODE_FIELDS[node.type];
          if (!fields)
            return;
          const field = fields[key];
          validateField(node, key, val, field), validateChild(node, key, val);
        }, exports2.validateChild = validateChild, exports2.validateField = validateField;
        var _definitions = __webpack_require__2("./node_modules/@babel/types/lib/definitions/index.js");
        function validateField(node, key, val, field) {
          field != null && field.validate && (field.optional && val == null || field.validate(node, key, val));
        }
        function validateChild(node, key, val) {
          if (val == null)
            return;
          const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
          validate && validate(node, key, val);
        }
      }, "./node_modules/babel-plugin-dynamic-import-node/lib/index.js": (module3, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true }), exports2.default = function(api) {
          var transformImport = (0, _utils.createDynamicImportTransform)(api);
          return { manipulateOptions: function(opts, parserOpts) {
            parserOpts.plugins.push("dynamicImport");
          }, visitor: { Import: function(path) {
            transformImport(this, path);
          } } };
        };
        var _utils = __webpack_require__2("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
        module3.exports = exports2.default;
      }, "./node_modules/babel-plugin-dynamic-import-node/lib/utils.js": (__unused_webpack_module, exports2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var _slicedToArray = function(arr, i) {
          if (Array.isArray(arr))
            return arr;
          if (Symbol.iterator in Object(arr))
            return function(arr2, i2) {
              var _arr = [], _n = true, _d = false, _e = void 0;
              try {
                for (var _s, _i = arr2[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = true)
                  ;
              } catch (err) {
                _d = true, _e = err;
              } finally {
                try {
                  !_n && _i.return && _i.return();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }(arr, i);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
        function getImportSource(t, callNode) {
          var importArguments = callNode.arguments, importPath = _slicedToArray(importArguments, 1)[0];
          return t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath) ? (t.removeComments(importPath), importPath) : t.templateLiteral([t.templateElement({ raw: "", cooked: "" }), t.templateElement({ raw: "", cooked: "" }, true)], importArguments);
        }
        exports2.getImportSource = getImportSource, exports2.createDynamicImportTransform = function(_ref) {
          var template = _ref.template, t = _ref.types, builders = { static: { interop: template("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: template("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: template("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: template("Promise.resolve(SOURCE).then(s => require(s))") } }, visited = typeof WeakSet == "function" && /* @__PURE__ */ new WeakSet();
          return function(context, path) {
            if (visited) {
              if (visited.has(path))
                return;
              visited.add(path);
            }
            var node, SOURCE = getImportSource(t, path.parent), builder = (node = SOURCE, t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0 ? builders.static : builders.dynamic), newImport = context.opts.noInterop ? builder.noInterop({ SOURCE }) : builder.interop({ SOURCE, INTEROP: context.addHelper("interopRequireWildcard") });
            path.parentPath.replaceWith(newImport);
          };
        };
      }, "./node_modules/babel-plugin-dynamic-import-node/utils.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        module3.exports = __webpack_require__2("./node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
      }, "./node_modules/babel-plugin-parameter-decorator/lib/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        var _path = __webpack_require__2("path");
        function isInType(path) {
          switch (path.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            default:
              return false;
          }
        }
        module3.exports = function(_ref) {
          var types = _ref.types, decoratorExpressionForConstructor = function(decorator, param) {
            return function(className) {
              var resultantDecorator = types.callExpression(decorator.expression, [types.Identifier(className), types.Identifier("undefined"), types.NumericLiteral(param.key)]), resultantDecoratorWithFallback = types.logicalExpression("||", resultantDecorator, types.Identifier(className)), assignment = types.assignmentExpression("=", types.Identifier(className), resultantDecoratorWithFallback);
              return types.expressionStatement(assignment);
            };
          }, decoratorExpressionForMethod = function(decorator, param) {
            return function(className, functionName) {
              var resultantDecorator = types.callExpression(decorator.expression, [types.Identifier("".concat(className, ".prototype")), types.StringLiteral(functionName), types.NumericLiteral(param.key)]);
              return types.expressionStatement(resultantDecorator);
            };
          };
          return { visitor: { Program: function(path, state) {
            var extension = (0, _path.extname)(state.file.opts.filename);
            extension !== ".ts" && extension !== ".tsx" || function() {
              var decorators = /* @__PURE__ */ Object.create(null);
              path.node.body.filter(function(it) {
                var type = it.type, declaration = it.declaration;
                switch (type) {
                  case "ClassDeclaration":
                    return true;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return declaration && declaration.type === "ClassDeclaration";
                  default:
                    return false;
                }
              }).map(function(it) {
                return it.type === "ClassDeclaration" ? it : it.declaration;
              }).forEach(function(clazz) {
                clazz.body.body.forEach(function(body) {
                  (body.params || []).forEach(function(param) {
                    (param.decorators || []).forEach(function(decorator) {
                      decorator.expression.callee ? decorators[decorator.expression.callee.name] = decorator : decorators[decorator.expression.name] = decorator;
                    });
                  });
                });
              });
              var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
              try {
                for (var _step, _iterator = path.get("body")[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var stmt = _step.value;
                  if (stmt.node.type === "ImportDeclaration") {
                    if (stmt.node.specifiers.length === 0)
                      continue;
                    var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
                    try {
                      for (var _step2, _loop = function() {
                        var specifier = _step2.value, binding = stmt.scope.getBinding(specifier.local.name);
                        binding.referencePaths.length ? binding.referencePaths.reduce(function(prev, next) {
                          return prev || isInType(next);
                        }, false) && Object.keys(decorators).forEach(function(k) {
                          var decorator = decorators[k];
                          (decorator.expression.arguments || []).forEach(function(arg) {
                            arg.name === specifier.local.name && binding.referencePaths.push({ parent: decorator.expression });
                          });
                        }) : decorators[specifier.local.name] && binding.referencePaths.push({ parent: decorators[specifier.local.name] });
                      }, _iterator2 = stmt.node.specifiers[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true)
                        _loop();
                    } catch (err) {
                      _didIteratorError2 = true, _iteratorError2 = err;
                    } finally {
                      try {
                        _iteratorNormalCompletion2 || _iterator2.return == null || _iterator2.return();
                      } finally {
                        if (_didIteratorError2)
                          throw _iteratorError2;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError = true, _iteratorError = err;
              } finally {
                try {
                  _iteratorNormalCompletion || _iterator.return == null || _iterator.return();
                } finally {
                  if (_didIteratorError)
                    throw _iteratorError;
                }
              }
            }();
          }, Function: function(path) {
            var functionName = "";
            path.node.id ? functionName = path.node.id.name : path.node.key && (functionName = path.node.key.name), (path.get("params") || []).slice().forEach(function(param) {
              var decorators = param.node.decorators || [], transformable = decorators.length;
              if (decorators.slice().forEach(function(decorator) {
                if (path.type === "ClassMethod") {
                  var classIdentifier, parentNode = path.parentPath.parentPath, classDeclaration = path.findParent(function(p) {
                    return p.type === "ClassDeclaration";
                  });
                  if (classDeclaration ? classIdentifier = classDeclaration.node.id.name : (parentNode.insertAfter(null), classIdentifier = function(path2) {
                    var assignment = path2.findParent(function(p) {
                      return p.node.type === "AssignmentExpression";
                    });
                    return assignment.node.right.type === "SequenceExpression" ? assignment.node.right.expressions[1].name : assignment.node.right.type === "ClassExpression" ? assignment.node.left.name : null;
                  }(path)), functionName === "constructor") {
                    var expression = decoratorExpressionForConstructor(decorator, param)(classIdentifier);
                    parentNode.insertAfter(expression);
                  } else {
                    var _expression = decoratorExpressionForMethod(decorator, param)(classIdentifier, functionName);
                    parentNode.insertAfter(_expression);
                  }
                } else {
                  var className = path.findParent(function(p) {
                    return p.node.type === "VariableDeclarator";
                  }).node.id.name;
                  if (functionName === className) {
                    var _expression2 = decoratorExpressionForConstructor(decorator, param)(className);
                    if (path.parentKey === "body")
                      path.insertAfter(_expression2);
                    else
                      path.findParent(function(p) {
                        return p.parentKey === "body";
                      }).insertAfter(_expression2);
                  } else {
                    var classParent = path.findParent(function(p) {
                      return p.node.type === "CallExpression";
                    }), _expression3 = decoratorExpressionForMethod(decorator, param)(className, functionName);
                    classParent.insertAfter(_expression3);
                  }
                }
              }), transformable) {
                var replacement = function(path2) {
                  switch (path2.node.type) {
                    case "ObjectPattern":
                      return types.ObjectPattern(path2.node.properties);
                    case "AssignmentPattern":
                      return types.AssignmentPattern(path2.node.left, path2.node.right);
                    case "TSParameterProperty":
                      return types.Identifier(path2.node.parameter.name);
                    default:
                      return types.Identifier(path2.node.name);
                  }
                }(param);
                param.replaceWith(replacement);
              }
            });
          } } };
        };
      }, "./node_modules/convert-source-map/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        var fs3 = __webpack_require__2("fs"), path = __webpack_require__2("path"), SafeBuffer = __webpack_require__2("./node_modules/safe-buffer/index.js");
        function Converter(sm, opts) {
          var base64;
          (opts = opts || {}).isFileComment && (sm = function(sm2, dir) {
            var r = exports2.mapFileCommentRegex.exec(sm2), filename = r[1] || r[2], filepath = path.resolve(dir, filename);
            try {
              return fs3.readFileSync(filepath, "utf8");
            } catch (e2) {
              throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e2);
            }
          }(sm, opts.commentFileDir)), opts.hasComment && (sm = function(sm2) {
            return sm2.split(",").pop();
          }(sm)), opts.isEncoded && (base64 = sm, sm = (SafeBuffer.Buffer.from(base64, "base64") || "").toString()), (opts.isJSON || opts.isEncoded) && (sm = JSON.parse(sm)), this.sourcemap = sm;
        }
        Object.defineProperty(exports2, "commentRegex", { get: function() {
          return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm;
        } }), Object.defineProperty(exports2, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm;
        } }), Converter.prototype.toJSON = function(space) {
          return JSON.stringify(this.sourcemap, null, space);
        }, Converter.prototype.toBase64 = function() {
          var json = this.toJSON();
          return (SafeBuffer.Buffer.from(json, "utf8") || "").toString("base64");
        }, Converter.prototype.toComment = function(options) {
          var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + this.toBase64();
          return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
        }, Converter.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, Converter.prototype.addProperty = function(key, value) {
          if (this.sourcemap.hasOwnProperty(key))
            throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(key, value);
        }, Converter.prototype.setProperty = function(key, value) {
          return this.sourcemap[key] = value, this;
        }, Converter.prototype.getProperty = function(key) {
          return this.sourcemap[key];
        }, exports2.fromObject = function(obj) {
          return new Converter(obj);
        }, exports2.fromJSON = function(json) {
          return new Converter(json, { isJSON: true });
        }, exports2.fromBase64 = function(base64) {
          return new Converter(base64, { isEncoded: true });
        }, exports2.fromComment = function(comment) {
          return new Converter(comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { isEncoded: true, hasComment: true });
        }, exports2.fromMapFileComment = function(comment, dir) {
          return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
        }, exports2.fromSource = function(content) {
          var m = content.match(exports2.commentRegex);
          return m ? exports2.fromComment(m.pop()) : null;
        }, exports2.fromMapFileSource = function(content, dir) {
          var m = content.match(exports2.mapFileCommentRegex);
          return m ? exports2.fromMapFileComment(m.pop(), dir) : null;
        }, exports2.removeComments = function(src) {
          return src.replace(exports2.commentRegex, "");
        }, exports2.removeMapFileComments = function(src) {
          return src.replace(exports2.mapFileCommentRegex, "");
        }, exports2.generateMapFileComment = function(file, options) {
          var data = "sourceMappingURL=" + file;
          return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
        };
      }, "./node_modules/debug/src/browser.js": (module3, exports2, __webpack_require__2) => {
        exports2.formatArgs = function(args) {
          if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff), !this.useColors)
            return;
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index = 0, lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            match !== "%%" && (index++, match === "%c" && (lastC = index));
          }), args.splice(lastC, 0, c);
        }, exports2.save = function(namespaces) {
          try {
            namespaces ? exports2.storage.setItem("debug", namespaces) : exports2.storage.removeItem("debug");
          } catch (error) {
          }
        }, exports2.load = function() {
          let r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error) {
          }
          !r && typeof process != "undefined" && "env" in process && (r = process.env.DEBUG);
          return r;
        }, exports2.useColors = function() {
          if (typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
            return true;
          if (typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
            return false;
          return typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, exports2.storage = function() {
          try {
            return localStorage;
          } catch (error) {
          }
        }(), exports2.destroy = (() => {
          let warned2 = false;
          return () => {
            warned2 || (warned2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], exports2.log = console.debug || console.log || (() => {
        }), module3.exports = __webpack_require__2("./node_modules/debug/src/common.js")(exports2);
        const { formatters } = module3.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
          }
        };
      }, "./node_modules/debug/src/common.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        module3.exports = function(env) {
          function createDebug(namespace) {
            let prevTime, namespacesCache, enabledCache, enableOverride = null;
            function debug(...args) {
              if (!debug.enabled)
                return;
              const self2 = debug, curr = Number(new Date()), ms = curr - (prevTime || curr);
              self2.diff = ms, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%")
                  return "%";
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter == "function") {
                  const val = args[index];
                  match = formatter.call(self2, val), args.splice(index, 1), index--;
                }
                return match;
              }), createDebug.formatArgs.call(self2, args);
              (self2.log || createDebug.log).apply(self2, args);
            }
            return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend2, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", { enumerable: true, configurable: false, get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache), set: (v) => {
              enableOverride = v;
            } }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
          }
          function extend2(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (delimiter === void 0 ? ":" : delimiter) + namespace);
            return newDebug.log = this.log, newDebug;
          }
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(val) {
            if (val instanceof Error)
              return val.stack || val.message;
            return val;
          }, createDebug.disable = function() {
            const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)].join(",");
            return createDebug.enable(""), namespaces;
          }, createDebug.enable = function(namespaces) {
            let i;
            createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
            const split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/), len = split.length;
            for (i = 0; i < len; i++)
              split[i] && ((namespaces = split[i].replace(/\*/g, ".*?"))[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
          }, createDebug.enabled = function(name) {
            if (name[name.length - 1] === "*")
              return true;
            let i, len;
            for (i = 0, len = createDebug.skips.length; i < len; i++)
              if (createDebug.skips[i].test(name))
                return false;
            for (i = 0, len = createDebug.names.length; i < len; i++)
              if (createDebug.names[i].test(name))
                return true;
            return false;
          }, createDebug.humanize = __webpack_require__2("./node_modules/ms/index.js"), createDebug.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {}, createDebug.selectColor = function(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++)
              hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }, createDebug.enable(createDebug.load()), createDebug;
        };
      }, "./node_modules/debug/src/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        typeof process == "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs ? module3.exports = __webpack_require__2("./node_modules/debug/src/browser.js") : module3.exports = __webpack_require__2("./node_modules/debug/src/node.js");
      }, "./node_modules/debug/src/node.js": (module3, exports2, __webpack_require__2) => {
        const tty = __webpack_require__2("tty"), util = __webpack_require__2("util");
        exports2.init = function(debug) {
          debug.inspectOpts = {};
          const keys = Object.keys(exports2.inspectOpts);
          for (let i = 0; i < keys.length; i++)
            debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
        }, exports2.log = function(...args) {
          return process.stderr.write(util.format(...args) + "\n");
        }, exports2.formatArgs = function(args) {
          const { namespace: name, useColors } = this;
          if (useColors) {
            const c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \x1B[0m`;
            args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module3.exports.humanize(this.diff) + "\x1B[0m");
          } else
            args[0] = function() {
              if (exports2.inspectOpts.hideDate)
                return "";
              return new Date().toISOString() + " ";
            }() + name + " " + args[0];
        }, exports2.save = function(namespaces) {
          namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
        }, exports2.load = function() {
          return process.env.DEBUG;
        }, exports2.useColors = function() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }, exports2.destroy = util.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), exports2.colors = [6, 2, 3, 4, 5, 1];
        try {
          const supportsColor = __webpack_require__2("./node_modules/supports-color/index.js");
          supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports2.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch (error) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {
          const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase());
          let val = process.env[key];
          return val = !!/^(yes|on|true|enabled)$/i.test(val) || !/^(no|off|false|disabled)$/i.test(val) && (val === "null" ? null : Number(val)), obj[prop] = val, obj;
        }, {}), module3.exports = __webpack_require__2("./node_modules/debug/src/common.js")(exports2);
        const { formatters } = module3.exports;
        formatters.o = function(v) {
          return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
        }, formatters.O = function(v) {
          return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
        };
      }, "./node_modules/gensync/index.js": (module3) => {
        "use strict";
        const GENSYNC_START = Symbol.for("gensync:v1:start"), GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend");
        function assertTypeof(type, name, value, allowUndefined) {
          if (typeof value === type || allowUndefined && value === void 0)
            return;
          let msg;
          throw msg = allowUndefined ? `Expected opts.${name} to be either a ${type}, or undefined.` : `Expected opts.${name} to be a ${type}.`, makeError(msg, "GENSYNC_OPTIONS_ERROR");
        }
        function makeError(msg, code) {
          return Object.assign(new Error(msg), { code });
        }
        function buildOperation({ name, arity, sync, async }) {
          return setFunctionMetadata(name, arity, function* (...args) {
            const resume = yield GENSYNC_START;
            if (!resume) {
              return sync.call(this, args);
            }
            let result;
            try {
              async.call(this, args, (value) => {
                result || (result = { value }, resume());
              }, (err) => {
                result || (result = { err }, resume());
              });
            } catch (err) {
              result = { err }, resume();
            }
            if (yield GENSYNC_SUSPEND, result.hasOwnProperty("err"))
              throw result.err;
            return result.value;
          });
        }
        function evaluateSync(gen) {
          let value;
          for (; !({ value } = gen.next()).done; )
            assertStart(value, gen);
          return value;
        }
        function evaluateAsync(gen, resolve5, reject) {
          !function step() {
            try {
              let value;
              for (; !({ value } = gen.next()).done; ) {
                assertStart(value, gen);
                let sync = true, didSyncResume = false;
                const out = gen.next(() => {
                  sync ? didSyncResume = true : step();
                });
                if (sync = false, assertSuspend(out, gen), !didSyncResume)
                  return;
              }
              return resolve5(value);
            } catch (err) {
              return reject(err);
            }
          }();
        }
        function assertStart(value, gen) {
          value !== GENSYNC_START && throwError(gen, makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(value)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, "GENSYNC_EXPECTED_START"));
        }
        function assertSuspend({ value, done }, gen) {
          (done || value !== GENSYNC_SUSPEND) && throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(value)}. If you get this, it is probably a gensync bug.`, "GENSYNC_EXPECTED_SUSPEND"));
        }
        function throwError(gen, err) {
          throw gen.throw && gen.throw(err), err;
        }
        function setFunctionMetadata(name, arity, fn) {
          if (typeof name == "string") {
            const nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
            nameDesc && !nameDesc.configurable || Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, { configurable: true, value: name }));
          }
          if (typeof arity == "number") {
            const lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
            lengthDesc && !lengthDesc.configurable || Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, { configurable: true, value: arity }));
          }
          return fn;
        }
        module3.exports = Object.assign(function(optsOrFn) {
          let genFn = optsOrFn;
          return genFn = typeof optsOrFn != "function" ? function({ name, arity, sync, async, errback }) {
            if (assertTypeof("string", "name", name, true), assertTypeof("number", "arity", arity, true), assertTypeof("function", "sync", sync), assertTypeof("function", "async", async, true), assertTypeof("function", "errback", errback, true), async && errback)
              throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", "GENSYNC_OPTIONS_ERROR");
            if (typeof name != "string") {
              let fnName;
              errback && errback.name && errback.name !== "errback" && (fnName = errback.name), async && async.name && async.name !== "async" && (fnName = async.name.replace(/Async$/, "")), sync && sync.name && sync.name !== "sync" && (fnName = sync.name.replace(/Sync$/, "")), typeof fnName == "string" && (name = fnName);
            }
            typeof arity != "number" && (arity = sync.length);
            return buildOperation({ name, arity, sync: function(args) {
              return sync.apply(this, args);
            }, async: function(args, resolve5, reject) {
              async ? async.apply(this, args).then(resolve5, reject) : errback ? errback.call(this, ...args, (err, value) => {
                err == null ? resolve5(value) : reject(err);
              }) : resolve5(sync.apply(this, args));
            } });
          }(optsOrFn) : function(genFn2) {
            return setFunctionMetadata(genFn2.name, genFn2.length, function(...args) {
              return genFn2.apply(this, args);
            });
          }(optsOrFn), Object.assign(genFn, function(genFn2) {
            return { sync: function(...args) {
              return evaluateSync(genFn2.apply(this, args));
            }, async: function(...args) {
              return new Promise((resolve5, reject) => {
                evaluateAsync(genFn2.apply(this, args), resolve5, reject);
              });
            }, errback: function(...args) {
              const cb = args.pop();
              if (typeof cb != "function")
                throw makeError("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
              let gen;
              try {
                gen = genFn2.apply(this, args);
              } catch (err) {
                return void cb(err);
              }
              evaluateAsync(gen, (val) => cb(void 0, val), (err) => cb(err));
            } };
          }(genFn));
        }, { all: buildOperation({ name: "all", arity: 1, sync: function(args) {
          return Array.from(args[0]).map((item) => evaluateSync(item));
        }, async: function(args, resolve5, reject) {
          const items = Array.from(args[0]);
          if (items.length === 0)
            return void Promise.resolve().then(() => resolve5([]));
          let count = 0;
          const results = items.map(() => {
          });
          items.forEach((item, i) => {
            evaluateAsync(item, (val) => {
              results[i] = val, count += 1, count === results.length && resolve5(results);
            }, reject);
          });
        } }), race: buildOperation({ name: "race", arity: 1, sync: function(args) {
          const items = Array.from(args[0]);
          if (items.length === 0)
            throw makeError("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          return evaluateSync(items[0]);
        }, async: function(args, resolve5, reject) {
          const items = Array.from(args[0]);
          if (items.length === 0)
            throw makeError("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          for (const item of items)
            evaluateAsync(item, resolve5, reject);
        } }) });
      }, "./node_modules/jsesc/jsesc.js": (module3) => {
        "use strict";
        const object = {}, hasOwnProperty = object.hasOwnProperty, forOwn = (object2, callback) => {
          for (const key in object2)
            hasOwnProperty.call(object2, key) && callback(key, object2[key]);
        }, toString = object.toString, isArray2 = Array.isArray, isBuffer = Buffer.isBuffer, singleEscapes = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, regexSingleEscape = /["'\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitelist = /[ !#-&\(-\[\]-_a-~]/, jsesc = (argument, options) => {
          const increaseIndentation = () => {
            oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
          }, defaults = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, json = options && options.json;
          var destination, source;
          json && (defaults.quotes = "double", defaults.wrap = true), destination = defaults, options = (source = options) ? (forOwn(source, (key, value) => {
            destination[key] = value;
          }), destination) : destination, options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick" && (options.quotes = "single");
          const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex;
          let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
          const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : "\n";
          let result, isEmpty = true;
          const useBinNumbers = options.numbers == "binary", useOctNumbers = options.numbers == "octal", useDecNumbers = options.numbers == "decimal", useHexNumbers = options.numbers == "hexadecimal";
          if (json && argument && typeof argument.toJSON == "function" && (argument = argument.toJSON()), !((value) => typeof value == "string" || toString.call(value) == "[object String]")(argument)) {
            if (((value) => toString.call(value) == "[object Map]")(argument))
              return argument.size == 0 ? "new Map()" : (compact || (options.__inline1__ = true, options.__inline2__ = false), "new Map(" + jsesc(Array.from(argument), options) + ")");
            if (((value) => toString.call(value) == "[object Set]")(argument))
              return argument.size == 0 ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
            if (isBuffer(argument))
              return argument.length == 0 ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
            if (isArray2(argument))
              return result = [], options.wrap = true, inline1 && (options.__inline1__ = false, options.__inline2__ = true), inline2 || increaseIndentation(), ((array, callback) => {
                const length2 = array.length;
                let index2 = -1;
                for (; ++index2 < length2; )
                  callback(array[index2]);
              })(argument, (value) => {
                isEmpty = false, inline2 && (options.__inline2__ = false), result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
              }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
            if (!((value) => typeof value == "number" || toString.call(value) == "[object Number]")(argument))
              return ((value) => toString.call(value) == "[object Object]")(argument) ? (result = [], options.wrap = true, increaseIndentation(), forOwn(argument, (key, value) => {
                isEmpty = false, result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
              }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json ? JSON.stringify(argument) || "null" : String(argument);
            if (json)
              return JSON.stringify(argument);
            if (useDecNumbers)
              return String(argument);
            if (useHexNumbers) {
              let hexadecimal = argument.toString(16);
              return lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), "0x" + hexadecimal;
            }
            if (useBinNumbers)
              return "0b" + argument.toString(2);
            if (useOctNumbers)
              return "0o" + argument.toString(8);
          }
          const string = argument;
          let index = -1;
          const length = string.length;
          for (result = ""; ++index < length; ) {
            const character = string.charAt(index);
            if (options.es6) {
              const first = string.charCodeAt(index);
              if (first >= 55296 && first <= 56319 && length > index + 1) {
                const second = string.charCodeAt(index + 1);
                if (second >= 56320 && second <= 57343) {
                  let hexadecimal2 = (1024 * (first - 55296) + second - 56320 + 65536).toString(16);
                  lowercaseHex || (hexadecimal2 = hexadecimal2.toUpperCase()), result += "\\u{" + hexadecimal2 + "}", ++index;
                  continue;
                }
              }
            }
            if (!options.escapeEverything) {
              if (regexWhitelist.test(character)) {
                result += character;
                continue;
              }
              if (character == '"') {
                result += quote == character ? '\\"' : character;
                continue;
              }
              if (character == "`") {
                result += quote == character ? "\\`" : character;
                continue;
              }
              if (character == "'") {
                result += quote == character ? "\\'" : character;
                continue;
              }
            }
            if (character == "\0" && !json && !regexDigit.test(string.charAt(index + 1))) {
              result += "\\0";
              continue;
            }
            if (regexSingleEscape.test(character)) {
              result += singleEscapes[character];
              continue;
            }
            const charCode = character.charCodeAt(0);
            if (options.minimal && charCode != 8232 && charCode != 8233) {
              result += character;
              continue;
            }
            let hexadecimal = charCode.toString(16);
            lowercaseHex || (hexadecimal = hexadecimal.toUpperCase());
            const longhand = hexadecimal.length > 2 || json, escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
            result += escaped;
          }
          return options.wrap && (result = quote + result + quote), quote == "`" && (result = result.replace(/\$\{/g, "\\${")), options.isScriptContext ? result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--") : result;
        };
        jsesc.version = "2.5.2", module3.exports = jsesc;
      }, "./node_modules/ms/index.js": (module3) => {
        var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, w = 7 * d, y = 365.25 * d;
        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= 1.5 * n;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
        module3.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0)
            return function(str) {
              if ((str = String(str)).length > 100)
                return;
              var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
              if (!match)
                return;
              var n = parseFloat(match[1]);
              switch ((match[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return n * y;
                case "weeks":
                case "week":
                case "w":
                  return n * w;
                case "days":
                case "day":
                case "d":
                  return n * d;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return n * h;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return n * m;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return n * s;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return n;
                default:
                  return;
              }
            }(val);
          if (type === "number" && isFinite(val))
            return options.long ? function(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d)
                return plural(ms, msAbs, d, "day");
              if (msAbs >= h)
                return plural(ms, msAbs, h, "hour");
              if (msAbs >= m)
                return plural(ms, msAbs, m, "minute");
              if (msAbs >= s)
                return plural(ms, msAbs, s, "second");
              return ms + " ms";
            }(val) : function(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d)
                return Math.round(ms / d) + "d";
              if (msAbs >= h)
                return Math.round(ms / h) + "h";
              if (msAbs >= m)
                return Math.round(ms / m) + "m";
              if (msAbs >= s)
                return Math.round(ms / s) + "s";
              return ms + "ms";
            }(val);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
      }, "./node_modules/safe-buffer/index.js": (module3, exports2, __webpack_require__2) => {
        var buffer = __webpack_require__2("buffer"), Buffer2 = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src)
            dst[key] = src[key];
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow ? module3.exports = buffer : (copyProps(buffer, exports2), exports2.Buffer = SafeBuffer), copyProps(Buffer2, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg == "number")
            throw new TypeError("Argument must not be a number");
          return Buffer2(arg, encodingOrOffset, length);
        }, SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size != "number")
            throw new TypeError("Argument must be a number");
          var buf = Buffer2(size);
          return fill !== void 0 ? typeof encoding == "string" ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), buf;
        }, SafeBuffer.allocUnsafe = function(size) {
          if (typeof size != "number")
            throw new TypeError("Argument must be a number");
          return Buffer2(size);
        }, SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size != "number")
            throw new TypeError("Argument must be a number");
          return buffer.SlowBuffer(size);
        };
      }, "./node_modules/supports-color/index.js": (module3, __unused_webpack_exports, __webpack_require__2) => {
        "use strict";
        const os = __webpack_require__2("os"), hasFlag = __webpack_require__2("./node_modules/supports-color/node_modules/has-flag/index.js"), env = process.env;
        let forceColor;
        function getSupportLevel(stream) {
          const level = function(stream2) {
            if (forceColor === false)
              return 0;
            if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
              return 3;
            if (hasFlag("color=256"))
              return 2;
            if (stream2 && !stream2.isTTY && forceColor !== true)
              return 0;
            const min = forceColor ? 1 : 0;
            if (process.platform === "win32") {
              const osRelease = os.release().split(".");
              return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
            }
            if ("CI" in env)
              return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship" ? 1 : min;
            if ("TEAMCITY_VERSION" in env)
              return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
            if (env.COLORTERM === "truecolor")
              return 3;
            if ("TERM_PROGRAM" in env) {
              const version3 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
              switch (env.TERM_PROGRAM) {
                case "iTerm.app":
                  return version3 >= 3 ? 3 : 2;
                case "Apple_Terminal":
                  return 2;
              }
            }
            return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : (env.TERM, min);
          }(stream);
          return function(level2) {
            return level2 !== 0 && { level: level2, hasBasic: true, has256: level2 >= 2, has16m: level2 >= 3 };
          }(level);
        }
        hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") ? forceColor = false : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = true), "FORCE_COLOR" in env && (forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0), module3.exports = { supportsColor: getSupportLevel, stdout: getSupportLevel(process.stdout), stderr: getSupportLevel(process.stderr) };
      }, "./node_modules/supports-color/node_modules/has-flag/index.js": (module3) => {
        "use strict";
        module3.exports = (flag, argv) => {
          argv = argv || process.argv;
          const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", pos = argv.indexOf(prefix + flag), terminatorPos = argv.indexOf("--");
          return pos !== -1 && (terminatorPos === -1 || pos < terminatorPos);
        };
      }, "./node_modules/to-fast-properties/index.js": (module3) => {
        "use strict";
        let fastProto = null;
        function FastObject(o) {
          if (fastProto !== null && (fastProto.property, 1)) {
            const result = fastProto;
            return fastProto = FastObject.prototype = null, result;
          }
          return fastProto = FastObject.prototype = o == null ? /* @__PURE__ */ Object.create(null) : o, new FastObject();
        }
        FastObject(), module3.exports = function(o) {
          return FastObject(o);
        };
      }, "./node_modules/tslib/tslib.es6.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { __extends: () => __extends, __assign: () => __assign, __rest: () => __rest, __decorate: () => __decorate, __param: () => __param, __metadata: () => __metadata, __awaiter: () => __awaiter, __generator: () => __generator, __createBinding: () => __createBinding, __exportStar: () => __exportStar, __values: () => __values, __read: () => __read, __spread: () => __spread, __spreadArrays: () => __spreadArrays, __spreadArray: () => __spreadArray, __await: () => __await, __asyncGenerator: () => __asyncGenerator, __asyncDelegator: () => __asyncDelegator, __asyncValues: () => __asyncValues, __makeTemplateObject: () => __makeTemplateObject, __importStar: () => __importStar, __importDefault: () => __importDefault, __classPrivateFieldGet: () => __classPrivateFieldGet, __classPrivateFieldSet: () => __classPrivateFieldSet });
        var extendStatics = function(d, b) {
          return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
          }, extendStatics(d, b);
        };
        function __extends(d, b) {
          if (typeof b != "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function __() {
            this.constructor = d;
          }
          extendStatics(d, b), d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }
        var __assign = function() {
          return __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++)
              for (var p in s = arguments[i])
                Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
            return t;
          }, __assign.apply(this, arguments);
        };
        function __rest(s, e2) {
          var t = {};
          for (var p in s)
            Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0 && (t[p] = s[p]);
          if (s != null && typeof Object.getOwnPropertySymbols == "function") {
            var i = 0;
            for (p = Object.getOwnPropertySymbols(s); i < p.length; i++)
              e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
          }
          return t;
        }
        function __decorate(decorators, target, key, desc) {
          var d, c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __param(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        }
        function __metadata(metadataKey, metadataValue) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(metadataKey, metadataValue);
        }
        function __awaiter(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve5, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function rejected(value) {
              try {
                step(generator.throw(value));
              } catch (e2) {
                reject(e2);
              }
            }
            function step(result) {
              var value;
              result.done ? resolve5(result.value) : (value = result.value, value instanceof P ? value : new P(function(resolve6) {
                resolve6(value);
              })).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var f, y, t, g, _ = { label: 0, sent: function() {
            if (1 & t[0])
              throw t[1];
            return t[1];
          }, trys: [], ops: [] };
          return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return function(op) {
                if (f)
                  throw new TypeError("Generator is already executing.");
                for (; _; )
                  try {
                    if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                      return t;
                    switch (y = 0, t && (op = [2 & op[0], t.value]), op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        return _.label++, { value: op[1], done: false };
                      case 5:
                        _.label++, y = op[1], op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop(), _.trys.pop();
                        continue;
                      default:
                        if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || op[0] !== 6 && op[0] !== 2)) {
                          _ = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1], t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2], _.ops.push(op);
                          break;
                        }
                        t[2] && _.ops.pop(), _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e2) {
                    op = [6, e2], y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (5 & op[0])
                  throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }([n, v]);
            };
          }
        }
        var __createBinding = Object.create ? function(o, m, k, k2) {
          k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          k2 === void 0 && (k2 = k), o[k2] = m[k];
        };
        function __exportStar(m, o) {
          for (var p in m)
            p === "default" || Object.prototype.hasOwnProperty.call(o, p) || __createBinding(o, m, p);
        }
        function __values(o) {
          var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length == "number")
            return { next: function() {
              return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
            } };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
          var m = typeof Symbol == "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var r, e2, i = m.call(o), ar = [];
          try {
            for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; )
              ar.push(r.value);
          } catch (error) {
            e2 = { error };
          } finally {
            try {
              r && !r.done && (m = i.return) && m.call(i);
            } finally {
              if (e2)
                throw e2.error;
            }
          }
          return ar;
        }
        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        }
        function __spreadArrays() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          var r = Array(s), k = 0;
          for (i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var ar, i = 0, l = from.length; i < l; i++)
              !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        function __await(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var i, g = generator.apply(thisArg, _arguments || []), q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            g[n] && (i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            });
          }
          function resume(n, v) {
            try {
              (r = g[n](v)).value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
            } catch (e2) {
              settle(q[0][3], e2);
            }
            var r;
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
          }
        }
        function __asyncDelegator(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e2) {
            throw e2;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        }
        function __asyncValues(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var i, m = o[Symbol.asyncIterator];
          return m ? m.call(o) : (o = __values(o), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve5, reject) {
                (function(resolve6, reject2, d, v2) {
                  Promise.resolve(v2).then(function(v3) {
                    resolve6({ value: v3, done: d });
                  }, reject2);
                })(resolve5, reject, (v = o[n](v)).done, v.value);
              });
            };
          }
        }
        function __makeTemplateObject(cooked, raw) {
          return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
        }
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o.default = v;
        };
        function __importStar(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
          return __setModuleDefault(result, mod), result;
        }
        function __importDefault(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        }
        function __classPrivateFieldGet(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        }
        function __classPrivateFieldSet(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        }
      }, "./stubs/babel_codeframe.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        function codeFrameColumns() {
          return "";
        }
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { codeFrameColumns: () => codeFrameColumns });
      }, "./stubs/helper_compilation_targets.js": (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        function getTargets() {
          return {};
        }
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { default: () => getTargets });
      }, assert: (module3) => {
        "use strict";
        module3.exports = require("assert");
      }, buffer: (module3) => {
        "use strict";
        module3.exports = require("buffer");
      }, fs: (module3) => {
        "use strict";
        module3.exports = require("fs");
      }, module: (module3) => {
        "use strict";
        module3.exports = require("module");
      }, os: (module3) => {
        "use strict";
        module3.exports = require("os");
      }, path: (module3) => {
        "use strict";
        module3.exports = require("path");
      }, tty: (module3) => {
        "use strict";
        module3.exports = require("tty");
      }, url: (module3) => {
        "use strict";
        module3.exports = require("url");
      }, util: (module3) => {
        "use strict";
        module3.exports = require("util");
      }, v8: (module3) => {
        "use strict";
        module3.exports = require("v8");
      }, "./node_modules/babel-plugin-transform-import-meta/lib/index.js": (__unused_webpack_module, exports2, __webpack_require__2) => {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var tslib = __webpack_require__2("./node_modules/tslib/tslib.es6.js");
        function _interopDefaultLegacy(e2) {
          return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
        }
        var templateObject_1, ast = _interopDefaultLegacy(__webpack_require__2("./node_modules/@babel/template/lib/index.js")).default.ast;
        exports2.default = function() {
          return { name: "transform-import-meta", visitor: { Program: function(path) {
            var metas = [];
            if (path.traverse({ MemberExpression: function(memberExpPath) {
              var node = memberExpPath.node;
              node.object.type === "MetaProperty" && node.object.meta.name === "import" && node.object.property.name === "meta" && node.property.type === "Identifier" && node.property.name === "url" && metas.push(memberExpPath);
            } }), metas.length !== 0)
              for (var _i = 0, metas_1 = metas; _i < metas_1.length; _i++) {
                metas_1[_i].replaceWith(ast(templateObject_1 || (templateObject_1 = tslib.__makeTemplateObject(["require('url').pathToFileURL(__filename).toString()"], ["require('url').pathToFileURL(__filename).toString()"]))));
              }
          } } };
        };
      }, "./node_modules/json5/dist/index.mjs": (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
        "use strict";
        __webpack_require__2.r(__webpack_exports__2), __webpack_require__2.d(__webpack_exports__2, { default: () => __WEBPACK_DEFAULT_EXPORT__ });
        var unicode = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, util = { isSpaceSeparator: (c2) => typeof c2 == "string" && unicode.Space_Separator.test(c2), isIdStartChar: (c2) => typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2)), isIdContinueChar: (c2) => typeof c2 == "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2)), isDigit: (c2) => typeof c2 == "string" && /[0-9]/.test(c2), isHexDigit: (c2) => typeof c2 == "string" && /[0-9A-Fa-f]/.test(c2) };
        let source, parseState, stack, pos, line, column, token, key, root;
        function internalize(holder, name, reviver) {
          const value = holder[name];
          if (value != null && typeof value == "object")
            for (const key2 in value) {
              const replacement = internalize(value, key2, reviver);
              replacement === void 0 ? delete value[key2] : value[key2] = replacement;
            }
          return reviver.call(holder, name, value);
        }
        let lexState, buffer, doubleQuote, sign, c;
        function lex() {
          for (lexState = "default", buffer = "", doubleQuote = false, sign = 1; ; ) {
            c = peek();
            const token2 = lexStates[lexState]();
            if (token2)
              return token2;
          }
        }
        function peek() {
          if (source[pos])
            return String.fromCodePoint(source.codePointAt(pos));
        }
        function read() {
          const c2 = peek();
          return c2 === "\n" ? (line++, column = 0) : c2 ? column += c2.length : column++, c2 && (pos += c2.length), c2;
        }
        const lexStates = { default() {
          switch (c) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "\xA0":
            case "\uFEFF":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return void read();
            case "/":
              return read(), void (lexState = "comment");
            case void 0:
              return read(), newToken("eof");
          }
          if (!util.isSpaceSeparator(c))
            return lexStates[parseState]();
          read();
        }, comment() {
          switch (c) {
            case "*":
              return read(), void (lexState = "multiLineComment");
            case "/":
              return read(), void (lexState = "singleLineComment");
          }
          throw invalidChar(read());
        }, multiLineComment() {
          switch (c) {
            case "*":
              return read(), void (lexState = "multiLineCommentAsterisk");
            case void 0:
              throw invalidChar(read());
          }
          read();
        }, multiLineCommentAsterisk() {
          switch (c) {
            case "*":
              return void read();
            case "/":
              return read(), void (lexState = "default");
            case void 0:
              throw invalidChar(read());
          }
          read(), lexState = "multiLineComment";
        }, singleLineComment() {
          switch (c) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return read(), void (lexState = "default");
            case void 0:
              return read(), newToken("eof");
          }
          read();
        }, value() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
            case "n":
              return read(), literal("ull"), newToken("null", null);
            case "t":
              return read(), literal("rue"), newToken("boolean", true);
            case "f":
              return read(), literal("alse"), newToken("boolean", false);
            case "-":
            case "+":
              return read() === "-" && (sign = -1), void (lexState = "sign");
            case ".":
              return buffer = read(), void (lexState = "decimalPointLeading");
            case "0":
              return buffer = read(), void (lexState = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return buffer = read(), void (lexState = "decimalInteger");
            case "I":
              return read(), literal("nfinity"), newToken("numeric", 1 / 0);
            case "N":
              return read(), literal("aN"), newToken("numeric", NaN);
            case '"':
            case "'":
              return doubleQuote = read() === '"', buffer = "", void (lexState = "string");
          }
          throw invalidChar(read());
        }, identifierNameStartEscape() {
          if (c !== "u")
            throw invalidChar(read());
          read();
          const u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
              break;
            default:
              if (!util.isIdStartChar(u))
                throw invalidIdentifier();
          }
          buffer += u, lexState = "identifierName";
        }, identifierName() {
          switch (c) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              return void (buffer += read());
            case "\\":
              return read(), void (lexState = "identifierNameEscape");
          }
          if (!util.isIdContinueChar(c))
            return newToken("identifier", buffer);
          buffer += read();
        }, identifierNameEscape() {
          if (c !== "u")
            throw invalidChar(read());
          read();
          const u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              break;
            default:
              if (!util.isIdContinueChar(u))
                throw invalidIdentifier();
          }
          buffer += u, lexState = "identifierName";
        }, sign() {
          switch (c) {
            case ".":
              return buffer = read(), void (lexState = "decimalPointLeading");
            case "0":
              return buffer = read(), void (lexState = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return buffer = read(), void (lexState = "decimalInteger");
            case "I":
              return read(), literal("nfinity"), newToken("numeric", sign * (1 / 0));
            case "N":
              return read(), literal("aN"), newToken("numeric", NaN);
          }
          throw invalidChar(read());
        }, zero() {
          switch (c) {
            case ".":
              return buffer += read(), void (lexState = "decimalPoint");
            case "e":
            case "E":
              return buffer += read(), void (lexState = "decimalExponent");
            case "x":
            case "X":
              return buffer += read(), void (lexState = "hexadecimal");
          }
          return newToken("numeric", 0 * sign);
        }, decimalInteger() {
          switch (c) {
            case ".":
              return buffer += read(), void (lexState = "decimalPoint");
            case "e":
            case "E":
              return buffer += read(), void (lexState = "decimalExponent");
          }
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read();
        }, decimalPointLeading() {
          if (util.isDigit(c))
            return buffer += read(), void (lexState = "decimalFraction");
          throw invalidChar(read());
        }, decimalPoint() {
          switch (c) {
            case "e":
            case "E":
              return buffer += read(), void (lexState = "decimalExponent");
          }
          return util.isDigit(c) ? (buffer += read(), void (lexState = "decimalFraction")) : newToken("numeric", sign * Number(buffer));
        }, decimalFraction() {
          switch (c) {
            case "e":
            case "E":
              return buffer += read(), void (lexState = "decimalExponent");
          }
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read();
        }, decimalExponent() {
          switch (c) {
            case "+":
            case "-":
              return buffer += read(), void (lexState = "decimalExponentSign");
          }
          if (util.isDigit(c))
            return buffer += read(), void (lexState = "decimalExponentInteger");
          throw invalidChar(read());
        }, decimalExponentSign() {
          if (util.isDigit(c))
            return buffer += read(), void (lexState = "decimalExponentInteger");
          throw invalidChar(read());
        }, decimalExponentInteger() {
          if (!util.isDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read();
        }, hexadecimal() {
          if (util.isHexDigit(c))
            return buffer += read(), void (lexState = "hexadecimalInteger");
          throw invalidChar(read());
        }, hexadecimalInteger() {
          if (!util.isHexDigit(c))
            return newToken("numeric", sign * Number(buffer));
          buffer += read();
        }, string() {
          switch (c) {
            case "\\":
              return read(), void (buffer += function() {
                switch (peek()) {
                  case "b":
                    return read(), "\b";
                  case "f":
                    return read(), "\f";
                  case "n":
                    return read(), "\n";
                  case "r":
                    return read(), "\r";
                  case "t":
                    return read(), "	";
                  case "v":
                    return read(), "\v";
                  case "0":
                    if (read(), util.isDigit(peek()))
                      throw invalidChar(read());
                    return "\0";
                  case "x":
                    return read(), function() {
                      let buffer2 = "", c2 = peek();
                      if (!util.isHexDigit(c2))
                        throw invalidChar(read());
                      if (buffer2 += read(), c2 = peek(), !util.isHexDigit(c2))
                        throw invalidChar(read());
                      return buffer2 += read(), String.fromCodePoint(parseInt(buffer2, 16));
                    }();
                  case "u":
                    return read(), unicodeEscape();
                  case "\n":
                  case "\u2028":
                  case "\u2029":
                    return read(), "";
                  case "\r":
                    return read(), peek() === "\n" && read(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw invalidChar(read());
                }
                return read();
              }());
            case '"':
              return doubleQuote ? (read(), newToken("string", buffer)) : void (buffer += read());
            case "'":
              return doubleQuote ? void (buffer += read()) : (read(), newToken("string", buffer));
            case "\n":
            case "\r":
              throw invalidChar(read());
            case "\u2028":
            case "\u2029":
              !function(c2) {
                console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
              }(c);
              break;
            case void 0:
              throw invalidChar(read());
          }
          buffer += read();
        }, start() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
          }
          lexState = "value";
        }, beforePropertyName() {
          switch (c) {
            case "$":
            case "_":
              return buffer = read(), void (lexState = "identifierName");
            case "\\":
              return read(), void (lexState = "identifierNameStartEscape");
            case "}":
              return newToken("punctuator", read());
            case '"':
            case "'":
              return doubleQuote = read() === '"', void (lexState = "string");
          }
          if (util.isIdStartChar(c))
            return buffer += read(), void (lexState = "identifierName");
          throw invalidChar(read());
        }, afterPropertyName() {
          if (c === ":")
            return newToken("punctuator", read());
          throw invalidChar(read());
        }, beforePropertyValue() {
          lexState = "value";
        }, afterPropertyValue() {
          switch (c) {
            case ",":
            case "}":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        }, beforeArrayValue() {
          if (c === "]")
            return newToken("punctuator", read());
          lexState = "value";
        }, afterArrayValue() {
          switch (c) {
            case ",":
            case "]":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        }, end() {
          throw invalidChar(read());
        } };
        function newToken(type, value) {
          return { type, value, line, column };
        }
        function literal(s) {
          for (const c2 of s) {
            if (peek() !== c2)
              throw invalidChar(read());
            read();
          }
        }
        function unicodeEscape() {
          let buffer2 = "", count = 4;
          for (; count-- > 0; ) {
            const c2 = peek();
            if (!util.isHexDigit(c2))
              throw invalidChar(read());
            buffer2 += read();
          }
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        const parseStates = { start() {
          if (token.type === "eof")
            throw invalidEOF();
          push();
        }, beforePropertyName() {
          switch (token.type) {
            case "identifier":
            case "string":
              return key = token.value, void (parseState = "afterPropertyName");
            case "punctuator":
              return void pop();
            case "eof":
              throw invalidEOF();
          }
        }, afterPropertyName() {
          if (token.type === "eof")
            throw invalidEOF();
          parseState = "beforePropertyValue";
        }, beforePropertyValue() {
          if (token.type === "eof")
            throw invalidEOF();
          push();
        }, beforeArrayValue() {
          if (token.type === "eof")
            throw invalidEOF();
          token.type !== "punctuator" || token.value !== "]" ? push() : pop();
        }, afterPropertyValue() {
          if (token.type === "eof")
            throw invalidEOF();
          switch (token.value) {
            case ",":
              return void (parseState = "beforePropertyName");
            case "}":
              pop();
          }
        }, afterArrayValue() {
          if (token.type === "eof")
            throw invalidEOF();
          switch (token.value) {
            case ",":
              return void (parseState = "beforeArrayValue");
            case "]":
              pop();
          }
        }, end() {
        } };
        function push() {
          let value;
          switch (token.type) {
            case "punctuator":
              switch (token.value) {
                case "{":
                  value = {};
                  break;
                case "[":
                  value = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              value = token.value;
          }
          if (root === void 0)
            root = value;
          else {
            const parent = stack[stack.length - 1];
            Array.isArray(parent) ? parent.push(value) : parent[key] = value;
          }
          if (value !== null && typeof value == "object")
            stack.push(value), parseState = Array.isArray(value) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const current = stack[stack.length - 1];
            parseState = current == null ? "end" : Array.isArray(current) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function pop() {
          stack.pop();
          const current = stack[stack.length - 1];
          parseState = current == null ? "end" : Array.isArray(current) ? "afterArrayValue" : "afterPropertyValue";
        }
        function invalidChar(c2) {
          return syntaxError(c2 === void 0 ? `JSON5: invalid end of input at ${line}:${column}` : `JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
        }
        function invalidEOF() {
          return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
        }
        function invalidIdentifier() {
          return column -= 5, syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
        }
        function formatChar(c2) {
          const replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if (replacements[c2])
            return replacements[c2];
          if (c2 < " ") {
            const hexString = c2.charCodeAt(0).toString(16);
            return "\\x" + ("00" + hexString).substring(hexString.length);
          }
          return c2;
        }
        function syntaxError(message) {
          const err = new SyntaxError(message);
          return err.lineNumber = line, err.columnNumber = column, err;
        }
        const JSON5 = { parse: function(text, reviver) {
          source = String(text), parseState = "start", stack = [], pos = 0, line = 1, column = 0, token = void 0, key = void 0, root = void 0;
          do {
            token = lex(), parseStates[parseState]();
          } while (token.type !== "eof");
          return typeof reviver == "function" ? internalize({ "": root }, "", reviver) : root;
        }, stringify: function(value, replacer, space) {
          const stack2 = [];
          let propertyList, replacerFunc, quote, indent = "", gap = "";
          if (replacer == null || typeof replacer != "object" || Array.isArray(replacer) || (space = replacer.space, quote = replacer.quote, replacer = replacer.replacer), typeof replacer == "function")
            replacerFunc = replacer;
          else if (Array.isArray(replacer)) {
            propertyList = [];
            for (const v of replacer) {
              let item;
              typeof v == "string" ? item = v : (typeof v == "number" || v instanceof String || v instanceof Number) && (item = String(v)), item !== void 0 && propertyList.indexOf(item) < 0 && propertyList.push(item);
            }
          }
          return space instanceof Number ? space = Number(space) : space instanceof String && (space = String(space)), typeof space == "number" ? space > 0 && (space = Math.min(10, Math.floor(space)), gap = "          ".substr(0, space)) : typeof space == "string" && (gap = space.substr(0, 10)), serializeProperty("", { "": value });
          function serializeProperty(key2, holder) {
            let value2 = holder[key2];
            switch (value2 != null && (typeof value2.toJSON5 == "function" ? value2 = value2.toJSON5(key2) : typeof value2.toJSON == "function" && (value2 = value2.toJSON(key2))), replacerFunc && (value2 = replacerFunc.call(holder, key2, value2)), value2 instanceof Number ? value2 = Number(value2) : value2 instanceof String ? value2 = String(value2) : value2 instanceof Boolean && (value2 = value2.valueOf()), value2) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            return typeof value2 == "string" ? quoteString(value2) : typeof value2 == "number" ? String(value2) : typeof value2 == "object" ? Array.isArray(value2) ? function(value3) {
              if (stack2.indexOf(value3) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              stack2.push(value3);
              let stepback = indent;
              indent += gap;
              let final, partial = [];
              for (let i = 0; i < value3.length; i++) {
                const propertyString = serializeProperty(String(i), value3);
                partial.push(propertyString !== void 0 ? propertyString : "null");
              }
              if (partial.length === 0)
                final = "[]";
              else if (gap === "") {
                final = "[" + partial.join(",") + "]";
              } else {
                let separator = ",\n" + indent, properties = partial.join(separator);
                final = "[\n" + indent + properties + ",\n" + stepback + "]";
              }
              return stack2.pop(), indent = stepback, final;
            }(value2) : function(value3) {
              if (stack2.indexOf(value3) >= 0)
                throw TypeError("Converting circular structure to JSON5");
              stack2.push(value3);
              let stepback = indent;
              indent += gap;
              let final, keys = propertyList || Object.keys(value3), partial = [];
              for (const key3 of keys) {
                const propertyString = serializeProperty(key3, value3);
                if (propertyString !== void 0) {
                  let member = serializeKey(key3) + ":";
                  gap !== "" && (member += " "), member += propertyString, partial.push(member);
                }
              }
              if (partial.length === 0)
                final = "{}";
              else {
                let properties;
                if (gap === "")
                  properties = partial.join(","), final = "{" + properties + "}";
                else {
                  let separator = ",\n" + indent;
                  properties = partial.join(separator), final = "{\n" + indent + properties + ",\n" + stepback + "}";
                }
              }
              return stack2.pop(), indent = stepback, final;
            }(value2) : void 0;
          }
          function quoteString(value2) {
            const quotes = { "'": 0.1, '"': 0.2 }, replacements = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let product = "";
            for (let i = 0; i < value2.length; i++) {
              const c2 = value2[i];
              switch (c2) {
                case "'":
                case '"':
                  quotes[c2]++, product += c2;
                  continue;
                case "\0":
                  if (util.isDigit(value2[i + 1])) {
                    product += "\\x00";
                    continue;
                  }
              }
              if (replacements[c2])
                product += replacements[c2];
              else if (c2 < " ") {
                let hexString = c2.charCodeAt(0).toString(16);
                product += "\\x" + ("00" + hexString).substring(hexString.length);
              } else
                product += c2;
            }
            const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
            return product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]), quoteChar + product + quoteChar;
          }
          function serializeKey(key2) {
            if (key2.length === 0)
              return quoteString(key2);
            const firstChar = String.fromCodePoint(key2.codePointAt(0));
            if (!util.isIdStartChar(firstChar))
              return quoteString(key2);
            for (let i = firstChar.length; i < key2.length; i++)
              if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i))))
                return quoteString(key2);
            return key2;
          }
        } };
        const __WEBPACK_DEFAULT_EXPORT__ = JSON5;
      }, "./node_modules/@babel/traverse/node_modules/globals/globals.json": (module3) => {
        "use strict";
        module3.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0)
          return cachedModule.exports;
        var module3 = __webpack_module_cache__[moduleId] = { exports: {} };
        return __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__), module3.exports;
      }
      __webpack_require__.d = (exports2, definition) => {
        for (var key in definition)
          __webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key) && Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
      }, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.r = (exports2) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(exports2, "__esModule", { value: true });
      };
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, { default: () => transform });
        var _babel_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/@babel/core/lib/index.js");
        function transform(opts) {
          var _a, _b, _c, _d, _e, _f;
          const _opts = Object.assign(Object.assign({ babelrc: false, configFile: false, compact: false, retainLines: typeof opts.retainLines != "boolean" || opts.retainLines, filename: "", cwd: "/" }, opts.babel), { plugins: [[__webpack_require__("./node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), { allowTopLevelThis: true }], [__webpack_require__("./node_modules/babel-plugin-dynamic-import-node/lib/index.js"), { noInterop: true }], [__webpack_require__("./node_modules/babel-plugin-transform-import-meta/lib/index.js")], [__webpack_require__("./node_modules/@babel/plugin-syntax-class-properties/lib/index.js")]] });
          opts.ts && (_opts.plugins.push([__webpack_require__("./node_modules/@babel/plugin-transform-typescript/lib/index.js"), { allowDeclareFields: true }]), _opts.plugins.unshift([__webpack_require__("./node_modules/@babel/plugin-proposal-decorators/lib/index.js"), { legacy: true }]), _opts.plugins.push(__webpack_require__("./node_modules/babel-plugin-parameter-decorator/lib/index.js"))), opts.legacy && (_opts.plugins.push(__webpack_require__("./node_modules/@babel/plugin-proposal-nullish-coalescing-operator/lib/index.js")), _opts.plugins.push(__webpack_require__("./node_modules/@babel/plugin-proposal-optional-chaining/lib/index.js"))), opts.babel && Array.isArray(opts.babel.plugins) && ((_a = _opts.plugins) === null || _a === void 0 || _a.push(...opts.babel.plugins));
          try {
            return { code: ((_b = (0, _babel_core__WEBPACK_IMPORTED_MODULE_0__.transformSync)(opts.source, _opts)) === null || _b === void 0 ? void 0 : _b.code) || "" };
          } catch (err) {
            return { error: err, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: opts.filename, line: ((_c = err.loc) === null || _c === void 0 ? void 0 : _c.line) || 0, column: ((_d = err.loc) === null || _d === void 0 ? void 0 : _d.column) || 0, code: (_e = err.code) === null || _e === void 0 ? void 0 : _e.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: (_f = err.message) === null || _f === void 0 ? void 0 : _f.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), module2.exports = __webpack_exports__.default;
    })();
  }
});

// ../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/jiti@1.13.0/node_modules/jiti/lib/index.js"(exports, module2) {
    function onError(err) {
      throw err;
    }
    module2.exports = function(filename, opts) {
      const jiti2 = require_jiti();
      opts = __spreadValues({ onError }, opts);
      if (!opts.transform) {
        opts.transform = require_babel();
      }
      return jiti2(filename, opts);
    };
  }
});

// ../../node_modules/.pnpm/prettier@2.6.0/node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "../../node_modules/.pnpm/prettier@2.6.0/node_modules/prettier/standalone.js"(exports, module2) {
    (function(e2) {
      if (typeof exports == "object" && typeof module2 == "object")
        module2.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f.prettier = e2();
      }
    })(function() {
      "use strict";
      var Xn = ((e2) => typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(e2, { get: (s, t) => (typeof require != "undefined" ? require : s)[t] }) : e2)(function(e2) {
        if (typeof require != "undefined")
          return require.apply(this, arguments);
        throw new Error('Dynamic require of "' + e2 + '" is not supported');
      });
      var xe = (e2, s) => () => (s || e2((s = { exports: {} }).exports, s), s.exports);
      var Ye = xe((Ud, Kn) => {
        var Yt = function(e2) {
          return e2 && e2.Math == Math && e2;
        };
        Kn.exports = Yt(typeof globalThis == "object" && globalThis) || Yt(typeof window == "object" && window) || Yt(typeof self == "object" && self) || Yt(typeof global == "object" && global) || function() {
          return this;
        }() || Function("return this")();
      });
      var pt = xe((zd, Yn) => {
        Yn.exports = function(e2) {
          try {
            return !!e2();
          } catch {
            return true;
          }
        };
      });
      var yt = xe((Xd, Qn) => {
        var go = pt();
        Qn.exports = !go(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Qt = xe((Kd, Zn) => {
        var yo = pt();
        Zn.exports = !yo(function() {
          var e2 = function() {
          }.bind();
          return typeof e2 != "function" || e2.hasOwnProperty("prototype");
        });
      });
      var ht = xe((Yd, eu) => {
        var ho = Qt(), Zt = Function.prototype.call;
        eu.exports = ho ? Zt.bind(Zt) : function() {
          return Zt.apply(Zt, arguments);
        };
      });
      var uu = xe((nu) => {
        "use strict";
        var tu = {}.propertyIsEnumerable, ru = Object.getOwnPropertyDescriptor, Co = ru && !tu.call({ 1: 2 }, 1);
        nu.f = Co ? function(s) {
          var t = ru(this, s);
          return !!t && t.enumerable;
        } : tu;
      });
      var er = xe((Zd, su) => {
        su.exports = function(e2, s) {
          return { enumerable: !(e2 & 1), configurable: !(e2 & 2), writable: !(e2 & 4), value: s };
        };
      });
      var at = xe((eg, ou) => {
        var au = Qt(), iu = Function.prototype, Eo = iu.bind, Nr = iu.call, vo = au && Eo.bind(Nr, Nr);
        ou.exports = au ? function(e2) {
          return e2 && vo(e2);
        } : function(e2) {
          return e2 && function() {
            return Nr.apply(e2, arguments);
          };
        };
      });
      var tr = xe((tg, lu) => {
        var cu = at(), Fo = cu({}.toString), Ao = cu("".slice);
        lu.exports = function(e2) {
          return Ao(Fo(e2), 8, -1);
        };
      });
      var fu = xe((rg, pu) => {
        var So = Ye(), bo = at(), xo = pt(), To = tr(), wr = So.Object, Bo = bo("".split);
        pu.exports = xo(function() {
          return !wr("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return To(e2) == "String" ? Bo(e2, "") : wr(e2);
        } : wr;
      });
      var Pr = xe((ng, Du) => {
        var No = Ye(), wo = No.TypeError;
        Du.exports = function(e2) {
          if (e2 == null)
            throw wo("Can't call method on " + e2);
          return e2;
        };
      });
      var rr = xe((ug, mu) => {
        var Po = fu(), _o = Pr();
        mu.exports = function(e2) {
          return Po(_o(e2));
        };
      });
      var it = xe((sg, du) => {
        du.exports = function(e2) {
          return typeof e2 == "function";
        };
      });
      var Ct = xe((ag, gu) => {
        var Io = it();
        gu.exports = function(e2) {
          return typeof e2 == "object" ? e2 !== null : Io(e2);
        };
      });
      var jt = xe((ig, yu) => {
        var _r = Ye(), ko = it(), Lo = function(e2) {
          return ko(e2) ? e2 : void 0;
        };
        yu.exports = function(e2, s) {
          return arguments.length < 2 ? Lo(_r[e2]) : _r[e2] && _r[e2][s];
        };
      });
      var Ir = xe((og, hu) => {
        var Oo = at();
        hu.exports = Oo({}.isPrototypeOf);
      });
      var Eu = xe((cg, Cu) => {
        var jo = jt();
        Cu.exports = jo("navigator", "userAgent") || "";
      });
      var Tu = xe((lg, xu) => {
        var bu = Ye(), kr = Eu(), vu = bu.process, Fu = bu.Deno, Au = vu && vu.versions || Fu && Fu.version, Su = Au && Au.v8, lt, nr;
        Su && (lt = Su.split("."), nr = lt[0] > 0 && lt[0] < 4 ? 1 : +(lt[0] + lt[1]));
        !nr && kr && (lt = kr.match(/Edge\/(\d+)/), (!lt || lt[1] >= 74) && (lt = kr.match(/Chrome\/(\d+)/), lt && (nr = +lt[1])));
        xu.exports = nr;
      });
      var Lr = xe((pg, Nu) => {
        var Bu = Tu(), qo = pt();
        Nu.exports = !!Object.getOwnPropertySymbols && !qo(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Bu && Bu < 41;
        });
      });
      var Or = xe((fg, wu) => {
        var Mo = Lr();
        wu.exports = Mo && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var jr = xe((Dg, Pu) => {
        var Ro = Ye(), Vo = jt(), Wo = it(), $o = Ir(), Ho = Or(), Go = Ro.Object;
        Pu.exports = Ho ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var s = Vo("Symbol");
          return Wo(s) && $o(s.prototype, Go(e2));
        };
      });
      var ur = xe((mg, _u) => {
        var Jo = Ye(), Uo = Jo.String;
        _u.exports = function(e2) {
          try {
            return Uo(e2);
          } catch {
            return "Object";
          }
        };
      });
      var qt = xe((dg, Iu) => {
        var zo = Ye(), Xo = it(), Ko = ur(), Yo = zo.TypeError;
        Iu.exports = function(e2) {
          if (Xo(e2))
            return e2;
          throw Yo(Ko(e2) + " is not a function");
        };
      });
      var sr = xe((gg, ku) => {
        var Qo = qt();
        ku.exports = function(e2, s) {
          var t = e2[s];
          return t == null ? void 0 : Qo(t);
        };
      });
      var Ou = xe((yg, Lu) => {
        var Zo = Ye(), qr = ht(), Mr = it(), Rr = Ct(), ec = Zo.TypeError;
        Lu.exports = function(e2, s) {
          var t, i;
          if (s === "string" && Mr(t = e2.toString) && !Rr(i = qr(t, e2)) || Mr(t = e2.valueOf) && !Rr(i = qr(t, e2)) || s !== "string" && Mr(t = e2.toString) && !Rr(i = qr(t, e2)))
            return i;
          throw ec("Can't convert object to primitive value");
        };
      });
      var qu = xe((hg, ju) => {
        ju.exports = false;
      });
      var ar = xe((Cg, Ru) => {
        var Mu = Ye(), tc = Object.defineProperty;
        Ru.exports = function(e2, s) {
          try {
            tc(Mu, e2, { value: s, configurable: true, writable: true });
          } catch {
            Mu[e2] = s;
          }
          return s;
        };
      });
      var ir = xe((Eg, Wu) => {
        var rc = Ye(), nc = ar(), Vu = "__core-js_shared__", uc = rc[Vu] || nc(Vu, {});
        Wu.exports = uc;
      });
      var Vr = xe((vg, Hu) => {
        var sc = qu(), $u = ir();
        (Hu.exports = function(e2, s) {
          return $u[e2] || ($u[e2] = s !== void 0 ? s : {});
        })("versions", []).push({ version: "3.21.1", mode: sc ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var or = xe((Fg, Gu) => {
        var ac = Ye(), ic = Pr(), oc = ac.Object;
        Gu.exports = function(e2) {
          return oc(ic(e2));
        };
      });
      var ft = xe((Ag, Ju) => {
        var cc = at(), lc = or(), pc = cc({}.hasOwnProperty);
        Ju.exports = Object.hasOwn || function(s, t) {
          return pc(lc(s), t);
        };
      });
      var Wr = xe((Sg, Uu) => {
        var fc = at(), Dc = 0, mc = Math.random(), dc = fc(1 .toString);
        Uu.exports = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + dc(++Dc + mc, 36);
        };
      });
      var vt = xe((bg, Qu) => {
        var gc = Ye(), yc = Vr(), zu = ft(), hc = Wr(), Xu = Lr(), Yu = Or(), bt = yc("wks"), Et = gc.Symbol, Ku = Et && Et.for, Cc = Yu ? Et : Et && Et.withoutSetter || hc;
        Qu.exports = function(e2) {
          if (!zu(bt, e2) || !(Xu || typeof bt[e2] == "string")) {
            var s = "Symbol." + e2;
            Xu && zu(Et, e2) ? bt[e2] = Et[e2] : Yu && Ku ? bt[e2] = Ku(s) : bt[e2] = Cc(s);
          }
          return bt[e2];
        };
      });
      var rs = xe((xg, ts) => {
        var Ec = Ye(), vc = ht(), Zu = Ct(), es = jr(), Fc = sr(), Ac = Ou(), Sc = vt(), bc = Ec.TypeError, xc = Sc("toPrimitive");
        ts.exports = function(e2, s) {
          if (!Zu(e2) || es(e2))
            return e2;
          var t = Fc(e2, xc), i;
          if (t) {
            if (s === void 0 && (s = "default"), i = vc(t, e2, s), !Zu(i) || es(i))
              return i;
            throw bc("Can't convert object to primitive value");
          }
          return s === void 0 && (s = "number"), Ac(e2, s);
        };
      });
      var cr = xe((Tg, ns) => {
        var Tc = rs(), Bc = jr();
        ns.exports = function(e2) {
          var s = Tc(e2, "string");
          return Bc(s) ? s : s + "";
        };
      });
      var as = xe((Bg, ss) => {
        var Nc = Ye(), us = Ct(), $r = Nc.document, wc = us($r) && us($r.createElement);
        ss.exports = function(e2) {
          return wc ? $r.createElement(e2) : {};
        };
      });
      var Hr = xe((Ng, is) => {
        var Pc = yt(), _c = pt(), Ic = as();
        is.exports = !Pc && !_c(function() {
          return Object.defineProperty(Ic("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Gr = xe((cs) => {
        var kc = yt(), Lc = ht(), Oc = uu(), jc = er(), qc = rr(), Mc = cr(), Rc = ft(), Vc = Hr(), os = Object.getOwnPropertyDescriptor;
        cs.f = kc ? os : function(s, t) {
          if (s = qc(s), t = Mc(t), Vc)
            try {
              return os(s, t);
            } catch {
            }
          if (Rc(s, t))
            return jc(!Lc(Oc.f, s, t), s[t]);
        };
      });
      var ps = xe((Pg, ls) => {
        var Wc = yt(), $c = pt();
        ls.exports = Wc && $c(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var xt = xe((_g, Ds) => {
        var fs3 = Ye(), Hc = Ct(), Gc = fs3.String, Jc = fs3.TypeError;
        Ds.exports = function(e2) {
          if (Hc(e2))
            return e2;
          throw Jc(Gc(e2) + " is not an object");
        };
      });
      var pr = xe((ds) => {
        var Uc = Ye(), zc = yt(), Xc = Hr(), Kc = ps(), lr = xt(), ms = cr(), Yc = Uc.TypeError, Jr = Object.defineProperty, Qc = Object.getOwnPropertyDescriptor, Ur = "enumerable", zr = "configurable", Xr = "writable";
        ds.f = zc ? Kc ? function(s, t, i) {
          if (lr(s), t = ms(t), lr(i), typeof s == "function" && t === "prototype" && "value" in i && Xr in i && !i[Xr]) {
            var l = Qc(s, t);
            l && l[Xr] && (s[t] = i.value, i = { configurable: zr in i ? i[zr] : l[zr], enumerable: Ur in i ? i[Ur] : l[Ur], writable: false });
          }
          return Jr(s, t, i);
        } : Jr : function(s, t, i) {
          if (lr(s), t = ms(t), lr(i), Xc)
            try {
              return Jr(s, t, i);
            } catch {
            }
          if ("get" in i || "set" in i)
            throw Yc("Accessors not supported");
          return "value" in i && (s[t] = i.value), s;
        };
      });
      var fr = xe((kg, gs) => {
        var Zc = yt(), el = pr(), tl = er();
        gs.exports = Zc ? function(e2, s, t) {
          return el.f(e2, s, tl(1, t));
        } : function(e2, s, t) {
          return e2[s] = t, e2;
        };
      });
      var Dr = xe((Lg, ys) => {
        var rl = at(), nl = it(), Kr = ir(), ul = rl(Function.toString);
        nl(Kr.inspectSource) || (Kr.inspectSource = function(e2) {
          return ul(e2);
        });
        ys.exports = Kr.inspectSource;
      });
      var Es = xe((Og, Cs) => {
        var sl = Ye(), al = it(), il = Dr(), hs = sl.WeakMap;
        Cs.exports = al(hs) && /native code/.test(il(hs));
      });
      var As = xe((jg, Fs) => {
        var ol = Vr(), cl = Wr(), vs = ol("keys");
        Fs.exports = function(e2) {
          return vs[e2] || (vs[e2] = cl(e2));
        };
      });
      var Yr = xe((qg, Ss) => {
        Ss.exports = {};
      });
      var ws = xe((Mg, Ns) => {
        var ll = Es(), Bs = Ye(), Qr = at(), pl = Ct(), fl = fr(), Zr = ft(), en = ir(), Dl = As(), ml = Yr(), bs = "Object already initialized", rn = Bs.TypeError, dl = Bs.WeakMap, mr, Mt, dr, gl = function(e2) {
          return dr(e2) ? Mt(e2) : mr(e2, {});
        }, yl = function(e2) {
          return function(s) {
            var t;
            if (!pl(s) || (t = Mt(s)).type !== e2)
              throw rn("Incompatible receiver, " + e2 + " required");
            return t;
          };
        };
        ll || en.state ? (Dt = en.state || (en.state = new dl()), xs = Qr(Dt.get), tn = Qr(Dt.has), Ts = Qr(Dt.set), mr = function(e2, s) {
          if (tn(Dt, e2))
            throw new rn(bs);
          return s.facade = e2, Ts(Dt, e2, s), s;
        }, Mt = function(e2) {
          return xs(Dt, e2) || {};
        }, dr = function(e2) {
          return tn(Dt, e2);
        }) : (Ft = Dl("state"), ml[Ft] = true, mr = function(e2, s) {
          if (Zr(e2, Ft))
            throw new rn(bs);
          return s.facade = e2, fl(e2, Ft, s), s;
        }, Mt = function(e2) {
          return Zr(e2, Ft) ? e2[Ft] : {};
        }, dr = function(e2) {
          return Zr(e2, Ft);
        });
        var Dt, xs, tn, Ts, Ft;
        Ns.exports = { set: mr, get: Mt, has: dr, enforce: gl, getterFor: yl };
      });
      var Is = xe((Rg, _s) => {
        var nn = yt(), hl = ft(), Ps = Function.prototype, Cl = nn && Object.getOwnPropertyDescriptor, un = hl(Ps, "name"), El = un && function() {
        }.name === "something", vl = un && (!nn || nn && Cl(Ps, "name").configurable);
        _s.exports = { EXISTS: un, PROPER: El, CONFIGURABLE: vl };
      });
      var qs = xe((Vg, js) => {
        var Fl = Ye(), ks = it(), Al = ft(), Ls = fr(), Sl = ar(), bl = Dr(), Os = ws(), xl = Is().CONFIGURABLE, Tl = Os.get, Bl = Os.enforce, Nl = String(String).split("String");
        (js.exports = function(e2, s, t, i) {
          var l = i ? !!i.unsafe : false, u = i ? !!i.enumerable : false, n = i ? !!i.noTargetGet : false, a = i && i.name !== void 0 ? i.name : s, o;
          if (ks(t) && (String(a).slice(0, 7) === "Symbol(" && (a = "[" + String(a).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Al(t, "name") || xl && t.name !== a) && Ls(t, "name", a), o = Bl(t), o.source || (o.source = Nl.join(typeof a == "string" ? a : ""))), e2 === Fl) {
            u ? e2[s] = t : Sl(s, t);
            return;
          } else
            l ? !n && e2[s] && (u = true) : delete e2[s];
          u ? e2[s] = t : Ls(e2, s, t);
        })(Function.prototype, "toString", function() {
          return ks(this) && Tl(this).source || bl(this);
        });
      });
      var gr = xe((Wg, Ms) => {
        var wl = Math.ceil, Pl = Math.floor;
        Ms.exports = function(e2) {
          var s = +e2;
          return s !== s || s === 0 ? 0 : (s > 0 ? Pl : wl)(s);
        };
      });
      var Vs = xe(($g, Rs) => {
        var _l = gr(), Il = Math.max, kl = Math.min;
        Rs.exports = function(e2, s) {
          var t = _l(e2);
          return t < 0 ? Il(t + s, 0) : kl(t, s);
        };
      });
      var $s = xe((Hg, Ws) => {
        var Ll = gr(), Ol = Math.min;
        Ws.exports = function(e2) {
          return e2 > 0 ? Ol(Ll(e2), 9007199254740991) : 0;
        };
      });
      var Tt = xe((Gg, Hs) => {
        var jl = $s();
        Hs.exports = function(e2) {
          return jl(e2.length);
        };
      });
      var Us = xe((Jg, Js) => {
        var ql = rr(), Ml = Vs(), Rl = Tt(), Gs = function(e2) {
          return function(s, t, i) {
            var l = ql(s), u = Rl(l), n = Ml(i, u), a;
            if (e2 && t != t) {
              for (; u > n; )
                if (a = l[n++], a != a)
                  return true;
            } else
              for (; u > n; n++)
                if ((e2 || n in l) && l[n] === t)
                  return e2 || n || 0;
            return !e2 && -1;
          };
        };
        Js.exports = { includes: Gs(true), indexOf: Gs(false) };
      });
      var Ks = xe((Ug, Xs) => {
        var Vl = at(), sn = ft(), Wl = rr(), $l = Us().indexOf, Hl = Yr(), zs = Vl([].push);
        Xs.exports = function(e2, s) {
          var t = Wl(e2), i = 0, l = [], u;
          for (u in t)
            !sn(Hl, u) && sn(t, u) && zs(l, u);
          for (; s.length > i; )
            sn(t, u = s[i++]) && (~$l(l, u) || zs(l, u));
          return l;
        };
      });
      var Qs = xe((zg, Ys) => {
        Ys.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ea = xe((Zs) => {
        var Gl = Ks(), Jl = Qs(), Ul = Jl.concat("length", "prototype");
        Zs.f = Object.getOwnPropertyNames || function(s) {
          return Gl(s, Ul);
        };
      });
      var ra = xe((ta) => {
        ta.f = Object.getOwnPropertySymbols;
      });
      var ua = xe((Yg, na) => {
        var zl = jt(), Xl = at(), Kl = ea(), Yl = ra(), Ql = xt(), Zl = Xl([].concat);
        na.exports = zl("Reflect", "ownKeys") || function(s) {
          var t = Kl.f(Ql(s)), i = Yl.f;
          return i ? Zl(t, i(s)) : t;
        };
      });
      var ia = xe((Qg, aa) => {
        var sa = ft(), ep = ua(), tp = Gr(), rp = pr();
        aa.exports = function(e2, s, t) {
          for (var i = ep(s), l = rp.f, u = tp.f, n = 0; n < i.length; n++) {
            var a = i[n];
            !sa(e2, a) && !(t && sa(t, a)) && l(e2, a, u(s, a));
          }
        };
      });
      var ca = xe((Zg, oa) => {
        var np = pt(), up = it(), sp = /#|\.prototype\./, Rt = function(e2, s) {
          var t = ip[ap(e2)];
          return t == cp ? true : t == op ? false : up(s) ? np(s) : !!s;
        }, ap = Rt.normalize = function(e2) {
          return String(e2).replace(sp, ".").toLowerCase();
        }, ip = Rt.data = {}, op = Rt.NATIVE = "N", cp = Rt.POLYFILL = "P";
        oa.exports = Rt;
      });
      var Vt = xe((e0, la) => {
        var an = Ye(), lp = Gr().f, pp = fr(), fp = qs(), Dp = ar(), mp = ia(), dp = ca();
        la.exports = function(e2, s) {
          var t = e2.target, i = e2.global, l = e2.stat, u, n, a, o, D, F;
          if (i ? n = an : l ? n = an[t] || Dp(t, {}) : n = (an[t] || {}).prototype, n)
            for (a in s) {
              if (D = s[a], e2.noTargetGet ? (F = lp(n, a), o = F && F.value) : o = n[a], u = dp(i ? a : t + (l ? "." : "#") + a, e2.forced), !u && o !== void 0) {
                if (typeof D == typeof o)
                  continue;
                mp(D, o);
              }
              (e2.sham || o && o.sham) && pp(D, "sham", true), fp(n, a, D, e2);
            }
        };
      });
      var on = xe((t0, pa) => {
        var gp = tr();
        pa.exports = Array.isArray || function(s) {
          return gp(s) == "Array";
        };
      });
      var cn = xe((r0, Da) => {
        var fa = at(), yp = qt(), hp = Qt(), Cp = fa(fa.bind);
        Da.exports = function(e2, s) {
          return yp(e2), s === void 0 ? e2 : hp ? Cp(e2, s) : function() {
            return e2.apply(s, arguments);
          };
        };
      });
      var ln = xe((n0, da) => {
        "use strict";
        var Ep = Ye(), vp = on(), Fp = Tt(), Ap = cn(), Sp = Ep.TypeError, ma = function(e2, s, t, i, l, u, n, a) {
          for (var o = l, D = 0, F = n ? Ap(n, a) : false, h, v; D < i; ) {
            if (D in t) {
              if (h = F ? F(t[D], D, s) : t[D], u > 0 && vp(h))
                v = Fp(h), o = ma(e2, s, h, v, o, u - 1) - 1;
              else {
                if (o >= 9007199254740991)
                  throw Sp("Exceed the acceptable array length");
                e2[o] = h;
              }
              o++;
            }
            D++;
          }
          return o;
        };
        da.exports = ma;
      });
      var ha = xe((u0, ya) => {
        var bp = vt(), xp = bp("toStringTag"), ga = {};
        ga[xp] = "z";
        ya.exports = String(ga) === "[object z]";
      });
      var pn = xe((s0, Ca) => {
        var Tp = Ye(), Bp = ha(), Np = it(), yr = tr(), wp = vt(), Pp = wp("toStringTag"), _p = Tp.Object, Ip = yr(function() {
          return arguments;
        }()) == "Arguments", kp = function(e2, s) {
          try {
            return e2[s];
          } catch {
          }
        };
        Ca.exports = Bp ? yr : function(e2) {
          var s, t, i;
          return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (t = kp(s = _p(e2), Pp)) == "string" ? t : Ip ? yr(s) : (i = yr(s)) == "Object" && Np(s.callee) ? "Arguments" : i;
        };
      });
      var ba = xe((a0, Sa) => {
        var Lp = at(), Op = pt(), Ea = it(), jp = pn(), qp = jt(), Mp = Dr(), va = function() {
        }, Rp = [], Fa = qp("Reflect", "construct"), fn = /^\s*(?:class|function)\b/, Vp = Lp(fn.exec), Wp = !fn.exec(va), Wt = function(s) {
          if (!Ea(s))
            return false;
          try {
            return Fa(va, Rp, s), true;
          } catch {
            return false;
          }
        }, Aa = function(s) {
          if (!Ea(s))
            return false;
          switch (jp(s)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Wp || !!Vp(fn, Mp(s));
          } catch {
            return true;
          }
        };
        Aa.sham = true;
        Sa.exports = !Fa || Op(function() {
          var e2;
          return Wt(Wt.call) || !Wt(Object) || !Wt(function() {
            e2 = true;
          }) || e2;
        }) ? Aa : Wt;
      });
      var Na = xe((i0, Ba) => {
        var $p = Ye(), xa = on(), Hp = ba(), Gp = Ct(), Jp = vt(), Up = Jp("species"), Ta = $p.Array;
        Ba.exports = function(e2) {
          var s;
          return xa(e2) && (s = e2.constructor, Hp(s) && (s === Ta || xa(s.prototype)) ? s = void 0 : Gp(s) && (s = s[Up], s === null && (s = void 0))), s === void 0 ? Ta : s;
        };
      });
      var Dn = xe((o0, wa) => {
        var zp = Na();
        wa.exports = function(e2, s) {
          return new (zp(e2))(s === 0 ? 0 : s);
        };
      });
      var Pa = xe(() => {
        "use strict";
        var Xp = Vt(), Kp = ln(), Yp = qt(), Qp = or(), Zp = Tt(), ef = Dn();
        Xp({ target: "Array", proto: true }, { flatMap: function(s) {
          var t = Qp(this), i = Zp(t), l;
          return Yp(s), l = ef(t, 0), l.length = Kp(l, t, t, i, 0, 1, s, arguments.length > 1 ? arguments[1] : void 0), l;
        } });
      });
      var mn = xe((p0, _a) => {
        _a.exports = {};
      });
      var ka = xe((f0, Ia) => {
        var tf = vt(), rf = mn(), nf = tf("iterator"), uf = Array.prototype;
        Ia.exports = function(e2) {
          return e2 !== void 0 && (rf.Array === e2 || uf[nf] === e2);
        };
      });
      var dn = xe((D0, Oa) => {
        var sf = pn(), La = sr(), af = mn(), of = vt(), cf = of("iterator");
        Oa.exports = function(e2) {
          if (e2 != null)
            return La(e2, cf) || La(e2, "@@iterator") || af[sf(e2)];
        };
      });
      var qa = xe((m0, ja) => {
        var lf = Ye(), pf = ht(), ff = qt(), Df = xt(), mf = ur(), df = dn(), gf = lf.TypeError;
        ja.exports = function(e2, s) {
          var t = arguments.length < 2 ? df(e2) : s;
          if (ff(t))
            return Df(pf(t, e2));
          throw gf(mf(e2) + " is not iterable");
        };
      });
      var Va = xe((d0, Ra) => {
        var yf = ht(), Ma = xt(), hf = sr();
        Ra.exports = function(e2, s, t) {
          var i, l;
          Ma(e2);
          try {
            if (i = hf(e2, "return"), !i) {
              if (s === "throw")
                throw t;
              return t;
            }
            i = yf(i, e2);
          } catch (u) {
            l = true, i = u;
          }
          if (s === "throw")
            throw t;
          if (l)
            throw i;
          return Ma(i), t;
        };
      });
      var Ja = xe((g0, Ga) => {
        var Cf = Ye(), Ef = cn(), vf = ht(), Ff = xt(), Af = ur(), Sf = ka(), bf = Tt(), Wa = Ir(), xf = qa(), Tf = dn(), $a = Va(), Bf = Cf.TypeError, hr = function(e2, s) {
          this.stopped = e2, this.result = s;
        }, Ha = hr.prototype;
        Ga.exports = function(e2, s, t) {
          var i = t && t.that, l = !!(t && t.AS_ENTRIES), u = !!(t && t.IS_ITERATOR), n = !!(t && t.INTERRUPTED), a = Ef(s, i), o, D, F, h, v, p, m, E = function(N) {
            return o && $a(o, "normal", N), new hr(true, N);
          }, P = function(N) {
            return l ? (Ff(N), n ? a(N[0], N[1], E) : a(N[0], N[1])) : n ? a(N, E) : a(N);
          };
          if (u)
            o = e2;
          else {
            if (D = Tf(e2), !D)
              throw Bf(Af(e2) + " is not iterable");
            if (Sf(D)) {
              for (F = 0, h = bf(e2); h > F; F++)
                if (v = P(e2[F]), v && Wa(Ha, v))
                  return v;
              return new hr(false);
            }
            o = xf(e2, D);
          }
          for (p = o.next; !(m = vf(p, o)).done; ) {
            try {
              v = P(m.value);
            } catch (N) {
              $a(o, "throw", N);
            }
            if (typeof v == "object" && v && Wa(Ha, v))
              return v;
          }
          return new hr(false);
        };
      });
      var za = xe((y0, Ua) => {
        "use strict";
        var Nf = cr(), wf = pr(), Pf = er();
        Ua.exports = function(e2, s, t) {
          var i = Nf(s);
          i in e2 ? wf.f(e2, i, Pf(0, t)) : e2[i] = t;
        };
      });
      var Xa = xe(() => {
        var _f = Vt(), If = Ja(), kf = za();
        _f({ target: "Object", stat: true }, { fromEntries: function(s) {
          var t = {};
          return If(s, function(i, l) {
            kf(t, i, l);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var Ka = xe(() => {
        var Lf = Vt(), Of = Ye();
        Lf({ global: true }, { globalThis: Of });
      });
      var Ya = xe(() => {
        Ka();
      });
      var Qa = xe(() => {
        "use strict";
        var jf = Vt(), qf = ln(), Mf = or(), Rf = Tt(), Vf = gr(), Wf = Dn();
        jf({ target: "Array", proto: true }, { flat: function() {
          var s = arguments.length ? arguments[0] : void 0, t = Mf(this), i = Rf(t), l = Wf(t, 0);
          return l.length = qf(l, t, t, i, 0, s === void 0 ? 1 : Vf(s)), l;
        } });
      });
      var Gd = xe((T0, po) => {
        var $f = ["cliName", "cliCategory", "cliDescription"], Hf = ["_"], Gf = ["languageId"], Za, ei, ti, ri, ni, ui;
        function Sn(e2, s) {
          if (e2 == null)
            return {};
          var t = Jf(e2, s), i, l;
          if (Object.getOwnPropertySymbols) {
            var u = Object.getOwnPropertySymbols(e2);
            for (l = 0; l < u.length; l++)
              i = u[l], !(s.indexOf(i) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e2, i) || (t[i] = e2[i]));
          }
          return t;
        }
        function Jf(e2, s) {
          if (e2 == null)
            return {};
          var t = {}, i = Object.keys(e2), l, u;
          for (u = 0; u < i.length; u++)
            l = i[u], !(s.indexOf(l) >= 0) && (t[l] = e2[l]);
          return t;
        }
        Pa();
        Xa();
        Ya();
        Qa();
        function Bt(e2, s) {
          return s || (s = e2.slice(0)), Object.freeze(Object.defineProperties(e2, { raw: { value: Object.freeze(s) } }));
        }
        var bn = Object.defineProperty, Uf = Object.getOwnPropertyDescriptor, xn = Object.getOwnPropertyNames, zf = Object.prototype.hasOwnProperty, Tn = (e2, s) => function() {
          return e2 && (s = (0, e2[xn(e2)[0]])(e2 = 0)), s;
        }, ee = (e2, s) => function() {
          return s || (0, e2[xn(e2)[0]])((s = { exports: {} }).exports, s), s.exports;
        }, li = (e2, s) => {
          for (var t in s)
            bn(e2, t, { get: s[t], enumerable: true });
        }, Xf = (e2, s, t, i) => {
          if (s && typeof s == "object" || typeof s == "function")
            for (let l of xn(s))
              !zf.call(e2, l) && l !== t && bn(e2, l, { get: () => s[l], enumerable: !(i = Uf(s, l)) || i.enumerable });
          return e2;
        }, pi = (e2) => Xf(bn({}, "__esModule", { value: true }), e2), si, ai, mt, ae = Tn({ "<define:process>"() {
          si = {}, ai = [], mt = { env: si, argv: ai };
        } }), fi = ee({ "package.json"(e2, s) {
          s.exports = { version: "2.6.0" };
        } }), Kf = ee({ "node_modules/diff/lib/diff/base.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = s;
          function s() {
          }
          s.prototype = { diff: function(u, n) {
            var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = a.callback;
            typeof a == "function" && (o = a, a = {}), this.options = a;
            var D = this;
            function F(T) {
              return o ? (setTimeout(function() {
                o(void 0, T);
              }, 0), true) : T;
            }
            u = this.castInput(u), n = this.castInput(n), u = this.removeEmpty(this.tokenize(u)), n = this.removeEmpty(this.tokenize(n));
            var h = n.length, v = u.length, p = 1, m = h + v, E = [{ newPos: -1, components: [] }], P = this.extractCommon(E[0], n, u, 0);
            if (E[0].newPos + 1 >= h && P + 1 >= v)
              return F([{ value: this.join(n), count: n.length }]);
            function N() {
              for (var T = -1 * p; T <= p; T += 2) {
                var S = void 0, w = E[T - 1], _ = E[T + 1], k = (_ ? _.newPos : 0) - T;
                w && (E[T - 1] = void 0);
                var A = w && w.newPos + 1 < h, f = _ && 0 <= k && k < v;
                if (!A && !f) {
                  E[T] = void 0;
                  continue;
                }
                if (!A || f && w.newPos < _.newPos ? (S = i(_), D.pushComponent(S.components, void 0, true)) : (S = w, S.newPos++, D.pushComponent(S.components, true, void 0)), k = D.extractCommon(S, n, u, T), S.newPos + 1 >= h && k + 1 >= v)
                  return F(t(D, S.components, n, u, D.useLongestToken));
                E[T] = S;
              }
              p++;
            }
            if (o)
              (function T() {
                setTimeout(function() {
                  if (p > m)
                    return o();
                  N() || T();
                }, 0);
              })();
            else
              for (; p <= m; ) {
                var b = N();
                if (b)
                  return b;
              }
          }, pushComponent: function(u, n, a) {
            var o = u[u.length - 1];
            o && o.added === n && o.removed === a ? u[u.length - 1] = { count: o.count + 1, added: n, removed: a } : u.push({ count: 1, added: n, removed: a });
          }, extractCommon: function(u, n, a, o) {
            for (var D = n.length, F = a.length, h = u.newPos, v = h - o, p = 0; h + 1 < D && v + 1 < F && this.equals(n[h + 1], a[v + 1]); )
              h++, v++, p++;
            return p && u.components.push({ count: p }), u.newPos = h, v;
          }, equals: function(u, n) {
            return this.options.comparator ? this.options.comparator(u, n) : u === n || this.options.ignoreCase && u.toLowerCase() === n.toLowerCase();
          }, removeEmpty: function(u) {
            for (var n = [], a = 0; a < u.length; a++)
              u[a] && n.push(u[a]);
            return n;
          }, castInput: function(u) {
            return u;
          }, tokenize: function(u) {
            return u.split("");
          }, join: function(u) {
            return u.join("");
          } };
          function t(l, u, n, a, o) {
            for (var D = 0, F = u.length, h = 0, v = 0; D < F; D++) {
              var p = u[D];
              if (p.removed) {
                if (p.value = l.join(a.slice(v, v + p.count)), v += p.count, D && u[D - 1].added) {
                  var E = u[D - 1];
                  u[D - 1] = u[D], u[D] = E;
                }
              } else {
                if (!p.added && o) {
                  var m = n.slice(h, h + p.count);
                  m = m.map(function(N, b) {
                    var T = a[v + b];
                    return T.length > N.length ? T : N;
                  }), p.value = l.join(m);
                } else
                  p.value = l.join(n.slice(h, h + p.count));
                h += p.count, p.added || (v += p.count);
              }
            }
            var P = u[F - 1];
            return F > 1 && typeof P.value == "string" && (P.added || P.removed) && l.equals("", P.value) && (u[F - 2].value += P.value, u.pop()), u;
          }
          function i(l) {
            return { newPos: l.newPos, components: l.components.slice(0) };
          }
        } }), Yf = ee({ "node_modules/diff/lib/diff/array.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.diffArrays = l, e2.arrayDiff = void 0;
          var s = t(Kf());
          function t(u) {
            return u && u.__esModule ? u : { default: u };
          }
          var i = new s.default();
          e2.arrayDiff = i, i.tokenize = function(u) {
            return u.slice();
          }, i.join = i.removeEmpty = function(u) {
            return u;
          };
          function l(u, n, a) {
            return i.diff(u, n, a);
          }
        } }), Bn = ee({ "src/document/doc-builders.js"(e2, s) {
          "use strict";
          ae();
          function t(c) {
            return { type: "concat", parts: c };
          }
          function i(c) {
            return { type: "indent", contents: c };
          }
          function l(c, r) {
            return { type: "align", contents: r, n: c };
          }
          function u(c) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: r.id, contents: c, break: Boolean(r.shouldBreak), expandedStates: r.expandedStates };
          }
          function n(c) {
            return l(Number.NEGATIVE_INFINITY, c);
          }
          function a(c) {
            return l({ type: "root" }, c);
          }
          function o(c) {
            return l(-1, c);
          }
          function D(c, r) {
            return u(c[0], Object.assign(Object.assign({}, r), {}, { expandedStates: c }));
          }
          function F(c) {
            return { type: "fill", parts: c };
          }
          function h(c, r) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: c, flatContents: r, groupId: y.groupId };
          }
          function v(c, r) {
            return { type: "indent-if-break", contents: c, groupId: r.groupId, negate: r.negate };
          }
          function p(c) {
            return { type: "line-suffix", contents: c };
          }
          var m = { type: "line-suffix-boundary" }, E = { type: "break-parent" }, P = { type: "trim" }, N = { type: "line", hard: true }, b = { type: "line", hard: true, literal: true }, T = { type: "line" }, S = { type: "line", soft: true }, w = t([N, E]), _ = t([b, E]), k = { type: "cursor", placeholder: Symbol("cursor") };
          function A(c, r) {
            let y = [];
            for (let g = 0; g < r.length; g++)
              g !== 0 && y.push(c), y.push(r[g]);
            return t(y);
          }
          function f(c, r, y) {
            let g = c;
            if (r > 0) {
              for (let C = 0; C < Math.floor(r / y); ++C)
                g = i(g);
              g = l(r % y, g), g = l(Number.NEGATIVE_INFINITY, g);
            }
            return g;
          }
          function d(c, r) {
            return { type: "label", label: c, contents: r };
          }
          s.exports = { concat: t, join: A, line: T, softline: S, hardline: w, literalline: _, group: u, conditionalGroup: D, fill: F, lineSuffix: p, lineSuffixBoundary: m, cursor: k, breakParent: E, ifBreak: h, trim: P, indent: i, indentIfBreak: v, align: l, addAlignmentToDoc: f, markAsRoot: a, dedentToRoot: n, dedent: o, hardlineWithoutBreakParent: N, literallineWithoutBreakParent: b, label: d };
        } }), Nn = ee({ "src/common/end-of-line.js"(e2, s) {
          "use strict";
          ae();
          function t(n) {
            let a = n.indexOf("\r");
            return a >= 0 ? n.charAt(a + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function i(n) {
            switch (n) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function l(n, a) {
            let o;
            switch (a) {
              case `
`:
                o = /\n/g;
                break;
              case "\r":
                o = /\r/g;
                break;
              case `\r
`:
                o = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(a), "."));
            }
            let D = n.match(o);
            return D ? D.length : 0;
          }
          function u(n) {
            return n.replace(/\r\n?/g, `
`);
          }
          s.exports = { guessEndOfLine: t, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: u };
        } }), st = ee({ "src/utils/get-last.js"(e2, s) {
          "use strict";
          ae();
          var t = (i) => i[i.length - 1];
          s.exports = t;
        } }), Qf = ee({ "vendors/string-width.js"(e2, s) {
          ae();
          var t = Object.create, i = Object.defineProperty, l = Object.getOwnPropertyDescriptor, u = Object.getOwnPropertyNames, n = Object.getPrototypeOf, a = Object.prototype.hasOwnProperty, o = (S, w) => function() {
            return w || (0, S[u(S)[0]])((w = { exports: {} }).exports, w), w.exports;
          }, D = (S, w) => {
            for (var _ in w)
              i(S, _, { get: w[_], enumerable: true });
          }, F = (S, w, _, k) => {
            if (w && typeof w == "object" || typeof w == "function")
              for (let A of u(w))
                !a.call(S, A) && A !== _ && i(S, A, { get: () => w[A], enumerable: !(k = l(w, A)) || k.enumerable });
            return S;
          }, h = (S, w, _) => (_ = S != null ? t(n(S)) : {}, F(w || !S || !S.__esModule ? i(_, "default", { value: S, enumerable: true }) : _, S)), v = (S) => F(i({}, "__esModule", { value: true }), S), p = o({ "node_modules/emoji-regex/index.js"(S, w) {
            "use strict";
            w.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), m = {};
          D(m, { default: () => T }), s.exports = v(m);
          function E() {
            let { onlyFirst: S = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, w = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(w, S ? void 0 : "g");
          }
          function P(S) {
            if (typeof S != "string")
              throw new TypeError("Expected a `string`, got `".concat(typeof S, "`"));
            return S.replace(E(), "");
          }
          function N(S) {
            return Number.isInteger(S) ? S >= 4352 && (S <= 4447 || S === 9001 || S === 9002 || 11904 <= S && S <= 12871 && S !== 12351 || 12880 <= S && S <= 19903 || 19968 <= S && S <= 42182 || 43360 <= S && S <= 43388 || 44032 <= S && S <= 55203 || 63744 <= S && S <= 64255 || 65040 <= S && S <= 65049 || 65072 <= S && S <= 65131 || 65281 <= S && S <= 65376 || 65504 <= S && S <= 65510 || 110592 <= S && S <= 110593 || 127488 <= S && S <= 127569 || 131072 <= S && S <= 262141) : false;
          }
          var b = h(p(), 1);
          function T(S) {
            if (typeof S != "string" || S.length === 0 || (S = P(S), S.length === 0))
              return 0;
            S = S.replace((0, b.default)(), "  ");
            let w = 0;
            for (let _ = 0; _ < S.length; _++) {
              let k = S.codePointAt(_);
              k <= 31 || k >= 127 && k <= 159 || k >= 768 && k <= 879 || (k > 65535 && _++, w += N(k) ? 2 : 1);
            }
            return w;
          }
        } }), Di = ee({ "src/utils/get-string-width.js"(e2, s) {
          "use strict";
          ae();
          var t = Qf().default, i = /[^\x20-\x7F]/;
          function l(u) {
            return u ? i.test(u) ? t(u) : u.length : 0;
          }
          s.exports = l;
        } }), wn = ee({ "src/document/doc-utils.js"(e2, s) {
          "use strict";
          ae();
          var t = st(), { literalline: i, join: l } = Bn(), u = (r) => Array.isArray(r) || r && r.type === "concat", n = (r) => {
            if (Array.isArray(r))
              return r;
            if (r.type !== "concat" && r.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return r.parts;
          }, a = {};
          function o(r, y, g, C) {
            let x = [r];
            for (; x.length > 0; ) {
              let B = x.pop();
              if (B === a) {
                g(x.pop());
                continue;
              }
              if (g && x.push(B, a), !y || y(B) !== false)
                if (u(B) || B.type === "fill") {
                  let L = n(B);
                  for (let M = L.length, j = M - 1; j >= 0; --j)
                    x.push(L[j]);
                } else if (B.type === "if-break")
                  B.flatContents && x.push(B.flatContents), B.breakContents && x.push(B.breakContents);
                else if (B.type === "group" && B.expandedStates)
                  if (C)
                    for (let L = B.expandedStates.length, M = L - 1; M >= 0; --M)
                      x.push(B.expandedStates[M]);
                  else
                    x.push(B.contents);
                else
                  B.contents && x.push(B.contents);
            }
          }
          function D(r, y) {
            let g = /* @__PURE__ */ new Map();
            return C(r);
            function C(B) {
              if (g.has(B))
                return g.get(B);
              let L = x(B);
              return g.set(B, L), L;
            }
            function x(B) {
              if (Array.isArray(B))
                return y(B.map(C));
              if (B.type === "concat" || B.type === "fill") {
                let L = B.parts.map(C);
                return y(Object.assign(Object.assign({}, B), {}, { parts: L }));
              }
              if (B.type === "if-break") {
                let L = B.breakContents && C(B.breakContents), M = B.flatContents && C(B.flatContents);
                return y(Object.assign(Object.assign({}, B), {}, { breakContents: L, flatContents: M }));
              }
              if (B.type === "group" && B.expandedStates) {
                let L = B.expandedStates.map(C), M = L[0];
                return y(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: L }));
              }
              if (B.contents) {
                let L = C(B.contents);
                return y(Object.assign(Object.assign({}, B), {}, { contents: L }));
              }
              return y(B);
            }
          }
          function F(r, y, g) {
            let C = g, x = false;
            function B(L) {
              let M = y(L);
              if (M !== void 0 && (x = true, C = M), x)
                return false;
            }
            return o(r, B), C;
          }
          function h(r) {
            if (r.type === "group" && r.break || r.type === "line" && r.hard || r.type === "break-parent")
              return true;
          }
          function v(r) {
            return F(r, h, false);
          }
          function p(r) {
            if (r.length > 0) {
              let y = t(r);
              !y.expandedStates && !y.break && (y.break = "propagated");
            }
            return null;
          }
          function m(r) {
            let y = /* @__PURE__ */ new Set(), g = [];
            function C(B) {
              if (B.type === "break-parent" && p(g), B.type === "group") {
                if (g.push(B), y.has(B))
                  return false;
                y.add(B);
              }
            }
            function x(B) {
              B.type === "group" && g.pop().break && p(g);
            }
            o(r, C, x, true);
          }
          function E(r) {
            return r.type === "line" && !r.hard ? r.soft ? "" : " " : r.type === "if-break" ? r.flatContents || "" : r;
          }
          function P(r) {
            return D(r, E);
          }
          var N = (r, y) => r && r.type === "line" && r.hard && y && y.type === "break-parent";
          function b(r) {
            if (!r)
              return r;
            if (u(r) || r.type === "fill") {
              let y = n(r);
              for (; y.length > 1 && N(...y.slice(-2)); )
                y.length -= 2;
              if (y.length > 0) {
                let g = b(t(y));
                y[y.length - 1] = g;
              }
              return Array.isArray(r) ? y : Object.assign(Object.assign({}, r), {}, { parts: y });
            }
            switch (r.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let y = b(r.contents);
                return Object.assign(Object.assign({}, r), {}, { contents: y });
              }
              case "if-break": {
                let y = b(r.breakContents), g = b(r.flatContents);
                return Object.assign(Object.assign({}, r), {}, { breakContents: y, flatContents: g });
              }
            }
            return r;
          }
          function T(r) {
            return b(w(r));
          }
          function S(r) {
            switch (r.type) {
              case "fill":
                if (r.parts.every((g) => g === ""))
                  return "";
                break;
              case "group":
                if (!r.contents && !r.id && !r.break && !r.expandedStates)
                  return "";
                if (r.contents.type === "group" && r.contents.id === r.id && r.contents.break === r.break && r.contents.expandedStates === r.expandedStates)
                  return r.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!r.contents)
                  return "";
                break;
              case "if-break":
                if (!r.flatContents && !r.breakContents)
                  return "";
                break;
            }
            if (!u(r))
              return r;
            let y = [];
            for (let g of n(r)) {
              if (!g)
                continue;
              let [C, ...x] = u(g) ? n(g) : [g];
              typeof C == "string" && typeof t(y) == "string" ? y[y.length - 1] += C : y.push(C), y.push(...x);
            }
            return y.length === 0 ? "" : y.length === 1 ? y[0] : Array.isArray(r) ? y : Object.assign(Object.assign({}, r), {}, { parts: y });
          }
          function w(r) {
            return D(r, (y) => S(y));
          }
          function _(r) {
            let y = [], g = r.filter(Boolean);
            for (; g.length > 0; ) {
              let C = g.shift();
              if (!!C) {
                if (u(C)) {
                  g.unshift(...n(C));
                  continue;
                }
                if (y.length > 0 && typeof t(y) == "string" && typeof C == "string") {
                  y[y.length - 1] += C;
                  continue;
                }
                y.push(C);
              }
            }
            return y;
          }
          function k(r) {
            return D(r, (y) => Array.isArray(y) ? _(y) : y.parts ? Object.assign(Object.assign({}, y), {}, { parts: _(y.parts) }) : y);
          }
          function A(r) {
            return D(r, (y) => typeof y == "string" && y.includes(`
`) ? f(y) : y);
          }
          function f(r) {
            let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i;
            return l(y, r.split(`
`)).parts;
          }
          function d(r) {
            if (r.type === "line")
              return true;
          }
          function c(r) {
            return F(r, d, false);
          }
          s.exports = { isConcat: u, getDocParts: n, willBreak: v, traverseDoc: o, findInDoc: F, mapDoc: D, propagateBreaks: m, removeLines: P, stripTrailingHardline: T, normalizeParts: _, normalizeDoc: k, cleanDoc: w, replaceTextEndOfLine: f, replaceEndOfLine: A, canBreak: c };
        } }), Zf = ee({ "src/document/doc-printer.js"(e2, s) {
          "use strict";
          ae();
          var { convertEndOfLineToChars: t } = Nn(), i = st(), l = Di(), { fill: u, cursor: n, indent: a } = Bn(), { isConcat: o, getDocParts: D } = wn(), F, h = 1, v = 2;
          function p() {
            return { value: "", length: 0, queue: [] };
          }
          function m(S, w) {
            return P(S, { type: "indent" }, w);
          }
          function E(S, w, _) {
            return w === Number.NEGATIVE_INFINITY ? S.root || p() : w < 0 ? P(S, { type: "dedent" }, _) : w ? w.type === "root" ? Object.assign(Object.assign({}, S), {}, { root: S }) : P(S, { type: typeof w == "string" ? "stringAlign" : "numberAlign", n: w }, _) : S;
          }
          function P(S, w, _) {
            let k = w.type === "dedent" ? S.queue.slice(0, -1) : [...S.queue, w], A = "", f = 0, d = 0, c = 0;
            for (let L of k)
              switch (L.type) {
                case "indent":
                  g(), _.useTabs ? r(1) : y(_.tabWidth);
                  break;
                case "stringAlign":
                  g(), A += L.n, f += L.n.length;
                  break;
                case "numberAlign":
                  d += 1, c += L.n;
                  break;
                default:
                  throw new Error("Unexpected type '".concat(L.type, "'"));
              }
            return x(), Object.assign(Object.assign({}, S), {}, { value: A, length: f, queue: k });
            function r(L) {
              A += "	".repeat(L), f += _.tabWidth * L;
            }
            function y(L) {
              A += " ".repeat(L), f += L;
            }
            function g() {
              _.useTabs ? C() : x();
            }
            function C() {
              d > 0 && r(d), B();
            }
            function x() {
              c > 0 && y(c), B();
            }
            function B() {
              d = 0, c = 0;
            }
          }
          function N(S) {
            if (S.length === 0)
              return 0;
            let w = 0;
            for (; S.length > 0 && typeof i(S) == "string" && /^[\t ]*$/.test(i(S)); )
              w += S.pop().length;
            if (S.length > 0 && typeof i(S) == "string") {
              let _ = i(S).replace(/[\t ]*$/, "");
              w += i(S).length - _.length, S[S.length - 1] = _;
            }
            return w;
          }
          function b(S, w, _, k, A, f) {
            let d = w.length, c = [S], r = [];
            for (; _ >= 0; ) {
              if (c.length === 0) {
                if (d === 0)
                  return true;
                c.push(w[d - 1]), d--;
                continue;
              }
              let [y, g, C] = c.pop();
              if (typeof C == "string")
                r.push(C), _ -= l(C);
              else if (o(C)) {
                let x = D(C);
                for (let B = x.length - 1; B >= 0; B--)
                  c.push([y, g, x[B]]);
              } else
                switch (C.type) {
                  case "indent":
                    c.push([m(y, k), g, C.contents]);
                    break;
                  case "align":
                    c.push([E(y, C.n, k), g, C.contents]);
                    break;
                  case "trim":
                    _ += N(r);
                    break;
                  case "group": {
                    if (f && C.break)
                      return false;
                    let x = C.break ? h : g;
                    c.push([y, x, C.expandedStates && x === h ? i(C.expandedStates) : C.contents]), C.id && (F[C.id] = x);
                    break;
                  }
                  case "fill":
                    for (let x = C.parts.length - 1; x >= 0; x--)
                      c.push([y, g, C.parts[x]]);
                    break;
                  case "if-break":
                  case "indent-if-break": {
                    let x = C.groupId ? F[C.groupId] : g;
                    if (x === h) {
                      let B = C.type === "if-break" ? C.breakContents : C.negate ? C.contents : a(C.contents);
                      B && c.push([y, g, B]);
                    }
                    if (x === v) {
                      let B = C.type === "if-break" ? C.flatContents : C.negate ? a(C.contents) : C.contents;
                      B && c.push([y, g, B]);
                    }
                    break;
                  }
                  case "line":
                    switch (g) {
                      case v:
                        if (!C.hard) {
                          C.soft || (r.push(" "), _ -= 1);
                          break;
                        }
                        return true;
                      case h:
                        return true;
                    }
                    break;
                  case "line-suffix":
                    A = true;
                    break;
                  case "line-suffix-boundary":
                    if (A)
                      return false;
                    break;
                  case "label":
                    c.push([y, g, C.contents]);
                    break;
                }
            }
            return false;
          }
          function T(S, w) {
            F = {};
            let _ = w.printWidth, k = t(w.endOfLine), A = 0, f = [[p(), h, S]], d = [], c = false, r = [];
            for (; f.length > 0; ) {
              let [g, C, x] = f.pop();
              if (typeof x == "string") {
                let B = k !== `
` ? x.replace(/\n/g, k) : x;
                d.push(B), A += l(B);
              } else if (o(x)) {
                let B = D(x);
                for (let L = B.length - 1; L >= 0; L--)
                  f.push([g, C, B[L]]);
              } else
                switch (x.type) {
                  case "cursor":
                    d.push(n.placeholder);
                    break;
                  case "indent":
                    f.push([m(g, w), C, x.contents]);
                    break;
                  case "align":
                    f.push([E(g, x.n, w), C, x.contents]);
                    break;
                  case "trim":
                    A -= N(d);
                    break;
                  case "group":
                    switch (C) {
                      case v:
                        if (!c) {
                          f.push([g, x.break ? h : v, x.contents]);
                          break;
                        }
                      case h: {
                        c = false;
                        let B = [g, v, x.contents], L = _ - A, M = r.length > 0;
                        if (!x.break && b(B, f, L, w, M))
                          f.push(B);
                        else if (x.expandedStates) {
                          let j = i(x.expandedStates);
                          if (x.break) {
                            f.push([g, h, j]);
                            break;
                          } else
                            for (let H = 1; H < x.expandedStates.length + 1; H++)
                              if (H >= x.expandedStates.length) {
                                f.push([g, h, j]);
                                break;
                              } else {
                                let I = x.expandedStates[H], G = [g, v, I];
                                if (b(G, f, L, w, M)) {
                                  f.push(G);
                                  break;
                                }
                              }
                        } else
                          f.push([g, h, x.contents]);
                        break;
                      }
                    }
                    x.id && (F[x.id] = i(f)[1]);
                    break;
                  case "fill": {
                    let B = _ - A, { parts: L } = x;
                    if (L.length === 0)
                      break;
                    let [M, j] = L, H = [g, v, M], I = [g, h, M], G = b(H, [], B, w, r.length > 0, true);
                    if (L.length === 1) {
                      G ? f.push(H) : f.push(I);
                      break;
                    }
                    let Z = [g, v, j], W = [g, h, j];
                    if (L.length === 2) {
                      G ? f.push(Z, H) : f.push(W, I);
                      break;
                    }
                    L.splice(0, 2);
                    let $ = [g, C, u(L)], te = L[0];
                    b([g, v, [M, j, te]], [], B, w, r.length > 0, true) ? f.push($, Z, H) : G ? f.push($, W, H) : f.push($, W, I);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let B = x.groupId ? F[x.groupId] : C;
                    if (B === h) {
                      let L = x.type === "if-break" ? x.breakContents : x.negate ? x.contents : a(x.contents);
                      L && f.push([g, C, L]);
                    }
                    if (B === v) {
                      let L = x.type === "if-break" ? x.flatContents : x.negate ? a(x.contents) : x.contents;
                      L && f.push([g, C, L]);
                    }
                    break;
                  }
                  case "line-suffix":
                    r.push([g, C, x.contents]);
                    break;
                  case "line-suffix-boundary":
                    r.length > 0 && f.push([g, C, { type: "line", hard: true }]);
                    break;
                  case "line":
                    switch (C) {
                      case v:
                        if (x.hard)
                          c = true;
                        else {
                          x.soft || (d.push(" "), A += 1);
                          break;
                        }
                      case h:
                        if (r.length > 0) {
                          f.push([g, C, x], ...r.reverse()), r = [];
                          break;
                        }
                        x.literal ? g.root ? (d.push(k, g.root.value), A = g.root.length) : (d.push(k), A = 0) : (A -= N(d), d.push(k + g.value), A = g.length);
                        break;
                    }
                    break;
                  case "label":
                    f.push([g, C, x.contents]);
                    break;
                  default:
                }
              f.length === 0 && r.length > 0 && (f.push(...r.reverse()), r = []);
            }
            let y = d.indexOf(n.placeholder);
            if (y !== -1) {
              let g = d.indexOf(n.placeholder, y + 1), C = d.slice(0, y).join(""), x = d.slice(y + 1, g).join(""), B = d.slice(g + 1).join("");
              return { formatted: C + x + B, cursorNodeStart: C.length, cursorNodeText: x };
            }
            return { formatted: d.join("") };
          }
          s.exports = { printDocToString: T };
        } }), eD = ee({ "src/document/doc-debug.js"(e2, s) {
          "use strict";
          ae();
          var { isConcat: t, getDocParts: i } = wn();
          function l(n) {
            if (!n)
              return "";
            if (t(n)) {
              let a = [];
              for (let o of i(n))
                if (t(o))
                  a.push(...l(o).parts);
                else {
                  let D = l(o);
                  D !== "" && a.push(D);
                }
              return { type: "concat", parts: a };
            }
            return n.type === "if-break" ? Object.assign(Object.assign({}, n), {}, { breakContents: l(n.breakContents), flatContents: l(n.flatContents) }) : n.type === "group" ? Object.assign(Object.assign({}, n), {}, { contents: l(n.contents), expandedStates: n.expandedStates && n.expandedStates.map(l) }) : n.type === "fill" ? { type: "fill", parts: n.parts.map(l) } : n.contents ? Object.assign(Object.assign({}, n), {}, { contents: l(n.contents) }) : n;
          }
          function u(n) {
            let a = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Set();
            return D(l(n));
            function D(h, v, p) {
              if (typeof h == "string")
                return JSON.stringify(h);
              if (t(h)) {
                let m = i(h).map(D).filter(Boolean);
                return m.length === 1 ? m[0] : "[".concat(m.join(", "), "]");
              }
              if (h.type === "line") {
                let m = Array.isArray(p) && p[v + 1] && p[v + 1].type === "break-parent";
                return h.literal ? m ? "literalline" : "literallineWithoutBreakParent" : h.hard ? m ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
              }
              if (h.type === "break-parent")
                return Array.isArray(p) && p[v - 1] && p[v - 1].type === "line" && p[v - 1].hard ? void 0 : "breakParent";
              if (h.type === "trim")
                return "trim";
              if (h.type === "indent")
                return "indent(" + D(h.contents) + ")";
              if (h.type === "align")
                return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + D(h.contents) + ")" : h.n < 0 ? "dedent(" + D(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + D(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + D(h.contents) + ")";
              if (h.type === "if-break")
                return "ifBreak(" + D(h.breakContents) + (h.flatContents ? ", " + D(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + ", { groupId: ".concat(F(h.groupId), " }") : "") + ")";
              if (h.type === "indent-if-break") {
                let m = [];
                h.negate && m.push("negate: true"), h.groupId && m.push("groupId: ".concat(F(h.groupId)));
                let E = m.length > 0 ? ", { ".concat(m.join(", "), " }") : "";
                return "indentIfBreak(".concat(D(h.contents)).concat(E, ")");
              }
              if (h.type === "group") {
                let m = [];
                h.break && h.break !== "propagated" && m.push("shouldBreak: true"), h.id && m.push("id: ".concat(F(h.id)));
                let E = m.length > 0 ? ", { ".concat(m.join(", "), " }") : "";
                return h.expandedStates ? "conditionalGroup([".concat(h.expandedStates.map((P) => D(P)).join(","), "]").concat(E, ")") : "group(".concat(D(h.contents)).concat(E, ")");
              }
              if (h.type === "fill")
                return "fill([".concat(h.parts.map((m) => D(m)).join(", "), "])");
              if (h.type === "line-suffix")
                return "lineSuffix(" + D(h.contents) + ")";
              if (h.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h.type === "label")
                return "label(".concat(JSON.stringify(h.label), ", ").concat(D(h.contents), ")");
              throw new Error("Unknown doc type " + h.type);
            }
            function F(h) {
              if (typeof h != "symbol")
                return JSON.stringify(String(h));
              if (h in a)
                return a[h];
              let v = String(h).slice(7, -1) || "symbol";
              for (let p = 0; ; p++) {
                let m = v + (p > 0 ? " #".concat(p) : "");
                if (!o.has(m))
                  return o.add(m), a[h] = "Symbol.for(".concat(JSON.stringify(m), ")");
              }
            }
          }
          s.exports = { printDocToDebug: u };
        } }), Le = ee({ "src/document/index.js"(e2, s) {
          "use strict";
          ae(), s.exports = { builders: Bn(), printer: Zf(), utils: wn(), debug: eD() };
        } }), tD = ee({ "node_modules/escape-string-regexp/index.js"(e2, s) {
          "use strict";
          ae(), s.exports = (t) => {
            if (typeof t != "string")
              throw new TypeError("Expected a string");
            return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          };
        } }), mi = ee({ "node_modules/semver/internal/debug.js"(e2, s) {
          ae();
          var t = typeof mt == "object" && mt.env && mt.env.NODE_DEBUG && /\bsemver\b/i.test(mt.env.NODE_DEBUG) ? function() {
            for (var i = arguments.length, l = new Array(i), u = 0; u < i; u++)
              l[u] = arguments[u];
            return console.error("SEMVER", ...l);
          } : () => {
          };
          s.exports = t;
        } }), di = ee({ "node_modules/semver/internal/constants.js"(e2, s) {
          ae();
          var t = "2.0.0", i = 256, l = Number.MAX_SAFE_INTEGER || 9007199254740991, u = 16;
          s.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: i, MAX_SAFE_INTEGER: l, MAX_SAFE_COMPONENT_LENGTH: u };
        } }), rD = ee({ "node_modules/semver/internal/re.js"(e2, s) {
          ae();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = di(), i = mi();
          e2 = s.exports = {};
          var l = e2.re = [], u = e2.src = [], n = e2.t = {}, a = 0, o = (D, F, h) => {
            let v = a++;
            i(v, F), n[D] = v, u[v] = F, l[v] = new RegExp(F, h ? "g" : void 0);
          };
          o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(u[n.NUMERICIDENTIFIER], ")\\.(").concat(u[n.NUMERICIDENTIFIER], ")\\.(").concat(u[n.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(u[n.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(u[n.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(u[n.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(u[n.NUMERICIDENTIFIER], "|").concat(u[n.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(u[n.NUMERICIDENTIFIERLOOSE], "|").concat(u[n.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(u[n.PRERELEASEIDENTIFIER], "(?:\\.").concat(u[n.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(u[n.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(u[n.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(u[n.BUILDIDENTIFIER], "(?:\\.").concat(u[n.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(u[n.MAINVERSION]).concat(u[n.PRERELEASE], "?").concat(u[n.BUILD], "?")), o("FULL", "^".concat(u[n.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(u[n.MAINVERSIONLOOSE]).concat(u[n.PRERELEASELOOSE], "?").concat(u[n.BUILD], "?")), o("LOOSE", "^".concat(u[n.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(u[n.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(u[n.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(u[n.XRANGEIDENTIFIER], ")(?:\\.(").concat(u[n.XRANGEIDENTIFIER], ")(?:\\.(").concat(u[n.XRANGEIDENTIFIER], ")(?:").concat(u[n.PRERELEASE], ")?").concat(u[n.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(u[n.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(u[n.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(u[n.XRANGEIDENTIFIERLOOSE], ")(?:").concat(u[n.PRERELEASELOOSE], ")?").concat(u[n.BUILD], "?)?)?")), o("XRANGE", "^".concat(u[n.GTLT], "\\s*").concat(u[n.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(u[n.GTLT], "\\s*").concat(u[n.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", u[n.COERCE], true), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(u[n.LONETILDE], "\\s+"), true), e2.tildeTrimReplace = "$1~", o("TILDE", "^".concat(u[n.LONETILDE]).concat(u[n.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(u[n.LONETILDE]).concat(u[n.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(u[n.LONECARET], "\\s+"), true), e2.caretTrimReplace = "$1^", o("CARET", "^".concat(u[n.LONECARET]).concat(u[n.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(u[n.LONECARET]).concat(u[n.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(u[n.GTLT], "\\s*(").concat(u[n.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(u[n.GTLT], "\\s*(").concat(u[n.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(u[n.GTLT], "\\s*(").concat(u[n.LOOSEPLAIN], "|").concat(u[n.XRANGEPLAIN], ")"), true), e2.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(u[n.XRANGEPLAIN], ")\\s+-\\s+(").concat(u[n.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(u[n.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(u[n.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
        } }), nD = ee({ "node_modules/semver/internal/parse-options.js"(e2, s) {
          ae();
          var t = ["includePrerelease", "loose", "rtl"], i = (l) => l ? typeof l != "object" ? { loose: true } : t.filter((u) => l[u]).reduce((u, n) => (u[n] = true, u), {}) : {};
          s.exports = i;
        } }), uD = ee({ "node_modules/semver/internal/identifiers.js"(e2, s) {
          ae();
          var t = /^[0-9]+$/, i = (u, n) => {
            let a = t.test(u), o = t.test(n);
            return a && o && (u = +u, n = +n), u === n ? 0 : a && !o ? -1 : o && !a ? 1 : u < n ? -1 : 1;
          }, l = (u, n) => i(n, u);
          s.exports = { compareIdentifiers: i, rcompareIdentifiers: l };
        } }), sD = ee({ "node_modules/semver/classes/semver.js"(e2, s) {
          ae();
          var t = mi(), { MAX_LENGTH: i, MAX_SAFE_INTEGER: l } = di(), { re: u, t: n } = rD(), a = nD(), { compareIdentifiers: o } = uD(), D = class {
            constructor(F, h) {
              if (h = a(h), F instanceof D) {
                if (F.loose === !!h.loose && F.includePrerelease === !!h.includePrerelease)
                  return F;
                F = F.version;
              } else if (typeof F != "string")
                throw new TypeError("Invalid Version: ".concat(F));
              if (F.length > i)
                throw new TypeError("version is longer than ".concat(i, " characters"));
              t("SemVer", F, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
              let v = F.trim().match(h.loose ? u[n.LOOSE] : u[n.FULL]);
              if (!v)
                throw new TypeError("Invalid Version: ".concat(F));
              if (this.raw = F, this.major = +v[1], this.minor = +v[2], this.patch = +v[3], this.major > l || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > l || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > l || this.patch < 0)
                throw new TypeError("Invalid patch version");
              v[4] ? this.prerelease = v[4].split(".").map((p) => {
                if (/^[0-9]+$/.test(p)) {
                  let m = +p;
                  if (m >= 0 && m < l)
                    return m;
                }
                return p;
              }) : this.prerelease = [], this.build = v[5] ? v[5].split(".") : [], this.format();
            }
            format() {
              return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
            }
            toString() {
              return this.version;
            }
            compare(F) {
              if (t("SemVer.compare", this.version, this.options, F), !(F instanceof D)) {
                if (typeof F == "string" && F === this.version)
                  return 0;
                F = new D(F, this.options);
              }
              return F.version === this.version ? 0 : this.compareMain(F) || this.comparePre(F);
            }
            compareMain(F) {
              return F instanceof D || (F = new D(F, this.options)), o(this.major, F.major) || o(this.minor, F.minor) || o(this.patch, F.patch);
            }
            comparePre(F) {
              if (F instanceof D || (F = new D(F, this.options)), this.prerelease.length && !F.prerelease.length)
                return -1;
              if (!this.prerelease.length && F.prerelease.length)
                return 1;
              if (!this.prerelease.length && !F.prerelease.length)
                return 0;
              let h = 0;
              do {
                let v = this.prerelease[h], p = F.prerelease[h];
                if (t("prerelease compare", h, v, p), v === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (v === void 0)
                  return -1;
                if (v === p)
                  continue;
                return o(v, p);
              } while (++h);
            }
            compareBuild(F) {
              F instanceof D || (F = new D(F, this.options));
              let h = 0;
              do {
                let v = this.build[h], p = F.build[h];
                if (t("prerelease compare", h, v, p), v === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (v === void 0)
                  return -1;
                if (v === p)
                  continue;
                return o(v, p);
              } while (++h);
            }
            inc(F, h) {
              switch (F) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let v = this.prerelease.length;
                    for (; --v >= 0; )
                      typeof this.prerelease[v] == "number" && (this.prerelease[v]++, v = -2);
                    v === -1 && this.prerelease.push(0);
                  }
                  h && (this.prerelease[0] === h ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                  break;
                default:
                  throw new Error("invalid increment argument: ".concat(F));
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          s.exports = D;
        } }), Pn = ee({ "node_modules/semver/functions/compare.js"(e2, s) {
          ae();
          var t = sD(), i = (l, u, n) => new t(l, n).compare(new t(u, n));
          s.exports = i;
        } }), aD = ee({ "node_modules/semver/functions/lt.js"(e2, s) {
          ae();
          var t = Pn(), i = (l, u, n) => t(l, u, n) < 0;
          s.exports = i;
        } }), iD = ee({ "node_modules/semver/functions/gte.js"(e2, s) {
          ae();
          var t = Pn(), i = (l, u, n) => t(l, u, n) >= 0;
          s.exports = i;
        } }), oD = ee({ "src/utils/arrayify.js"(e2, s) {
          "use strict";
          ae(), s.exports = (t, i) => Object.entries(t).map((l) => {
            let [u, n] = l;
            return Object.assign({ [i]: u }, n);
          });
        } }), cD = ee({ "node_modules/outdent/lib/index.js"(e2, s) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.outdent = void 0;
          function t() {
            for (var b = [], T = 0; T < arguments.length; T++)
              b[T] = arguments[T];
          }
          function i() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : l();
          }
          function l() {
            return { add: t, delete: t, get: t, set: t, has: function(b) {
              return false;
            } };
          }
          var u = Object.prototype.hasOwnProperty, n = function(b, T) {
            return u.call(b, T);
          };
          function a(b, T) {
            for (var S in T)
              n(T, S) && (b[S] = T[S]);
            return b;
          }
          var o = /^[ \t]*(?:\r\n|\r|\n)/, D = /(?:\r\n|\r|\n)[ \t]*$/, F = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, v = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p(b, T, S) {
            var w = 0, _ = b[0].match(h);
            _ && (w = _[1].length);
            var k = "(\\r\\n|\\r|\\n).{0," + w + "}", A = new RegExp(k, "g");
            T && (b = b.slice(1));
            var f = S.newline, d = S.trimLeadingNewline, c = S.trimTrailingNewline, r = typeof f == "string", y = b.length, g = b.map(function(C, x) {
              return C = C.replace(A, "$1"), x === 0 && d && (C = C.replace(o, "")), x === y - 1 && c && (C = C.replace(D, "")), r && (C = C.replace(/\r\n|\n|\r/g, function(B) {
                return f;
              })), C;
            });
            return g;
          }
          function m(b, T) {
            for (var S = "", w = 0, _ = b.length; w < _; w++)
              S += b[w], w < _ - 1 && (S += T[w]);
            return S;
          }
          function E(b) {
            return n(b, "raw") && n(b, "length");
          }
          function P(b) {
            var T = i(), S = i();
            function w(k) {
              for (var A = [], f = 1; f < arguments.length; f++)
                A[f - 1] = arguments[f];
              if (E(k)) {
                var d = k, c = (A[0] === w || A[0] === N) && v.test(d[0]) && F.test(d[1]), r = c ? S : T, y = r.get(d);
                if (y || (y = p(d, c, b), r.set(d, y)), A.length === 0)
                  return y[0];
                var g = m(y, c ? A.slice(1) : A);
                return g;
              } else
                return P(a(a({}, b), k || {}));
            }
            var _ = a(w, { string: function(k) {
              return p([k], false, b)[0];
            } });
            return _;
          }
          var N = P({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e2.outdent = N, e2.default = N, typeof s < "u")
            try {
              s.exports = N, Object.defineProperty(N, "__esModule", { value: true }), N.default = N, N.outdent = N;
            } catch {
            }
        } }), lD = ee({ "src/main/core-options.js"(e2, s) {
          "use strict";
          ae();
          var { outdent: t } = cD(), i = "Config", l = "Editor", u = "Format", n = "Other", a = "Output", o = "Global", D = "Special", F = { cursorOffset: { since: "1.4.0", category: D, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Za || (Za = Bt([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: l }, endOfLine: { since: "1.15.0", category: o, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(ei || (ei = Bt([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: D, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: n, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: D, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: n }, parser: { since: "0.0.10", category: o, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: o, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: i }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: o, description: t(ti || (ti = Bt([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: i }, printWidth: { since: "0.0.0", category: o, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: D, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ri || (ri = Bt([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: l }, rangeStart: { since: "1.4.0", category: D, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ni || (ni = Bt([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: l }, requirePragma: { since: "1.7.0", category: D, type: "boolean", default: false, description: t(ui || (ui = Bt([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: n }, tabWidth: { type: "int", category: o, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: o, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: o, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          s.exports = { CATEGORY_CONFIG: i, CATEGORY_EDITOR: l, CATEGORY_FORMAT: u, CATEGORY_OTHER: n, CATEGORY_OUTPUT: a, CATEGORY_GLOBAL: o, CATEGORY_SPECIAL: D, options: F };
        } }), _n = ee({ "src/main/support.js"(e2, s) {
          "use strict";
          ae();
          var t = { compare: Pn(), lt: aD(), gte: iD() }, i = oD(), l = fi().version, u = lD().options;
          function n() {
            let { plugins: o = [], showUnreleased: D = false, showDeprecated: F = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, v = l.split("-", 1)[0], p = o.flatMap((b) => b.languages || []).filter(E), m = i(Object.assign({}, ...o.map((b) => {
              let { options: T } = b;
              return T;
            }), u), "name").filter((b) => E(b) && P(b)).sort((b, T) => b.name === T.name ? 0 : b.name < T.name ? -1 : 1).map(N).map((b) => {
              b = Object.assign({}, b), Array.isArray(b.default) && (b.default = b.default.length === 1 ? b.default[0].value : b.default.filter(E).sort((S, w) => t.compare(w.since, S.since))[0].value), Array.isArray(b.choices) && (b.choices = b.choices.filter((S) => E(S) && P(S)), b.name === "parser" && a(b, p, o));
              let T = Object.fromEntries(o.filter((S) => S.defaultOptions && S.defaultOptions[b.name] !== void 0).map((S) => [S.name, S.defaultOptions[b.name]]));
              return Object.assign(Object.assign({}, b), {}, { pluginDefaults: T });
            });
            return { languages: p, options: m };
            function E(b) {
              return D || !("since" in b) || b.since && t.gte(v, b.since);
            }
            function P(b) {
              return F || !("deprecated" in b) || b.deprecated && t.lt(v, b.deprecated);
            }
            function N(b) {
              if (h)
                return b;
              let { cliName: T, cliCategory: S, cliDescription: w } = b;
              return Sn(b, $f);
            }
          }
          function a(o, D, F) {
            let h = new Set(o.choices.map((v) => v.value));
            for (let v of D)
              if (v.parsers) {
                for (let p of v.parsers)
                  if (!h.has(p)) {
                    h.add(p);
                    let m = F.find((P) => P.parsers && P.parsers[p]), E = v.name;
                    m && m.name && (E += " (plugin: ".concat(m.name, ")")), o.choices.push({ value: p, description: E });
                  }
              }
          }
          s.exports = { getSupportInfo: n };
        } }), In = ee({ "src/utils/is-non-empty-array.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            return Array.isArray(i) && i.length > 0;
          }
          s.exports = t;
        } }), vr = ee({ "src/utils/text/skip.js"(e2, s) {
          "use strict";
          ae();
          function t(a) {
            return (o, D, F) => {
              let h = F && F.backwards;
              if (D === false)
                return false;
              let { length: v } = o, p = D;
              for (; p >= 0 && p < v; ) {
                let m = o.charAt(p);
                if (a instanceof RegExp) {
                  if (!a.test(m))
                    return p;
                } else if (!a.includes(m))
                  return p;
                h ? p-- : p++;
              }
              return p === -1 || p === v ? p : false;
            };
          }
          var i = t(/\s/), l = t(" 	"), u = t(",; 	"), n = t(/[^\n\r]/);
          s.exports = { skipWhitespace: i, skipSpaces: l, skipToLineEnd: u, skipEverythingButNewLine: n };
        } }), gi = ee({ "src/utils/text/skip-inline-comment.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l) {
            if (l === false)
              return false;
            if (i.charAt(l) === "/" && i.charAt(l + 1) === "*") {
              for (let u = l + 2; u < i.length; ++u)
                if (i.charAt(u) === "*" && i.charAt(u + 1) === "/")
                  return u + 2;
            }
            return l;
          }
          s.exports = t;
        } }), yi = ee({ "src/utils/text/skip-trailing-comment.js"(e2, s) {
          "use strict";
          ae();
          var { skipEverythingButNewLine: t } = vr();
          function i(l, u) {
            return u === false ? false : l.charAt(u) === "/" && l.charAt(u + 1) === "/" ? t(l, u) : u;
          }
          s.exports = i;
        } }), hi = ee({ "src/utils/text/skip-newline.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l, u) {
            let n = u && u.backwards;
            if (l === false)
              return false;
            let a = i.charAt(l);
            if (n) {
              if (i.charAt(l - 1) === "\r" && a === `
`)
                return l - 2;
              if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029")
                return l - 1;
            } else {
              if (a === "\r" && i.charAt(l + 1) === `
`)
                return l + 2;
              if (a === `
` || a === "\r" || a === "\u2028" || a === "\u2029")
                return l + 1;
            }
            return l;
          }
          s.exports = t;
        } }), pD = ee({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e2, s) {
          "use strict";
          ae();
          var t = gi(), i = hi(), l = yi(), { skipSpaces: u } = vr();
          function n(a, o) {
            let D = null, F = o;
            for (; F !== D; )
              D = F, F = u(a, F), F = t(a, F), F = l(a, F), F = i(a, F);
            return F;
          }
          s.exports = n;
        } }), Ge = ee({ "src/common/util.js"(e2, s) {
          "use strict";
          ae();
          var t = tD(), i = st(), { getSupportInfo: l } = _n(), u = In(), n = Di(), { skipWhitespace: a, skipSpaces: o, skipToLineEnd: D, skipEverythingButNewLine: F } = vr(), h = gi(), v = yi(), p = hi(), m = pD(), E = (W) => W[W.length - 2];
          function P(W) {
            return ($, te, U) => {
              let ne = U && U.backwards;
              if (te === false)
                return false;
              let { length: se } = $, V = te;
              for (; V >= 0 && V < se; ) {
                let oe = $.charAt(V);
                if (W instanceof RegExp) {
                  if (!W.test(oe))
                    return V;
                } else if (!W.includes(oe))
                  return V;
                ne ? V-- : V++;
              }
              return V === -1 || V === se ? V : false;
            };
          }
          function N(W, $) {
            let te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, U = o(W, te.backwards ? $ - 1 : $, te), ne = p(W, U, te);
            return U !== ne;
          }
          function b(W, $, te) {
            for (let U = $; U < te; ++U)
              if (W.charAt(U) === `
`)
                return true;
            return false;
          }
          function T(W, $, te) {
            let U = te($) - 1;
            U = o(W, U, { backwards: true }), U = p(W, U, { backwards: true }), U = o(W, U, { backwards: true });
            let ne = p(W, U, { backwards: true });
            return U !== ne;
          }
          function S(W, $) {
            let te = null, U = $;
            for (; U !== te; )
              te = U, U = D(W, U), U = h(W, U), U = o(W, U);
            return U = v(W, U), U = p(W, U), U !== false && N(W, U);
          }
          function w(W, $, te) {
            return S(W, te($));
          }
          function _(W, $, te) {
            return m(W, te($));
          }
          function k(W, $, te) {
            return W.charAt(_(W, $, te));
          }
          function A(W, $) {
            let te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return o(W, te.backwards ? $ - 1 : $, te) !== $;
          }
          function f(W, $) {
            let te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, U = 0;
            for (let ne = te; ne < W.length; ++ne)
              W[ne] === "	" ? U = U + $ - U % $ : U++;
            return U;
          }
          function d(W, $) {
            let te = W.lastIndexOf(`
`);
            return te === -1 ? 0 : f(W.slice(te + 1).match(/^[\t ]*/)[0], $);
          }
          function c(W, $) {
            let te = { quote: '"', regex: /"/g, escaped: "&quot;" }, U = { quote: "'", regex: /'/g, escaped: "&apos;" }, ne = $ === "'" ? U : te, se = ne === U ? te : U, V = ne;
            if (W.includes(ne.quote) || W.includes(se.quote)) {
              let oe = (W.match(ne.regex) || []).length, K = (W.match(se.regex) || []).length;
              V = oe > K ? se : ne;
            }
            return V;
          }
          function r(W, $) {
            let te = W.slice(1, -1), U = $.parser === "json" || $.parser === "json5" && $.quoteProps === "preserve" && !$.singleQuote ? '"' : $.__isInHtmlAttribute ? "'" : c(te, $.singleQuote ? "'" : '"').quote;
            return y(te, U, !($.parser === "css" || $.parser === "less" || $.parser === "scss" || $.__embeddedInHtml));
          }
          function y(W, $, te) {
            let U = $ === '"' ? "'" : '"', ne = /\\(.)|(["'])/gs, se = W.replace(ne, (V, oe, K) => oe === U ? oe : K === $ ? "\\" + K : K || (te && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(oe) ? oe : "\\" + oe));
            return $ + se + $;
          }
          function g(W) {
            return W.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function C(W, $) {
            let te = W.match(new RegExp("(".concat(t($), ")+"), "g"));
            return te === null ? 0 : te.reduce((U, ne) => Math.max(U, ne.length / $.length), 0);
          }
          function x(W, $) {
            let te = W.match(new RegExp("(".concat(t($), ")+"), "g"));
            if (te === null)
              return 0;
            let U = /* @__PURE__ */ new Map(), ne = 0;
            for (let se of te) {
              let V = se.length / $.length;
              U.set(V, true), V > ne && (ne = V);
            }
            for (let se = 1; se < ne; se++)
              if (!U.get(se))
                return se;
            return ne + 1;
          }
          function B(W, $) {
            (W.comments || (W.comments = [])).push($), $.printed = false, $.nodeDescription = Z(W);
          }
          function L(W, $) {
            $.leading = true, $.trailing = false, B(W, $);
          }
          function M(W, $, te) {
            $.leading = false, $.trailing = false, te && ($.marker = te), B(W, $);
          }
          function j(W, $) {
            $.leading = false, $.trailing = true, B(W, $);
          }
          function H(W, $) {
            let { languages: te } = l({ plugins: $.plugins }), U = te.find((ne) => {
              let { name: se } = ne;
              return se.toLowerCase() === W;
            }) || te.find((ne) => {
              let { aliases: se } = ne;
              return Array.isArray(se) && se.includes(W);
            }) || te.find((ne) => {
              let { extensions: se } = ne;
              return Array.isArray(se) && se.includes(".".concat(W));
            });
            return U && U.parsers[0];
          }
          function I(W) {
            return W && W.type === "front-matter";
          }
          function G(W) {
            let $ = /* @__PURE__ */ new WeakMap();
            return function(te) {
              return $.has(te) || $.set(te, Symbol(W)), $.get(te);
            };
          }
          function Z(W) {
            let $ = W.type || W.kind || "(unknown type)", te = String(W.name || W.id && (typeof W.id == "object" ? W.id.name : W.id) || W.key && (typeof W.key == "object" ? W.key.name : W.key) || W.value && (typeof W.value == "object" ? "" : String(W.value)) || W.operator || "");
            return te.length > 20 && (te = te.slice(0, 19) + "\u2026"), $ + (te ? " " + te : "");
          }
          s.exports = { inferParserByLanguage: H, getStringWidth: n, getMaxContinuousCount: C, getMinNotPresentContinuousCount: x, getPenultimate: E, getLast: i, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: m, getNextNonSpaceNonCommentCharacterIndex: _, getNextNonSpaceNonCommentCharacter: k, skip: P, skipWhitespace: a, skipSpaces: o, skipToLineEnd: D, skipEverythingButNewLine: F, skipInlineComment: h, skipTrailingComment: v, skipNewline: p, isNextLineEmptyAfterIndex: S, isNextLineEmpty: w, isPreviousLineEmpty: T, hasNewline: N, hasNewlineInRange: b, hasSpaces: A, getAlignmentSize: f, getIndentSize: d, getPreferredQuote: c, printString: r, printNumber: g, makeString: y, addLeadingComment: L, addDanglingComment: M, addTrailingComment: j, isFrontMatterNode: I, isNonEmptyArray: u, createGroupIdMapper: G };
        } }), Ci = {};
        li(Ci, { basename: () => Si, default: () => xi, delimiter: () => En, dirname: () => Ai, extname: () => bi, isAbsolute: () => Ln, join: () => vi, normalize: () => kn, relative: () => Fi, resolve: () => Er, sep: () => Cn });
        function Ei(e2, s) {
          for (var t = 0, i = e2.length - 1; i >= 0; i--) {
            var l = e2[i];
            l === "." ? e2.splice(i, 1) : l === ".." ? (e2.splice(i, 1), t++) : t && (e2.splice(i, 1), t--);
          }
          if (s)
            for (; t--; t)
              e2.unshift("..");
          return e2;
        }
        function Er() {
          for (var e2 = "", s = false, t = arguments.length - 1; t >= -1 && !s; t--) {
            var i = t >= 0 ? arguments[t] : "/";
            if (typeof i != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!i)
              continue;
            e2 = i + "/" + e2, s = i.charAt(0) === "/";
          }
          return e2 = Ei(On(e2.split("/"), function(l) {
            return !!l;
          }), !s).join("/"), (s ? "/" : "") + e2 || ".";
        }
        function kn(e2) {
          var s = Ln(e2), t = Ti(e2, -1) === "/";
          return e2 = Ei(On(e2.split("/"), function(i) {
            return !!i;
          }), !s).join("/"), !e2 && !s && (e2 = "."), e2 && t && (e2 += "/"), (s ? "/" : "") + e2;
        }
        function Ln(e2) {
          return e2.charAt(0) === "/";
        }
        function vi() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return kn(On(e2, function(s, t) {
            if (typeof s != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return s;
          }).join("/"));
        }
        function Fi(e2, s) {
          e2 = Er(e2).substr(1), s = Er(s).substr(1);
          function t(D) {
            for (var F = 0; F < D.length && D[F] === ""; F++)
              ;
            for (var h = D.length - 1; h >= 0 && D[h] === ""; h--)
              ;
            return F > h ? [] : D.slice(F, h - F + 1);
          }
          for (var i = t(e2.split("/")), l = t(s.split("/")), u = Math.min(i.length, l.length), n = u, a = 0; a < u; a++)
            if (i[a] !== l[a]) {
              n = a;
              break;
            }
          for (var o = [], a = n; a < i.length; a++)
            o.push("..");
          return o = o.concat(l.slice(n)), o.join("/");
        }
        function Ai(e2) {
          var s = Fr(e2), t = s[0], i = s[1];
          return !t && !i ? "." : (i && (i = i.substr(0, i.length - 1)), t + i);
        }
        function Si(e2, s) {
          var t = Fr(e2)[2];
          return s && t.substr(-1 * s.length) === s && (t = t.substr(0, t.length - s.length)), t;
        }
        function bi(e2) {
          return Fr(e2)[3];
        }
        function On(e2, s) {
          if (e2.filter)
            return e2.filter(s);
          for (var t = [], i = 0; i < e2.length; i++)
            s(e2[i], i, e2) && t.push(e2[i]);
          return t;
        }
        var ii, Fr, Cn, En, xi, Ti, fD = Tn({ "node-modules-polyfills:path"() {
          ae(), ii = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Fr = function(e2) {
            return ii.exec(e2).slice(1);
          }, Cn = "/", En = ":", xi = { extname: bi, basename: Si, dirname: Ai, sep: Cn, delimiter: En, relative: Fi, join: vi, isAbsolute: Ln, normalize: kn, resolve: Er }, Ti = "ab".substr(-1) === "b" ? function(e2, s, t) {
            return e2.substr(s, t);
          } : function(e2, s, t) {
            return s < 0 && (s = e2.length + s), e2.substr(s, t);
          };
        } }), Bi = ee({ "node-modules-polyfills-commonjs:path"(e2, s) {
          ae();
          var t = (fD(), pi(Ci));
          if (t && t.default) {
            s.exports = t.default;
            for (let i in t)
              s.exports[i] = t[i];
          } else
            t && (s.exports = t);
        } }), $t = ee({ "src/common/errors.js"(e2, s) {
          "use strict";
          ae();
          var t = class extends Error {
          }, i = class extends Error {
          }, l = class extends Error {
          }, u = class extends Error {
          };
          s.exports = { ConfigError: t, DebugError: i, UndefinedParserError: l, ArgExpansionBailout: u };
        } }), dt = ee({ "node_modules/tslib/tslib.js"(e2, s) {
          ae();
          var t, i, l, u, n, a, o, D, F, h, v, p, m, E, P, N, b, T, S, w, _, k, A;
          (function(f) {
            var d = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof this == "object" ? this : {};
            typeof define == "function" && define.amd ? define("tslib", ["exports"], function(r) {
              f(c({}, c(r)));
            }) : typeof s == "object" && typeof s.exports == "object" ? f(c({}, c(s.exports))) : f(c({}));
            function c(r, y) {
              return r !== d && (typeof Object.create == "function" ? Object.defineProperty(r, "__esModule", { value: true }) : r.__esModule = true), function(g, C) {
                return r[g] = y ? y(g, C) : C;
              };
            }
          })(function(f) {
            var d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, r) {
              c.__proto__ = r;
            } || function(c, r) {
              for (var y in r)
                r.hasOwnProperty(y) && (c[y] = r[y]);
            };
            t = function(c, r) {
              d(c, r);
              function y() {
                this.constructor = c;
              }
              c.prototype = r === null ? Object.create(r) : (y.prototype = r.prototype, new y());
            }, i = Object.assign || function(c) {
              for (var r, y = 1, g = arguments.length; y < g; y++) {
                r = arguments[y];
                for (var C in r)
                  Object.prototype.hasOwnProperty.call(r, C) && (c[C] = r[C]);
              }
              return c;
            }, l = function(c, r) {
              var y = {};
              for (var g in c)
                Object.prototype.hasOwnProperty.call(c, g) && r.indexOf(g) < 0 && (y[g] = c[g]);
              if (c != null && typeof Object.getOwnPropertySymbols == "function")
                for (var C = 0, g = Object.getOwnPropertySymbols(c); C < g.length; C++)
                  r.indexOf(g[C]) < 0 && Object.prototype.propertyIsEnumerable.call(c, g[C]) && (y[g[C]] = c[g[C]]);
              return y;
            }, u = function(c, r, y, g) {
              var C = arguments.length, x = C < 3 ? r : g === null ? g = Object.getOwnPropertyDescriptor(r, y) : g, B;
              if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
                x = Reflect.decorate(c, r, y, g);
              else
                for (var L = c.length - 1; L >= 0; L--)
                  (B = c[L]) && (x = (C < 3 ? B(x) : C > 3 ? B(r, y, x) : B(r, y)) || x);
              return C > 3 && x && Object.defineProperty(r, y, x), x;
            }, n = function(c, r) {
              return function(y, g) {
                r(y, g, c);
              };
            }, a = function(c, r) {
              if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
                return Reflect.metadata(c, r);
            }, o = function(c, r, y, g) {
              function C(x) {
                return x instanceof y ? x : new y(function(B) {
                  B(x);
                });
              }
              return new (y || (y = Promise))(function(x, B) {
                function L(H) {
                  try {
                    j(g.next(H));
                  } catch (I) {
                    B(I);
                  }
                }
                function M(H) {
                  try {
                    j(g.throw(H));
                  } catch (I) {
                    B(I);
                  }
                }
                function j(H) {
                  H.done ? x(H.value) : C(H.value).then(L, M);
                }
                j((g = g.apply(c, r || [])).next());
              });
            }, D = function(c, r) {
              var y = { label: 0, sent: function() {
                if (x[0] & 1)
                  throw x[1];
                return x[1];
              }, trys: [], ops: [] }, g, C, x, B;
              return B = { next: L(0), throw: L(1), return: L(2) }, typeof Symbol == "function" && (B[Symbol.iterator] = function() {
                return this;
              }), B;
              function L(j) {
                return function(H) {
                  return M([j, H]);
                };
              }
              function M(j) {
                if (g)
                  throw new TypeError("Generator is already executing.");
                for (; y; )
                  try {
                    if (g = 1, C && (x = j[0] & 2 ? C.return : j[0] ? C.throw || ((x = C.return) && x.call(C), 0) : C.next) && !(x = x.call(C, j[1])).done)
                      return x;
                    switch (C = 0, x && (j = [j[0] & 2, x.value]), j[0]) {
                      case 0:
                      case 1:
                        x = j;
                        break;
                      case 4:
                        return y.label++, { value: j[1], done: false };
                      case 5:
                        y.label++, C = j[1], j = [0];
                        continue;
                      case 7:
                        j = y.ops.pop(), y.trys.pop();
                        continue;
                      default:
                        if (x = y.trys, !(x = x.length > 0 && x[x.length - 1]) && (j[0] === 6 || j[0] === 2)) {
                          y = 0;
                          continue;
                        }
                        if (j[0] === 3 && (!x || j[1] > x[0] && j[1] < x[3])) {
                          y.label = j[1];
                          break;
                        }
                        if (j[0] === 6 && y.label < x[1]) {
                          y.label = x[1], x = j;
                          break;
                        }
                        if (x && y.label < x[2]) {
                          y.label = x[2], y.ops.push(j);
                          break;
                        }
                        x[2] && y.ops.pop(), y.trys.pop();
                        continue;
                    }
                    j = r.call(c, y);
                  } catch (H) {
                    j = [6, H], C = 0;
                  } finally {
                    g = x = 0;
                  }
                if (j[0] & 5)
                  throw j[1];
                return { value: j[0] ? j[1] : void 0, done: true };
              }
            }, A = function(c, r, y, g) {
              g === void 0 && (g = y), c[g] = r[y];
            }, F = function(c, r) {
              for (var y in c)
                y !== "default" && !r.hasOwnProperty(y) && (r[y] = c[y]);
            }, h = function(c) {
              var r = typeof Symbol == "function" && Symbol.iterator, y = r && c[r], g = 0;
              if (y)
                return y.call(c);
              if (c && typeof c.length == "number")
                return { next: function() {
                  return c && g >= c.length && (c = void 0), { value: c && c[g++], done: !c };
                } };
              throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }, v = function(c, r) {
              var y = typeof Symbol == "function" && c[Symbol.iterator];
              if (!y)
                return c;
              var g = y.call(c), C, x = [], B;
              try {
                for (; (r === void 0 || r-- > 0) && !(C = g.next()).done; )
                  x.push(C.value);
              } catch (L) {
                B = { error: L };
              } finally {
                try {
                  C && !C.done && (y = g.return) && y.call(g);
                } finally {
                  if (B)
                    throw B.error;
                }
              }
              return x;
            }, p = function() {
              for (var c = [], r = 0; r < arguments.length; r++)
                c = c.concat(v(arguments[r]));
              return c;
            }, m = function() {
              for (var c = 0, r = 0, y = arguments.length; r < y; r++)
                c += arguments[r].length;
              for (var g = Array(c), C = 0, r = 0; r < y; r++)
                for (var x = arguments[r], B = 0, L = x.length; B < L; B++, C++)
                  g[C] = x[B];
              return g;
            }, E = function(c) {
              return this instanceof E ? (this.v = c, this) : new E(c);
            }, P = function(c, r, y) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var g = y.apply(c, r || []), C, x = [];
              return C = {}, B("next"), B("throw"), B("return"), C[Symbol.asyncIterator] = function() {
                return this;
              }, C;
              function B(G) {
                g[G] && (C[G] = function(Z) {
                  return new Promise(function(W, $) {
                    x.push([G, Z, W, $]) > 1 || L(G, Z);
                  });
                });
              }
              function L(G, Z) {
                try {
                  M(g[G](Z));
                } catch (W) {
                  I(x[0][3], W);
                }
              }
              function M(G) {
                G.value instanceof E ? Promise.resolve(G.value.v).then(j, H) : I(x[0][2], G);
              }
              function j(G) {
                L("next", G);
              }
              function H(G) {
                L("throw", G);
              }
              function I(G, Z) {
                G(Z), x.shift(), x.length && L(x[0][0], x[0][1]);
              }
            }, N = function(c) {
              var r, y;
              return r = {}, g("next"), g("throw", function(C) {
                throw C;
              }), g("return"), r[Symbol.iterator] = function() {
                return this;
              }, r;
              function g(C, x) {
                r[C] = c[C] ? function(B) {
                  return (y = !y) ? { value: E(c[C](B)), done: C === "return" } : x ? x(B) : B;
                } : x;
              }
            }, b = function(c) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var r = c[Symbol.asyncIterator], y;
              return r ? r.call(c) : (c = typeof h == "function" ? h(c) : c[Symbol.iterator](), y = {}, g("next"), g("throw"), g("return"), y[Symbol.asyncIterator] = function() {
                return this;
              }, y);
              function g(x) {
                y[x] = c[x] && function(B) {
                  return new Promise(function(L, M) {
                    B = c[x](B), C(L, M, B.done, B.value);
                  });
                };
              }
              function C(x, B, L, M) {
                Promise.resolve(M).then(function(j) {
                  x({ value: j, done: L });
                }, B);
              }
            }, T = function(c, r) {
              return Object.defineProperty ? Object.defineProperty(c, "raw", { value: r }) : c.raw = r, c;
            }, S = function(c) {
              if (c && c.__esModule)
                return c;
              var r = {};
              if (c != null)
                for (var y in c)
                  Object.hasOwnProperty.call(c, y) && (r[y] = c[y]);
              return r.default = c, r;
            }, w = function(c) {
              return c && c.__esModule ? c : { default: c };
            }, _ = function(c, r) {
              if (!r.has(c))
                throw new TypeError("attempted to get private field on non-instance");
              return r.get(c);
            }, k = function(c, r, y) {
              if (!r.has(c))
                throw new TypeError("attempted to set private field on non-instance");
              return r.set(c, y), y;
            }, f("__extends", t), f("__assign", i), f("__rest", l), f("__decorate", u), f("__param", n), f("__metadata", a), f("__awaiter", o), f("__generator", D), f("__exportStar", F), f("__createBinding", A), f("__values", h), f("__read", v), f("__spread", p), f("__spreadArrays", m), f("__await", E), f("__asyncGenerator", P), f("__asyncDelegator", N), f("__asyncValues", b), f("__makeTemplateObject", T), f("__importStar", S), f("__importDefault", w), f("__classPrivateFieldGet", _), f("__classPrivateFieldSet", k);
          });
        } }), Ni = ee({ "node_modules/vnopts/lib/descriptors/api.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.apiDescriptor = { key: (s) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(s) ? s : JSON.stringify(s), value(s) {
            if (s === null || typeof s != "object")
              return JSON.stringify(s);
            if (Array.isArray(s))
              return "[".concat(s.map((i) => e2.apiDescriptor.value(i)).join(", "), "]");
            let t = Object.keys(s);
            return t.length === 0 ? "{}" : "{ ".concat(t.map((i) => "".concat(e2.apiDescriptor.key(i), ": ").concat(e2.apiDescriptor.value(s[i]))).join(", "), " }");
          }, pair: (s) => {
            let { key: t, value: i } = s;
            return e2.apiDescriptor.value({ [t]: i });
          } };
        } }), DD = ee({ "node_modules/vnopts/lib/descriptors/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(Ni(), e2);
        } }), Ar = ee({ "scripts/build/shims/chalk.cjs"(e2, s) {
          "use strict";
          ae();
          var t = (i) => i;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, s.exports = t;
        } }), wi = ee({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = Ar();
          e2.commonDeprecatedHandler = (t, i, l) => {
            let { descriptor: u } = l, n = ["".concat(s.default.yellow(typeof t == "string" ? u.key(t) : u.pair(t)), " is deprecated")];
            return i && n.push("we now treat it as ".concat(s.default.blue(typeof i == "string" ? u.key(i) : u.pair(i)))), n.join("; ") + ".";
          };
        } }), mD = ee({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(wi(), e2);
        } }), dD = ee({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = Ar();
          e2.commonInvalidHandler = (t, i, l) => ["Invalid ".concat(s.default.red(l.descriptor.key(t)), " value."), "Expected ".concat(s.default.blue(l.schemas[t].expected(l)), ","), "but received ".concat(s.default.red(l.descriptor.value(i)), ".")].join(" ");
        } }), Pi = ee({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(dD(), e2);
        } }), gD = ee({ "node_modules/vnopts/node_modules/leven/index.js"(e2, s) {
          "use strict";
          ae();
          var t = [], i = [];
          s.exports = function(l, u) {
            if (l === u)
              return 0;
            var n = l;
            l.length > u.length && (l = u, u = n);
            var a = l.length, o = u.length;
            if (a === 0)
              return o;
            if (o === 0)
              return a;
            for (; a > 0 && l.charCodeAt(~-a) === u.charCodeAt(~-o); )
              a--, o--;
            if (a === 0)
              return o;
            for (var D = 0; D < a && l.charCodeAt(D) === u.charCodeAt(D); )
              D++;
            if (a -= D, o -= D, a === 0)
              return o;
            for (var F, h, v, p, m = 0, E = 0; m < a; )
              i[D + m] = l.charCodeAt(D + m), t[m] = ++m;
            for (; E < o; )
              for (F = u.charCodeAt(D + E), v = E++, h = E, m = 0; m < a; m++)
                p = F === i[D + m] ? v : v + 1, v = t[m], h = t[m] = v > h ? p > h ? h + 1 : p : p > v ? v + 1 : p;
            return h;
          };
        } }), _i = ee({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = Ar(), t = gD();
          e2.levenUnknownHandler = (i, l, u) => {
            let { descriptor: n, logger: a, schemas: o } = u, D = ["Ignored unknown option ".concat(s.default.yellow(n.pair({ key: i, value: l })), ".")], F = Object.keys(o).sort().find((h) => t(i, h) < 3);
            F && D.push("Did you mean ".concat(s.default.blue(n.key(F)), "?")), a.warn(D.join(" "));
          };
        } }), yD = ee({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(_i(), e2);
        } }), hD = ee({ "node_modules/vnopts/lib/handlers/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(mD(), e2), s.__exportStar(Pi(), e2), s.__exportStar(yD(), e2);
        } }), gt = ee({ "node_modules/vnopts/lib/schema.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(u, n) {
            let a = new u(n), o = Object.create(a);
            for (let D of s)
              D in n && (o[D] = l(n[D], a, i.prototype[D].length));
            return o;
          }
          e2.createSchema = t;
          var i = class {
            constructor(u) {
              this.name = u.name;
            }
            static create(u) {
              return t(this, u);
            }
            default(u) {
            }
            expected(u) {
              return "nothing";
            }
            validate(u, n) {
              return false;
            }
            deprecated(u, n) {
              return false;
            }
            forward(u, n) {
            }
            redirect(u, n) {
            }
            overlap(u, n, a) {
              return u;
            }
            preprocess(u, n) {
              return u;
            }
            postprocess(u, n) {
              return u;
            }
          };
          e2.Schema = i;
          function l(u, n, a) {
            return typeof u == "function" ? function() {
              for (var o = arguments.length, D = new Array(o), F = 0; F < o; F++)
                D[F] = arguments[F];
              return u(...D.slice(0, a - 1), n, ...D.slice(a - 1));
            } : () => u;
          }
        } }), CD = ee({ "node_modules/vnopts/lib/schemas/alias.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = class extends s.Schema {
            constructor(i) {
              super(i);
              this._sourceName = i.sourceName;
            }
            expected(i) {
              return i.schemas[this._sourceName].expected(i);
            }
            validate(i, l) {
              return l.schemas[this._sourceName].validate(i, l);
            }
            redirect(i, l) {
              return this._sourceName;
            }
          };
          e2.AliasSchema = t;
        } }), ED = ee({ "node_modules/vnopts/lib/schemas/any.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = class extends s.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e2.AnySchema = t;
        } }), vD = ee({ "node_modules/vnopts/lib/schemas/array.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt(), t = gt(), i = class extends t.Schema {
            constructor(u) {
              var { valueSchema: n, name: a = n.name } = u, o = s.__rest(u, ["valueSchema", "name"]);
              super(Object.assign({}, o, { name: a }));
              this._valueSchema = n;
            }
            expected(u) {
              return "an array of ".concat(this._valueSchema.expected(u));
            }
            validate(u, n) {
              if (!Array.isArray(u))
                return false;
              let a = [];
              for (let o of u) {
                let D = n.normalizeValidateResult(this._valueSchema.validate(o, n), o);
                D !== true && a.push(D.value);
              }
              return a.length === 0 ? true : { value: a };
            }
            deprecated(u, n) {
              let a = [];
              for (let o of u) {
                let D = n.normalizeDeprecatedResult(this._valueSchema.deprecated(o, n), o);
                D !== false && a.push(...D.map((F) => {
                  let { value: h } = F;
                  return { value: [h] };
                }));
              }
              return a;
            }
            forward(u, n) {
              let a = [];
              for (let o of u) {
                let D = n.normalizeForwardResult(this._valueSchema.forward(o, n), o);
                a.push(...D.map(l));
              }
              return a;
            }
            redirect(u, n) {
              let a = [], o = [];
              for (let D of u) {
                let F = n.normalizeRedirectResult(this._valueSchema.redirect(D, n), D);
                "remain" in F && a.push(F.remain), o.push(...F.redirect.map(l));
              }
              return a.length === 0 ? { redirect: o } : { redirect: o, remain: a };
            }
            overlap(u, n) {
              return u.concat(n);
            }
          };
          e2.ArraySchema = i;
          function l(u) {
            let { from: n, to: a } = u;
            return { from: [n], to: a };
          }
        } }), FD = ee({ "node_modules/vnopts/lib/schemas/boolean.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = class extends s.Schema {
            expected() {
              return "true or false";
            }
            validate(i) {
              return typeof i == "boolean";
            }
          };
          e2.BooleanSchema = t;
        } }), jn = ee({ "node_modules/vnopts/lib/utils.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          function s(p, m) {
            let E = /* @__PURE__ */ Object.create(null);
            for (let P of p) {
              let N = P[m];
              if (E[N])
                throw new Error("Duplicate ".concat(m, " ").concat(JSON.stringify(N)));
              E[N] = P;
            }
            return E;
          }
          e2.recordFromArray = s;
          function t(p, m) {
            let E = /* @__PURE__ */ new Map();
            for (let P of p) {
              let N = P[m];
              if (E.has(N))
                throw new Error("Duplicate ".concat(m, " ").concat(JSON.stringify(N)));
              E.set(N, P);
            }
            return E;
          }
          e2.mapFromArray = t;
          function i() {
            let p = /* @__PURE__ */ Object.create(null);
            return (m) => {
              let E = JSON.stringify(m);
              return p[E] ? true : (p[E] = true, false);
            };
          }
          e2.createAutoChecklist = i;
          function l(p, m) {
            let E = [], P = [];
            for (let N of p)
              m(N) ? E.push(N) : P.push(N);
            return [E, P];
          }
          e2.partition = l;
          function u(p) {
            return p === Math.floor(p);
          }
          e2.isInt = u;
          function n(p, m) {
            if (p === m)
              return 0;
            let E = typeof p, P = typeof m, N = ["undefined", "object", "boolean", "number", "string"];
            return E !== P ? N.indexOf(E) - N.indexOf(P) : E !== "string" ? Number(p) - Number(m) : p.localeCompare(m);
          }
          e2.comparePrimitive = n;
          function a(p) {
            return p === void 0 ? {} : p;
          }
          e2.normalizeDefaultResult = a;
          function o(p, m) {
            return p === true ? true : p === false ? { value: m } : p;
          }
          e2.normalizeValidateResult = o;
          function D(p, m) {
            let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return p === false ? false : p === true ? E ? true : [{ value: m }] : "value" in p ? [p] : p.length === 0 ? false : p;
          }
          e2.normalizeDeprecatedResult = D;
          function F(p, m) {
            return typeof p == "string" || "key" in p ? { from: m, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: m, to: p.to };
          }
          e2.normalizeTransferResult = F;
          function h(p, m) {
            return p === void 0 ? [] : Array.isArray(p) ? p.map((E) => F(E, m)) : [F(p, m)];
          }
          e2.normalizeForwardResult = h;
          function v(p, m) {
            let E = h(typeof p == "object" && "redirect" in p ? p.redirect : p, m);
            return E.length === 0 ? { remain: m, redirect: E } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: E } : { redirect: E };
          }
          e2.normalizeRedirectResult = v;
        } }), AD = ee({ "node_modules/vnopts/lib/schemas/choice.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = jn(), i = class extends s.Schema {
            constructor(l) {
              super(l);
              this._choices = t.mapFromArray(l.choices.map((u) => u && typeof u == "object" ? u : { value: u }), "value");
            }
            expected(l) {
              let { descriptor: u } = l, n = Array.from(this._choices.keys()).map((D) => this._choices.get(D)).filter((D) => !D.deprecated).map((D) => D.value).sort(t.comparePrimitive).map(u.value), a = n.slice(0, -2), o = n.slice(-2);
              return a.concat(o.join(" or ")).join(", ");
            }
            validate(l) {
              return this._choices.has(l);
            }
            deprecated(l) {
              let u = this._choices.get(l);
              return u && u.deprecated ? { value: l } : false;
            }
            forward(l) {
              let u = this._choices.get(l);
              return u ? u.forward : void 0;
            }
            redirect(l) {
              let u = this._choices.get(l);
              return u ? u.redirect : void 0;
            }
          };
          e2.ChoiceSchema = i;
        } }), Ii = ee({ "node_modules/vnopts/lib/schemas/number.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = class extends s.Schema {
            expected() {
              return "a number";
            }
            validate(i, l) {
              return typeof i == "number";
            }
          };
          e2.NumberSchema = t;
        } }), SD = ee({ "node_modules/vnopts/lib/schemas/integer.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = jn(), t = Ii(), i = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(l, u) {
              return u.normalizeValidateResult(super.validate(l, u), l) === true && s.isInt(l);
            }
          };
          e2.IntegerSchema = i;
        } }), bD = ee({ "node_modules/vnopts/lib/schemas/string.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = gt(), t = class extends s.Schema {
            expected() {
              return "a string";
            }
            validate(i) {
              return typeof i == "string";
            }
          };
          e2.StringSchema = t;
        } }), xD = ee({ "node_modules/vnopts/lib/schemas/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(CD(), e2), s.__exportStar(ED(), e2), s.__exportStar(vD(), e2), s.__exportStar(FD(), e2), s.__exportStar(AD(), e2), s.__exportStar(SD(), e2), s.__exportStar(Ii(), e2), s.__exportStar(bD(), e2);
        } }), TD = ee({ "node_modules/vnopts/lib/defaults.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = Ni(), t = wi(), i = Pi(), l = _i();
          e2.defaultDescriptor = s.apiDescriptor, e2.defaultUnknownHandler = l.levenUnknownHandler, e2.defaultInvalidHandler = i.commonInvalidHandler, e2.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), BD = ee({ "node_modules/vnopts/lib/normalize.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = TD(), t = jn();
          e2.normalize = (l, u, n) => new i(u, n).normalize(l);
          var i = class {
            constructor(l, u) {
              let { logger: n = console, descriptor: a = s.defaultDescriptor, unknown: o = s.defaultUnknownHandler, invalid: D = s.defaultInvalidHandler, deprecated: F = s.defaultDeprecatedHandler } = u || {};
              this._utils = { descriptor: a, logger: n || { warn: () => {
              } }, schemas: t.recordFromArray(l, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = D, this._deprecatedHandler = F, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(l) {
              let u = {}, n = [l], a = () => {
                for (; n.length !== 0; ) {
                  let o = n.shift(), D = this._applyNormalization(o, u);
                  n.push(...D);
                }
              };
              a();
              for (let o of Object.keys(this._utils.schemas)) {
                let D = this._utils.schemas[o];
                if (!(o in u)) {
                  let F = t.normalizeDefaultResult(D.default(this._utils));
                  "value" in F && n.push({ [o]: F.value });
                }
              }
              a();
              for (let o of Object.keys(this._utils.schemas)) {
                let D = this._utils.schemas[o];
                o in u && (u[o] = D.postprocess(u[o], this._utils));
              }
              return u;
            }
            _applyNormalization(l, u) {
              let n = [], [a, o] = t.partition(Object.keys(l), (D) => D in this._utils.schemas);
              for (let D of a) {
                let F = this._utils.schemas[D], h = F.preprocess(l[D], this._utils), v = t.normalizeValidateResult(F.validate(h, this._utils), h);
                if (v !== true) {
                  let { value: N } = v, b = this._invalidHandler(D, N, this._utils);
                  throw typeof b == "string" ? new Error(b) : b;
                }
                let p = (N) => {
                  let { from: b, to: T } = N;
                  n.push(typeof T == "string" ? { [T]: b } : { [T.key]: T.value });
                }, m = (N) => {
                  let { value: b, redirectTo: T } = N, S = t.normalizeDeprecatedResult(F.deprecated(b, this._utils), h, true);
                  if (S !== false)
                    if (S === true)
                      this._hasDeprecationWarned(D) || this._utils.logger.warn(this._deprecatedHandler(D, T, this._utils));
                    else
                      for (let { value: w } of S) {
                        let _ = { key: D, value: w };
                        if (!this._hasDeprecationWarned(_)) {
                          let k = typeof T == "string" ? { key: T, value: w } : T;
                          this._utils.logger.warn(this._deprecatedHandler(_, k, this._utils));
                        }
                      }
                };
                t.normalizeForwardResult(F.forward(h, this._utils), h).forEach(p);
                let P = t.normalizeRedirectResult(F.redirect(h, this._utils), h);
                if (P.redirect.forEach(p), "remain" in P) {
                  let N = P.remain;
                  u[D] = D in u ? F.overlap(u[D], N, this._utils) : N, m({ value: N });
                }
                for (let { from: N, to: b } of P.redirect)
                  m({ value: N, redirectTo: b });
              }
              for (let D of o) {
                let F = l[D], h = this._unknownHandler(D, F, this._utils);
                if (h)
                  for (let v of Object.keys(h)) {
                    let p = { [v]: h[v] };
                    v in this._utils.schemas ? n.push(p) : Object.assign(u, p);
                  }
              }
              return n;
            }
          };
          e2.Normalizer = i;
        } }), ND = ee({ "node_modules/vnopts/lib/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = dt();
          s.__exportStar(DD(), e2), s.__exportStar(hD(), e2), s.__exportStar(xD(), e2), s.__exportStar(BD(), e2), s.__exportStar(gt(), e2);
        } }), wD = ee({ "src/main/options-normalizer.js"(e2, s) {
          "use strict";
          ae();
          var t = ND(), i = st(), l = { key: (v) => v.length === 1 ? "-".concat(v) : "--".concat(v), value: (v) => t.apiDescriptor.value(v), pair: (v) => {
            let { key: p, value: m } = v;
            return m === false ? "--no-".concat(p) : m === true ? l.key(p) : m === "" ? "".concat(l.key(p), " without an argument") : "".concat(l.key(p), "=").concat(m);
          } }, u = (v) => {
            let { colorsModule: p, levenshteinDistance: m } = v;
            return class extends t.ChoiceSchema {
              constructor(P) {
                let { name: N, flags: b } = P;
                super({ name: N, choices: b });
                this._flags = [...b].sort();
              }
              preprocess(P, N) {
                if (typeof P == "string" && P.length > 0 && !this._flags.includes(P)) {
                  let b = this._flags.find((T) => m(T, P) < 3);
                  if (b)
                    return N.logger.warn(["Unknown flag ".concat(p.yellow(N.descriptor.value(P)), ","), "did you mean ".concat(p.blue(N.descriptor.value(b)), "?")].join(" ")), b;
                }
                return P;
              }
              expected() {
                return "a flag";
              }
            };
          }, n;
          function a(v, p) {
            let { logger: m, isCLI: E = false, passThrough: P = false, colorsModule: N, levenshteinDistance: b } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, T = P ? Array.isArray(P) ? (f, d) => P.includes(f) ? { [f]: d } : void 0 : (f, d) => ({ [f]: d }) : (f, d, c) => {
              let r = c.schemas, { _: y } = r, g = Sn(r, Hf);
              return t.levenUnknownHandler(f, d, Object.assign(Object.assign({}, c), {}, { schemas: g }));
            }, S = E ? l : t.apiDescriptor, w = o(p, { isCLI: E, colorsModule: N, levenshteinDistance: b }), _ = new t.Normalizer(w, { logger: m, unknown: T, descriptor: S }), k = m !== false;
            k && n && (_._hasDeprecationWarned = n);
            let A = _.normalize(v);
            return k && (n = _._hasDeprecationWarned), E && A["plugin-search"] === false && (A["plugin-search-dir"] = false), A;
          }
          function o(v, p) {
            let { isCLI: m, colorsModule: E, levenshteinDistance: P } = p, N = [];
            m && N.push(t.AnySchema.create({ name: "_" }));
            for (let b of v)
              N.push(D(b, { isCLI: m, optionInfos: v, colorsModule: E, levenshteinDistance: P })), b.alias && m && N.push(t.AliasSchema.create({ name: b.alias, sourceName: b.name }));
            return N;
          }
          function D(v, p) {
            let { isCLI: m, optionInfos: E, colorsModule: P, levenshteinDistance: N } = p, { name: b } = v;
            if (b === "plugin-search-dir" || b === "pluginSearchDirs")
              return t.AnySchema.create({ name: b, preprocess(_) {
                return _ === false || (_ = Array.isArray(_) ? _ : [_]), _;
              }, validate(_) {
                return _ === false ? true : _.every((k) => typeof k == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let T = { name: b }, S, w = {};
            switch (v.type) {
              case "int":
                S = t.IntegerSchema, m && (T.preprocess = (_) => Number(_));
                break;
              case "string":
                S = t.StringSchema;
                break;
              case "choice":
                S = t.ChoiceSchema, T.choices = v.choices.map((_) => typeof _ == "object" && _.redirect ? Object.assign(Object.assign({}, _), {}, { redirect: { to: { key: v.name, value: _.redirect } } }) : _);
                break;
              case "boolean":
                S = t.BooleanSchema;
                break;
              case "flag":
                S = u({ colorsModule: P, levenshteinDistance: N }), T.flags = E.flatMap((_) => [_.alias, _.description && _.name, _.oppositeDescription && "no-".concat(_.name)].filter(Boolean));
                break;
              case "path":
                S = t.StringSchema;
                break;
              default:
                throw new Error("Unexpected type ".concat(v.type));
            }
            if (v.exception ? T.validate = (_, k, A) => v.exception(_) || k.validate(_, A) : T.validate = (_, k, A) => _ === void 0 || k.validate(_, A), v.redirect && (w.redirect = (_) => _ ? { to: { key: v.redirect.option, value: v.redirect.value } } : void 0), v.deprecated && (w.deprecated = true), m && !v.array) {
              let _ = T.preprocess || ((k) => k);
              T.preprocess = (k, A, f) => A.preprocess(_(Array.isArray(k) ? i(k) : k), f);
            }
            return v.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, m ? { preprocess: (_) => Array.isArray(_) ? _ : [_] } : {}), w), {}, { valueSchema: S.create(T) })) : S.create(Object.assign(Object.assign({}, T), w));
          }
          function F(v, p, m) {
            return a(v, p, m);
          }
          function h(v, p, m) {
            return a(v, p, Object.assign({ isCLI: true }, m));
          }
          s.exports = { normalizeApiOptions: F, normalizeCliOptions: h };
        } }), nt = ee({ "src/language-js/loc.js"(e2, s) {
          "use strict";
          ae();
          var t = In();
          function i(o, D) {
            let { ignoreDecorators: F } = D || {};
            if (!F) {
              let h = o.declaration && o.declaration.decorators || o.decorators;
              if (t(h))
                return i(h[0]);
            }
            return o.range ? o.range[0] : o.start;
          }
          function l(o) {
            return o.range ? o.range[1] : o.end;
          }
          function u(o, D) {
            let F = i(o);
            return Number.isInteger(F) && F === i(D);
          }
          function n(o, D) {
            let F = l(o);
            return Number.isInteger(F) && F === l(D);
          }
          function a(o, D) {
            return u(o, D) && n(o, D);
          }
          s.exports = { locStart: i, locEnd: l, hasSameLocStart: u, hasSameLoc: a };
        } }), PD = ee({ "scripts/build/shims/babel-highlight.cjs"(e2, s) {
          "use strict";
          ae();
          var t = Ar(), i = { shouldHighlight: () => false, getChalk: () => t };
          s.exports = i;
        } }), _D = ee({ "node_modules/@babel/code-frame/lib/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.codeFrameColumns = n, e2.default = a;
          var s = PD(), t = false;
          function i(o) {
            return { gutter: o.grey, marker: o.red.bold, message: o.red.bold };
          }
          var l = /\r\n|[\n\r\u2028\u2029]/;
          function u(o, D, F) {
            let h = Object.assign({ column: 0, line: -1 }, o.start), v = Object.assign({}, h, o.end), { linesAbove: p = 2, linesBelow: m = 3 } = F || {}, E = h.line, P = h.column, N = v.line, b = v.column, T = Math.max(E - (p + 1), 0), S = Math.min(D.length, N + m);
            E === -1 && (T = 0), N === -1 && (S = D.length);
            let w = N - E, _ = {};
            if (w)
              for (let k = 0; k <= w; k++) {
                let A = k + E;
                if (!P)
                  _[A] = true;
                else if (k === 0) {
                  let f = D[A - 1].length;
                  _[A] = [P, f - P + 1];
                } else if (k === w)
                  _[A] = [0, b];
                else {
                  let f = D[A - k].length;
                  _[A] = [0, f];
                }
              }
            else
              P === b ? P ? _[E] = [P, 0] : _[E] = true : _[E] = [P, b - P];
            return { start: T, end: S, markerLines: _ };
          }
          function n(o, D) {
            let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (F.highlightCode || F.forceColor) && (0, s.shouldHighlight)(F), v = (0, s.getChalk)(F), p = i(v), m = (k, A) => h ? k(A) : A, E = o.split(l), { start: P, end: N, markerLines: b } = u(D, E, F), T = D.start && typeof D.start.column == "number", S = String(N).length, _ = (h ? (0, s.default)(o, F) : o).split(l, N).slice(P, N).map((k, A) => {
              let f = P + 1 + A, d = " ".concat(f).slice(-S), c = " ".concat(d, " |"), r = b[f], y = !b[f + 1];
              if (r) {
                let g = "";
                if (Array.isArray(r)) {
                  let C = k.slice(0, Math.max(r[0] - 1, 0)).replace(/[^\t]/g, " "), x = r[1] || 1;
                  g = [`
 `, m(p.gutter, c.replace(/\d/g, " ")), " ", C, m(p.marker, "^").repeat(x)].join(""), y && F.message && (g += " " + m(p.message, F.message));
                }
                return [m(p.marker, ">"), m(p.gutter, c), k.length > 0 ? " ".concat(k) : "", g].join("");
              } else
                return " ".concat(m(p.gutter, c)).concat(k.length > 0 ? " ".concat(k) : "");
            }).join(`
`);
            return F.message && !T && (_ = "".concat(" ".repeat(S + 1)).concat(F.message, `
`).concat(_)), h ? v.reset(_) : _;
          }
          function a(o, D, F) {
            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (mt.emitWarning)
                mt.emitWarning(p, "DeprecationWarning");
              else {
                let m = new Error(p);
                m.name = "DeprecationWarning", console.warn(new Error(p));
              }
            }
            return F = Math.max(F, 0), n(o, { start: { column: F, line: D } }, h);
          }
        } }), qn = ee({ "src/main/parser.js"(e2, s) {
          "use strict";
          ae();
          var t = Bi(), { ConfigError: i } = $t(), l = nt(), { locStart: u, locEnd: n } = l, a = Object.getOwnPropertyNames, o = Object.getOwnPropertyDescriptor;
          function D(v) {
            let p = {};
            for (let m of v.plugins)
              if (!!m.parsers)
                for (let E of a(m.parsers))
                  Object.defineProperty(p, E, o(m.parsers, E));
            return p;
          }
          function F(v) {
            let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : D(v);
            if (typeof v.parser == "function")
              return { parse: v.parser, astFormat: "estree", locStart: u, locEnd: n };
            if (typeof v.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p, v.parser))
                return p[v.parser];
              throw new i(`Couldn't resolve parser "`.concat(v.parser, '". Parsers must be explicitly added to the standalone bundle.'));
              try {
                return { parse: Xn(t.resolve(mt.cwd(), v.parser)), astFormat: "estree", locStart: u, locEnd: n };
              } catch {
                throw new i(`Couldn't resolve parser "`.concat(v.parser, '"'));
              }
            }
          }
          function h(v, p) {
            let m = D(p), E = Object.defineProperties({}, Object.fromEntries(Object.keys(m).map((N) => [N, { enumerable: true, get() {
              return m[N].parse;
            } }]))), P = F(p, m);
            try {
              return P.preprocess && (v = P.preprocess(v, p)), { text: v, ast: P.parse(v, E, p) };
            } catch (N) {
              let { loc: b } = N;
              if (b) {
                let { codeFrameColumns: T } = _D();
                throw N.codeFrame = T(v, b, { highlightCode: true }), N.message += `
` + N.codeFrame, N;
              }
              throw N.stack;
            }
          }
          s.exports = { parse: h, resolveParser: F };
        } }), ki = ee({ "src/main/options.js"(e2, s) {
          "use strict";
          ae();
          var t = Bi(), { UndefinedParserError: i } = $t(), { getSupportInfo: l } = _n(), u = wD(), { resolveParser: n } = qn(), a = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function o(h) {
            let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, h), m = l({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, E = Object.assign(Object.assign({}, a), Object.fromEntries(m.filter((S) => S.default !== void 0).map((S) => [S.name, S.default])));
            if (!p.parser) {
              if (!p.filepath)
                (v.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
              else if (p.parser = F(p.filepath, p.plugins), !p.parser)
                throw new i("No parser could be inferred for file: ".concat(p.filepath));
            }
            let P = n(u.normalizeApiOptions(p, [m.find((S) => S.name === "parser")], { passThrough: true, logger: false }));
            p.astFormat = P.astFormat, p.locEnd = P.locEnd, p.locStart = P.locStart;
            let N = D(p);
            p.printer = N.printers[p.astFormat];
            let b = Object.fromEntries(m.filter((S) => S.pluginDefaults && S.pluginDefaults[N.name] !== void 0).map((S) => [S.name, S.pluginDefaults[N.name]])), T = Object.assign(Object.assign({}, E), b);
            for (let [S, w] of Object.entries(T))
              (p[S] === null || p[S] === void 0) && (p[S] = w);
            return p.parser === "json" && (p.trailingComma = "none"), u.normalizeApiOptions(p, m, Object.assign({ passThrough: Object.keys(a) }, v));
          }
          function D(h) {
            let { astFormat: v } = h;
            if (!v)
              throw new Error("getPlugin() requires astFormat to be set");
            let p = h.plugins.find((m) => m.printers && m.printers[v]);
            if (!p)
              throw new Error(`Couldn't find plugin for AST format "`.concat(v, '"'));
            return p;
          }
          function F(h, v) {
            let p = t.basename(h).toLowerCase(), E = l({ plugins: v }).languages.filter((P) => P.since !== null).find((P) => P.extensions && P.extensions.some((N) => p.endsWith(N)) || P.filenames && P.filenames.some((N) => N.toLowerCase() === p));
            return E && E.parsers[0];
          }
          s.exports = { normalize: o, hiddenDefaults: a, inferParser: F };
        } }), ID = ee({ "src/main/massage-ast.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l, u) {
            if (Array.isArray(i))
              return i.map((D) => t(D, l, u)).filter(Boolean);
            if (!i || typeof i != "object")
              return i;
            let n = l.printer.massageAstNode, a;
            n && n.ignoredProperties ? a = n.ignoredProperties : a = /* @__PURE__ */ new Set();
            let o = {};
            for (let [D, F] of Object.entries(i))
              !a.has(D) && typeof F != "function" && (o[D] = t(F, l, i));
            if (n) {
              let D = n(i, o, u);
              if (D === null)
                return;
              if (D)
                return D;
            }
            return o;
          }
          s.exports = t;
        } }), Ht = ee({ "scripts/build/shims/assert.cjs"(e2, s) {
          "use strict";
          ae();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, s.exports = t;
        } }), Qe = ee({ "src/main/comments.js"(e2, s) {
          "use strict";
          ae();
          var t = Ht(), { builders: { line: i, hardline: l, breakParent: u, indent: n, lineSuffix: a, join: o, cursor: D } } = Le(), { hasNewline: F, skipNewline: h, skipSpaces: v, isPreviousLineEmpty: p, addLeadingComment: m, addDanglingComment: E, addTrailingComment: P } = Ge(), N = /* @__PURE__ */ new WeakMap();
          function b(L, M, j) {
            if (!L)
              return;
            let { printer: H, locStart: I, locEnd: G } = M;
            if (j) {
              if (H.canAttachComment && H.canAttachComment(L)) {
                let W;
                for (W = j.length - 1; W >= 0 && !(I(j[W]) <= I(L) && G(j[W]) <= G(L)); --W)
                  ;
                j.splice(W + 1, 0, L);
                return;
              }
            } else if (N.has(L))
              return N.get(L);
            let Z = H.getCommentChildNodes && H.getCommentChildNodes(L, M) || typeof L == "object" && Object.entries(L).filter((W) => {
              let [$] = W;
              return $ !== "enclosingNode" && $ !== "precedingNode" && $ !== "followingNode" && $ !== "tokens" && $ !== "comments" && $ !== "parent";
            }).map((W) => {
              let [, $] = W;
              return $;
            });
            if (!!Z) {
              j || (j = [], N.set(L, j));
              for (let W of Z)
                b(W, M, j);
              return j;
            }
          }
          function T(L, M, j, H) {
            let { locStart: I, locEnd: G } = j, Z = I(M), W = G(M), $ = b(L, j), te, U, ne = 0, se = $.length;
            for (; ne < se; ) {
              let V = ne + se >> 1, oe = $[V], K = I(oe), Ee = G(oe);
              if (K <= Z && W <= Ee)
                return T(oe, M, j, oe);
              if (Ee <= Z) {
                te = oe, ne = V + 1;
                continue;
              }
              if (W <= K) {
                U = oe, se = V;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (H && H.type === "TemplateLiteral") {
              let { quasis: V } = H, oe = c(V, M, j);
              te && c(V, te, j) !== oe && (te = null), U && c(V, U, j) !== oe && (U = null);
            }
            return { enclosingNode: H, precedingNode: te, followingNode: U };
          }
          var S = () => false;
          function w(L, M, j, H) {
            if (!Array.isArray(L))
              return;
            let I = [], { locStart: G, locEnd: Z, printer: { handleComments: W = {} } } = H, { avoidAstMutation: $, ownLine: te = S, endOfLine: U = S, remaining: ne = S } = W, se = L.map((V, oe) => Object.assign(Object.assign({}, T(M, V, H)), {}, { comment: V, text: j, options: H, ast: M, isLastComment: L.length - 1 === oe }));
            for (let [V, oe] of se.entries()) {
              let { comment: K, precedingNode: Ee, enclosingNode: R, followingNode: le, text: ue, options: Q, ast: de, isLastComment: ge } = oe;
              if (Q.parser === "json" || Q.parser === "json5" || Q.parser === "__js_expression" || Q.parser === "__vue_expression") {
                if (G(K) - G(de) <= 0) {
                  m(de, K);
                  continue;
                }
                if (Z(K) - Z(de) >= 0) {
                  P(de, K);
                  continue;
                }
              }
              let ve;
              if ($ ? ve = [oe] : (K.enclosingNode = R, K.precedingNode = Ee, K.followingNode = le, ve = [K, ue, Q, de, ge]), k(ue, Q, se, V))
                K.placement = "ownLine", te(...ve) || (le ? m(le, K) : Ee ? P(Ee, K) : E(R || de, K));
              else if (A(ue, Q, se, V))
                K.placement = "endOfLine", U(...ve) || (Ee ? P(Ee, K) : le ? m(le, K) : E(R || de, K));
              else if (K.placement = "remaining", !ne(...ve))
                if (Ee && le) {
                  let be = I.length;
                  be > 0 && I[be - 1].followingNode !== le && f(I, ue, Q), I.push(oe);
                } else
                  Ee ? P(Ee, K) : le ? m(le, K) : E(R || de, K);
            }
            if (f(I, j, H), !$)
              for (let V of L)
                delete V.precedingNode, delete V.enclosingNode, delete V.followingNode;
          }
          var _ = (L) => !/[\S\n\u2028\u2029]/.test(L);
          function k(L, M, j, H) {
            let { comment: I, precedingNode: G } = j[H], { locStart: Z, locEnd: W } = M, $ = Z(I);
            if (G)
              for (let te = H - 1; te >= 0; te--) {
                let { comment: U, precedingNode: ne } = j[te];
                if (ne !== G || !_(L.slice(W(U), $)))
                  break;
                $ = Z(U);
              }
            return F(L, $, { backwards: true });
          }
          function A(L, M, j, H) {
            let { comment: I, followingNode: G } = j[H], { locStart: Z, locEnd: W } = M, $ = W(I);
            if (G)
              for (let te = H + 1; te < j.length; te++) {
                let { comment: U, followingNode: ne } = j[te];
                if (ne !== G || !_(L.slice($, Z(U))))
                  break;
                $ = W(U);
              }
            return F(L, $);
          }
          function f(L, M, j) {
            let H = L.length;
            if (H === 0)
              return;
            let { precedingNode: I, followingNode: G, enclosingNode: Z } = L[0], W = j.printer.getGapRegex && j.printer.getGapRegex(Z) || /^[\s(]*$/, $ = j.locStart(G), te;
            for (te = H; te > 0; --te) {
              let { comment: U, precedingNode: ne, followingNode: se } = L[te - 1];
              t.strictEqual(ne, I), t.strictEqual(se, G);
              let V = M.slice(j.locEnd(U), $);
              if (W.test(V))
                $ = j.locStart(U);
              else
                break;
            }
            for (let [U, { comment: ne }] of L.entries())
              U < te ? P(I, ne) : m(G, ne);
            for (let U of [I, G])
              U.comments && U.comments.length > 1 && U.comments.sort((ne, se) => j.locStart(ne) - j.locStart(se));
            L.length = 0;
          }
          function d(L, M) {
            let j = L.getValue();
            return j.printed = true, M.printer.printComment(L, M);
          }
          function c(L, M, j) {
            let H = j.locStart(M) - 1;
            for (let I = 1; I < L.length; ++I)
              if (H < j.locStart(L[I]))
                return I - 1;
            return 0;
          }
          function r(L, M) {
            let j = L.getValue(), H = [d(L, M)], { printer: I, originalText: G, locStart: Z, locEnd: W } = M;
            if (I.isBlockComment && I.isBlockComment(j)) {
              let U = F(G, W(j)) ? F(G, Z(j), { backwards: true }) ? l : i : " ";
              H.push(U);
            } else
              H.push(l);
            let te = h(G, v(G, W(j)));
            return te !== false && F(G, te) && H.push(l), H;
          }
          function y(L, M) {
            let j = L.getValue(), H = d(L, M), { printer: I, originalText: G, locStart: Z } = M, W = I.isBlockComment && I.isBlockComment(j);
            if (F(G, Z(j), { backwards: true })) {
              let te = p(G, j, Z);
              return a([l, te ? l : "", H]);
            }
            let $ = [" ", H];
            return W || ($ = [a($), u]), $;
          }
          function g(L, M, j, H) {
            let I = [], G = L.getValue();
            return !G || !G.comments || (L.each(() => {
              let Z = L.getValue();
              !Z.leading && !Z.trailing && (!H || H(Z)) && I.push(d(L, M));
            }, "comments"), I.length === 0) ? "" : j ? o(l, I) : n([l, o(l, I)]);
          }
          function C(L, M, j) {
            let H = L.getValue();
            if (!H)
              return {};
            let I = H.comments || [];
            j && (I = I.filter(($) => !j.has($)));
            let G = H === M.cursorNode;
            if (I.length === 0) {
              let $ = G ? D : "";
              return { leading: $, trailing: $ };
            }
            let Z = [], W = [];
            return L.each(() => {
              let $ = L.getValue();
              if (j && j.has($))
                return;
              let { leading: te, trailing: U } = $;
              te ? Z.push(r(L, M)) : U && W.push(y(L, M));
            }, "comments"), G && (Z.unshift(D), W.push(D)), { leading: Z, trailing: W };
          }
          function x(L, M, j, H) {
            let { leading: I, trailing: G } = C(L, j, H);
            return !I && !G ? M : [I, M, G];
          }
          function B(L) {
            if (!!L)
              for (let M of L) {
                if (!M.printed)
                  throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                delete M.printed;
              }
          }
          s.exports = { attach: w, printComments: x, printCommentsSeparately: C, printDanglingComments: g, getSortedChildNodes: b, ensureAllCommentsPrinted: B };
        } }), kD = ee({ "src/common/ast-path.js"(e2, s) {
          "use strict";
          ae();
          var t = st();
          function i(n, a) {
            let o = l(n.stack, a);
            return o === -1 ? null : n.stack[o];
          }
          function l(n, a) {
            for (let o = n.length - 1; o >= 0; o -= 2) {
              let D = n[o];
              if (D && !Array.isArray(D) && --a < 0)
                return o;
            }
            return -1;
          }
          var u = class {
            constructor(n) {
              this.stack = [n];
            }
            getName() {
              let { stack: n } = this, { length: a } = n;
              return a > 1 ? n[a - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return i(this, n);
            }
            getParentNode() {
              let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return i(this, n + 1);
            }
            call(n) {
              let { stack: a } = this, { length: o } = a, D = t(a);
              for (var F = arguments.length, h = new Array(F > 1 ? F - 1 : 0), v = 1; v < F; v++)
                h[v - 1] = arguments[v];
              for (let m of h)
                D = D[m], a.push(m, D);
              let p = n(this);
              return a.length = o, p;
            }
            callParent(n) {
              let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = l(this.stack, a + 1), D = this.stack.splice(o + 1), F = n(this);
              return this.stack.push(...D), F;
            }
            each(n) {
              let { stack: a } = this, { length: o } = a, D = t(a);
              for (var F = arguments.length, h = new Array(F > 1 ? F - 1 : 0), v = 1; v < F; v++)
                h[v - 1] = arguments[v];
              for (let p of h)
                D = D[p], a.push(p, D);
              for (let p = 0; p < D.length; ++p)
                a.push(p, D[p]), n(this, p, D), a.length -= 2;
              a.length = o;
            }
            map(n) {
              let a = [];
              for (var o = arguments.length, D = new Array(o > 1 ? o - 1 : 0), F = 1; F < o; F++)
                D[F - 1] = arguments[F];
              return this.each((h, v, p) => {
                a[v] = n(h, v, p);
              }, ...D), a;
            }
            try(n) {
              let { stack: a } = this, o = [...a];
              try {
                return n();
              } finally {
                a.length = 0, a.push(...o);
              }
            }
            match() {
              let n = this.stack.length - 1, a = null, o = this.stack[n--];
              for (var D = arguments.length, F = new Array(D), h = 0; h < D; h++)
                F[h] = arguments[h];
              for (let v of F) {
                if (o === void 0)
                  return false;
                let p = null;
                if (typeof a == "number" && (p = a, a = this.stack[n--], o = this.stack[n--]), v && !v(o, a, p))
                  return false;
                a = this.stack[n--], o = this.stack[n--];
              }
              return true;
            }
            findAncestor(n) {
              let a = this.stack.length - 1, o = null, D = this.stack[a--];
              for (; D; ) {
                let F = null;
                if (typeof o == "number" && (F = o, o = this.stack[a--], D = this.stack[a--]), o !== null && n(D, o, F))
                  return D;
                o = this.stack[a--], D = this.stack[a--];
              }
            }
          };
          s.exports = u;
        } }), LD = ee({ "src/main/multiparser.js"(e2, s) {
          "use strict";
          ae();
          var { utils: { stripTrailingHardline: t } } = Le(), { normalize: i } = ki(), l = Qe();
          function u(a, o, D, F) {
            if (D.printer.embed && D.embeddedLanguageFormatting === "auto")
              return D.printer.embed(a, o, (h, v, p) => n(h, v, D, F, p), D);
          }
          function n(a, o, D, F) {
            let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, v = i(Object.assign(Object.assign(Object.assign({}, D), o), {}, { parentParser: D.parser, originalText: a }), { passThrough: true }), p = qn().parse(a, v), { ast: m } = p;
            a = p.text;
            let E = m.comments;
            delete m.comments, l.attach(E, m, a, v), v[Symbol.for("comments")] = E || [], v[Symbol.for("tokens")] = m.tokens || [];
            let P = F(m, v);
            return l.ensureAllCommentsPrinted(E), h ? typeof P == "string" ? P.replace(/(?:\r?\n)*$/, "") : t(P) : P;
          }
          s.exports = { printSubtree: u };
        } }), OD = ee({ "src/main/ast-to-doc.js"(e2, s) {
          "use strict";
          ae();
          var t = kD(), { builders: { hardline: i, addAlignmentToDoc: l }, utils: { propagateBreaks: u } } = Le(), { printComments: n } = Qe(), a = LD();
          function o(h, v) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: m } = v;
            m.preprocess && (h = m.preprocess(h, v));
            let E = /* @__PURE__ */ new Map(), P = new t(h), N = b();
            return p > 0 && (N = l([i, N], p, v.tabWidth)), u(N), N;
            function b(S, w) {
              return S === void 0 || S === P ? T(w) : Array.isArray(S) ? P.call(() => T(w), ...S) : P.call(() => T(w), S);
            }
            function T(S) {
              let w = P.getValue(), _ = w && typeof w == "object" && S === void 0;
              if (_ && E.has(w))
                return E.get(w);
              let k = F(P, v, b, S);
              return _ && E.set(w, k), k;
            }
          }
          function D(h, v) {
            let { originalText: p, [Symbol.for("comments")]: m, locStart: E, locEnd: P } = v, N = E(h), b = P(h), T = /* @__PURE__ */ new Set();
            for (let S of m)
              E(S) >= N && P(S) <= b && (S.printed = true, T.add(S));
            return { doc: p.slice(N, b), printedComments: T };
          }
          function F(h, v, p, m) {
            let E = h.getValue(), { printer: P } = v, N, b;
            if (P.hasPrettierIgnore && P.hasPrettierIgnore(h))
              ({ doc: N, printedComments: b } = D(E, v));
            else {
              if (E)
                try {
                  N = a.printSubtree(h, p, v, o);
                } catch (T) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw T;
                }
              N || (N = P.print(h, v, p, m));
            }
            return (!P.willPrintOwnComments || !P.willPrintOwnComments(h, v)) && (N = n(h, N, v, b)), N;
          }
          s.exports = o;
        } }), jD = ee({ "src/main/range-util.js"(e2, s) {
          "use strict";
          ae();
          var t = Ht(), i = Qe(), l = (m) => {
            let { parser: E } = m;
            return E === "json" || E === "json5" || E === "json-stringify";
          };
          function u(m, E) {
            let P = [m.node, ...m.parentNodes], N = /* @__PURE__ */ new Set([E.node, ...E.parentNodes]);
            return P.find((b) => F.has(b.type) && N.has(b));
          }
          function n(m) {
            let E = m.length - 1;
            for (; ; ) {
              let P = m[E];
              if (P && (P.type === "Program" || P.type === "File"))
                E--;
              else
                break;
            }
            return m.slice(0, E + 1);
          }
          function a(m, E, P) {
            let { locStart: N, locEnd: b } = P, T = m.node, S = E.node;
            if (T === S)
              return { startNode: T, endNode: S };
            let w = N(m.node);
            for (let k of n(E.parentNodes))
              if (N(k) >= w)
                S = k;
              else
                break;
            let _ = b(E.node);
            for (let k of n(m.parentNodes))
              if (b(k) <= _)
                T = k;
              else
                break;
            return { startNode: T, endNode: S };
          }
          function o(m, E, P, N) {
            let b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], T = arguments.length > 5 ? arguments[5] : void 0, { locStart: S, locEnd: w } = P, _ = S(m), k = w(m);
            if (!(E > k || E < _ || T === "rangeEnd" && E === _ || T === "rangeStart" && E === k)) {
              for (let A of i.getSortedChildNodes(m, P)) {
                let f = o(A, E, P, N, [m, ...b], T);
                if (f)
                  return f;
              }
              if (!N || N(m, b[0]))
                return { node: m, parentNodes: b };
            }
          }
          function D(m, E) {
            return E !== "DeclareExportDeclaration" && m !== "TypeParameterDeclaration" && (m === "Directive" || m === "TypeAlias" || m === "TSExportAssignment" || m.startsWith("Declare") || m.startsWith("TSDeclare") || m.endsWith("Statement") || m.endsWith("Declaration"));
          }
          var F = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function v(m, E, P) {
            if (!E)
              return false;
            switch (m.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return D(E.type, P && P.type);
              case "json":
              case "json5":
              case "json-stringify":
                return F.has(E.type);
              case "graphql":
                return h.has(E.kind);
              case "vue":
                return E.tag !== "root";
            }
            return false;
          }
          function p(m, E, P) {
            let { rangeStart: N, rangeEnd: b, locStart: T, locEnd: S } = E;
            t.ok(b > N);
            let w = m.slice(N, b).search(/\S/), _ = w === -1;
            if (!_)
              for (N += w; b > N && !/\S/.test(m[b - 1]); --b)
                ;
            let k = o(P, N, E, (c, r) => v(E, c, r), [], "rangeStart"), A = _ ? k : o(P, b, E, (c) => v(E, c), [], "rangeEnd");
            if (!k || !A)
              return { rangeStart: 0, rangeEnd: 0 };
            let f, d;
            if (l(E)) {
              let c = u(k, A);
              f = c, d = c;
            } else
              ({ startNode: f, endNode: d } = a(k, A, E));
            return { rangeStart: Math.min(T(f), T(d)), rangeEnd: Math.max(S(f), S(d)) };
          }
          s.exports = { calculateRange: p, findNodeAtOffset: o };
        } }), qD = ee({ "src/main/core.js"(e2, s) {
          "use strict";
          ae();
          var { diffArrays: t } = Yf(), { printer: { printDocToString: i }, debug: { printDocToDebug: l } } = Le(), { getAlignmentSize: u } = Ge(), { guessEndOfLine: n, convertEndOfLineToChars: a, countEndOfLineChars: o, normalizeEndOfLine: D } = Nn(), F = ki().normalize, h = ID(), v = Qe(), p = qn(), m = OD(), E = jD(), P = "\uFEFF", N = Symbol("cursor");
          function b(d, c, r) {
            let y = c.comments;
            return y && (delete c.comments, v.attach(y, c, d, r)), r[Symbol.for("comments")] = y || [], r[Symbol.for("tokens")] = c.tokens || [], r.originalText = d, y;
          }
          function T(d, c) {
            let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!d || d.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: y, text: g } = p.parse(d, c);
            if (c.cursorOffset >= 0) {
              let L = E.findNodeAtOffset(y, c.cursorOffset, c);
              L && L.node && (c.cursorNode = L.node);
            }
            let C = b(g, y, c), x = m(y, c, r), B = i(x, c);
            if (v.ensureAllCommentsPrinted(C), r > 0) {
              let L = B.formatted.trim();
              B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(L)), B.formatted = L + a(c.endOfLine);
            }
            if (c.cursorOffset >= 0) {
              let L, M, j, H, I;
              if (c.cursorNode && B.cursorNodeText ? (L = c.locStart(c.cursorNode), M = g.slice(L, c.locEnd(c.cursorNode)), j = c.cursorOffset - L, H = B.cursorNodeStart, I = B.cursorNodeText) : (L = 0, M = g, j = c.cursorOffset, H = 0, I = B.formatted), M === I)
                return { formatted: B.formatted, cursorOffset: H + j, comments: C };
              let G = [...M];
              G.splice(j, 0, N);
              let Z = [...I], W = t(G, Z), $ = H;
              for (let te of W)
                if (te.removed) {
                  if (te.value.includes(N))
                    break;
                } else
                  $ += te.count;
              return { formatted: B.formatted, cursorOffset: $, comments: C };
            }
            return { formatted: B.formatted, cursorOffset: -1, comments: C };
          }
          function S(d, c) {
            let { ast: r, text: y } = p.parse(d, c), { rangeStart: g, rangeEnd: C } = E.calculateRange(y, c, r), x = y.slice(g, C), B = Math.min(g, y.lastIndexOf(`
`, g) + 1), L = y.slice(B, g).match(/^\s*/)[0], M = u(L, c.tabWidth), j = T(x, Object.assign(Object.assign({}, c), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: c.cursorOffset > g && c.cursorOffset <= C ? c.cursorOffset - g : -1, endOfLine: "lf" }), M), H = j.formatted.trimEnd(), { cursorOffset: I } = c;
            I > C ? I += H.length - x.length : j.cursorOffset >= 0 && (I = j.cursorOffset + g);
            let G = y.slice(0, g) + H + y.slice(C);
            if (c.endOfLine !== "lf") {
              let Z = a(c.endOfLine);
              I >= 0 && Z === `\r
` && (I += o(G.slice(0, I), `
`)), G = G.replace(/\n/g, Z);
            }
            return { formatted: G, cursorOffset: I, comments: j.comments };
          }
          function w(d, c, r) {
            return typeof c != "number" || Number.isNaN(c) || c < 0 || c > d.length ? r : c;
          }
          function _(d, c) {
            let { cursorOffset: r, rangeStart: y, rangeEnd: g } = c;
            return r = w(d, r, -1), y = w(d, y, 0), g = w(d, g, d.length), Object.assign(Object.assign({}, c), {}, { cursorOffset: r, rangeStart: y, rangeEnd: g });
          }
          function k(d, c) {
            let { cursorOffset: r, rangeStart: y, rangeEnd: g, endOfLine: C } = _(d, c), x = d.charAt(0) === P;
            if (x && (d = d.slice(1), r--, y--, g--), C === "auto" && (C = n(d)), d.includes("\r")) {
              let B = (L) => o(d.slice(0, Math.max(L, 0)), `\r
`);
              r -= B(r), y -= B(y), g -= B(g), d = D(d);
            }
            return { hasBOM: x, text: d, options: _(d, Object.assign(Object.assign({}, c), {}, { cursorOffset: r, rangeStart: y, rangeEnd: g, endOfLine: C })) };
          }
          function A(d, c) {
            let r = p.resolveParser(c);
            return !r.hasPragma || r.hasPragma(d);
          }
          function f(d, c) {
            let { hasBOM: r, text: y, options: g } = k(d, F(c));
            if (g.rangeStart >= g.rangeEnd && y !== "" || g.requirePragma && !A(y, g))
              return { formatted: d, cursorOffset: c.cursorOffset, comments: [] };
            let C;
            return g.rangeStart > 0 || g.rangeEnd < y.length ? C = S(y, g) : (!g.requirePragma && g.insertPragma && g.printer.insertPragma && !A(y, g) && (y = g.printer.insertPragma(y)), C = T(y, g)), r && (C.formatted = P + C.formatted, C.cursorOffset >= 0 && C.cursorOffset++), C;
          }
          s.exports = { formatWithCursor: f, parse(d, c, r) {
            let { text: y, options: g } = k(d, F(c)), C = p.parse(y, g);
            return r && (C.ast = h(C.ast, g)), C;
          }, formatAST(d, c) {
            c = F(c);
            let r = m(d, c);
            return i(r, c);
          }, formatDoc(d, c) {
            return f(l(d), Object.assign(Object.assign({}, c), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(d, c) {
            c = F(c);
            let { ast: r, text: y } = p.parse(d, c);
            return b(y, r, c), m(r, c);
          }, printDocToString(d, c) {
            return i(d, F(c));
          } };
        } }), MD = ee({ "src/common/util-shared.js"(e2, s) {
          "use strict";
          ae();
          var { getMaxContinuousCount: t, getStringWidth: i, getAlignmentSize: l, getIndentSize: u, skip: n, skipWhitespace: a, skipSpaces: o, skipNewline: D, skipToLineEnd: F, skipEverythingButNewLine: h, skipInlineComment: v, skipTrailingComment: p, hasNewline: m, hasNewlineInRange: E, hasSpaces: P, isNextLineEmpty: N, isNextLineEmptyAfterIndex: b, isPreviousLineEmpty: T, getNextNonSpaceNonCommentCharacterIndex: S, makeString: w, addLeadingComment: _, addDanglingComment: k, addTrailingComment: A } = Ge();
          s.exports = { getMaxContinuousCount: t, getStringWidth: i, getAlignmentSize: l, getIndentSize: u, skip: n, skipWhitespace: a, skipSpaces: o, skipNewline: D, skipToLineEnd: F, skipEverythingButNewLine: h, skipInlineComment: v, skipTrailingComment: p, hasNewline: m, hasNewlineInRange: E, hasSpaces: P, isNextLineEmpty: N, isNextLineEmptyAfterIndex: b, isPreviousLineEmpty: T, getNextNonSpaceNonCommentCharacterIndex: S, makeString: w, addLeadingComment: _, addDanglingComment: k, addTrailingComment: A };
        } }), St = ee({ "src/utils/create-language.js"(e2, s) {
          "use strict";
          ae(), s.exports = function(t, i) {
            let { languageId: l } = t, u = Sn(t, Gf);
            return Object.assign(Object.assign({ linguistLanguageId: l }, u), i(t));
          };
        } }), RD = ee({ "node_modules/esutils/lib/ast.js"(e2, s) {
          ae(), function() {
            "use strict";
            function t(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function i(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function l(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function u(o) {
              return l(o) || o != null && o.type === "FunctionDeclaration";
            }
            function n(o) {
              switch (o.type) {
                case "IfStatement":
                  return o.alternate != null ? o.alternate : o.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return o.body;
              }
              return null;
            }
            function a(o) {
              var D;
              if (o.type !== "IfStatement" || o.alternate == null)
                return false;
              D = o.consequent;
              do {
                if (D.type === "IfStatement" && D.alternate == null)
                  return true;
                D = n(D);
              } while (D);
              return false;
            }
            s.exports = { isExpression: t, isStatement: l, isIterationStatement: i, isSourceElement: u, isProblematicIfStatement: a, trailingStatement: n };
          }();
        } }), Li = ee({ "node_modules/esutils/lib/code.js"(e2, s) {
          ae(), function() {
            "use strict";
            var t, i, l, u, n, a;
            i = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function o(b) {
              return 48 <= b && b <= 57;
            }
            function D(b) {
              return 48 <= b && b <= 57 || 97 <= b && b <= 102 || 65 <= b && b <= 70;
            }
            function F(b) {
              return b >= 48 && b <= 55;
            }
            l = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h(b) {
              return b === 32 || b === 9 || b === 11 || b === 12 || b === 160 || b >= 5760 && l.indexOf(b) >= 0;
            }
            function v(b) {
              return b === 10 || b === 13 || b === 8232 || b === 8233;
            }
            function p(b) {
              if (b <= 65535)
                return String.fromCharCode(b);
              var T = String.fromCharCode(Math.floor((b - 65536) / 1024) + 55296), S = String.fromCharCode((b - 65536) % 1024 + 56320);
              return T + S;
            }
            for (u = new Array(128), a = 0; a < 128; ++a)
              u[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a === 36 || a === 95;
            for (n = new Array(128), a = 0; a < 128; ++a)
              n[a] = a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || a === 36 || a === 95;
            function m(b) {
              return b < 128 ? u[b] : i.NonAsciiIdentifierStart.test(p(b));
            }
            function E(b) {
              return b < 128 ? n[b] : i.NonAsciiIdentifierPart.test(p(b));
            }
            function P(b) {
              return b < 128 ? u[b] : t.NonAsciiIdentifierStart.test(p(b));
            }
            function N(b) {
              return b < 128 ? n[b] : t.NonAsciiIdentifierPart.test(p(b));
            }
            s.exports = { isDecimalDigit: o, isHexDigit: D, isOctalDigit: F, isWhiteSpace: h, isLineTerminator: v, isIdentifierStartES5: m, isIdentifierPartES5: E, isIdentifierStartES6: P, isIdentifierPartES6: N };
          }();
        } }), VD = ee({ "node_modules/esutils/lib/keyword.js"(e2, s) {
          ae(), function() {
            "use strict";
            var t = Li();
            function i(m) {
              switch (m) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function l(m, E) {
              return !E && m === "yield" ? false : u(m, E);
            }
            function u(m, E) {
              if (E && i(m))
                return true;
              switch (m.length) {
                case 2:
                  return m === "if" || m === "in" || m === "do";
                case 3:
                  return m === "var" || m === "for" || m === "new" || m === "try";
                case 4:
                  return m === "this" || m === "else" || m === "case" || m === "void" || m === "with" || m === "enum";
                case 5:
                  return m === "while" || m === "break" || m === "catch" || m === "throw" || m === "const" || m === "yield" || m === "class" || m === "super";
                case 6:
                  return m === "return" || m === "typeof" || m === "delete" || m === "switch" || m === "export" || m === "import";
                case 7:
                  return m === "default" || m === "finally" || m === "extends";
                case 8:
                  return m === "function" || m === "continue" || m === "debugger";
                case 10:
                  return m === "instanceof";
                default:
                  return false;
              }
            }
            function n(m, E) {
              return m === "null" || m === "true" || m === "false" || l(m, E);
            }
            function a(m, E) {
              return m === "null" || m === "true" || m === "false" || u(m, E);
            }
            function o(m) {
              return m === "eval" || m === "arguments";
            }
            function D(m) {
              var E, P, N;
              if (m.length === 0 || (N = m.charCodeAt(0), !t.isIdentifierStartES5(N)))
                return false;
              for (E = 1, P = m.length; E < P; ++E)
                if (N = m.charCodeAt(E), !t.isIdentifierPartES5(N))
                  return false;
              return true;
            }
            function F(m, E) {
              return (m - 55296) * 1024 + (E - 56320) + 65536;
            }
            function h(m) {
              var E, P, N, b, T;
              if (m.length === 0)
                return false;
              for (T = t.isIdentifierStartES6, E = 0, P = m.length; E < P; ++E) {
                if (N = m.charCodeAt(E), 55296 <= N && N <= 56319) {
                  if (++E, E >= P || (b = m.charCodeAt(E), !(56320 <= b && b <= 57343)))
                    return false;
                  N = F(N, b);
                }
                if (!T(N))
                  return false;
                T = t.isIdentifierPartES6;
              }
              return true;
            }
            function v(m, E) {
              return D(m) && !n(m, E);
            }
            function p(m, E) {
              return h(m) && !a(m, E);
            }
            s.exports = { isKeywordES5: l, isKeywordES6: u, isReservedWordES5: n, isReservedWordES6: a, isRestrictedWord: o, isIdentifierNameES5: D, isIdentifierNameES6: h, isIdentifierES5: v, isIdentifierES6: p };
          }();
        } }), WD = ee({ "node_modules/esutils/lib/utils.js"(e2) {
          ae(), function() {
            "use strict";
            e2.ast = RD(), e2.code = Li(), e2.keyword = VD();
          }();
        } }), wt = ee({ "src/language-js/utils/is-block-comment.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            return i.type === "Block" || i.type === "CommentBlock" || i.type === "MultiLine";
          }
          s.exports = t;
        } }), Xe = ee({ "src/language-js/utils/index.js"(e2, s) {
          "use strict";
          ae();
          var t = WD().keyword.isIdentifierNameES5, { getLast: i, hasNewline: l, skipWhitespace: u, isNonEmptyArray: n, isNextLineEmptyAfterIndex: a, getStringWidth: o } = Ge(), { locStart: D, locEnd: F, hasSameLocStart: h } = nt(), v = wt(), p = "(?:(?=.)\\s)", m = new RegExp("^".concat(p, "*:")), E = new RegExp("^".concat(p, "*::"));
          function P(O) {
            return O.extra && O.extra.parenthesized && n(O.trailingComments) && v(O.trailingComments[0]) && m.test(O.trailingComments[0].value);
          }
          function N(O) {
            return n(O) && v(O[0]) && E.test(O[0].value);
          }
          function b(O, De) {
            if (!O || typeof O != "object")
              return false;
            if (Array.isArray(O))
              return O.some((We) => b(We, De));
            let ke = De(O);
            return typeof ke == "boolean" ? ke : Object.values(O).some((We) => b(We, De));
          }
          function T(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || Ee(O) || R(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || O.type === "TSAsExpression" || O.type === "TSNonNullExpression";
          }
          function S(O) {
            return O.expressions ? O.expressions[0] : O.left || O.test || O.callee || O.object || O.tag || O.argument || O.expression;
          }
          function w(O, De) {
            if (De.expressions)
              return ["expressions", 0];
            if (De.left)
              return ["left"];
            if (De.test)
              return ["test"];
            if (De.object)
              return ["object"];
            if (De.callee)
              return ["callee"];
            if (De.tag)
              return ["tag"];
            if (De.argument)
              return ["argument"];
            if (De.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function _(O) {
            return O.type === "Line" || O.type === "CommentLine" || O.type === "SingleLine" || O.type === "HashbangComment" || O.type === "HTMLOpen" || O.type === "HTMLClose";
          }
          var k = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function A(O) {
            return O && k.has(O.type);
          }
          function f(O) {
            let De = O.getParentNode();
            return O.getName() === "declaration" && A(De) ? De : null;
          }
          function d(O) {
            return O.type === "BooleanLiteral" || O.type === "DirectiveLiteral" || O.type === "Literal" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "TemplateLiteral" || O.type === "TSTypeLiteral" || O.type === "JSXText";
          }
          function c(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function r(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && c(O.argument);
          }
          function y(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          function g(O) {
            return O.type === "ObjectTypeAnnotation" || O.type === "TSTypeLiteral" || O.type === "TSMappedType";
          }
          function C(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression";
          }
          function x(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function B(O) {
            return O.type === "TemplateLiteral";
          }
          function L(O) {
            return Ee(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          function M(O) {
            return O.type === "JSXElement" || O.type === "JSXFragment";
          }
          function j(O, De) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
              return false;
            let ke = De.getNode();
            if (!ke.expression || !M(ke.expression))
              return false;
            let We = De.getParentNode();
            return We.type === "Program" && We.body.length === 1;
          }
          function H(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function I(O) {
            return H(O) || h(O, O.value);
          }
          function G(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !I(O);
          }
          function Z(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h(O, O.typeAnnotation);
          }
          var W = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function $(O) {
            return W.has(O.type);
          }
          function te(O) {
            return R(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var U = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ne(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || U.has(O.type)) : false;
          }
          var se = /^(?:skip|[fx]?(?:it|describe|test))$/;
          function V(O) {
            return R(O.callee) && O.callee.object.type === "Identifier" && O.callee.property.type === "Identifier" && se.test(O.callee.object.name) && (O.callee.property.name === "only" || O.callee.property.name === "skip");
          }
          function oe(O) {
            let De = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && De.test(O.callee.name) && O.arguments.length === 1;
          }
          function K(O, De) {
            if (O.type !== "CallExpression")
              return false;
            if (O.arguments.length === 1) {
              if (L(O) && De && K(De))
                return C(O.arguments[0]);
              if (oe(O))
                return L(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.callee.type === "Identifier" && se.test(O.callee.name) || V(O)) && (B(O.arguments[0]) || y(O.arguments[0])))
              return O.arguments[2] && !c(O.arguments[2]) ? false : (O.arguments.length === 2 ? C(O.arguments[1]) : x(O.arguments[1]) && Ke(O.arguments[1]).length <= 1) || L(O.arguments[1]);
            return false;
          }
          function Ee(O) {
            return O && (O.type === "CallExpression" || O.type === "OptionalCallExpression");
          }
          function R(O) {
            return O && (O.type === "MemberExpression" || O.type === "OptionalMemberExpression");
          }
          function le(O) {
            let De = "expressions";
            O.type === "TSTemplateLiteralType" && (De = "types");
            let ke = O[De];
            return ke.length === 0 ? false : ke.every((We) => {
              if (Me(We))
                return false;
              if (We.type === "Identifier" || We.type === "ThisExpression")
                return true;
              if (R(We)) {
                let Ve = We;
                for (; R(Ve); )
                  if (Ve.property.type !== "Identifier" && Ve.property.type !== "Literal" && Ve.property.type !== "StringLiteral" && Ve.property.type !== "NumericLiteral" || (Ve = Ve.object, Me(Ve)))
                    return false;
                return Ve.type === "Identifier" || Ve.type === "ThisExpression";
              }
              return false;
            });
          }
          function ue(O, De) {
            return O === "+" ? "+" + De : O === "-" ? "-" + De : De;
          }
          function Q(O, De) {
            let ke = D(De), We = u(O, F(De));
            return We !== false && O.slice(ke, ke + 2) === "/*" && O.slice(We, We + 2) === "*/";
          }
          function de(O, De) {
            return M(De) ? Ae(De) : Me(De, _e.Leading, (ke) => l(O, F(ke)));
          }
          function ge(O, De) {
            return De.parser !== "json" && y(O.key) && J(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(De.parser === "babel-ts" && O.type === "ClassProperty" || De.parser === "typescript" && O.type === "PropertyDefinition") || ve(O.key.value) && String(Number(O.key.value)) === O.key.value && (De.parser === "babel" || De.parser === "acorn" || De.parser === "espree" || De.parser === "meriyah" || De.parser === "__babel_estree"));
          }
          function ve(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function be(O, De) {
            let ke = /^[fx]?(?:describe|it|test)$/;
            return De.type === "TaggedTemplateExpression" && De.quasi === O && De.tag.type === "MemberExpression" && De.tag.property.type === "Identifier" && De.tag.property.name === "each" && (De.tag.object.type === "Identifier" && ke.test(De.tag.object.name) || De.tag.object.type === "MemberExpression" && De.tag.object.property.type === "Identifier" && (De.tag.object.property.name === "only" || De.tag.object.property.name === "skip") && De.tag.object.object.type === "Identifier" && ke.test(De.tag.object.object.name));
          }
          function we(O) {
            return O.quasis.some((De) => De.value.raw.includes(`
`));
          }
          function fe(O, De) {
            return (O.type === "TemplateLiteral" && we(O) || O.type === "TaggedTemplateExpression" && we(O.quasi)) && !l(De, D(O), { backwards: true });
          }
          function pe(O) {
            if (!Me(O))
              return false;
            let De = i(qe(O, _e.Dangling));
            return De && !v(De);
          }
          function me(O) {
            if (O.length <= 1)
              return false;
            let De = 0;
            for (let ke of O)
              if (C(ke)) {
                if (De += 1, De > 1)
                  return true;
              } else if (Ee(ke)) {
                for (let We of ke.arguments)
                  if (C(We))
                    return true;
              }
            return false;
          }
          function ce(O) {
            let De = O.getValue(), ke = O.getParentNode();
            return Ee(De) && Ee(ke) && ke.callee === De && De.arguments.length > ke.arguments.length && ke.arguments.length > 0;
          }
          function he(O, De) {
            if (De >= 2)
              return false;
            let ke = (Ve) => he(Ve, De + 1), We = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            return We && o(We) > 5 ? false : O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import" ? true : O.type === "TemplateLiteral" ? O.quasis.every((Ve) => !Ve.value.raw.includes(`
`)) && O.expressions.every(ke) : O.type === "ObjectExpression" ? O.properties.every((Ve) => !Ve.computed && (Ve.shorthand || Ve.value && ke(Ve.value))) : O.type === "ArrayExpression" ? O.elements.every((Ve) => Ve === null || ke(Ve)) : rt(O) ? (O.type === "ImportExpression" || he(O.callee, De)) && Be(O).every(ke) : R(O) ? he(O.object, De) && he(O.property, De) : O.type === "UnaryExpression" && (O.operator === "!" || O.operator === "-") ? he(O.argument, De) : O.type === "TSNonNullExpression" ? he(O.expression, De) : false;
          }
          function J(O) {
            return O.extra ? O.extra.raw : O.raw;
          }
          function ye(O) {
            return O;
          }
          function X(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function Y(O) {
            let De = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && De === "es5" || O.trailingComma === "all" && (De === "all" || De === "es5");
          }
          function re(O, De) {
            switch (O = tt(O), O.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return De;
              case "ObjectExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return re(O.object, De);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : re(O.tag, De);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : re(O.callee, De);
              case "ConditionalExpression":
                return re(O.test, De);
              case "UpdateExpression":
                return !O.prefix && re(O.argument, De);
              case "BindExpression":
                return O.object && re(O.object, De);
              case "SequenceExpression":
                return re(O.expressions[0], De);
              case "TSAsExpression":
              case "TSNonNullExpression":
                return re(O.expression, De);
              default:
                return false;
            }
          }
          var z = { "==": true, "!=": true, "===": true, "!==": true }, q = { "*": true, "/": true, "%": true }, Ce = { ">>": true, ">>>": true, "<<": true };
          function Ne(O, De) {
            return !(Ue(De) !== Ue(O) || O === "**" || z[O] && z[De] || De === "%" && q[O] || O === "%" && q[De] || De !== O && q[De] && q[O] || Ce[O] && Ce[De]);
          }
          var je = {};
          for (let [O, De] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
            for (let ke of De)
              je[ke] = O;
          function Ue(O) {
            return je[O];
          }
          function tt(O) {
            for (; O.left; )
              O = O.left;
            return O;
          }
          function Te(O) {
            return Boolean(Ce[O]) || O === "|" || O === "^" || O === "&";
          }
          function Pe(O) {
            if (O.rest)
              return true;
            let De = Ke(O);
            return De.length > 0 && i(De).type === "RestElement";
          }
          var Fe = /* @__PURE__ */ new WeakMap();
          function Ke(O) {
            if (Fe.has(O))
              return Fe.get(O);
            let De = [];
            return O.this && De.push(O.this), Array.isArray(O.parameters) ? De.push(...O.parameters) : Array.isArray(O.params) && De.push(...O.params), O.rest && De.push(O.rest), Fe.set(O, De), De;
          }
          function Se(O, De) {
            let ke = O.getValue(), We = 0, Ve = (ut) => De(ut, We++);
            ke.this && O.call(Ve, "this"), Array.isArray(ke.parameters) ? O.each(Ve, "parameters") : Array.isArray(ke.params) && O.each(Ve, "params"), ke.rest && O.call(Ve, "rest");
          }
          var ze = /* @__PURE__ */ new WeakMap();
          function Be(O) {
            if (ze.has(O))
              return ze.get(O);
            let De = O.arguments;
            return O.type === "ImportExpression" && (De = [O.source], O.attributes && De.push(O.attributes)), ze.set(O, De), De;
          }
          function Ie(O, De) {
            let ke = O.getValue();
            ke.type === "ImportExpression" ? (O.call((We) => De(We, 0), "source"), ke.attributes && O.call((We) => De(We, 1), "attributes")) : O.each(De, "arguments");
          }
          function Re(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Ae(O) {
            return O && (O.prettierIgnore || Me(O, _e.PrettierIgnore));
          }
          function Oe(O) {
            let De = O.getValue();
            return Ae(De);
          }
          var _e = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, ie = (O, De) => {
            if (typeof O == "function" && (De = O, O = 0), O || De)
              return (ke, We, Ve) => !(O & _e.Leading && !ke.leading || O & _e.Trailing && !ke.trailing || O & _e.Dangling && (ke.leading || ke.trailing) || O & _e.Block && !v(ke) || O & _e.Line && !_(ke) || O & _e.First && We !== 0 || O & _e.Last && We !== Ve.length - 1 || O & _e.PrettierIgnore && !Re(ke) || De && !De(ke));
          };
          function Me(O, De, ke) {
            if (!O || !n(O.comments))
              return false;
            let We = ie(De, ke);
            return We ? O.comments.some(We) : true;
          }
          function qe(O, De, ke) {
            if (!O || !Array.isArray(O.comments))
              return [];
            let We = ie(De, ke);
            return We ? O.comments.filter(We) : O.comments;
          }
          var Je = (O, De) => {
            let { originalText: ke } = De;
            return a(ke, F(O));
          };
          function rt(O) {
            return Ee(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function Ze(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function ct(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var Ot = Symbol("ifWithoutBlockAndSameLineComment");
          s.exports = { getFunctionParameters: Ke, iterateFunctionParametersPath: Se, getCallArguments: Be, iterateCallArgumentsPath: Ie, hasRestParameter: Pe, getLeftSide: S, getLeftSidePathName: w, getParentExportDeclaration: f, getTypeScriptMappedTypeModifier: ue, hasFlowAnnotationComment: N, hasFlowShorthandAnnotationComment: P, hasLeadingOwnLineComment: de, hasNakedLeftSide: T, hasNode: b, hasIgnoreComment: Oe, hasNodeIgnoreComment: Ae, identity: ye, isBinaryish: $, isCallLikeExpression: rt, isEnabledHackPipeline: ct, isLineComment: _, isPrettierIgnoreComment: Re, isCallExpression: Ee, isMemberExpression: R, isExportDeclaration: A, isFlowAnnotationComment: Q, isFunctionCompositionArgs: me, isFunctionNotation: I, isFunctionOrArrowExpression: C, isGetterOrSetter: H, isJestEachTemplateLiteral: be, isJsxNode: M, isLiteral: d, isLongCurriedCallExpression: ce, isSimpleCallArgument: he, isMemberish: te, isNumericLiteral: c, isSignedNumericLiteral: r, isObjectProperty: Ze, isObjectType: g, isObjectTypePropertyAFunction: G, isSimpleType: ne, isSimpleNumber: ve, isSimpleTemplateLiteral: le, isStringLiteral: y, isStringPropSafeToUnquote: ge, isTemplateOnItsOwnLine: fe, isTestCall: K, isTheOnlyJsxElementInMarkdown: j, isTSXFile: X, isTypeAnnotationAFunction: Z, isNextLineEmpty: Je, needsHardlineAfterDanglingComment: pe, rawText: J, shouldPrintComma: Y, isBitwiseOperator: Te, shouldFlatten: Ne, startsWithNoLookaheadToken: re, getPrecedence: Ue, hasComment: Me, getComments: qe, CommentCheckFlags: _e, markerForIfWithoutBlockAndSameLineComment: Ot };
        } }), Pt = ee({ "src/language-js/print/template-literal.js"(e2, s) {
          "use strict";
          ae();
          var t = st(), { getStringWidth: i, getIndentSize: l } = Ge(), { builders: { join: u, hardline: n, softline: a, group: o, indent: D, align: F, lineSuffixBoundary: h, addAlignmentToDoc: v }, printer: { printDocToString: p }, utils: { mapDoc: m } } = Le(), { isBinaryish: E, isJestEachTemplateLiteral: P, isSimpleTemplateLiteral: N, hasComment: b, isMemberExpression: T } = Xe();
          function S(d, c, r) {
            let y = d.getValue();
            if (y.type === "TemplateLiteral" && P(y, d.getParentNode())) {
              let M = w(d, r, c);
              if (M)
                return M;
            }
            let C = "expressions";
            y.type === "TSTemplateLiteralType" && (C = "types");
            let x = [], B = d.map(c, C), L = N(y);
            return L && (B = B.map((M) => p(M, Object.assign(Object.assign({}, r), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), x.push(h, "`"), d.each((M) => {
              let j = M.getName();
              if (x.push(c()), j < B.length) {
                let { tabWidth: H } = r, I = M.getValue(), G = l(I.value.raw, H), Z = B[j];
                if (!L) {
                  let $ = y[C][j];
                  (b($) || T($) || $.type === "ConditionalExpression" || $.type === "SequenceExpression" || $.type === "TSAsExpression" || E($)) && (Z = [D([a, Z]), a]);
                }
                let W = G === 0 && I.value.raw.endsWith(`
`) ? F(Number.NEGATIVE_INFINITY, Z) : v(Z, G, H);
                x.push(o(["${", W, h, "}"]));
              }
            }, "quasis"), x.push("`"), x;
          }
          function w(d, c, r) {
            let y = d.getNode(), g = y.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (g.length > 1 || g.some((C) => C.length > 0)) {
              c.__inJestEach = true;
              let C = d.map(r, "expressions");
              c.__inJestEach = false;
              let x = [], B = C.map((I) => "${" + p(I, Object.assign(Object.assign({}, c), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), L = [{ hasLineBreak: false, cells: [] }];
              for (let I = 1; I < y.quasis.length; I++) {
                let G = t(L), Z = B[I - 1];
                G.cells.push(Z), Z.includes(`
`) && (G.hasLineBreak = true), y.quasis[I].value.raw.includes(`
`) && L.push({ hasLineBreak: false, cells: [] });
              }
              let M = Math.max(g.length, ...L.map((I) => I.cells.length)), j = Array.from({ length: M }).fill(0), H = [{ cells: g }, ...L.filter((I) => I.cells.length > 0)];
              for (let { cells: I } of H.filter((G) => !G.hasLineBreak))
                for (let [G, Z] of I.entries())
                  j[G] = Math.max(j[G], i(Z));
              return x.push(h, "`", D([n, u(n, H.map((I) => u(" | ", I.cells.map((G, Z) => I.hasLineBreak ? G : G + " ".repeat(j[Z] - i(G))))))]), n, "`"), x;
            }
          }
          function _(d, c) {
            let r = d.getValue(), y = c();
            return b(r) && (y = o([D([a, y]), a])), ["${", y, h, "}"];
          }
          function k(d, c) {
            return d.map((r) => _(r, c), "expressions");
          }
          function A(d, c) {
            return m(d, (r) => typeof r == "string" ? c ? r.replace(/(\\*)`/g, "$1$1\\`") : f(r) : r);
          }
          function f(d) {
            return d.replace(/([\\`]|\${)/g, "\\$1");
          }
          s.exports = { printTemplateLiteral: S, printTemplateExpressions: k, escapeTemplateCharacters: A, uncookTemplateElementValue: f };
        } }), $D = ee({ "src/language-js/embed/markdown.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { indent: t, softline: i, literalline: l, dedentToRoot: u } } = Le(), { escapeTemplateCharacters: n } = Pt();
          function a(D, F, h) {
            let p = D.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (N, b) => "\\".repeat(b.length / 2) + "`"), m = o(p), E = m !== "";
            E && (p = p.replace(new RegExp("^".concat(m), "gm"), ""));
            let P = n(h(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", E ? t([i, P]) : [l, u(P)], i, "`"];
          }
          function o(D) {
            let F = D.match(/^([^\S\n]*)\S/m);
            return F === null ? "" : F[1];
          }
          s.exports = a;
        } }), HD = ee({ "src/language-js/embed/css.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t } = Ge(), { builders: { indent: i, hardline: l, softline: u }, utils: { mapDoc: n, replaceEndOfLine: a, cleanDoc: o } } = Le(), { printTemplateExpressions: D } = Pt();
          function F(p, m, E) {
            let P = p.getValue(), N = P.quasis.map((_) => _.value.raw), b = 0, T = N.reduce((_, k, A) => A === 0 ? k : _ + "@prettier-placeholder-" + b++ + "-id" + k, ""), S = E(T, { parser: "scss" }, { stripTrailingHardline: true }), w = D(p, m);
            return h(S, P, w);
          }
          function h(p, m, E) {
            if (m.quasis.length === 1 && !m.quasis[0].value.raw.trim())
              return "``";
            let N = v(p, E);
            if (!N)
              throw new Error("Couldn't insert all the expressions");
            return ["`", i([l, N]), u, "`"];
          }
          function v(p, m) {
            if (!t(m))
              return p;
            let E = 0, P = n(o(p), (N) => typeof N != "string" || !N.includes("@prettier-placeholder") ? N : N.split(/@prettier-placeholder-(\d+)-id/).map((b, T) => T % 2 === 0 ? a(b) : (E++, m[b])));
            return m.length === E ? P : null;
          }
          s.exports = F;
        } }), GD = ee({ "src/language-js/embed/graphql.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { indent: t, join: i, hardline: l } } = Le(), { escapeTemplateCharacters: u, printTemplateExpressions: n } = Pt();
          function a(D, F, h) {
            let v = D.getValue(), p = v.quasis.length;
            if (p === 1 && v.quasis[0].value.raw.trim() === "")
              return "``";
            let m = n(D, F), E = [];
            for (let P = 0; P < p; P++) {
              let N = v.quasis[P], b = P === 0, T = P === p - 1, S = N.value.cooked, w = S.split(`
`), _ = w.length, k = m[P], A = _ > 2 && w[0].trim() === "" && w[1].trim() === "", f = _ > 2 && w[_ - 1].trim() === "" && w[_ - 2].trim() === "", d = w.every((r) => /^\s*(?:#[^\n\r]*)?$/.test(r));
              if (!T && /#[^\n\r]*$/.test(w[_ - 1]))
                return null;
              let c = null;
              d ? c = o(w) : c = h(S, { parser: "graphql" }, { stripTrailingHardline: true }), c ? (c = u(c, false), !b && A && E.push(""), E.push(c), !T && f && E.push("")) : !b && !T && A && E.push(""), k && E.push(k);
            }
            return ["`", t([l, i(l, E)]), l, "`"];
          }
          function o(D) {
            let F = [], h = false, v = D.map((p) => p.trim());
            for (let [p, m] of v.entries())
              m !== "" && (v[p - 1] === "" && h ? F.push([l, m]) : F.push(m), h = true);
            return F.length === 0 ? null : i(l, F);
          }
          s.exports = a;
        } }), JD = ee({ "src/language-js/embed/html.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { indent: t, line: i, hardline: l, group: u }, utils: { mapDoc: n } } = Le(), { printTemplateExpressions: a, uncookTemplateElementValue: o } = Pt(), D = 0;
          function F(h, v, p, m, E) {
            let { parser: P } = E, N = h.getValue(), b = D;
            D = D + 1 >>> 0;
            let T = (y) => "PRETTIER_HTML_PLACEHOLDER_".concat(y, "_").concat(b, "_IN_JS"), S = N.quasis.map((y, g, C) => g === C.length - 1 ? y.value.cooked : y.value.cooked + T(g)).join(""), w = a(h, v);
            if (w.length === 0 && S.trim().length === 0)
              return "``";
            let _ = new RegExp(T("(\\d+)"), "g"), k = 0, A = p(S, { parser: P, __onHtmlRoot(y) {
              k = y.children.length;
            } }, { stripTrailingHardline: true }), f = n(A, (y) => {
              if (typeof y != "string")
                return y;
              let g = [], C = y.split(_);
              for (let x = 0; x < C.length; x++) {
                let B = C[x];
                if (x % 2 === 0) {
                  B && (B = o(B), m.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), g.push(B));
                  continue;
                }
                let L = Number(B);
                g.push(w[L]);
              }
              return g;
            }), d = /^\s/.test(S) ? " " : "", c = /\s$/.test(S) ? " " : "", r = m.htmlWhitespaceSensitivity === "ignore" ? l : d && c ? i : null;
            return u(r ? ["`", t([r, u(f)]), r, "`"] : ["`", d, k > 1 ? t(u(f)) : u(f), c, "`"]);
          }
          s.exports = F;
        } }), UD = ee({ "src/language-js/embed.js"(e2, s) {
          "use strict";
          ae();
          var { hasComment: t, CommentCheckFlags: i, isObjectProperty: l } = Xe(), u = $D(), n = HD(), a = GD(), o = JD();
          function D(A) {
            if (v(A) || P(A) || N(A) || p(A))
              return "css";
            if (S(A))
              return "graphql";
            if (_(A))
              return "html";
            if (m(A))
              return "angular";
            if (h(A))
              return "markdown";
          }
          function F(A, f, d, c) {
            let r = A.getValue();
            if (r.type !== "TemplateLiteral" || k(r))
              return;
            let y = D(A);
            if (!!y) {
              if (y === "markdown")
                return u(A, f, d);
              if (y === "css")
                return n(A, f, d);
              if (y === "graphql")
                return a(A, f, d);
              if (y === "html" || y === "angular")
                return o(A, f, d, c, { parser: y });
            }
          }
          function h(A) {
            let f = A.getValue(), d = A.getParentNode();
            return d && d.type === "TaggedTemplateExpression" && f.quasis.length === 1 && d.tag.type === "Identifier" && (d.tag.name === "md" || d.tag.name === "markdown");
          }
          function v(A) {
            let f = A.getValue(), d = A.getParentNode(), c = A.getParentNode(1);
            return c && f.quasis && d.type === "JSXExpressionContainer" && c.type === "JSXElement" && c.openingElement.name.name === "style" && c.openingElement.attributes.some((r) => r.name.name === "jsx") || d && d.type === "TaggedTemplateExpression" && d.tag.type === "Identifier" && d.tag.name === "css" || d && d.type === "TaggedTemplateExpression" && d.tag.type === "MemberExpression" && d.tag.object.name === "css" && (d.tag.property.name === "global" || d.tag.property.name === "resolve");
          }
          function p(A) {
            return A.match((f) => f.type === "TemplateLiteral", (f, d) => f.type === "ArrayExpression" && d === "elements", (f, d) => l(f) && f.key.type === "Identifier" && f.key.name === "styles" && d === "value", ...E);
          }
          function m(A) {
            return A.match((f) => f.type === "TemplateLiteral", (f, d) => l(f) && f.key.type === "Identifier" && f.key.name === "template" && d === "value", ...E);
          }
          var E = [(A, f) => A.type === "ObjectExpression" && f === "properties", (A, f) => A.type === "CallExpression" && A.callee.type === "Identifier" && A.callee.name === "Component" && f === "arguments", (A, f) => A.type === "Decorator" && f === "expression"];
          function P(A) {
            let f = A.getParentNode();
            if (!f || f.type !== "TaggedTemplateExpression")
              return false;
            let d = f.tag.type === "ParenthesizedExpression" ? f.tag.expression : f.tag;
            switch (d.type) {
              case "MemberExpression":
                return b(d.object) || T(d);
              case "CallExpression":
                return b(d.callee) || d.callee.type === "MemberExpression" && (d.callee.object.type === "MemberExpression" && (b(d.callee.object.object) || T(d.callee.object)) || d.callee.object.type === "CallExpression" && b(d.callee.object.callee));
              case "Identifier":
                return d.name === "css";
              default:
                return false;
            }
          }
          function N(A) {
            let f = A.getParentNode(), d = A.getParentNode(1);
            return d && f.type === "JSXExpressionContainer" && d.type === "JSXAttribute" && d.name.type === "JSXIdentifier" && d.name.name === "css";
          }
          function b(A) {
            return A.type === "Identifier" && A.name === "styled";
          }
          function T(A) {
            return /^[A-Z]/.test(A.object.name) && A.property.name === "extend";
          }
          function S(A) {
            let f = A.getValue(), d = A.getParentNode();
            return w(f, "GraphQL") || d && (d.type === "TaggedTemplateExpression" && (d.tag.type === "MemberExpression" && d.tag.object.name === "graphql" && d.tag.property.name === "experimental" || d.tag.type === "Identifier" && (d.tag.name === "gql" || d.tag.name === "graphql")) || d.type === "CallExpression" && d.callee.type === "Identifier" && d.callee.name === "graphql");
          }
          function w(A, f) {
            return t(A, i.Block | i.Leading, (d) => {
              let { value: c } = d;
              return c === " ".concat(f, " ");
            });
          }
          function _(A) {
            return w(A.getValue(), "HTML") || A.match((f) => f.type === "TemplateLiteral", (f, d) => f.type === "TaggedTemplateExpression" && f.tag.type === "Identifier" && f.tag.name === "html" && d === "quasi");
          }
          function k(A) {
            let { quasis: f } = A;
            return f.some((d) => {
              let { value: { cooked: c } } = d;
              return c === null;
            });
          }
          s.exports = F;
        } }), zD = ee({ "src/language-js/clean.js"(e2, s) {
          "use strict";
          ae();
          var t = wt(), i = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), l = (n) => {
            for (let a of n.quasis)
              delete a.value;
          };
          function u(n, a, o) {
            if (n.type === "Program" && delete a.sourceType, (n.type === "BigIntLiteral" || n.type === "BigIntLiteralTypeAnnotation") && a.value && (a.value = a.value.toLowerCase()), (n.type === "BigIntLiteral" || n.type === "Literal") && a.bigint && (a.bigint = a.bigint.toLowerCase()), n.type === "DecimalLiteral" && (a.value = Number(a.value)), n.type === "Literal" && a.decimal && (a.decimal = Number(a.decimal)), n.type === "EmptyStatement" || n.type === "JSXText" || n.type === "JSXExpressionContainer" && (n.expression.type === "Literal" || n.expression.type === "StringLiteral") && n.expression.value === " ")
              return null;
            if ((n.type === "Property" || n.type === "ObjectProperty" || n.type === "MethodDefinition" || n.type === "ClassProperty" || n.type === "ClassMethod" || n.type === "PropertyDefinition" || n.type === "TSDeclareMethod" || n.type === "TSPropertySignature" || n.type === "ObjectTypeProperty") && typeof n.key == "object" && n.key && (n.key.type === "Literal" || n.key.type === "NumericLiteral" || n.key.type === "StringLiteral" || n.key.type === "Identifier") && delete a.key, n.type === "JSXElement" && n.openingElement.name.name === "style" && n.openingElement.attributes.some((F) => F.name.name === "jsx"))
              for (let { type: F, expression: h } of a.children)
                F === "JSXExpressionContainer" && h.type === "TemplateLiteral" && l(h);
            n.type === "JSXAttribute" && n.name.name === "css" && n.value.type === "JSXExpressionContainer" && n.value.expression.type === "TemplateLiteral" && l(a.value.expression), n.type === "JSXAttribute" && n.value && n.value.type === "Literal" && /["']|&quot;|&apos;/.test(n.value.value) && (a.value.value = a.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let D = n.expression || n.callee;
            if (n.type === "Decorator" && D.type === "CallExpression" && D.callee.name === "Component" && D.arguments.length === 1) {
              let F = n.expression.arguments[0].properties;
              for (let [h, v] of a.expression.arguments[0].properties.entries())
                switch (F[h].key.name) {
                  case "styles":
                    v.value.type === "ArrayExpression" && l(v.value.elements[0]);
                    break;
                  case "template":
                    v.value.type === "TemplateLiteral" && l(v.value);
                    break;
                }
            }
            if (n.type === "TaggedTemplateExpression" && (n.tag.type === "MemberExpression" || n.tag.type === "Identifier" && (n.tag.name === "gql" || n.tag.name === "graphql" || n.tag.name === "css" || n.tag.name === "md" || n.tag.name === "markdown" || n.tag.name === "html") || n.tag.type === "CallExpression") && l(a.quasi), n.type === "TemplateLiteral" && (n.leadingComments && n.leadingComments.some((h) => t(h) && ["GraphQL", "HTML"].some((v) => h.value === " ".concat(v, " "))) || o.type === "CallExpression" && o.callee.name === "graphql" || !n.leadingComments) && l(a), n.type === "InterpreterDirective" && (a.value = a.value.trimEnd()), (n.type === "TSIntersectionType" || n.type === "TSUnionType") && n.types.length === 1)
              return a.types[0];
          }
          u.ignoredProperties = i, s.exports = u;
        } }), Oi = {};
        li(Oi, { EOL: () => An, arch: () => XD, cpus: () => $i, default: () => zi, endianness: () => ji, freemem: () => Vi, getNetworkInterfaces: () => Ui, hostname: () => qi, loadavg: () => Mi, networkInterfaces: () => Ji, platform: () => KD, release: () => Gi, tmpDir: () => vn, tmpdir: () => Fn, totalmem: () => Wi, type: () => Hi, uptime: () => Ri });
        function ji() {
          if (typeof Cr > "u") {
            var e2 = new ArrayBuffer(2), s = new Uint8Array(e2), t = new Uint16Array(e2);
            if (s[0] = 1, s[1] = 2, t[0] === 258)
              Cr = "BE";
            else if (t[0] === 513)
              Cr = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Cr;
        }
        function qi() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Mi() {
          return [];
        }
        function Ri() {
          return 0;
        }
        function Vi() {
          return Number.MAX_VALUE;
        }
        function Wi() {
          return Number.MAX_VALUE;
        }
        function $i() {
          return [];
        }
        function Hi() {
          return "Browser";
        }
        function Gi() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function Ji() {
        }
        function Ui() {
        }
        function XD() {
          return "javascript";
        }
        function KD() {
          return "browser";
        }
        function vn() {
          return "/tmp";
        }
        var Cr, Fn, An, zi, YD = Tn({ "node-modules-polyfills:os"() {
          ae(), Fn = vn, An = `
`, zi = { EOL: An, tmpdir: Fn, tmpDir: vn, networkInterfaces: Ji, getNetworkInterfaces: Ui, release: Gi, type: Hi, cpus: $i, totalmem: Wi, freemem: Vi, uptime: Ri, loadavg: Mi, hostname: qi, endianness: ji };
        } }), QD = ee({ "node-modules-polyfills-commonjs:os"(e2, s) {
          ae();
          var t = (YD(), pi(Oi));
          if (t && t.default) {
            s.exports = t.default;
            for (let i in t)
              s.exports[i] = t[i];
          } else
            t && (s.exports = t);
        } }), ZD = ee({ "node_modules/detect-newline/index.js"(e2, s) {
          "use strict";
          ae();
          var t = (i) => {
            if (typeof i != "string")
              throw new TypeError("Expected a string");
            let l = i.match(/(?:\r?\n)/g) || [];
            if (l.length === 0)
              return;
            let u = l.filter((a) => a === `\r
`).length, n = l.length - u;
            return u > n ? `\r
` : `
`;
          };
          s.exports = t, s.exports.graceful = (i) => typeof i == "string" && t(i) || `
`;
        } }), em = ee({ "node_modules/jest-docblock/build/index.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.extract = p, e2.parse = E, e2.parseWithComments = P, e2.print = N, e2.strip = m;
          function s() {
            let T = QD();
            return s = function() {
              return T;
            }, T;
          }
          function t() {
            let T = i(ZD());
            return t = function() {
              return T;
            }, T;
          }
          function i(T) {
            return T && T.__esModule ? T : { default: T };
          }
          var l = /\*\/$/, u = /^\/\*\*/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a = /(^|\s+)\/\/([^\r\n]*)/g, o = /^(\r?\n)+/, D = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, F = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, v = [];
          function p(T) {
            let S = T.match(n);
            return S ? S[0].trimLeft() : "";
          }
          function m(T) {
            let S = T.match(n);
            return S && S[0] ? T.substring(S[0].length) : T;
          }
          function E(T) {
            return P(T).pragmas;
          }
          function P(T) {
            let S = (0, t().default)(T) || s().EOL;
            T = T.replace(u, "").replace(l, "").replace(h, "$1");
            let w = "";
            for (; w !== T; )
              w = T, T = T.replace(D, "".concat(S, "$1 $2").concat(S));
            T = T.replace(o, "").trimRight();
            let _ = /* @__PURE__ */ Object.create(null), k = T.replace(F, "").replace(o, "").trimRight(), A;
            for (; A = F.exec(T); ) {
              let f = A[2].replace(a, "");
              typeof _[A[1]] == "string" || Array.isArray(_[A[1]]) ? _[A[1]] = v.concat(_[A[1]], f) : _[A[1]] = f;
            }
            return { comments: k, pragmas: _ };
          }
          function N(T) {
            let { comments: S = "", pragmas: w = {} } = T, _ = (0, t().default)(S) || s().EOL, k = "/**", A = " *", f = " */", d = Object.keys(w), c = d.map((y) => b(y, w[y])).reduce((y, g) => y.concat(g), []).map((y) => A + " " + y + _).join("");
            if (!S) {
              if (d.length === 0)
                return "";
              if (d.length === 1 && !Array.isArray(w[d[0]])) {
                let y = w[d[0]];
                return "".concat(k, " ").concat(b(d[0], y)[0]).concat(f);
              }
            }
            let r = S.split(_).map((y) => "".concat(A, " ").concat(y)).join(_) + _;
            return k + _ + (S ? r : "") + (S && d.length ? A + _ : "") + c + f;
          }
          function b(T, S) {
            return v.concat(S).map((w) => "@".concat(T, " ").concat(w).trim());
          }
        } }), tm = ee({ "src/language-js/utils/get-shebang.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            if (!i.startsWith("#!"))
              return "";
            let l = i.indexOf(`
`);
            return l === -1 ? i : i.slice(0, l);
          }
          s.exports = t;
        } }), Xi = ee({ "src/language-js/pragma.js"(e2, s) {
          "use strict";
          ae();
          var { parseWithComments: t, strip: i, extract: l, print: u } = em(), { normalizeEndOfLine: n } = Nn(), a = tm();
          function o(h) {
            let v = a(h);
            v && (h = h.slice(v.length + 1));
            let p = l(h), { pragmas: m, comments: E } = t(p);
            return { shebang: v, text: h, pragmas: m, comments: E };
          }
          function D(h) {
            let v = Object.keys(o(h).pragmas);
            return v.includes("prettier") || v.includes("format");
          }
          function F(h) {
            let { shebang: v, text: p, pragmas: m, comments: E } = o(h), P = i(p), N = u({ pragmas: Object.assign({ format: "" }, m), comments: E.trimStart() });
            return (v ? "".concat(v, `
`) : "") + n(N) + (P.startsWith(`
`) ? `
` : `

`) + P;
          }
          s.exports = { hasPragma: D, insertPragma: F };
        } }), Ki = ee({ "src/language-js/comments.js"(e2, s) {
          "use strict";
          ae();
          var { getLast: t, hasNewline: i, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: l, getNextNonSpaceNonCommentCharacter: u, hasNewlineInRange: n, addLeadingComment: a, addTrailingComment: o, addDanglingComment: D, getNextNonSpaceNonCommentCharacterIndex: F, isNonEmptyArray: h } = Ge(), { getFunctionParameters: v, isPrettierIgnoreComment: p, isJsxNode: m, hasFlowShorthandAnnotationComment: E, hasFlowAnnotationComment: P, hasIgnoreComment: N, isCallLikeExpression: b, getCallArguments: T, isCallExpression: S, isMemberExpression: w, isObjectProperty: _, isLineComment: k, getComments: A, CommentCheckFlags: f, markerForIfWithoutBlockAndSameLineComment: d } = Xe(), { locStart: c, locEnd: r } = nt(), y = wt();
          function g(X) {
            return [fe, V, G, j, H, I, $, oe, de, le, Q, ge, ve, te, K, Ee].some((Y) => Y(X));
          }
          function C(X) {
            return [M, V, Z, oe, j, H, I, $, K, R, ue, Q, be, Ee, me].some((Y) => Y(X));
          }
          function x(X) {
            return [fe, j, H, W, se, te, Q, ne, U, pe, Ee, we].some((Y) => Y(X));
          }
          function B(X, Y) {
            let re = (X.body || X.properties).find((z) => {
              let { type: q } = z;
              return q !== "EmptyStatement";
            });
            re ? a(re, Y) : D(X, Y);
          }
          function L(X, Y) {
            X.type === "BlockStatement" ? B(X, Y) : a(X, Y);
          }
          function M(X) {
            let { comment: Y, followingNode: re } = X;
            return re && J(Y) ? (a(re, Y), true) : false;
          }
          function j(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q, text: Ce } = X;
            if (!z || z.type !== "IfStatement" || !q)
              return false;
            if (u(Ce, Y, r) === ")")
              return o(re, Y), true;
            if (re === z.consequent && q === z.alternate) {
              if (re.type === "BlockStatement")
                o(re, Y);
              else {
                let je = Y.type === "SingleLine" || Y.loc.start.line === Y.loc.end.line, Ue = Y.loc.start.line === re.loc.start.line;
                je && Ue ? D(re, Y, d) : D(z, Y);
              }
              return true;
            }
            return q.type === "BlockStatement" ? (B(q, Y), true) : q.type === "IfStatement" ? (L(q.consequent, Y), true) : z.consequent === q ? (a(q, Y), true) : false;
          }
          function H(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q, text: Ce } = X;
            return !z || z.type !== "WhileStatement" || !q ? false : u(Ce, Y, r) === ")" ? (o(re, Y), true) : q.type === "BlockStatement" ? (B(q, Y), true) : z.body === q ? (a(q, Y), true) : false;
          }
          function I(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q } = X;
            return !z || z.type !== "TryStatement" && z.type !== "CatchClause" || !q ? false : z.type === "CatchClause" && re ? (o(re, Y), true) : q.type === "BlockStatement" ? (B(q, Y), true) : q.type === "TryStatement" ? (L(q.finalizer, Y), true) : q.type === "CatchClause" ? (L(q.body, Y), true) : false;
          }
          function G(X) {
            let { comment: Y, enclosingNode: re, followingNode: z } = X;
            return w(re) && z && z.type === "Identifier" ? (a(re, Y), true) : false;
          }
          function Z(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q, text: Ce } = X, Ne = re && !n(Ce, r(re), c(Y));
            return (!re || !Ne) && z && (z.type === "ConditionalExpression" || z.type === "TSConditionalType") && q ? (a(q, Y), true) : false;
          }
          function W(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z } = X;
            return _(z) && z.shorthand && z.key === re && z.value.type === "AssignmentPattern" ? (o(z.value.left, Y), true) : false;
          }
          function $(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q } = X;
            if (z && (z.type === "ClassDeclaration" || z.type === "ClassExpression" || z.type === "DeclareClass" || z.type === "DeclareInterface" || z.type === "InterfaceDeclaration" || z.type === "TSInterfaceDeclaration")) {
              if (h(z.decorators) && !(q && q.type === "Decorator"))
                return o(t(z.decorators), Y), true;
              if (z.body && q === z.body)
                return B(z.body, Y), true;
              if (q) {
                if (z.superClass && q === z.superClass && re && (re === z.id || re === z.typeParameters))
                  return o(re, Y), true;
                for (let Ce of ["implements", "extends", "mixins"])
                  if (z[Ce] && q === z[Ce][0])
                    return re && (re === z.id || re === z.typeParameters || re === z.superClass) ? o(re, Y) : D(z, Y, Ce), true;
              }
            }
            return false;
          }
          function te(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, text: q } = X;
            return z && re && u(q, Y, r) === "(" && (z.type === "Property" || z.type === "TSDeclareMethod" || z.type === "TSAbstractMethodDefinition") && re.type === "Identifier" && z.key === re && u(q, re, r) !== ":" || re && z && re.type === "Decorator" && (z.type === "ClassMethod" || z.type === "ClassProperty" || z.type === "PropertyDefinition" || z.type === "TSAbstractPropertyDefinition" || z.type === "TSAbstractMethodDefinition" || z.type === "TSDeclareMethod" || z.type === "MethodDefinition") ? (o(re, Y), true) : false;
          }
          function U(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, text: q } = X;
            return u(q, Y, r) !== "(" ? false : re && z && (z.type === "FunctionDeclaration" || z.type === "FunctionExpression" || z.type === "ClassMethod" || z.type === "MethodDefinition" || z.type === "ObjectMethod") ? (o(re, Y), true) : false;
          }
          function ne(X) {
            let { comment: Y, enclosingNode: re, text: z } = X;
            if (!(re && re.type === "ArrowFunctionExpression"))
              return false;
            let q = F(z, Y, r);
            return q !== false && z.slice(q, q + 2) === "=>" ? (D(re, Y), true) : false;
          }
          function se(X) {
            let { comment: Y, enclosingNode: re, text: z } = X;
            return u(z, Y, r) !== ")" ? false : re && (ce(re) && v(re).length === 0 || b(re) && T(re).length === 0) ? (D(re, Y), true) : re && (re.type === "MethodDefinition" || re.type === "TSAbstractMethodDefinition") && v(re.value).length === 0 ? (D(re.value, Y), true) : false;
          }
          function V(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q, text: Ce } = X;
            if (re && re.type === "FunctionTypeParam" && z && z.type === "FunctionTypeAnnotation" && q && q.type !== "FunctionTypeParam" || re && (re.type === "Identifier" || re.type === "AssignmentPattern") && z && ce(z) && u(Ce, Y, r) === ")")
              return o(re, Y), true;
            if (z && z.type === "FunctionDeclaration" && q && q.type === "BlockStatement") {
              let Ne = (() => {
                let je = v(z);
                if (je.length > 0)
                  return l(Ce, r(t(je)));
                let Ue = l(Ce, r(z.id));
                return Ue !== false && l(Ce, Ue + 1);
              })();
              if (c(Y) > Ne)
                return B(q, Y), true;
            }
            return false;
          }
          function oe(X) {
            let { comment: Y, enclosingNode: re } = X;
            return re && re.type === "ImportSpecifier" ? (a(re, Y), true) : false;
          }
          function K(X) {
            let { comment: Y, enclosingNode: re } = X;
            return re && re.type === "LabeledStatement" ? (a(re, Y), true) : false;
          }
          function Ee(X) {
            let { comment: Y, enclosingNode: re } = X;
            return re && (re.type === "ContinueStatement" || re.type === "BreakStatement") && !re.label ? (o(re, Y), true) : false;
          }
          function R(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z } = X;
            return S(z) && re && z.callee === re && z.arguments.length > 0 ? (a(z.arguments[0], Y), true) : false;
          }
          function le(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q } = X;
            return z && (z.type === "UnionTypeAnnotation" || z.type === "TSUnionType") ? (p(Y) && (q.prettierIgnore = true, Y.unignore = true), re ? (o(re, Y), true) : false) : (q && (q.type === "UnionTypeAnnotation" || q.type === "TSUnionType") && p(Y) && (q.types[0].prettierIgnore = true, Y.unignore = true), false);
          }
          function ue(X) {
            let { comment: Y, enclosingNode: re } = X;
            return _(re) ? (a(re, Y), true) : false;
          }
          function Q(X) {
            let { comment: Y, enclosingNode: re, followingNode: z, ast: q, isLastComment: Ce } = X;
            return q && q.body && q.body.length === 0 ? (Ce ? D(q, Y) : a(q, Y), true) : re && re.type === "Program" && re.body.length === 0 && !h(re.directives) ? (Ce ? D(re, Y) : a(re, Y), true) : z && z.type === "Program" && z.body.length === 0 && re && re.type === "ModuleExpression" ? (D(z, Y), true) : false;
          }
          function de(X) {
            let { comment: Y, enclosingNode: re } = X;
            return re && (re.type === "ForInStatement" || re.type === "ForOfStatement") ? (a(re, Y), true) : false;
          }
          function ge(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, text: q } = X;
            return re && re.type === "ImportSpecifier" && z && z.type === "ImportDeclaration" && i(q, r(Y)) ? (o(re, Y), true) : false;
          }
          function ve(X) {
            let { comment: Y, enclosingNode: re } = X;
            return re && re.type === "AssignmentPattern" ? (a(re, Y), true) : false;
          }
          function be(X) {
            let { comment: Y, enclosingNode: re, followingNode: z } = X;
            return re && (re.type === "VariableDeclarator" || re.type === "AssignmentExpression" || re.type === "TypeAlias" || re.type === "TSTypeAliasDeclaration") && z && (z.type === "ObjectExpression" || z.type === "ArrayExpression" || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "ObjectTypeAnnotation" || z.type === "TSTypeLiteral" || y(Y)) ? (a(z, Y), true) : false;
          }
          function we(X) {
            let { comment: Y, enclosingNode: re, followingNode: z, text: q } = X;
            return !z && re && (re.type === "TSMethodSignature" || re.type === "TSDeclareFunction" || re.type === "TSAbstractMethodDefinition") && u(q, Y, r) === ";" ? (o(re, Y), true) : false;
          }
          function fe(X) {
            let { comment: Y, enclosingNode: re, followingNode: z } = X;
            if (p(Y) && re && re.type === "TSMappedType" && z && z.type === "TSTypeParameter" && z.constraint)
              return re.prettierIgnore = true, Y.unignore = true, true;
          }
          function pe(X) {
            let { comment: Y, precedingNode: re, enclosingNode: z, followingNode: q } = X;
            return !z || z.type !== "TSMappedType" ? false : q && q.type === "TSTypeParameter" && q.name ? (a(q.name, Y), true) : re && re.type === "TSTypeParameter" && re.constraint ? (o(re.constraint, Y), true) : false;
          }
          function me(X) {
            let { comment: Y, enclosingNode: re, followingNode: z } = X;
            return !re || re.type !== "SwitchCase" || re.test ? false : (z.type === "BlockStatement" && k(Y) ? B(z, Y) : D(re, Y), true);
          }
          function ce(X) {
            return X.type === "ArrowFunctionExpression" || X.type === "FunctionExpression" || X.type === "FunctionDeclaration" || X.type === "ObjectMethod" || X.type === "ClassMethod" || X.type === "TSDeclareFunction" || X.type === "TSCallSignatureDeclaration" || X.type === "TSConstructSignatureDeclaration" || X.type === "TSMethodSignature" || X.type === "TSConstructorType" || X.type === "TSFunctionType" || X.type === "TSDeclareMethod";
          }
          function he(X, Y) {
            if ((Y.parser === "typescript" || Y.parser === "flow" || Y.parser === "acorn" || Y.parser === "espree" || Y.parser === "meriyah" || Y.parser === "__babel_estree") && X.type === "MethodDefinition" && X.value && X.value.type === "FunctionExpression" && v(X.value).length === 0 && !X.value.returnType && !h(X.value.typeParameters) && X.value.body)
              return [...X.decorators || [], X.key, X.value.body];
          }
          function J(X) {
            return y(X) && X.value[0] === "*" && /@type\b/.test(X.value);
          }
          function ye(X) {
            let Y = X.getValue(), re = X.getParentNode(), z = (q) => P(A(q, f.Leading)) || P(A(q, f.Trailing));
            return (Y && (m(Y) || E(Y) || S(re) && z(Y)) || re && (re.type === "JSXSpreadAttribute" || re.type === "JSXSpreadChild" || re.type === "UnionTypeAnnotation" || re.type === "TSUnionType" || (re.type === "ClassDeclaration" || re.type === "ClassExpression") && re.superClass === Y)) && (!N(X) || re.type === "UnionTypeAnnotation" || re.type === "TSUnionType");
          }
          s.exports = { handleOwnLineComment: g, handleEndOfLineComment: C, handleRemainingComment: x, isTypeCastComment: J, getCommentChildNodes: he, willPrintOwnComments: ye };
        } }), _t = ee({ "src/language-js/needs-parens.js"(e2, s) {
          "use strict";
          ae();
          var t = st(), i = In(), { getFunctionParameters: l, getLeftSidePathName: u, hasFlowShorthandAnnotationComment: n, hasNakedLeftSide: a, hasNode: o, isBitwiseOperator: D, startsWithNoLookaheadToken: F, shouldFlatten: h, getPrecedence: v, isCallExpression: p, isMemberExpression: m, isObjectProperty: E } = Xe();
          function P(k, A) {
            let f = k.getParentNode();
            if (!f)
              return false;
            let d = k.getName(), c = k.getNode();
            if (A.__isInHtmlInterpolation && !A.bracketSpacing && S(c) && w(k))
              return true;
            if (N(c))
              return false;
            if (A.parser !== "flow" && n(k.getValue()))
              return true;
            if (c.type === "Identifier")
              return !!(c.extra && c.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(c.name) || d === "left" && c.name === "async" && f.type === "ForOfStatement" && !f.await);
            switch (f.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (d === "superClass" && (c.type === "ArrowFunctionExpression" || c.type === "AssignmentExpression" || c.type === "AwaitExpression" || c.type === "BinaryExpression" || c.type === "ConditionalExpression" || c.type === "LogicalExpression" || c.type === "NewExpression" || c.type === "ObjectExpression" || c.type === "SequenceExpression" || c.type === "TaggedTemplateExpression" || c.type === "UnaryExpression" || c.type === "UpdateExpression" || c.type === "YieldExpression" || c.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return _(k, A) || c.type === "SequenceExpression";
              case "Decorator": {
                if (d === "expression") {
                  let r = false, y = false, g = c;
                  for (; g; )
                    switch (g.type) {
                      case "MemberExpression":
                        y = true, g = g.object;
                        break;
                      case "CallExpression":
                        if (y || r)
                          return A.parser !== "typescript";
                        r = true, g = g.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return A.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ExpressionStatement": {
                if (F(c, true))
                  return true;
                break;
              }
              case "ArrowFunctionExpression": {
                if (d === "body" && c.type !== "SequenceExpression" && F(c, false))
                  return true;
                break;
              }
            }
            switch (c.type) {
              case "UpdateExpression":
                if (f.type === "UnaryExpression")
                  return c.prefix && (c.operator === "++" && f.operator === "+" || c.operator === "--" && f.operator === "-");
              case "UnaryExpression":
                switch (f.type) {
                  case "UnaryExpression":
                    return c.operator === f.operator && (c.operator === "+" || c.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return d === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "BinaryExpression":
                    return d === "left" && f.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (f.type === "UpdateExpression" || c.operator === "in" && b(k))
                  return true;
                if (c.operator === "|>" && c.extra && c.extra.parenthesized) {
                  let r = k.getParentNode(1);
                  if (r.type === "BinaryExpression" && r.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "LogicalExpression":
                switch (f.type) {
                  case "TSAsExpression":
                    return c.type !== "TSAsExpression";
                  case "ConditionalExpression":
                    return c.type === "TSAsExpression";
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return d === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return d === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return d === "left" && (c.type === "TSTypeAssertion" || c.type === "TSAsExpression");
                  case "LogicalExpression":
                    if (c.type === "LogicalExpression")
                      return f.operator !== c.operator;
                  case "BinaryExpression": {
                    let { operator: r, type: y } = c;
                    if (!r && y !== "TSTypeAssertion")
                      return true;
                    let g = v(r), C = f.operator, x = v(C);
                    return x > g || d === "right" && x === g || x === g && !h(C, r) ? true : x < g && r === "%" ? C === "+" || C === "-" : !!D(C);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (f.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return d !== "expression";
                  case "ArrowFunctionExpression":
                    return d !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (f.type === "UnaryExpression" || f.type === "AwaitExpression" || f.type === "TSAsExpression" || f.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (f.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return d === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "ConditionalExpression":
                    return d === "test";
                  case "BinaryExpression":
                    return !(!c.argument && f.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
                if (d === "extendsType" && f.type === "TSConditionalType")
                  return true;
              case "TSFunctionType":
              case "TSConstructorType":
                if (d === "checkType" && f.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((f.type === "TSUnionType" || f.type === "TSIntersectionType") && f.types.length > 1 && (!c.types || c.types.length > 1))
                  return true;
              case "TSInferType":
                if (c.type === "TSInferType" && f.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return f.type === "TSArrayType" || f.type === "TSOptionalType" || f.type === "TSRestType" || d === "objectType" && f.type === "TSIndexedAccessType" || f.type === "TSTypeOperator" || f.type === "TSTypeAnnotation" && k.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return f.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return f.type === "ArrayTypeAnnotation" || f.type === "NullableTypeAnnotation" || f.type === "IntersectionTypeAnnotation" || f.type === "UnionTypeAnnotation" || d === "objectType" && (f.type === "IndexedAccessType" || f.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return f.type === "ArrayTypeAnnotation" || d === "objectType" && (f.type === "IndexedAccessType" || f.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let r = f.type === "NullableTypeAnnotation" ? k.getParentNode(1) : f;
                return r.type === "UnionTypeAnnotation" || r.type === "IntersectionTypeAnnotation" || r.type === "ArrayTypeAnnotation" || d === "objectType" && (r.type === "IndexedAccessType" || r.type === "OptionalIndexedAccessType") || r.type === "NullableTypeAnnotation" || f.type === "FunctionTypeParam" && f.name === null && l(c).some((y) => y.typeAnnotation && y.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return d === "objectType" && f.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return d === "objectType" && (f.type === "IndexedAccessType" || f.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof c.value == "string" && f.type === "ExpressionStatement" && !f.directive) {
                  let r = k.getParentNode(1);
                  return r.type === "Program" || r.type === "BlockStatement";
                }
                return d === "object" && f.type === "MemberExpression" && typeof c.value == "number";
              case "AssignmentExpression": {
                let r = k.getParentNode(1);
                return d === "body" && f.type === "ArrowFunctionExpression" ? true : d === "key" && (f.type === "ClassProperty" || f.type === "PropertyDefinition") && f.computed || (d === "init" || d === "update") && f.type === "ForStatement" ? false : f.type === "ExpressionStatement" ? c.left.type === "ObjectPattern" : !(d === "key" && f.type === "TSPropertySignature" || f.type === "AssignmentExpression" || f.type === "SequenceExpression" && r && r.type === "ForStatement" && (r.init === f || r.update === f) || d === "value" && f.type === "Property" && r && r.type === "ObjectPattern" && r.properties.includes(f) || f.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (f.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "ConditionalExpression":
                    return d === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return d === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (f.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (f.type) {
                  case "BinaryExpression":
                    return f.operator !== "|>" || c.extra && c.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return d === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return d === "object";
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return d === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (i(c.decorators))
                  return true;
                switch (f.type) {
                  case "NewExpression":
                    return d === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let r = k.getParentNode(1);
                if (d === "object" && f.type === "MemberExpression" || d === "callee" && (f.type === "CallExpression" || f.type === "NewExpression") || f.type === "TSNonNullExpression" && r.type === "MemberExpression" && r.object === f)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (d === "callee" && (f.type === "BindExpression" || f.type === "NewExpression")) {
                  let r = c;
                  for (; r; )
                    switch (r.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        r = r.object;
                        break;
                      case "TaggedTemplateExpression":
                        r = r.tag;
                        break;
                      case "TSNonNullExpression":
                        r = r.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return d === "callee" && (f.type === "BindExpression" || f.type === "NewExpression") || d === "object" && m(f);
              case "NGPipeExpression":
                return !(f.type === "NGRoot" || f.type === "NGMicrosyntaxExpression" || f.type === "ObjectProperty" && !(c.extra && c.extra.parenthesized) || f.type === "ArrayExpression" || p(f) && f.arguments[d] === c || d === "right" && f.type === "NGPipeExpression" || d === "property" && f.type === "MemberExpression" || f.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return d === "callee" || d === "left" && f.type === "BinaryExpression" && f.operator === "<" || f.type !== "ArrayExpression" && f.type !== "ArrowFunctionExpression" && f.type !== "AssignmentExpression" && f.type !== "AssignmentPattern" && f.type !== "BinaryExpression" && f.type !== "NewExpression" && f.type !== "ConditionalExpression" && f.type !== "ExpressionStatement" && f.type !== "JsExpressionRoot" && f.type !== "JSXAttribute" && f.type !== "JSXElement" && f.type !== "JSXExpressionContainer" && f.type !== "JSXFragment" && f.type !== "LogicalExpression" && !p(f) && !E(f) && f.type !== "ReturnStatement" && f.type !== "ThrowStatement" && f.type !== "TypeCastExpression" && f.type !== "VariableDeclarator" && f.type !== "YieldExpression";
              case "TypeAnnotation":
                return d === "returnType" && f.type === "ArrowFunctionExpression" && T(c);
            }
            return false;
          }
          function N(k) {
            return k.type === "BlockStatement" || k.type === "BreakStatement" || k.type === "ClassBody" || k.type === "ClassDeclaration" || k.type === "ClassMethod" || k.type === "ClassProperty" || k.type === "PropertyDefinition" || k.type === "ClassPrivateProperty" || k.type === "ContinueStatement" || k.type === "DebuggerStatement" || k.type === "DeclareClass" || k.type === "DeclareExportAllDeclaration" || k.type === "DeclareExportDeclaration" || k.type === "DeclareFunction" || k.type === "DeclareInterface" || k.type === "DeclareModule" || k.type === "DeclareModuleExports" || k.type === "DeclareVariable" || k.type === "DoWhileStatement" || k.type === "EnumDeclaration" || k.type === "ExportAllDeclaration" || k.type === "ExportDefaultDeclaration" || k.type === "ExportNamedDeclaration" || k.type === "ExpressionStatement" || k.type === "ForInStatement" || k.type === "ForOfStatement" || k.type === "ForStatement" || k.type === "FunctionDeclaration" || k.type === "IfStatement" || k.type === "ImportDeclaration" || k.type === "InterfaceDeclaration" || k.type === "LabeledStatement" || k.type === "MethodDefinition" || k.type === "ReturnStatement" || k.type === "SwitchStatement" || k.type === "ThrowStatement" || k.type === "TryStatement" || k.type === "TSDeclareFunction" || k.type === "TSEnumDeclaration" || k.type === "TSImportEqualsDeclaration" || k.type === "TSInterfaceDeclaration" || k.type === "TSModuleDeclaration" || k.type === "TSNamespaceExportDeclaration" || k.type === "TypeAlias" || k.type === "VariableDeclaration" || k.type === "WhileStatement" || k.type === "WithStatement";
          }
          function b(k) {
            let A = 0, f = k.getValue();
            for (; f; ) {
              let d = k.getParentNode(A++);
              if (d && d.type === "ForStatement" && d.init === f)
                return true;
              f = d;
            }
            return false;
          }
          function T(k) {
            return o(k, (A) => A.type === "ObjectTypeAnnotation" && o(A, (f) => f.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function S(k) {
            switch (k.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function w(k) {
            let A = k.getValue(), f = k.getParentNode(), d = k.getName();
            switch (f.type) {
              case "NGPipeExpression":
                if (typeof d == "number" && f.arguments[d] === A && f.arguments.length - 1 === d)
                  return k.callParent(w);
                break;
              case "ObjectProperty":
                if (d === "value") {
                  let c = k.getParentNode(1);
                  return t(c.properties) === f;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (d === "right")
                  return k.callParent(w);
                break;
              case "ConditionalExpression":
                if (d === "alternate")
                  return k.callParent(w);
                break;
              case "UnaryExpression":
                if (f.prefix)
                  return k.callParent(w);
                break;
            }
            return false;
          }
          function _(k, A) {
            let f = k.getValue(), d = k.getParentNode();
            return f.type === "FunctionExpression" || f.type === "ClassExpression" ? d.type === "ExportDefaultDeclaration" || !P(k, A) : !a(f) || d.type !== "ExportDefaultDeclaration" && P(k, A) ? false : k.call((c) => _(c, A), ...u(k, f));
          }
          s.exports = P;
        } }), Yi = ee({ "src/language-js/print-preprocess.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l) {
            switch (l.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
                return Object.assign(Object.assign({}, i), {}, { type: l.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: i, comments: [], rootMarker: l.rootMarker });
              default:
                return i;
            }
          }
          s.exports = t;
        } }), rm = ee({ "src/language-js/print/html-binding.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { join: t, line: i, group: l, softline: u, indent: n } } = Le();
          function a(D, F, h) {
            let v = D.getValue();
            if (F.__onHtmlBindingRoot && D.getName() === null && F.__onHtmlBindingRoot(v, F), v.type === "File") {
              if (F.__isVueForBindingLeft)
                return D.call((p) => {
                  let m = t([",", i], p.map(h, "params")), { params: E } = p.getValue();
                  return E.length === 1 ? m : ["(", n([u, l(m)]), u, ")"];
                }, "program", "body", 0);
              if (F.__isVueBindings)
                return D.call((p) => t([",", i], p.map(h, "params")), "program", "body", 0);
            }
          }
          function o(D) {
            switch (D.type) {
              case "MemberExpression":
                switch (D.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return o(D.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          s.exports = { isVueEventBindingExpression: o, printHtmlBinding: a };
        } }), Mn = ee({ "src/language-js/print/binaryish.js"(e2, s) {
          "use strict";
          ae();
          var { printComments: t } = Qe(), { getLast: i } = Ge(), { builders: { join: l, line: u, softline: n, group: a, indent: o, align: D, ifBreak: F, indentIfBreak: h }, utils: { cleanDoc: v, getDocParts: p, isConcat: m } } = Le(), { hasLeadingOwnLineComment: E, isBinaryish: P, isJsxNode: N, shouldFlatten: b, hasComment: T, CommentCheckFlags: S, isCallExpression: w, isMemberExpression: _, isObjectProperty: k, isEnabledHackPipeline: A } = Xe(), f = 0;
          function d(y, g, C) {
            let x = y.getValue(), B = y.getParentNode(), L = y.getParentNode(1), M = x !== B.body && (B.type === "IfStatement" || B.type === "WhileStatement" || B.type === "SwitchStatement" || B.type === "DoWhileStatement"), j = A(g) && x.operator === "|>", H = c(y, C, g, false, M);
            if (M)
              return H;
            if (j)
              return a(H);
            if (w(B) && B.callee === x || B.type === "UnaryExpression" || _(B) && !B.computed)
              return a([o([n, ...H]), n]);
            let I = B.type === "ReturnStatement" || B.type === "ThrowStatement" || B.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x.operator !== "|" && B.type === "JsExpressionRoot" || x.type !== "NGPipeExpression" && (B.type === "NGRoot" && g.parser === "__ng_binding" || B.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x === B.body && B.type === "ArrowFunctionExpression" || x !== B.body && B.type === "ForStatement" || B.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !w(L) || B.type === "TemplateLiteral", G = B.type === "AssignmentExpression" || B.type === "VariableDeclarator" || B.type === "ClassProperty" || B.type === "PropertyDefinition" || B.type === "TSAbstractPropertyDefinition" || B.type === "ClassPrivateProperty" || k(B), Z = P(x.left) && b(x.operator, x.left.operator);
            if (I || r(x) && !Z || !r(x) && G)
              return a(H);
            if (H.length === 0)
              return "";
            let W = N(x.right), $ = H.findIndex((oe) => typeof oe != "string" && !Array.isArray(oe) && oe.type === "group"), te = H.slice(0, $ === -1 ? 1 : $ + 1), U = H.slice(te.length, W ? -1 : void 0), ne = Symbol("logicalChain-" + ++f), se = a([...te, o(U)], { id: ne });
            if (!W)
              return se;
            let V = i(H);
            return a([se, h(V, { groupId: ne })]);
          }
          function c(y, g, C, x, B) {
            let L = y.getValue();
            if (!P(L))
              return [a(g())];
            let M = [];
            b(L.operator, L.left.operator) ? M = y.call((U) => c(U, g, C, true, B), "left") : M.push(a(g("left")));
            let j = r(L), H = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && C.parser === "__vue_expression") && !E(C.originalText, L.right), I = L.type === "NGPipeExpression" ? "|" : L.operator, G = L.type === "NGPipeExpression" && L.arguments.length > 0 ? a(o([n, ": ", l([n, ":", F(" ")], y.map(g, "arguments").map((U) => D(2, a(U))))])) : "", Z;
            if (j)
              Z = [I, " ", g("right"), G];
            else {
              let ne = A(C) && I === "|>" ? y.call((se) => c(se, g, C, true, B), "right") : g("right");
              Z = [H ? u : "", I, H ? " " : u, ne, G];
            }
            let W = y.getParentNode(), $ = T(L.left, S.Trailing | S.Line), te = $ || !(B && L.type === "LogicalExpression") && W.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
            if (M.push(H ? "" : " ", te ? a(Z, { shouldBreak: $ }) : Z), x && T(L)) {
              let U = v(t(y, M, C));
              return m(U) || U.type === "fill" ? p(U) : [U];
            }
            return M;
          }
          function r(y) {
            return y.type !== "LogicalExpression" ? false : !!(y.right.type === "ObjectExpression" && y.right.properties.length > 0 || y.right.type === "ArrayExpression" && y.right.elements.length > 0 || N(y.right));
          }
          s.exports = { printBinaryishExpression: d, shouldInlineLogicalExpression: r };
        } }), nm = ee({ "src/language-js/print/angular.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { join: t, line: i, group: l } } = Le(), { hasNode: u, hasComment: n, getComments: a } = Xe(), { printBinaryishExpression: o } = Mn();
          function D(v, p, m) {
            let E = v.getValue();
            if (!!E.type.startsWith("NG"))
              switch (E.type) {
                case "NGRoot":
                  return [m("node"), n(E.node) ? " //" + a(E.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return o(v, p, m);
                case "NGChainedExpression":
                  return l(t([";", i], v.map((P) => h(P) ? m() : ["(", m(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [E.prefix, ": ", E.value.trim()];
                case "NGMicrosyntax":
                  return v.map((P, N) => [N === 0 ? "" : F(P.getValue(), N, E) ? " " : [";", i], m()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(E.name) ? E.name : JSON.stringify(E.name);
                case "NGMicrosyntaxExpression":
                  return [m("expression"), E.alias === null ? "" : [" as ", m("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let P = v.getName(), N = v.getParentNode(), b = F(E, P, N) || (P === 1 && (E.key.name === "then" || E.key.name === "else") || P === 2 && E.key.name === "else" && N.body[P - 1].type === "NGMicrosyntaxKeyedExpression" && N.body[P - 1].key.name === "then") && N.body[0].type === "NGMicrosyntaxExpression";
                  return [m("key"), b ? " " : ": ", m("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", m("key"), E.value === null ? "" : [" = ", m("value")]];
                case "NGMicrosyntaxAs":
                  return [m("key"), " as ", m("alias")];
                default:
                  throw new Error("Unknown Angular node type: ".concat(JSON.stringify(E.type), "."));
              }
          }
          function F(v, p, m) {
            return v.type === "NGMicrosyntaxKeyedExpression" && v.key.name === "of" && p === 1 && m.body[0].type === "NGMicrosyntaxLet" && m.body[0].value === null;
          }
          function h(v) {
            return u(v.getValue(), (p) => {
              switch (p.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          s.exports = { printAngular: D };
        } }), um = ee({ "src/language-js/print/jsx.js"(e2, s) {
          "use strict";
          ae();
          var { printComments: t, printDanglingComments: i } = Qe(), { builders: { line: l, hardline: u, softline: n, group: a, indent: o, conditionalGroup: D, fill: F, ifBreak: h, lineSuffixBoundary: v, join: p }, utils: { willBreak: m } } = Le(), { getLast: E, getPreferredQuote: P } = Ge(), { isJsxNode: N, rawText: b, isLiteral: T, isCallExpression: S, isStringLiteral: w, isBinaryish: _, hasComment: k, CommentCheckFlags: A, hasNodeIgnoreComment: f } = Xe(), d = _t(), { willPrintOwnComments: c } = Ki(), r = (R) => R === "" || R === l || R === u || R === n;
          function y(R, le, ue) {
            let Q = R.getValue();
            if (Q.type === "JSXElement" && V(Q))
              return [ue("openingElement"), ue("closingElement")];
            let de = Q.type === "JSXElement" ? ue("openingElement") : ue("openingFragment"), ge = Q.type === "JSXElement" ? ue("closingElement") : ue("closingFragment");
            if (Q.children.length === 1 && Q.children[0].type === "JSXExpressionContainer" && (Q.children[0].expression.type === "TemplateLiteral" || Q.children[0].expression.type === "TaggedTemplateExpression"))
              return [de, ...R.map(ue, "children"), ge];
            Q.children = Q.children.map((z) => K(z) ? { type: "JSXText", value: " ", raw: " " } : z);
            let ve = Q.children.some(N), be = Q.children.filter((z) => z.type === "JSXExpressionContainer").length > 1, we = Q.type === "JSXElement" && Q.openingElement.attributes.length > 1, fe = m(de) || ve || we || be, pe = R.getParentNode().rootMarker === "mdx", me = le.singleQuote ? "{' '}" : '{" "}', ce = pe ? " " : h([me, n], " "), he = Q.openingElement && Q.openingElement.name && Q.openingElement.name.name === "fbt", J = g(R, le, ue, ce, he), ye = Q.children.some((z) => oe(z));
            for (let z = J.length - 2; z >= 0; z--) {
              let q = J[z] === "" && J[z + 1] === "", Ce = J[z] === u && J[z + 1] === "" && J[z + 2] === u, Ne = (J[z] === n || J[z] === u) && J[z + 1] === "" && J[z + 2] === ce, je = J[z] === ce && J[z + 1] === "" && (J[z + 2] === n || J[z + 2] === u), Ue = J[z] === ce && J[z + 1] === "" && J[z + 2] === ce, tt = J[z] === n && J[z + 1] === "" && J[z + 2] === u || J[z] === u && J[z + 1] === "" && J[z + 2] === n;
              Ce && ye || q || Ne || Ue || tt ? J.splice(z, 2) : je && J.splice(z + 1, 2);
            }
            for (; J.length > 0 && r(E(J)); )
              J.pop();
            for (; J.length > 1 && r(J[0]) && r(J[1]); )
              J.shift(), J.shift();
            let X = [];
            for (let [z, q] of J.entries()) {
              if (q === ce) {
                if (z === 1 && J[z - 1] === "") {
                  if (J.length === 2) {
                    X.push(me);
                    continue;
                  }
                  X.push([me, u]);
                  continue;
                } else if (z === J.length - 1) {
                  X.push(me);
                  continue;
                } else if (J[z - 1] === "" && J[z - 2] === u) {
                  X.push(me);
                  continue;
                }
              }
              X.push(q), m(q) && (fe = true);
            }
            let Y = ye ? F(X) : a(X, { shouldBreak: true });
            if (pe)
              return Y;
            let re = a([de, o([u, Y]), u, ge]);
            return fe ? re : D([a([de, ...J, ge]), re]);
          }
          function g(R, le, ue, Q, de) {
            let ge = [];
            return R.each((ve, be, we) => {
              let fe = ve.getValue();
              if (T(fe)) {
                let pe = b(fe);
                if (oe(fe)) {
                  let me = pe.split(U);
                  if (me[0] === "") {
                    if (ge.push(""), me.shift(), /\n/.test(me[0])) {
                      let he = we[be + 1];
                      ge.push(x(de, me[1], fe, he));
                    } else
                      ge.push(Q);
                    me.shift();
                  }
                  let ce;
                  if (E(me) === "" && (me.pop(), ce = me.pop()), me.length === 0)
                    return;
                  for (let [he, J] of me.entries())
                    he % 2 === 1 ? ge.push(l) : ge.push(J);
                  if (ce !== void 0)
                    if (/\n/.test(ce)) {
                      let he = we[be + 1];
                      ge.push(x(de, E(ge), fe, he));
                    } else
                      ge.push(Q);
                  else {
                    let he = we[be + 1];
                    ge.push(C(de, E(ge), fe, he));
                  }
                } else
                  /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", u) : ge.push("", Q);
              } else {
                let pe = ue();
                ge.push(pe);
                let me = we[be + 1];
                if (me && oe(me)) {
                  let he = se(b(me)).split(U)[0];
                  ge.push(C(de, he, fe, me));
                } else
                  ge.push(u);
              }
            }, "children"), ge;
          }
          function C(R, le, ue, Q) {
            return R ? "" : ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? le.length === 1 ? n : u : n;
          }
          function x(R, le, ue, Q) {
            return R ? u : le.length === 1 ? ue.type === "JSXElement" && !ue.closingElement || Q && Q.type === "JSXElement" && !Q.closingElement ? u : n : u;
          }
          function B(R, le, ue) {
            let Q = R.getParentNode();
            if (!Q || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[Q.type])
              return le;
            let ge = R.match(void 0, (be) => be.type === "ArrowFunctionExpression", S, (be) => be.type === "JSXExpressionContainer"), ve = d(R, ue);
            return a([ve ? "" : h("("), o([n, le]), n, ve ? "" : h(")")], { shouldBreak: ge });
          }
          function L(R, le, ue) {
            let Q = R.getValue(), de = [];
            if (de.push(ue("name")), Q.value) {
              let ge;
              if (w(Q.value)) {
                let be = b(Q.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: we, quote: fe, regex: pe } = P(be, le.jsxSingleQuote ? "'" : '"');
                be = be.replace(pe, we), ge = [fe, be, fe];
              } else
                ge = ue("value");
              de.push("=", ge);
            }
            return de;
          }
          function M(R, le, ue) {
            let Q = R.getValue(), de = (ge, ve) => ge.type === "JSXEmptyExpression" || !k(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (de(ge.argument, ge) || ge.argument.type === "JSXElement") || S(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || N(ve) && (ge.type === "ConditionalExpression" || _(ge)));
            return de(Q.expression, R.getParentNode(0)) ? a(["{", ue("expression"), v, "}"]) : a(["{", o([n, ue("expression")]), n, v, "}"]);
          }
          function j(R, le, ue) {
            let Q = R.getValue(), de = Q.name && k(Q.name) || Q.typeParameters && k(Q.typeParameters);
            if (Q.selfClosing && Q.attributes.length === 0 && !de)
              return ["<", ue("name"), ue("typeParameters"), " />"];
            if (Q.attributes && Q.attributes.length === 1 && Q.attributes[0].value && w(Q.attributes[0].value) && !Q.attributes[0].value.value.includes(`
`) && !de && !k(Q.attributes[0]))
              return a(["<", ue("name"), ue("typeParameters"), " ", ...R.map(ue, "attributes"), Q.selfClosing ? " />" : ">"]);
            let ge = Q.attributes.length > 0 && k(E(Q.attributes), A.Trailing), ve = Q.attributes.length === 0 && !de || (le.bracketSameLine || le.jsxBracketSameLine) && (!de || Q.attributes.length > 0) && !ge, be = Q.attributes && Q.attributes.some((fe) => fe.value && w(fe.value) && fe.value.value.includes(`
`)), we = le.singleAttributePerLine && Q.attributes.length > 1 ? u : l;
            return a(["<", ue("name"), ue("typeParameters"), o(R.map(() => [we, ue()], "attributes")), Q.selfClosing ? l : ve ? ">" : n, Q.selfClosing ? "/>" : ve ? "" : ">"], { shouldBreak: be });
          }
          function H(R, le, ue) {
            let Q = R.getValue(), de = [];
            de.push("</");
            let ge = ue("name");
            return k(Q.name, A.Leading | A.Line) ? de.push(o([u, ge]), u) : k(Q.name, A.Leading | A.Block) ? de.push(" ", ge) : de.push(ge), de.push(">"), de;
          }
          function I(R, le) {
            let ue = R.getValue(), Q = k(ue), de = k(ue, A.Line), ge = ue.type === "JSXOpeningFragment";
            return [ge ? "<" : "</", o([de ? u : Q && !ge ? " " : "", i(R, le, true)]), de ? u : "", ">"];
          }
          function G(R, le, ue) {
            let Q = t(R, y(R, le, ue), le);
            return B(R, Q, le);
          }
          function Z(R, le) {
            let ue = R.getValue(), Q = k(ue, A.Line);
            return [i(R, le, !Q), Q ? u : ""];
          }
          function W(R, le, ue) {
            let Q = R.getValue();
            return ["{", R.call((de) => {
              let ge = ["...", ue()], ve = de.getValue();
              return !k(ve) || !c(de) ? ge : [o([n, t(de, ge, le)]), n];
            }, Q.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function $(R, le, ue) {
            let Q = R.getValue();
            if (!!Q.type.startsWith("JSX"))
              switch (Q.type) {
                case "JSXAttribute":
                  return L(R, le, ue);
                case "JSXIdentifier":
                  return String(Q.name);
                case "JSXNamespacedName":
                  return p(":", [ue("namespace"), ue("name")]);
                case "JSXMemberExpression":
                  return p(".", [ue("object"), ue("property")]);
                case "JSXSpreadAttribute":
                  return W(R, le, ue);
                case "JSXSpreadChild":
                  return W(R, le, ue);
                case "JSXExpressionContainer":
                  return M(R, le, ue);
                case "JSXFragment":
                case "JSXElement":
                  return G(R, le, ue);
                case "JSXOpeningElement":
                  return j(R, le, ue);
                case "JSXClosingElement":
                  return H(R, le, ue);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return I(R, le);
                case "JSXEmptyExpression":
                  return Z(R, le);
                case "JSXText":
                  throw new Error("JSXTest should be handled by JSXElement");
                default:
                  throw new Error("Unknown JSX node type: ".concat(JSON.stringify(Q.type), "."));
              }
          }
          var te = ` 
\r	`, U = new RegExp("([" + te + "]+)"), ne = new RegExp("[^" + te + "]"), se = (R) => R.replace(new RegExp("(?:^" + U.source + "|" + U.source + "$)"), "");
          function V(R) {
            if (R.children.length === 0)
              return true;
            if (R.children.length > 1)
              return false;
            let le = R.children[0];
            return T(le) && !oe(le);
          }
          function oe(R) {
            return T(R) && (ne.test(b(R)) || !/\n/.test(b(R)));
          }
          function K(R) {
            return R.type === "JSXExpressionContainer" && T(R.expression) && R.expression.value === " " && !k(R.expression);
          }
          function Ee(R) {
            let le = R.getValue(), ue = R.getParentNode();
            if (!ue || !le || !N(le) || !N(ue))
              return false;
            let Q = ue.children.indexOf(le), de = null;
            for (let ge = Q; ge > 0; ge--) {
              let ve = ue.children[ge - 1];
              if (!(ve.type === "JSXText" && !oe(ve))) {
                de = ve;
                break;
              }
            }
            return de && de.type === "JSXExpressionContainer" && de.expression.type === "JSXEmptyExpression" && f(de.expression);
          }
          s.exports = { hasJsxIgnoreComment: Ee, printJsx: $ };
        } }), ot = ee({ "src/language-js/print/misc.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t } = Ge(), { builders: { indent: i, join: l, line: u } } = Le(), { isFlowAnnotationComment: n } = Xe();
          function a(E) {
            let P = E.getValue();
            return !P.optional || P.type === "Identifier" && P === E.getParentNode().key ? "" : P.type === "OptionalCallExpression" || P.type === "OptionalMemberExpression" && P.computed ? "?." : "?";
          }
          function o(E) {
            return E.getValue().definite || E.match(void 0, (P, N) => N === "id" && P.type === "VariableDeclarator" && P.definite) ? "!" : "";
          }
          function D(E, P, N) {
            let b = E.getValue();
            return b.typeArguments ? N("typeArguments") : b.typeParameters ? N("typeParameters") : "";
          }
          function F(E, P, N) {
            let b = E.getValue();
            if (!b.typeAnnotation)
              return "";
            let T = E.getParentNode(), S = T.type === "DeclareFunction" && T.id === b;
            return n(P.originalText, b.typeAnnotation) ? [" /*: ", N("typeAnnotation"), " */"] : [S ? "" : ": ", N("typeAnnotation")];
          }
          function h(E, P, N) {
            return ["::", N("callee")];
          }
          function v(E, P, N) {
            let b = E.getValue();
            return t(b.modifiers) ? [l(" ", E.map(N, "modifiers")), " "] : "";
          }
          function p(E, P, N) {
            return E.type === "EmptyStatement" ? ";" : E.type === "BlockStatement" || N ? [" ", P] : i([u, P]);
          }
          function m(E, P, N) {
            return ["...", N("argument"), F(E, P, N)];
          }
          s.exports = { printOptionalToken: a, printDefiniteToken: o, printFunctionTypeParameters: D, printBindExpressionCallee: h, printTypeScriptModifiers: v, printTypeAnnotation: F, printRestSpread: m, adjustClause: p };
        } }), Gt = ee({ "src/language-js/print/array.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { builders: { line: i, softline: l, hardline: u, group: n, indent: a, ifBreak: o, fill: D } } = Le(), { getLast: F, hasNewline: h } = Ge(), { shouldPrintComma: v, hasComment: p, CommentCheckFlags: m, isNextLineEmpty: E, isNumericLiteral: P, isSignedNumericLiteral: N } = Xe(), { locStart: b } = nt(), { printOptionalToken: T, printTypeAnnotation: S } = ot();
          function w(f, d, c) {
            let r = f.getValue(), y = [], g = r.type === "TupleExpression" ? "#[" : "[", C = "]";
            if (r.elements.length === 0)
              p(r, m.Dangling) ? y.push(n([g, t(f, d), l, C])) : y.push(g, C);
            else {
              let x = F(r.elements), B = !(x && x.type === "RestElement"), L = x === null, M = Symbol("array"), j = !d.__inJestEach && r.elements.length > 1 && r.elements.every((G, Z, W) => {
                let $ = G && G.type;
                if ($ !== "ArrayExpression" && $ !== "ObjectExpression")
                  return false;
                let te = W[Z + 1];
                if (te && $ !== te.type)
                  return false;
                let U = $ === "ArrayExpression" ? "elements" : "properties";
                return G[U] && G[U].length > 1;
              }), H = _(r, d), I = B ? L ? "," : v(d) ? H ? o(",", "", { groupId: M }) : o(",") : "" : "";
              y.push(n([g, a([l, H ? A(f, d, c, I) : [k(f, d, "elements", c), I], t(f, d, true)]), l, C], { shouldBreak: j, id: M }));
            }
            return y.push(T(f), S(f, d, c)), y;
          }
          function _(f, d) {
            return f.elements.length > 1 && f.elements.every((c) => c && (P(c) || N(c) && !p(c.argument)) && !p(c, m.Trailing | m.Line, (r) => !h(d.originalText, b(r), { backwards: true })));
          }
          function k(f, d, c, r) {
            let y = [], g = [];
            return f.each((C) => {
              y.push(g, n(r())), g = [",", i], C.getValue() && E(C.getValue(), d) && g.push(l);
            }, c), y;
          }
          function A(f, d, c, r) {
            let y = [];
            return f.each((g, C, x) => {
              let B = C === x.length - 1;
              y.push([c(), B ? r : ","]), B || y.push(E(g.getValue(), d) ? [u, u] : p(x[C + 1], m.Leading | m.Line) ? u : i);
            }, "elements"), D(y);
          }
          s.exports = { printArray: w, printArrayItems: k, isConciselyPrintedArray: _ };
        } }), Qi = ee({ "src/language-js/print/call-arguments.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { getLast: i, getPenultimate: l } = Ge(), { getFunctionParameters: u, hasComment: n, CommentCheckFlags: a, isFunctionCompositionArgs: o, isJsxNode: D, isLongCurriedCallExpression: F, shouldPrintComma: h, getCallArguments: v, iterateCallArgumentsPath: p, isNextLineEmpty: m, isCallExpression: E, isStringLiteral: P, isObjectProperty: N } = Xe(), { builders: { line: b, hardline: T, softline: S, group: w, indent: _, conditionalGroup: k, ifBreak: A, breakParent: f }, utils: { willBreak: d } } = Le(), { ArgExpansionBailout: c } = $t(), { isConciselyPrintedArray: r } = Gt();
          function y(j, H, I) {
            let G = j.getValue(), Z = G.type === "ImportExpression", W = v(G);
            if (W.length === 0)
              return ["(", t(j, H, true), ")"];
            if (B(W))
              return ["(", I(["arguments", 0]), ", ", I(["arguments", 1]), ")"];
            let $ = false, te = false, U = W.length - 1, ne = [];
            p(j, (R, le) => {
              let ue = R.getNode(), Q = [I()];
              le === U || (m(ue, H) ? (le === 0 && (te = true), $ = true, Q.push(",", T, T)) : Q.push(",", b)), ne.push(Q);
            });
            let se = !(Z || G.callee && G.callee.type === "Import") && h(H, "all") ? "," : "";
            function V() {
              return w(["(", _([b, ...ne]), se, b, ")"], { shouldBreak: true });
            }
            if ($ || j.getParentNode().type !== "Decorator" && o(W))
              return V();
            let oe = x(W), K = C(W, H);
            if (oe || K) {
              if (oe ? ne.slice(1).some(d) : ne.slice(0, -1).some(d))
                return V();
              let R = [];
              try {
                j.try(() => {
                  p(j, (le, ue) => {
                    oe && ue === 0 && (R = [[I([], { expandFirstArg: true }), ne.length > 1 ? "," : "", te ? T : b, te ? T : ""], ...ne.slice(1)]), K && ue === U && (R = [...ne.slice(0, -1), I([], { expandLastArg: true })]);
                  });
                });
              } catch (le) {
                if (le instanceof c)
                  return V();
                throw le;
              }
              return [ne.some(d) ? f : "", k([["(", ...R, ")"], oe ? ["(", w(R[0], { shouldBreak: true }), ...R.slice(1), ")"] : ["(", ...ne.slice(0, -1), w(i(R), { shouldBreak: true }), ")"], V()])];
            }
            let Ee = ["(", _([S, ...ne]), A(se), S, ")"];
            return F(j) ? Ee : w(Ee, { shouldBreak: ne.some(d) || $ });
          }
          function g(j) {
            let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return j.type === "ObjectExpression" && (j.properties.length > 0 || n(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || n(j)) || j.type === "TSTypeAssertion" && g(j.expression) || j.type === "TSAsExpression" && g(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && g(j.body, true) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !H && (E(j.body) || j.body.type === "ConditionalExpression") || D(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
          }
          function C(j, H) {
            let I = i(j), G = l(j);
            return !n(I, a.Leading) && !n(I, a.Trailing) && g(I) && (!G || G.type !== I.type) && (j.length !== 2 || G.type !== "ArrowFunctionExpression" || I.type !== "ArrayExpression") && !(j.length > 1 && I.type === "ArrayExpression" && r(I, H));
          }
          function x(j) {
            if (j.length !== 2)
              return false;
            let [H, I] = j;
            return H.type === "ModuleExpression" && M(I) ? true : !n(H) && (H.type === "FunctionExpression" || H.type === "ArrowFunctionExpression" && H.body.type === "BlockStatement") && I.type !== "FunctionExpression" && I.type !== "ArrowFunctionExpression" && I.type !== "ConditionalExpression" && !g(I);
          }
          function B(j) {
            return j.length === 2 && j[0].type === "ArrowFunctionExpression" && u(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some((H) => n(H));
          }
          function L(j) {
            return j.type === "BlockStatement" && (j.body.some((H) => H.type !== "EmptyStatement") || n(j, a.Dangling));
          }
          function M(j) {
            return j.type === "ObjectExpression" && j.properties.length === 1 && N(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && P(j.properties[0].value) && j.properties[0].value.value === "module";
          }
          s.exports = y;
        } }), Zi = ee({ "src/language-js/print/member.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { softline: t, group: i, indent: l, label: u } } = Le(), { isNumericLiteral: n, isMemberExpression: a, isCallExpression: o } = Xe(), { printOptionalToken: D } = ot();
          function F(v, p, m) {
            let E = v.getValue(), P = v.getParentNode(), N, b = 0;
            do
              N = v.getParentNode(b), b++;
            while (N && (a(N) || N.type === "TSNonNullExpression"));
            let T = m("object"), S = h(v, p, m), w = N && (N.type === "NewExpression" || N.type === "BindExpression" || N.type === "AssignmentExpression" && N.left.type !== "Identifier") || E.computed || E.object.type === "Identifier" && E.property.type === "Identifier" && !a(P) || (P.type === "AssignmentExpression" || P.type === "VariableDeclarator") && (o(E.object) && E.object.arguments.length > 0 || E.object.type === "TSNonNullExpression" && o(E.object.expression) && E.object.expression.arguments.length > 0 || T.label === "member-chain");
            return u(T.label === "member-chain" ? "member-chain" : "member", [T, w ? S : i(l([t, S]))]);
          }
          function h(v, p, m) {
            let E = m("property"), P = v.getValue(), N = D(v);
            return P.computed ? !P.property || n(P.property) ? [N, "[", E, "]"] : i([N, "[", l([t, E]), t, "]"]) : [N, ".", E];
          }
          s.exports = { printMemberExpression: F, printMemberLookup: h };
        } }), sm = ee({ "src/language-js/print/member-chain.js"(e2, s) {
          "use strict";
          ae();
          var { printComments: t } = Qe(), { getLast: i, isNextLineEmptyAfterIndex: l, getNextNonSpaceNonCommentCharacterIndex: u } = Ge(), n = _t(), { isCallExpression: a, isMemberExpression: o, isFunctionOrArrowExpression: D, isLongCurriedCallExpression: F, isMemberish: h, isNumericLiteral: v, isSimpleCallArgument: p, hasComment: m, CommentCheckFlags: E, isNextLineEmpty: P } = Xe(), { locEnd: N } = nt(), { builders: { join: b, hardline: T, group: S, indent: w, conditionalGroup: _, breakParent: k, label: A }, utils: { willBreak: f } } = Le(), d = Qi(), { printMemberLookup: c } = Zi(), { printOptionalToken: r, printFunctionTypeParameters: y, printBindExpressionCallee: g } = ot();
          function C(x, B, L) {
            let M = x.getParentNode(), j = !M || M.type === "ExpressionStatement", H = [];
            function I(me) {
              let { originalText: ce } = B, he = u(ce, me, N);
              return ce.charAt(he) === ")" ? he !== false && l(ce, he + 1) : P(me, B);
            }
            function G(me) {
              let ce = me.getValue();
              a(ce) && (h(ce.callee) || a(ce.callee)) ? (H.unshift({ node: ce, printed: [t(me, [r(me), y(me, B, L), d(me, B, L)], B), I(ce) ? T : ""] }), me.call((he) => G(he), "callee")) : h(ce) ? (H.unshift({ node: ce, needsParens: n(me, B), printed: t(me, o(ce) ? c(me, B, L) : g(me, B, L), B) }), me.call((he) => G(he), "object")) : ce.type === "TSNonNullExpression" ? (H.unshift({ node: ce, printed: t(me, "!", B) }), me.call((he) => G(he), "expression")) : H.unshift({ node: ce, printed: L() });
            }
            let Z = x.getValue();
            H.unshift({ node: Z, printed: [r(x), y(x, B, L), d(x, B, L)] }), Z.callee && x.call((me) => G(me), "callee");
            let W = [], $ = [H[0]], te = 1;
            for (; te < H.length && (H[te].node.type === "TSNonNullExpression" || a(H[te].node) || o(H[te].node) && H[te].node.computed && v(H[te].node.property)); ++te)
              $.push(H[te]);
            if (!a(H[0].node))
              for (; te + 1 < H.length && (h(H[te].node) && h(H[te + 1].node)); ++te)
                $.push(H[te]);
            W.push($), $ = [];
            let U = false;
            for (; te < H.length; ++te) {
              if (U && h(H[te].node)) {
                if (H[te].node.computed && v(H[te].node.property)) {
                  $.push(H[te]);
                  continue;
                }
                W.push($), $ = [], U = false;
              }
              (a(H[te].node) || H[te].node.type === "ImportExpression") && (U = true), $.push(H[te]), m(H[te].node, E.Trailing) && (W.push($), $ = [], U = false);
            }
            $.length > 0 && W.push($);
            function ne(me) {
              return /^[A-Z]|^[$_]+$/.test(me);
            }
            function se(me) {
              return me.length <= B.tabWidth;
            }
            function V(me) {
              let ce = me[1].length > 0 && me[1][0].node.computed;
              if (me[0].length === 1) {
                let J = me[0][0].node;
                return J.type === "ThisExpression" || J.type === "Identifier" && (ne(J.name) || j && se(J.name) || ce);
              }
              let he = i(me[0]).node;
              return o(he) && he.property.type === "Identifier" && (ne(he.property.name) || ce);
            }
            let oe = W.length >= 2 && !m(W[1][0].node) && V(W);
            function K(me) {
              let ce = me.map((he) => he.printed);
              return me.length > 0 && i(me).needsParens ? ["(", ...ce, ")"] : ce;
            }
            function Ee(me) {
              return me.length === 0 ? "" : w(S([T, b(T, me.map(K))]));
            }
            let R = W.map(K), le = R, ue = oe ? 3 : 2, Q = W.flat(), de = Q.slice(1, -1).some((me) => m(me.node, E.Leading)) || Q.slice(0, -1).some((me) => m(me.node, E.Trailing)) || W[ue] && m(W[ue][0].node, E.Leading);
            if (W.length <= ue && !de)
              return F(x) ? le : S(le);
            let ge = i(W[oe ? 1 : 0]).node, ve = !a(ge) && I(ge), be = [K(W[0]), oe ? W.slice(1, 2).map(K) : "", ve ? T : "", Ee(W.slice(oe ? 2 : 1))], we = H.map((me) => {
              let { node: ce } = me;
              return ce;
            }).filter(a);
            function fe() {
              let me = i(i(W)).node, ce = i(R);
              return a(me) && f(ce) && we.slice(0, -1).some((he) => he.arguments.some(D));
            }
            let pe;
            return de || we.length > 2 && we.some((me) => !me.arguments.every((ce) => p(ce, 0))) || R.slice(0, -1).some(f) || fe() ? pe = S(be) : pe = [f(le) || ve ? k : "", _([le, be])], A("member-chain", pe);
          }
          s.exports = C;
        } }), eo = ee({ "src/language-js/print/call-expression.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { join: t, group: i } } = Le(), l = _t(), { getCallArguments: u, hasFlowAnnotationComment: n, isCallExpression: a, isMemberish: o, isStringLiteral: D, isTemplateOnItsOwnLine: F, isTestCall: h, iterateCallArgumentsPath: v } = Xe(), p = sm(), m = Qi(), { printOptionalToken: E, printFunctionTypeParameters: P } = ot();
          function N(T, S, w) {
            let _ = T.getValue(), k = T.getParentNode(), A = _.type === "NewExpression", f = _.type === "ImportExpression", d = E(T), c = u(_);
            if (c.length > 0 && (!f && !A && b(_, k) || c.length === 1 && F(c[0], S.originalText) || !A && h(_, k))) {
              let g = [];
              return v(T, () => {
                g.push(w());
              }), [A ? "new " : "", w("callee"), d, P(T, S, w), "(", t(", ", g), ")"];
            }
            let r = (S.parser === "babel" || S.parser === "babel-flow") && _.callee && _.callee.type === "Identifier" && n(_.callee.trailingComments);
            if (r && (_.callee.trailingComments[0].printed = true), !f && !A && o(_.callee) && !T.call((g) => l(g, S), "callee"))
              return p(T, S, w);
            let y = [A ? "new " : "", f ? "import" : w("callee"), d, r ? "/*:: ".concat(_.callee.trailingComments[0].value.slice(2).trim(), " */") : "", P(T, S, w), m(T, S, w)];
            return f || a(_.callee) ? i(y) : y;
          }
          function b(T, S) {
            if (T.callee.type !== "Identifier")
              return false;
            if (T.callee.name === "require")
              return true;
            if (T.callee.name === "define") {
              let w = u(T);
              return S.type === "ExpressionStatement" && (w.length === 1 || w.length === 2 && w[0].type === "ArrayExpression" || w.length === 3 && D(w[0]) && w[1].type === "ArrayExpression");
            }
            return false;
          }
          s.exports = { printCallExpression: N };
        } }), Jt = ee({ "src/language-js/print/assignment.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t, getStringWidth: i } = Ge(), { builders: { line: l, group: u, indent: n, indentIfBreak: a, lineSuffixBoundary: o }, utils: { cleanDoc: D, willBreak: F, canBreak: h } } = Le(), { hasLeadingOwnLineComment: v, isBinaryish: p, isStringLiteral: m, isLiteral: E, isNumericLiteral: P, isCallExpression: N, isMemberExpression: b, getCallArguments: T, rawText: S, hasComment: w, isSignedNumericLiteral: _, isObjectProperty: k } = Xe(), { shouldInlineLogicalExpression: A } = Mn(), { printCallExpression: f } = eo();
          function d(V, oe, K, Ee, R, le) {
            let ue = y(V, oe, K, Ee, le), Q = K(le, { assignmentLayout: ue });
            switch (ue) {
              case "break-after-operator":
                return u([u(Ee), R, u(n([l, Q]))]);
              case "never-break-after-operator":
                return u([u(Ee), R, " ", Q]);
              case "fluid": {
                let de = Symbol("assignment");
                return u([u(Ee), R, u(n(l), { id: de }), o, a(Q, { groupId: de })]);
              }
              case "break-lhs":
                return u([Ee, R, " ", u(Q)]);
              case "chain":
                return [u(Ee), R, l, Q];
              case "chain-tail":
                return [u(Ee), R, n([l, Q])];
              case "chain-tail-arrow-chain":
                return [u(Ee), R, Q];
              case "only-left":
                return Ee;
            }
          }
          function c(V, oe, K) {
            let Ee = V.getValue();
            return d(V, oe, K, K("left"), [" ", Ee.operator], "right");
          }
          function r(V, oe, K) {
            return d(V, oe, K, K("id"), " =", "init");
          }
          function y(V, oe, K, Ee, R) {
            let le = V.getValue(), ue = le[R];
            if (!ue)
              return "only-left";
            let Q = !x(ue);
            if (V.match(x, B, (be) => !Q || be.type !== "ExpressionStatement" && be.type !== "VariableDeclaration"))
              return Q ? ue.type === "ArrowFunctionExpression" && ue.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Q && x(ue.right) || v(oe.originalText, ue))
              return "break-after-operator";
            if (ue.type === "CallExpression" && ue.callee.name === "require" || oe.parser === "json5" || oe.parser === "json")
              return "never-break-after-operator";
            if (C(le) || L(le) || H(le) || I(le) && h(Ee))
              return "break-lhs";
            let ve = U(le, Ee, oe);
            return V.call(() => g(V, oe, K, ve), R) ? "break-after-operator" : ve || ue.type === "TemplateLiteral" || ue.type === "TaggedTemplateExpression" || ue.type === "BooleanLiteral" || P(ue) || ue.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function g(V, oe, K, Ee) {
            let R = V.getValue();
            if (p(R) && !A(R))
              return true;
            switch (R.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Q } = R;
                return p(Q) && !A(Q);
              }
              case "ClassExpression":
                return t(R.decorators);
            }
            if (Ee)
              return false;
            let le = R, ue = [];
            for (; ; )
              if (le.type === "UnaryExpression")
                le = le.argument, ue.push("argument");
              else if (le.type === "TSNonNullExpression")
                le = le.expression, ue.push("expression");
              else
                break;
            return !!(m(le) || V.call(() => W(V, oe, K), ...ue));
          }
          function C(V) {
            if (B(V)) {
              let oe = V.left || V.id;
              return oe.type === "ObjectPattern" && oe.properties.length > 2 && oe.properties.some((K) => k(K) && (!K.shorthand || K.value && K.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function x(V) {
            return V.type === "AssignmentExpression";
          }
          function B(V) {
            return x(V) || V.type === "VariableDeclarator";
          }
          function L(V) {
            let oe = M(V);
            if (t(oe)) {
              let K = V.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (oe.length > 1 && oe.some((Ee) => Ee[K] || Ee.default))
                return true;
            }
            return false;
          }
          function M(V) {
            return j(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
          }
          function j(V) {
            return V.type === "TSTypeAliasDeclaration" || V.type === "TypeAlias";
          }
          function H(V) {
            if (V.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: oe } = V.id;
            if (!oe || !oe.typeAnnotation)
              return false;
            let K = G(oe.typeAnnotation);
            return t(K) && K.length > 1 && K.some((Ee) => t(G(Ee)) || Ee.type === "TSConditionalType");
          }
          function I(V) {
            return V.type === "VariableDeclarator" && V.init && V.init.type === "ArrowFunctionExpression";
          }
          function G(V) {
            return Z(V) && V.typeParameters && V.typeParameters.params ? V.typeParameters.params : null;
          }
          function Z(V) {
            return V.type === "TSTypeReference" || V.type === "GenericTypeAnnotation";
          }
          function W(V, oe, K) {
            let Ee = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, R = V.getValue(), le = () => W(V, oe, K, true);
            if (R.type === "TSNonNullExpression")
              return V.call(le, "expression");
            if (N(R)) {
              if (f(V, oe, K).label === "member-chain")
                return false;
              let Q = T(R);
              return !(Q.length === 0 || Q.length === 1 && te(Q[0], oe)) || ne(R, K) ? false : V.call(le, "callee");
            }
            return b(R) ? V.call(le, "object") : Ee && (R.type === "Identifier" || R.type === "ThisExpression");
          }
          var $ = 0.25;
          function te(V, oe) {
            let { printWidth: K } = oe;
            if (w(V))
              return false;
            let Ee = K * $;
            if (V.type === "ThisExpression" || V.type === "Identifier" && V.name.length <= Ee || _(V) && !w(V.argument))
              return true;
            let R = V.type === "Literal" && "regex" in V && V.regex.pattern || V.type === "RegExpLiteral" && V.pattern;
            return R ? R.length <= Ee : m(V) ? S(V).length <= Ee : V.type === "TemplateLiteral" ? V.expressions.length === 0 && V.quasis[0].value.raw.length <= Ee && !V.quasis[0].value.raw.includes(`
`) : E(V);
          }
          function U(V, oe, K) {
            if (!k(V))
              return false;
            oe = D(oe);
            let Ee = 3;
            return typeof oe == "string" && i(oe) < K.tabWidth + Ee;
          }
          function ne(V, oe) {
            let K = se(V);
            if (t(K)) {
              if (K.length > 1)
                return true;
              if (K.length === 1) {
                let R = K[0];
                if (R.type === "TSUnionType" || R.type === "UnionTypeAnnotation" || R.type === "TSIntersectionType" || R.type === "IntersectionTypeAnnotation")
                  return true;
              }
              let Ee = V.typeParameters ? "typeParameters" : "typeArguments";
              if (F(oe(Ee)))
                return true;
            }
            return false;
          }
          function se(V) {
            return V.typeParameters && V.typeParameters.params || V.typeArguments && V.typeArguments.params;
          }
          s.exports = { printVariableDeclarator: r, printAssignmentExpression: c, printAssignment: d, isArrowFunctionVariableDeclarator: I };
        } }), Sr = ee({ "src/language-js/print/function-parameters.js"(e2, s) {
          "use strict";
          ae();
          var { getNextNonSpaceNonCommentCharacter: t } = Ge(), { printDanglingComments: i } = Qe(), { builders: { line: l, hardline: u, softline: n, group: a, indent: o, ifBreak: D }, utils: { removeLines: F, willBreak: h } } = Le(), { getFunctionParameters: v, iterateFunctionParametersPath: p, isSimpleType: m, isTestCall: E, isTypeAnnotationAFunction: P, isObjectType: N, isObjectTypePropertyAFunction: b, hasRestParameter: T, shouldPrintComma: S, hasComment: w, isNextLineEmpty: _ } = Xe(), { locEnd: k } = nt(), { ArgExpansionBailout: A } = $t(), { printFunctionTypeParameters: f } = ot();
          function d(g, C, x, B, L) {
            let M = g.getValue(), j = v(M), H = L ? f(g, x, C) : "";
            if (j.length === 0)
              return [H, "(", i(g, x, true, (U) => t(x.originalText, U, k) === ")"), ")"];
            let I = g.getParentNode(), G = E(I), Z = c(M), W = [];
            if (p(g, (U, ne) => {
              let se = ne === j.length - 1;
              se && M.rest && W.push("..."), W.push(C()), !se && (W.push(","), G || Z ? W.push(" ") : _(j[ne], x) ? W.push(u, u) : W.push(l));
            }), B) {
              if (h(H) || h(W))
                throw new A();
              return a([F(H), "(", F(W), ")"]);
            }
            let $ = j.every((U) => !U.decorators);
            return Z && $ ? [H, "(", ...W, ")"] : G ? [H, "(", ...W, ")"] : (b(I) || P(I) || I.type === "TypeAlias" || I.type === "UnionTypeAnnotation" || I.type === "TSUnionType" || I.type === "IntersectionTypeAnnotation" || I.type === "FunctionTypeAnnotation" && I.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && m(j[0].typeAnnotation) && !M.rest ? x.arrowParens === "always" ? ["(", ...W, ")"] : W : [H, "(", o([n, ...W]), D(!T(M) && S(x, "all") ? "," : ""), n, ")"];
          }
          function c(g) {
            if (!g)
              return false;
            let C = v(g);
            if (C.length !== 1)
              return false;
            let [x] = C;
            return !w(x) && (x.type === "ObjectPattern" || x.type === "ArrayPattern" || x.type === "Identifier" && x.typeAnnotation && (x.typeAnnotation.type === "TypeAnnotation" || x.typeAnnotation.type === "TSTypeAnnotation") && N(x.typeAnnotation.typeAnnotation) || x.type === "FunctionTypeParam" && N(x.typeAnnotation) || x.type === "AssignmentPattern" && (x.left.type === "ObjectPattern" || x.left.type === "ArrayPattern") && (x.right.type === "Identifier" || x.right.type === "ObjectExpression" && x.right.properties.length === 0 || x.right.type === "ArrayExpression" && x.right.elements.length === 0));
          }
          function r(g) {
            let C;
            return g.returnType ? (C = g.returnType, C.typeAnnotation && (C = C.typeAnnotation)) : g.typeAnnotation && (C = g.typeAnnotation), C;
          }
          function y(g, C) {
            let x = r(g);
            if (!x)
              return false;
            let B = g.typeParameters && g.typeParameters.params;
            if (B) {
              if (B.length > 1)
                return false;
              if (B.length === 1) {
                let L = B[0];
                if (L.constraint || L.default)
                  return false;
              }
            }
            return v(g).length === 1 && (N(x) || h(C));
          }
          s.exports = { printFunctionParameters: d, shouldHugFunctionParameters: c, shouldGroupFunctionParameters: y };
        } }), br = ee({ "src/language-js/print/type-annotation.js"(e2, s) {
          "use strict";
          ae();
          var { printComments: t, printDanglingComments: i } = Qe(), { isNonEmptyArray: l } = Ge(), { builders: { group: u, join: n, line: a, softline: o, indent: D, align: F, ifBreak: h } } = Le(), v = _t(), { locStart: p } = nt(), { isSimpleType: m, isObjectType: E, hasLeadingOwnLineComment: P, isObjectTypePropertyAFunction: N, shouldPrintComma: b } = Xe(), { printAssignment: T } = Jt(), { printFunctionParameters: S, shouldGroupFunctionParameters: w } = Sr(), { printArrayItems: _ } = Gt();
          function k(C) {
            if (m(C) || E(C))
              return true;
            if (C.type === "UnionTypeAnnotation" || C.type === "TSUnionType") {
              let x = C.types.filter((L) => L.type === "VoidTypeAnnotation" || L.type === "TSVoidKeyword" || L.type === "NullLiteralTypeAnnotation" || L.type === "TSNullKeyword").length, B = C.types.some((L) => L.type === "ObjectTypeAnnotation" || L.type === "TSTypeLiteral" || L.type === "GenericTypeAnnotation" || L.type === "TSTypeReference");
              if (C.types.length - 1 === x && B)
                return true;
            }
            return false;
          }
          function A(C, x, B) {
            let L = x.semi ? ";" : "", M = C.getValue(), j = [];
            return j.push("opaque type ", B("id"), B("typeParameters")), M.supertype && j.push(": ", B("supertype")), M.impltype && j.push(" = ", B("impltype")), j.push(L), j;
          }
          function f(C, x, B) {
            let L = x.semi ? ";" : "", M = C.getValue(), j = [];
            M.declare && j.push("declare "), j.push("type ", B("id"), B("typeParameters"));
            let H = M.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [T(C, x, B, j, " =", H), L];
          }
          function d(C, x, B) {
            let L = C.getValue(), M = C.map(B, "types"), j = [], H = false;
            for (let I = 0; I < M.length; ++I)
              I === 0 ? j.push(M[I]) : E(L.types[I - 1]) && E(L.types[I]) ? j.push([" & ", H ? D(M[I]) : M[I]]) : !E(L.types[I - 1]) && !E(L.types[I]) ? j.push(D([" &", a, M[I]])) : (I > 1 && (H = true), j.push(" & ", I > 1 ? D(M[I]) : M[I]));
            return u(j);
          }
          function c(C, x, B) {
            let L = C.getValue(), M = C.getParentNode(), j = M.type !== "TypeParameterInstantiation" && M.type !== "TSTypeParameterInstantiation" && M.type !== "GenericTypeAnnotation" && M.type !== "TSTypeReference" && M.type !== "TSTypeAssertion" && M.type !== "TupleTypeAnnotation" && M.type !== "TSTupleType" && !(M.type === "FunctionTypeParam" && !M.name && C.getParentNode(1).this !== M) && !((M.type === "TypeAlias" || M.type === "VariableDeclarator" || M.type === "TSTypeAliasDeclaration") && P(x.originalText, L)), H = k(L), I = C.map((W) => {
              let $ = B();
              return H || ($ = F(2, $)), t(W, $, x);
            }, "types");
            if (H)
              return n(" | ", I);
            let G = j && !P(x.originalText, L), Z = [h([G ? a : "", "| "]), n([a, "| "], I)];
            return v(C, x) ? u([D(Z), o]) : M.type === "TupleTypeAnnotation" && M.types.length > 1 || M.type === "TSTupleType" && M.elementTypes.length > 1 ? u([D([h(["(", o]), Z]), o, h(")")]) : u(j ? D(Z) : Z);
          }
          function r(C, x, B) {
            let L = C.getValue(), M = [], j = C.getParentNode(0), H = C.getParentNode(1), I = C.getParentNode(2), G = L.type === "TSFunctionType" || !((j.type === "ObjectTypeProperty" || j.type === "ObjectTypeInternalSlot") && !j.variance && !j.optional && p(j) === p(L) || j.type === "ObjectTypeCallProperty" || I && I.type === "DeclareFunction"), Z = G && (j.type === "TypeAnnotation" || j.type === "TSTypeAnnotation"), W = Z && G && (j.type === "TypeAnnotation" || j.type === "TSTypeAnnotation") && H.type === "ArrowFunctionExpression";
            N(j) && (G = true, Z = true), W && M.push("(");
            let $ = S(C, B, x, false, true), te = L.returnType || L.predicate || L.typeAnnotation ? [G ? " => " : ": ", B("returnType"), B("predicate"), B("typeAnnotation")] : "", U = w(L, te);
            return M.push(U ? u($) : $), te && M.push(te), W && M.push(")"), u(M);
          }
          function y(C, x, B) {
            let L = C.getValue(), M = L.type === "TSTupleType" ? "elementTypes" : "types", j = L[M], H = l(j), I = H ? o : "";
            return u(["[", D([I, _(C, x, M, B)]), h(H && b(x, "all") ? "," : ""), i(C, x, true), I, "]"]);
          }
          function g(C, x, B) {
            let L = C.getValue(), M = L.type === "OptionalIndexedAccessType" && L.optional ? "?.[" : "[";
            return [B("objectType"), M, B("indexType"), "]"];
          }
          s.exports = { printOpaqueType: A, printTypeAlias: f, printIntersectionType: d, printUnionType: c, printFunctionType: r, printTupleType: y, printIndexedAccessType: g, shouldHugType: k };
        } }), xr = ee({ "src/language-js/print/type-parameters.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { builders: { join: i, line: l, hardline: u, softline: n, group: a, indent: o, ifBreak: D } } = Le(), { isTestCall: F, hasComment: h, CommentCheckFlags: v, isTSXFile: p, shouldPrintComma: m, getFunctionParameters: E, isObjectType: P } = Xe(), { createGroupIdMapper: N } = Ge(), { shouldHugType: b } = br(), { isArrowFunctionVariableDeclarator: T } = Jt(), S = N("typeParameters");
          function w(A, f, d, c) {
            let r = A.getValue();
            if (!r[c])
              return "";
            if (!Array.isArray(r[c]))
              return d(c);
            let y = A.getNode(2), g = y && F(y);
            if (!A.match((L) => !(L[c].length === 1 && P(L[c][0])), void 0, (L, M) => M === "typeAnnotation", (L) => L.type === "Identifier", T) && (g || r[c].length === 0 || r[c].length === 1 && (r[c][0].type === "NullableTypeAnnotation" || b(r[c][0]))))
              return ["<", i(", ", A.map(d, c)), _(A, f), ">"];
            let B = r.type === "TSTypeParameterInstantiation" ? "" : E(r).length === 1 && p(f) && !r[c][0].constraint && A.getParentNode().type === "ArrowFunctionExpression" ? "," : m(f, "all") ? D(",") : "";
            return a(["<", o([n, i([",", l], A.map(d, c))]), B, n, ">"], { id: S(r) });
          }
          function _(A, f) {
            let d = A.getValue();
            if (!h(d, v.Dangling))
              return "";
            let c = !h(d, v.Line), r = t(A, f, c);
            return c ? r : [r, u];
          }
          function k(A, f, d) {
            let c = A.getValue(), r = [], y = A.getParentNode();
            return y.type === "TSMappedType" ? (r.push("[", d("name")), c.constraint && r.push(" in ", d("constraint")), y.nameType && r.push(" as ", A.callParent(() => d("nameType"))), r.push("]"), r) : (c.variance && r.push(d("variance")), r.push(d("name")), c.bound && r.push(": ", d("bound")), c.constraint && r.push(" extends ", d("constraint")), c.default && r.push(" = ", d("default")), r);
          }
          s.exports = { printTypeParameter: k, printTypeParameters: w, getTypeParametersGroupId: S };
        } }), Ut = ee({ "src/language-js/print/property.js"(e2, s) {
          "use strict";
          ae();
          var { printComments: t } = Qe(), { printString: i, printNumber: l } = Ge(), { isNumericLiteral: u, isSimpleNumber: n, isStringLiteral: a, isStringPropSafeToUnquote: o, rawText: D } = Xe(), { printAssignment: F } = Jt(), h = /* @__PURE__ */ new WeakMap();
          function v(m, E, P) {
            let N = m.getNode();
            if (N.computed)
              return ["[", P("key"), "]"];
            let b = m.getParentNode(), { key: T } = N;
            if (N.type === "ClassPrivateProperty" && T.type === "Identifier")
              return ["#", P("key")];
            if (E.quoteProps === "consistent" && !h.has(b)) {
              let S = (b.properties || b.body || b.members).some((w) => !w.computed && w.key && a(w.key) && !o(w, E));
              h.set(b, S);
            }
            if ((T.type === "Identifier" || u(T) && n(l(D(T))) && String(T.value) === l(D(T)) && !(E.parser === "typescript" || E.parser === "babel-ts")) && (E.parser === "json" || E.quoteProps === "consistent" && h.get(b))) {
              let S = i(JSON.stringify(T.type === "Identifier" ? T.name : T.value.toString()), E);
              return m.call((w) => t(w, S, E), "key");
            }
            return o(N, E) && (E.quoteProps === "as-needed" || E.quoteProps === "consistent" && !h.get(b)) ? m.call((S) => t(S, /^\d/.test(T.value) ? l(T.value) : T.value, E), "key") : P("key");
          }
          function p(m, E, P) {
            return m.getValue().shorthand ? P("value") : F(m, E, P, v(m, E, P), ":", "value");
          }
          s.exports = { printProperty: p, printPropertyKey: v };
        } }), Tr = ee({ "src/language-js/print/function.js"(e2, s) {
          "use strict";
          ae();
          var t = Ht(), { printDanglingComments: i, printCommentsSeparately: l } = Qe(), u = st(), { getNextNonSpaceNonCommentCharacterIndex: n } = Ge(), { builders: { line: a, softline: o, group: D, indent: F, ifBreak: h, hardline: v, join: p, indentIfBreak: m }, utils: { removeLines: E, willBreak: P } } = Le(), { ArgExpansionBailout: N } = $t(), { getFunctionParameters: b, hasLeadingOwnLineComment: T, isFlowAnnotationComment: S, isJsxNode: w, isTemplateOnItsOwnLine: _, shouldPrintComma: k, startsWithNoLookaheadToken: A, isBinaryish: f, isLineComment: d, hasComment: c, getComments: r, CommentCheckFlags: y, isCallLikeExpression: g, isCallExpression: C, getCallArguments: x, hasNakedLeftSide: B, getLeftSide: L } = Xe(), { locEnd: M } = nt(), { printFunctionParameters: j, shouldGroupFunctionParameters: H } = Sr(), { printPropertyKey: I } = Ut(), { printFunctionTypeParameters: G } = ot();
          function Z(ue, Q, de, ge) {
            let ve = ue.getValue(), be = false;
            if ((ve.type === "FunctionDeclaration" || ve.type === "FunctionExpression") && ge && ge.expandLastArg) {
              let ce = ue.getParentNode();
              C(ce) && x(ce).length > 1 && (be = true);
            }
            let we = [];
            ve.type === "TSDeclareFunction" && ve.declare && we.push("declare "), ve.async && we.push("async "), ve.generator ? we.push("function* ") : we.push("function "), ve.id && we.push(Q("id"));
            let fe = j(ue, Q, de, be), pe = oe(ue, Q, de), me = H(ve, pe);
            return we.push(G(ue, de, Q), D([me ? D(fe) : fe, pe]), ve.body ? " " : "", Q("body")), de.semi && (ve.declare || !ve.body) && we.push(";"), we;
          }
          function W(ue, Q, de) {
            let ge = ue.getNode(), { kind: ve } = ge, be = ge.value || ge, we = [];
            return !ve || ve === "init" || ve === "method" || ve === "constructor" ? be.async && we.push("async ") : (t.ok(ve === "get" || ve === "set"), we.push(ve, " ")), be.generator && we.push("*"), we.push(I(ue, Q, de), ge.optional || ge.key.optional ? "?" : ""), ge === be ? we.push($(ue, Q, de)) : be.type === "FunctionExpression" ? we.push(ue.call((fe) => $(fe, Q, de), "value")) : we.push(de("value")), we;
          }
          function $(ue, Q, de) {
            let ge = ue.getNode(), ve = j(ue, de, Q), be = oe(ue, de, Q), we = H(ge, be), fe = [G(ue, Q, de), D([we ? D(ve) : ve, be])];
            return ge.body ? fe.push(" ", de("body")) : fe.push(Q.semi ? ";" : ""), fe;
          }
          function te(ue, Q, de, ge) {
            let ve = ue.getValue(), be = [];
            if (ve.async && be.push("async "), V(ue, Q))
              be.push(de(["params", 0]));
            else {
              let fe = ge && (ge.expandLastArg || ge.expandFirstArg), pe = oe(ue, de, Q);
              if (fe) {
                if (P(pe))
                  throw new N();
                pe = D(E(pe));
              }
              be.push(D([j(ue, de, Q, fe, true), pe]));
            }
            let we = i(ue, Q, true, (fe) => {
              let pe = n(Q.originalText, fe, M);
              return pe !== false && Q.originalText.slice(pe, pe + 2) === "=>";
            });
            return we && be.push(" ", we), be;
          }
          function U(ue, Q, de, ge, ve, be) {
            let we = ue.getName(), fe = ue.getParentNode(), pe = g(fe) && we === "callee", me = Boolean(Q && Q.assignmentLayout), ce = be.body.type !== "BlockStatement" && be.body.type !== "ObjectExpression" && be.body.type !== "SequenceExpression", he = pe && ce || Q && Q.assignmentLayout === "chain-tail-arrow-chain", J = Symbol("arrow-chain");
            return be.body.type === "SequenceExpression" && (ve = D(["(", F([o, ve]), o, ")"])), D([D(F([pe || me ? o : "", D(p([" =>", a], de), { shouldBreak: ge })]), { id: J, shouldBreak: he }), " =>", m(ce ? F([a, ve]) : [" ", ve], { groupId: J }), pe ? h(o, "", { groupId: J }) : ""]);
          }
          function ne(ue, Q, de, ge) {
            let ve = ue.getValue(), be = [], we = [], fe = false;
            if (function J() {
              let ye = te(ue, Q, de, ge);
              if (be.length === 0)
                be.push(ye);
              else {
                let { leading: X, trailing: Y } = l(ue, Q);
                be.push([X, ye]), we.unshift(Y);
              }
              fe = fe || ve.returnType && b(ve).length > 0 || ve.typeParameters || b(ve).some((X) => X.type !== "Identifier"), ve.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? we.unshift(de("body", ge)) : (ve = ve.body, ue.call(J, "body"));
            }(), be.length > 1)
              return U(ue, ge, be, fe, we, ve);
            let pe = be;
            if (pe.push(" =>"), !T(Q.originalText, ve.body) && (ve.body.type === "ArrayExpression" || ve.body.type === "ObjectExpression" || ve.body.type === "BlockStatement" || w(ve.body) || _(ve.body, Q.originalText) || ve.body.type === "ArrowFunctionExpression" || ve.body.type === "DoExpression"))
              return D([...pe, " ", we]);
            if (ve.body.type === "SequenceExpression")
              return D([...pe, D([" (", F([o, we]), o, ")"])]);
            let me = (ge && ge.expandLastArg || ue.getParentNode().type === "JSXExpressionContainer") && !c(ve), ce = ge && ge.expandLastArg && k(Q, "all"), he = ve.body.type === "ConditionalExpression" && !A(ve.body, false);
            return D([...pe, D([F([a, he ? h("", "(") : "", we, he ? h("", ")") : ""]), me ? [h(ce ? "," : ""), o] : ""])]);
          }
          function se(ue) {
            let Q = b(ue);
            return Q.length === 1 && !ue.typeParameters && !c(ue, y.Dangling) && Q[0].type === "Identifier" && !Q[0].typeAnnotation && !c(Q[0]) && !Q[0].optional && !ue.predicate && !ue.returnType;
          }
          function V(ue, Q) {
            if (Q.arrowParens === "always")
              return false;
            if (Q.arrowParens === "avoid") {
              let de = ue.getValue();
              return se(de);
            }
            return false;
          }
          function oe(ue, Q, de) {
            let ge = ue.getValue(), ve = Q("returnType");
            if (ge.returnType && S(de.originalText, ge.returnType))
              return [" /*: ", ve, " */"];
            let be = [ve];
            return ge.returnType && ge.returnType.typeAnnotation && be.unshift(": "), ge.predicate && be.push(ge.returnType ? " " : ": ", Q("predicate")), be;
          }
          function K(ue, Q, de) {
            let ge = ue.getValue(), ve = Q.semi ? ";" : "", be = [];
            ge.argument && (le(Q, ge.argument) ? be.push([" (", F([v, de("argument")]), v, ")"]) : f(ge.argument) || ge.argument.type === "SequenceExpression" ? be.push(D([h(" (", " "), F([o, de("argument")]), o, h(")")])) : be.push(" ", de("argument")));
            let we = r(ge), fe = u(we), pe = fe && d(fe);
            return pe && be.push(ve), c(ge, y.Dangling) && be.push(" ", i(ue, Q, true)), pe || be.push(ve), be;
          }
          function Ee(ue, Q, de) {
            return ["return", K(ue, Q, de)];
          }
          function R(ue, Q, de) {
            return ["throw", K(ue, Q, de)];
          }
          function le(ue, Q) {
            if (T(ue.originalText, Q))
              return true;
            if (B(Q)) {
              let de = Q, ge;
              for (; ge = L(de); )
                if (de = ge, T(ue.originalText, de))
                  return true;
            }
            return false;
          }
          s.exports = { printFunction: Z, printArrowFunction: ne, printMethod: W, printReturnStatement: Ee, printThrowStatement: R, printMethodInternal: $, shouldPrintParamsWithoutParens: V };
        } }), Rn = ee({ "src/language-js/print/decorators.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t, hasNewline: i } = Ge(), { builders: { line: l, hardline: u, join: n, breakParent: a, group: o } } = Le(), { locStart: D, locEnd: F } = nt(), { getParentExportDeclaration: h } = Xe();
          function v(N, b, T) {
            let S = N.getValue();
            return o([n(l, N.map(T, "decorators")), E(S, b) ? u : l]);
          }
          function p(N, b, T) {
            return [n(u, N.map(T, "declaration", "decorators")), u];
          }
          function m(N, b, T) {
            let S = N.getValue(), { decorators: w } = S;
            if (!t(w) || P(N.getParentNode()))
              return;
            let _ = S.type === "ClassExpression" || S.type === "ClassDeclaration" || E(S, b);
            return [h(N) ? u : _ ? a : "", n(l, N.map(T, "decorators")), l];
          }
          function E(N, b) {
            return N.decorators.some((T) => i(b.originalText, F(T)));
          }
          function P(N) {
            if (N.type !== "ExportDefaultDeclaration" && N.type !== "ExportNamedDeclaration" && N.type !== "DeclareExportDeclaration")
              return false;
            let b = N.declaration && N.declaration.decorators;
            return t(b) && D(N, { ignoreDecorators: true }) > D(b[0]);
          }
          s.exports = { printDecorators: m, printClassMemberDecorators: v, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: P };
        } }), zt = ee({ "src/language-js/print/class.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t, createGroupIdMapper: i } = Ge(), { printComments: l, printDanglingComments: u } = Qe(), { builders: { join: n, line: a, hardline: o, softline: D, group: F, indent: h, ifBreak: v } } = Le(), { hasComment: p, CommentCheckFlags: m } = Xe(), { getTypeParametersGroupId: E } = xr(), { printMethod: P } = Tr(), { printOptionalToken: N, printTypeAnnotation: b, printDefiniteToken: T } = ot(), { printPropertyKey: S } = Ut(), { printAssignment: w } = Jt(), { printClassMemberDecorators: _ } = Rn();
          function k(x, B, L) {
            let M = x.getValue(), j = [];
            M.declare && j.push("declare "), M.abstract && j.push("abstract "), j.push("class");
            let H = M.id && p(M.id, m.Trailing) || M.typeParameters && p(M.typeParameters, m.Trailing) || M.superClass && p(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), I = [], G = [];
            if (M.id && I.push(" ", L("id")), I.push(L("typeParameters")), M.superClass) {
              let Z = [y(x, B, L), L("superTypeParameters")], W = x.call(($) => ["extends ", l($, Z, B)], "superClass");
              H ? G.push(a, F(W)) : G.push(" ", W);
            } else
              G.push(r(x, B, L, "extends"));
            if (G.push(r(x, B, L, "mixins"), r(x, B, L, "implements")), H) {
              let Z;
              c(M) ? Z = [...I, h(G)] : Z = h([...I, G]), j.push(F(Z, { id: A(M) }));
            } else
              j.push(...I, ...G);
            return j.push(" ", L("body")), j;
          }
          var A = i("heritageGroup");
          function f(x) {
            return v(o, "", { groupId: A(x) });
          }
          function d(x) {
            return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(x[B])).length > 1;
          }
          function c(x) {
            return x.typeParameters && !p(x.typeParameters, m.Trailing | m.Line) && !d(x);
          }
          function r(x, B, L, M) {
            let j = x.getValue();
            if (!t(j[M]))
              return "";
            let H = u(x, B, true, (I) => {
              let { marker: G } = I;
              return G === M;
            });
            return [c(j) ? v(" ", a, { groupId: E(j.typeParameters) }) : a, H, H && o, M, F(h([a, n([",", a], x.map(L, M))]))];
          }
          function y(x, B, L) {
            let M = L("superClass");
            return x.getParentNode().type === "AssignmentExpression" ? F(v(["(", h([D, M]), D, ")"], M)) : M;
          }
          function g(x, B, L) {
            let M = x.getValue(), j = [];
            return t(M.decorators) && j.push(_(x, B, L)), M.accessibility && j.push(M.accessibility + " "), M.readonly && j.push("readonly "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), j.push(P(x, B, L)), j;
          }
          function C(x, B, L) {
            let M = x.getValue(), j = [], H = B.semi ? ";" : "";
            return t(M.decorators) && j.push(_(x, B, L)), M.accessibility && j.push(M.accessibility + " "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), M.readonly && j.push("readonly "), M.variance && j.push(L("variance")), M.type === "ClassAccessorProperty" && j.push("accessor "), j.push(S(x, B, L), N(x), T(x), b(x, B, L)), [w(x, B, L, j, " =", "value"), H];
          }
          s.exports = { printClass: k, printClassMethod: g, printClassProperty: C, printHardlineAfterHeritage: f };
        } }), to = ee({ "src/language-js/print/interface.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t } = Ge(), { builders: { join: i, line: l, group: u, indent: n, ifBreak: a } } = Le(), { hasComment: o, identity: D, CommentCheckFlags: F } = Xe(), { getTypeParametersGroupId: h } = xr(), { printTypeScriptModifiers: v } = ot();
          function p(m, E, P) {
            let N = m.getValue(), b = [];
            N.declare && b.push("declare "), N.type === "TSInterfaceDeclaration" && b.push(N.abstract ? "abstract " : "", v(m, E, P)), b.push("interface");
            let T = [], S = [];
            N.type !== "InterfaceTypeAnnotation" && T.push(" ", P("id"), P("typeParameters"));
            let w = N.typeParameters && !o(N.typeParameters, F.Trailing | F.Line);
            return t(N.extends) && S.push(w ? a(" ", l, { groupId: h(N.typeParameters) }) : l, "extends ", (N.extends.length === 1 ? D : n)(i([",", l], m.map(P, "extends")))), N.id && o(N.id, F.Trailing) || t(N.extends) ? w ? b.push(u([...T, n(S)])) : b.push(u(n([...T, ...S]))) : b.push(...T, ...S), b.push(" ", P("body")), u(b);
          }
          s.exports = { printInterface: p };
        } }), ro = ee({ "src/language-js/print/module.js"(e2, s) {
          "use strict";
          ae();
          var { isNonEmptyArray: t } = Ge(), { builders: { softline: i, group: l, indent: u, join: n, line: a, ifBreak: o, hardline: D } } = Le(), { printDanglingComments: F } = Qe(), { hasComment: h, CommentCheckFlags: v, shouldPrintComma: p, needsHardlineAfterDanglingComment: m, isStringLiteral: E, rawText: P } = Xe(), { locStart: N, hasSameLoc: b } = nt(), { hasDecoratorsBeforeExport: T, printDecoratorsBeforeExport: S } = Rn();
          function w(C, x, B) {
            let L = C.getValue(), M = x.semi ? ";" : "", j = [], { importKind: H } = L;
            return j.push("import"), H && H !== "value" && j.push(" ", H), j.push(d(C, x, B), f(C, x, B), r(C, x, B), M), j;
          }
          function _(C, x, B) {
            let L = C.getValue(), M = [];
            T(L) && M.push(S(C, x, B));
            let { type: j, exportKind: H, declaration: I } = L;
            return M.push("export"), (L.default || j === "ExportDefaultDeclaration") && M.push(" default"), h(L, v.Dangling) && (M.push(" ", F(C, x, true)), m(L) && M.push(D)), I ? M.push(" ", B("declaration")) : M.push(H === "type" ? " type" : "", d(C, x, B), f(C, x, B), r(C, x, B)), A(L, x) && M.push(";"), M;
          }
          function k(C, x, B) {
            let L = C.getValue(), M = x.semi ? ";" : "", j = [], { exportKind: H, exported: I } = L;
            return j.push("export"), H === "type" && j.push(" type"), j.push(" *"), I && j.push(" as ", B("exported")), j.push(f(C, x, B), r(C, x, B), M), j;
          }
          function A(C, x) {
            if (!x.semi)
              return false;
            let { type: B, declaration: L } = C, M = C.default || B === "ExportDefaultDeclaration";
            if (!L)
              return true;
            let { type: j } = L;
            return !!(M && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
          }
          function f(C, x, B) {
            let L = C.getValue();
            if (!L.source)
              return "";
            let M = [];
            return c(L, x) || M.push(" from"), M.push(" ", B("source")), M;
          }
          function d(C, x, B) {
            let L = C.getValue();
            if (c(L, x))
              return "";
            let M = [" "];
            if (t(L.specifiers)) {
              let j = [], H = [];
              C.each(() => {
                let I = C.getValue().type;
                if (I === "ExportNamespaceSpecifier" || I === "ExportDefaultSpecifier" || I === "ImportNamespaceSpecifier" || I === "ImportDefaultSpecifier")
                  j.push(B());
                else if (I === "ExportSpecifier" || I === "ImportSpecifier")
                  H.push(B());
                else
                  throw new Error("Unknown specifier type ".concat(JSON.stringify(I)));
              }, "specifiers"), M.push(n(", ", j)), H.length > 0 && (j.length > 0 && M.push(", "), H.length > 1 || j.length > 0 || L.specifiers.some((G) => h(G)) ? M.push(l(["{", u([x.bracketSpacing ? a : i, n([",", a], H)]), o(p(x) ? "," : ""), x.bracketSpacing ? a : i, "}"])) : M.push(["{", x.bracketSpacing ? " " : "", ...H, x.bracketSpacing ? " " : "", "}"]));
            } else
              M.push("{}");
            return M;
          }
          function c(C, x) {
            let { type: B, importKind: L, source: M, specifiers: j } = C;
            return B !== "ImportDeclaration" || t(j) || L === "type" ? false : !/{\s*}/.test(x.originalText.slice(N(C), N(M)));
          }
          function r(C, x, B) {
            let L = C.getNode();
            return t(L.assertions) ? [" assert {", x.bracketSpacing ? " " : "", n(", ", C.map(B, "assertions")), x.bracketSpacing ? " " : "", "}"] : "";
          }
          function y(C, x, B) {
            let L = C.getNode(), { type: M } = L, j = [], H = M === "ImportSpecifier" ? L.importKind : L.exportKind;
            H && H !== "value" && j.push(H, " ");
            let I = M.startsWith("Import"), G = I ? "imported" : "local", Z = I ? "local" : "exported", W = L[G], $ = L[Z], te = "", U = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? te = "*" : W && (te = B(G)), $ && !g(L) && (U = B(Z)), j.push(te, te && U ? " as " : "", U), j;
          }
          function g(C) {
            if (C.type !== "ImportSpecifier" && C.type !== "ExportSpecifier")
              return false;
            let { local: x, [C.type === "ImportSpecifier" ? "imported" : "exported"]: B } = C;
            if (x.type !== B.type || !b(x, B))
              return false;
            if (E(x))
              return x.value === B.value && P(x) === P(B);
            switch (x.type) {
              case "Identifier":
                return x.name === B.name;
              default:
                return false;
            }
          }
          s.exports = { printImportDeclaration: w, printExportDeclaration: _, printExportAllDeclaration: k, printModuleSpecifier: y };
        } }), Vn = ee({ "src/language-js/print/object.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { builders: { line: i, softline: l, group: u, indent: n, ifBreak: a, hardline: o } } = Le(), { getLast: D, hasNewlineInRange: F, hasNewline: h, isNonEmptyArray: v } = Ge(), { shouldPrintComma: p, hasComment: m, getComments: E, CommentCheckFlags: P, isNextLineEmpty: N } = Xe(), { locStart: b, locEnd: T } = nt(), { printOptionalToken: S, printTypeAnnotation: w } = ot(), { shouldHugFunctionParameters: _ } = Sr(), { shouldHugType: k } = br(), { printHardlineAfterHeritage: A } = zt();
          function f(d, c, r) {
            let y = c.semi ? ";" : "", g = d.getValue(), C;
            g.type === "TSTypeLiteral" ? C = "members" : g.type === "TSInterfaceBody" ? C = "body" : C = "properties";
            let x = g.type === "ObjectTypeAnnotation", B = [C];
            x && B.push("indexers", "callProperties", "internalSlots");
            let L = B.map((V) => g[V][0]).sort((V, oe) => b(V) - b(oe))[0], M = d.getParentNode(0), j = x && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && d.getName() === "body", H = g.type === "TSInterfaceBody" || j || g.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && g.properties.some((V) => V.value && (V.value.type === "ObjectPattern" || V.value.type === "ArrayPattern")) || g.type !== "ObjectPattern" && L && F(c.originalText, b(g), b(L)), I = j ? ";" : g.type === "TSInterfaceBody" || g.type === "TSTypeLiteral" ? a(y, ";") : ",", G = g.type === "RecordExpression" ? "#{" : g.exact ? "{|" : "{", Z = g.exact ? "|}" : "}", W = [];
            for (let V of B)
              d.each((oe) => {
                let K = oe.getValue();
                W.push({ node: K, printed: r(), loc: b(K) });
              }, V);
            B.length > 1 && W.sort((V, oe) => V.loc - oe.loc);
            let $ = [], te = W.map((V) => {
              let oe = [...$, u(V.printed)];
              return $ = [I, i], (V.node.type === "TSPropertySignature" || V.node.type === "TSMethodSignature" || V.node.type === "TSConstructSignatureDeclaration") && m(V.node, P.PrettierIgnore) && $.shift(), N(V.node, c) && $.push(o), oe;
            });
            if (g.inexact) {
              let V;
              if (m(g, P.Dangling)) {
                let oe = m(g, P.Line);
                V = [t(d, c, true), oe || h(c.originalText, T(D(E(g)))) ? o : i, "..."];
              } else
                V = ["..."];
              te.push([...$, ...V]);
            }
            let U = D(g[C]), ne = !(g.inexact || U && U.type === "RestElement" || U && (U.type === "TSPropertySignature" || U.type === "TSCallSignatureDeclaration" || U.type === "TSMethodSignature" || U.type === "TSConstructSignatureDeclaration") && m(U, P.PrettierIgnore)), se;
            if (te.length === 0) {
              if (!m(g, P.Dangling))
                return [G, Z, w(d, c, r)];
              se = u([G, t(d, c), l, Z, S(d), w(d, c, r)]);
            } else
              se = [j && v(g.properties) ? A(M) : "", G, n([c.bracketSpacing ? i : l, ...te]), a(ne && (I !== "," || p(c)) ? I : ""), c.bracketSpacing ? i : l, Z, S(d), w(d, c, r)];
            return d.match((V) => V.type === "ObjectPattern" && !V.decorators, (V, oe, K) => _(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || d.match(k, (V, oe) => oe === "typeAnnotation", (V, oe) => oe === "typeAnnotation", (V, oe, K) => _(V) && (oe === "params" || oe === "parameters" || oe === "this" || oe === "rest") && K === 0) || !H && d.match((V) => V.type === "ObjectPattern", (V) => V.type === "AssignmentExpression" || V.type === "VariableDeclarator") ? se : u(se, { shouldBreak: H });
          }
          s.exports = { printObject: f };
        } }), am = ee({ "src/language-js/print/flow.js"(e2, s) {
          "use strict";
          ae();
          var t = Ht(), { printDanglingComments: i } = Qe(), { printString: l, printNumber: u } = Ge(), { builders: { hardline: n, softline: a, group: o, indent: D } } = Le(), { getParentExportDeclaration: F, isFunctionNotation: h, isGetterOrSetter: v, rawText: p, shouldPrintComma: m } = Xe(), { locStart: E, locEnd: P } = nt(), { printClass: N } = zt(), { printOpaqueType: b, printTypeAlias: T, printIntersectionType: S, printUnionType: w, printFunctionType: _, printTupleType: k, printIndexedAccessType: A } = br(), { printInterface: f } = to(), { printTypeParameter: d, printTypeParameters: c } = xr(), { printExportDeclaration: r, printExportAllDeclaration: y } = ro(), { printArrayItems: g } = Gt(), { printObject: C } = Vn(), { printPropertyKey: x } = Ut(), { printOptionalToken: B, printTypeAnnotation: L, printRestSpread: M } = ot();
          function j(I, G, Z) {
            let W = I.getValue(), $ = G.semi ? ";" : "", te = [];
            switch (W.type) {
              case "DeclareClass":
                return H(I, N(I, G, Z));
              case "DeclareFunction":
                return H(I, ["function ", Z("id"), W.predicate ? " " : "", Z("predicate"), $]);
              case "DeclareModule":
                return H(I, ["module ", Z("id"), " ", Z("body")]);
              case "DeclareModuleExports":
                return H(I, ["module.exports", ": ", Z("typeAnnotation"), $]);
              case "DeclareVariable":
                return H(I, ["var ", Z("id"), $]);
              case "DeclareOpaqueType":
                return H(I, b(I, G, Z));
              case "DeclareInterface":
                return H(I, f(I, G, Z));
              case "DeclareTypeAlias":
                return H(I, T(I, G, Z));
              case "DeclareExportDeclaration":
                return H(I, r(I, G, Z));
              case "DeclareExportAllDeclaration":
                return H(I, y(I, G, Z));
              case "OpaqueType":
                return b(I, G, Z);
              case "TypeAlias":
                return T(I, G, Z);
              case "IntersectionTypeAnnotation":
                return S(I, G, Z);
              case "UnionTypeAnnotation":
                return w(I, G, Z);
              case "FunctionTypeAnnotation":
                return _(I, G, Z);
              case "TupleTypeAnnotation":
                return k(I, G, Z);
              case "GenericTypeAnnotation":
                return [Z("id"), c(I, G, Z, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return A(I, G, Z);
              case "TypeAnnotation":
                return Z("typeAnnotation");
              case "TypeParameter":
                return d(I, G, Z);
              case "TypeofTypeAnnotation":
                return ["typeof ", Z("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [Z("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(W.value);
              case "EnumDeclaration":
                return ["enum ", Z("id"), " ", Z("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (W.type === "EnumSymbolBody" || W.explicitType) {
                  let U = null;
                  switch (W.type) {
                    case "EnumBooleanBody":
                      U = "boolean";
                      break;
                    case "EnumNumberBody":
                      U = "number";
                      break;
                    case "EnumStringBody":
                      U = "string";
                      break;
                    case "EnumSymbolBody":
                      U = "symbol";
                      break;
                  }
                  te.push("of ", U, " ");
                }
                if (W.members.length === 0 && !W.hasUnknownMembers)
                  te.push(o(["{", i(I, G), a, "}"]));
                else {
                  let U = W.members.length > 0 ? [n, g(I, G, "members", Z), W.hasUnknownMembers || m(G) ? "," : ""] : [];
                  te.push(o(["{", D([...U, ...W.hasUnknownMembers ? [n, "..."] : []]), i(I, G, true), n, "}"]));
                }
                return te;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [Z("id"), " = ", typeof W.init == "object" ? Z("init") : String(W.init)];
              case "EnumDefaultedMember":
                return Z("id");
              case "FunctionTypeParam": {
                let U = W.name ? Z("name") : I.getParentNode().this === W ? "this" : "";
                return [U, B(I), U ? ": " : "", Z("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return f(I, G, Z);
              case "ClassImplements":
              case "InterfaceExtends":
                return [Z("id"), Z("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", Z("typeAnnotation")];
              case "Variance": {
                let { kind: U } = W;
                return t.ok(U === "plus" || U === "minus"), U === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return W.static && te.push("static "), te.push(Z("value")), te;
              case "ObjectTypeIndexer":
                return [W.static ? "static " : "", W.variance ? Z("variance") : "", "[", Z("id"), W.id ? ": " : "", Z("key"), "]: ", Z("value")];
              case "ObjectTypeProperty": {
                let U = "";
                return W.proto ? U = "proto " : W.static && (U = "static "), [U, v(W) ? W.kind + " " : "", W.variance ? Z("variance") : "", x(I, G, Z), B(I), h(W) ? "" : ": ", Z("value")];
              }
              case "ObjectTypeAnnotation":
                return C(I, G, Z);
              case "ObjectTypeInternalSlot":
                return [W.static ? "static " : "", "[[", Z("id"), "]]", B(I), W.method ? "" : ": ", Z("value")];
              case "ObjectTypeSpreadProperty":
                return M(I, G, Z);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [Z("qualification"), ".", Z("id")];
              case "StringLiteralTypeAnnotation":
                return l(p(W), G);
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof W.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return W.extra ? u(W.extra.raw) : u(W.raw);
              case "TypeCastExpression":
                return ["(", Z("expression"), L(I, G, Z), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let U = c(I, G, Z, "params");
                if (G.parser === "flow") {
                  let ne = E(W), se = P(W), V = G.originalText.lastIndexOf("/*", ne), oe = G.originalText.indexOf("*/", se);
                  if (V !== -1 && oe !== -1) {
                    let K = G.originalText.slice(V + 2, oe).trim();
                    if (K.startsWith("::") && !K.includes("/*") && !K.includes("*/"))
                      return ["/*:: ", U, " */"];
                  }
                }
                return U;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", Z("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(W.type));
            }
          }
          function H(I, G) {
            let Z = F(I);
            return Z ? (t.strictEqual(Z.type, "DeclareExportDeclaration"), G) : ["declare ", G];
          }
          s.exports = { printFlow: j };
        } }), im = ee({ "src/language-js/utils/is-ts-keyword-type.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            let { type: l } = i;
            return l.startsWith("TS") && l.endsWith("Keyword");
          }
          s.exports = t;
        } }), no = ee({ "src/language-js/print/ternary.js"(e2, s) {
          "use strict";
          ae();
          var { hasNewlineInRange: t } = Ge(), { isJsxNode: i, getComments: l, isCallExpression: u, isMemberExpression: n } = Xe(), { locStart: a, locEnd: o } = nt(), D = wt(), { builders: { line: F, softline: h, group: v, indent: p, align: m, ifBreak: E, dedent: P, breakParent: N } } = Le();
          function b(k) {
            let A = [k];
            for (let f = 0; f < A.length; f++) {
              let d = A[f];
              for (let c of ["test", "consequent", "alternate"]) {
                let r = d[c];
                if (i(r))
                  return true;
                r.type === "ConditionalExpression" && A.push(r);
              }
            }
            return false;
          }
          function T(k, A, f) {
            let d = k.getValue(), c = d.type === "ConditionalExpression", r = c ? "alternate" : "falseType", y = k.getParentNode(), g = c ? f("test") : [f("checkType"), " ", "extends", " ", f("extendsType")];
            return y.type === d.type && y[r] === d ? m(2, g) : g;
          }
          var S = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function w(k) {
            let A = k.getValue();
            if (A.type !== "ConditionalExpression")
              return false;
            let f, d = A;
            for (let c = 0; !f; c++) {
              let r = k.getParentNode(c);
              if (u(r) && r.callee === d || n(r) && r.object === d || r.type === "TSNonNullExpression" && r.expression === d) {
                d = r;
                continue;
              }
              r.type === "NewExpression" && r.callee === d || r.type === "TSAsExpression" && r.expression === d ? (f = k.getParentNode(c + 1), d = r) : f = r;
            }
            return d === A ? false : f[S.get(f.type)] === d;
          }
          function _(k, A, f) {
            let d = k.getValue(), c = d.type === "ConditionalExpression", r = c ? "consequent" : "trueType", y = c ? "alternate" : "falseType", g = c ? ["test"] : ["checkType", "extendsType"], C = d[r], x = d[y], B = [], L = false, M = k.getParentNode(), j = M.type === d.type && g.some((K) => M[K] === d), H = M.type === d.type && !j, I, G, Z = 0;
            do
              G = I || d, I = k.getParentNode(Z), Z++;
            while (I && I.type === d.type && g.every((K) => I[K] !== G));
            let W = I || M, $ = G;
            if (c && (i(d[g[0]]) || i(C) || i(x) || b($))) {
              L = true, H = true;
              let K = (R) => [E("("), p([h, R]), h, E(")")], Ee = (R) => R.type === "NullLiteral" || R.type === "Literal" && R.value === null || R.type === "Identifier" && R.name === "undefined";
              B.push(" ? ", Ee(C) ? f(r) : K(f(r)), " : ", x.type === d.type || Ee(x) ? f(y) : K(f(y)));
            } else {
              let K = [F, "? ", C.type === d.type ? E("", "(") : "", m(2, f(r)), C.type === d.type ? E("", ")") : "", F, ": ", x.type === d.type ? f(y) : m(2, f(y))];
              B.push(M.type !== d.type || M[y] === d || j ? K : A.useTabs ? P(p(K)) : m(Math.max(0, A.tabWidth - 2), K));
            }
            let U = [...g.map((K) => l(d[K])), l(C), l(x)].flat().some((K) => D(K) && t(A.originalText, a(K), o(K))), ne = (K) => M === W ? v(K, { shouldBreak: U }) : U ? [K, N] : K, se = !L && (n(M) || M.type === "NGPipeExpression" && M.left === d) && !M.computed, V = w(k), oe = ne([T(k, A, f), H ? B : p(B), c && se && !V ? h : ""]);
            return j || V ? v([p([h, oe]), h]) : oe;
          }
          s.exports = { printTernary: _ };
        } }), uo = ee({ "src/language-js/print/statement.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { hardline: t } } = Le(), i = _t(), { getLeftSidePathName: l, hasNakedLeftSide: u, isJsxNode: n, isTheOnlyJsxElementInMarkdown: a, hasComment: o, CommentCheckFlags: D, isNextLineEmpty: F } = Xe(), { shouldPrintParamsWithoutParens: h } = Tr();
          function v(S, w, _, k) {
            let A = S.getValue(), f = [], d = A.type === "ClassBody", c = p(A[k]);
            return S.each((r, y, g) => {
              let C = r.getValue();
              if (C.type === "EmptyStatement")
                return;
              let x = _();
              !w.semi && !d && !a(w, r) && m(r, w) ? o(C, D.Leading) ? f.push(_([], { needsSemi: true })) : f.push(";", x) : f.push(x), !w.semi && d && b(C) && T(C, g[y + 1]) && f.push(";"), C !== c && (f.push(t), F(C, w) && f.push(t));
            }, k), f;
          }
          function p(S) {
            for (let w = S.length - 1; w >= 0; w--) {
              let _ = S[w];
              if (_.type !== "EmptyStatement")
                return _;
            }
          }
          function m(S, w) {
            return S.getNode().type !== "ExpressionStatement" ? false : S.call((k) => E(k, w), "expression");
          }
          function E(S, w) {
            let _ = S.getValue();
            switch (_.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h(S, w))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: k, operator: A } = _;
                if (k && (A === "+" || A === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!_.object)
                  return true;
                break;
              }
              case "Literal": {
                if (_.regex)
                  return true;
                break;
              }
              default:
                if (n(_))
                  return true;
            }
            return i(S, w) ? true : u(_) ? S.call((k) => E(k, w), ...l(S, _)) : false;
          }
          function P(S, w, _) {
            return v(S, w, _, "body");
          }
          function N(S, w, _) {
            return v(S, w, _, "consequent");
          }
          var b = (S) => {
            let { type: w } = S;
            return w === "ClassProperty" || w === "PropertyDefinition" || w === "ClassPrivateProperty" || w === "ClassAccessorProperty";
          };
          function T(S, w) {
            let _ = S.key && S.key.name;
            if ((_ === "static" || _ === "get" || _ === "set") && !S.value && !S.typeAnnotation)
              return true;
            if (!w || w.static || w.accessibility)
              return false;
            if (!w.computed) {
              let k = w.key && w.key.name;
              if (k === "in" || k === "instanceof")
                return true;
            }
            if (b(w) && w.variance && !w.static && !w.declare)
              return true;
            switch (w.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return w.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((w.value ? w.value.async : w.async) || w.kind === "get" || w.kind === "set")
                  return false;
                let A = w.value ? w.value.generator : w.generator;
                return !!(w.computed || A);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          s.exports = { printBody: P, printSwitchCaseConsequent: N };
        } }), so = ee({ "src/language-js/print/block.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { isNonEmptyArray: i } = Ge(), { builders: { hardline: l, indent: u } } = Le(), { hasComment: n, CommentCheckFlags: a, isNextLineEmpty: o } = Xe(), { printHardlineAfterHeritage: D } = zt(), { printBody: F } = uo();
          function h(p, m, E) {
            let P = p.getValue(), N = [];
            if (P.type === "StaticBlock" && N.push("static "), P.type === "ClassBody" && i(P.body)) {
              let T = p.getParentNode();
              N.push(D(T));
            }
            N.push("{");
            let b = v(p, m, E);
            if (b)
              N.push(u([l, b]), l);
            else {
              let T = p.getParentNode(), S = p.getParentNode(1);
              T.type === "ArrowFunctionExpression" || T.type === "FunctionExpression" || T.type === "FunctionDeclaration" || T.type === "ObjectMethod" || T.type === "ClassMethod" || T.type === "ClassPrivateMethod" || T.type === "ForStatement" || T.type === "WhileStatement" || T.type === "DoWhileStatement" || T.type === "DoExpression" || T.type === "CatchClause" && !S.finalizer || T.type === "TSModuleDeclaration" || T.type === "TSDeclareFunction" || P.type === "StaticBlock" || P.type === "ClassBody" || N.push(l);
            }
            return N.push("}"), N;
          }
          function v(p, m, E) {
            let P = p.getValue(), N = i(P.directives), b = P.body.some((w) => w.type !== "EmptyStatement"), T = n(P, a.Dangling);
            if (!N && !b && !T)
              return "";
            let S = [];
            if (N && p.each((w, _, k) => {
              S.push(E()), (_ < k.length - 1 || b || T) && (S.push(l), o(w.getValue(), m) && S.push(l));
            }, "directives"), b && S.push(F(p, m, E)), T && S.push(t(p, m, true)), P.type === "Program") {
              let w = p.getParentNode();
              (!w || w.type !== "ModuleExpression") && S.push(l);
            }
            return S;
          }
          s.exports = { printBlock: h, printBlockBody: v };
        } }), om = ee({ "src/language-js/print/typescript.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { hasNewlineInRange: i } = Ge(), { builders: { join: l, line: u, hardline: n, softline: a, group: o, indent: D, conditionalGroup: F, ifBreak: h } } = Le(), { isLiteral: v, getTypeScriptMappedTypeModifier: p, shouldPrintComma: m, isCallExpression: E, isMemberExpression: P } = Xe(), N = im(), { locStart: b, locEnd: T } = nt(), { printOptionalToken: S, printTypeScriptModifiers: w } = ot(), { printTernary: _ } = no(), { printFunctionParameters: k, shouldGroupFunctionParameters: A } = Sr(), { printTemplateLiteral: f } = Pt(), { printArrayItems: d } = Gt(), { printObject: c } = Vn(), { printClassProperty: r, printClassMethod: y } = zt(), { printTypeParameter: g, printTypeParameters: C } = xr(), { printPropertyKey: x } = Ut(), { printFunction: B, printMethodInternal: L } = Tr(), { printInterface: M } = to(), { printBlock: j } = so(), { printTypeAlias: H, printIntersectionType: I, printUnionType: G, printFunctionType: Z, printTupleType: W, printIndexedAccessType: $ } = br();
          function te(U, ne, se) {
            let V = U.getValue();
            if (!V.type.startsWith("TS"))
              return;
            if (N(V))
              return V.type.slice(2, -7).toLowerCase();
            let oe = ne.semi ? ";" : "", K = [];
            switch (V.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Ee = !(V.expression.type === "ArrayExpression" || V.expression.type === "ObjectExpression"), R = o(["<", D([a, se("typeAnnotation")]), a, ">"]), le = [h("("), D([a, se("expression")]), a, h(")")];
                return Ee ? F([[R, se("expression")], [R, o(le, { shouldBreak: true })], [R, se("expression")]]) : o([R, se("expression")]);
              }
              case "TSDeclareFunction":
                return B(U, se, ne);
              case "TSExportAssignment":
                return ["export = ", se("expression"), oe];
              case "TSModuleBlock":
                return j(U, ne, se);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return c(U, ne, se);
              case "TSTypeAliasDeclaration":
                return H(U, ne, se);
              case "TSQualifiedName":
                return l(".", [se("left"), se("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return y(U, ne, se);
              case "TSAbstractPropertyDefinition":
                return r(U, ne, se);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return K.push(se("expression")), V.typeParameters && K.push(se("typeParameters")), K;
              case "TSTemplateLiteralType":
                return f(U, se, ne);
              case "TSNamedTupleMember":
                return [se("label"), V.optional ? "?" : "", ": ", se("elementType")];
              case "TSRestType":
                return ["...", se("typeAnnotation")];
              case "TSOptionalType":
                return [se("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(U, ne, se);
              case "TSClassImplements":
                return [se("expression"), se("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return C(U, ne, se, "params");
              case "TSTypeParameter":
                return g(U, ne, se);
              case "TSAsExpression": {
                K.push(se("expression"), " as ", se("typeAnnotation"));
                let Ee = U.getParentNode();
                return E(Ee) && Ee.callee === V || P(Ee) && Ee.object === V ? o([D([a, ...K]), a]) : K;
              }
              case "TSArrayType":
                return [se("elementType"), "[]"];
              case "TSPropertySignature":
                return V.readonly && K.push("readonly "), K.push(x(U, ne, se), S(U)), V.typeAnnotation && K.push(": ", se("typeAnnotation")), V.initializer && K.push(" = ", se("initializer")), K;
              case "TSParameterProperty":
                return V.accessibility && K.push(V.accessibility + " "), V.export && K.push("export "), V.static && K.push("static "), V.override && K.push("override "), V.readonly && K.push("readonly "), K.push(se("parameter")), K;
              case "TSTypeQuery":
                return ["typeof ", se("exprName")];
              case "TSIndexSignature": {
                let Ee = U.getParentNode(), R = V.parameters.length > 1 ? h(m(ne) ? "," : "") : "", le = o([D([a, l([", ", a], U.map(se, "parameters"))]), R, a]);
                return [V.export ? "export " : "", V.accessibility ? [V.accessibility, " "] : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.declare ? "declare " : "", "[", V.parameters ? le : "", V.typeAnnotation ? "]: " : "]", V.typeAnnotation ? se("typeAnnotation") : "", Ee.type === "ClassBody" ? oe : ""];
              }
              case "TSTypePredicate":
                return [V.asserts ? "asserts " : "", se("parameterName"), V.typeAnnotation ? [" is ", se("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [se("expression"), "!"];
              case "TSImportType":
                return [V.isTypeOf ? "typeof " : "", "import(", se(V.parameter ? "parameter" : "argument"), ")", V.qualifier ? [".", se("qualifier")] : "", C(U, ne, se, "typeParameters")];
              case "TSLiteralType":
                return se("literal");
              case "TSIndexedAccessType":
                return $(U, ne, se);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (V.type === "TSConstructorType" && V.abstract && K.push("abstract "), V.type !== "TSCallSignatureDeclaration" && K.push("new "), K.push(o(k(U, se, ne, false, true))), V.returnType || V.typeAnnotation) {
                  let Ee = V.type === "TSConstructorType";
                  K.push(Ee ? " => " : ": ", se("returnType"), se("typeAnnotation"));
                }
                return K;
              }
              case "TSTypeOperator":
                return [V.operator, " ", se("typeAnnotation")];
              case "TSMappedType": {
                let Ee = i(ne.originalText, b(V), T(V));
                return o(["{", D([ne.bracketSpacing ? u : a, V.readonly ? [p(V.readonly, "readonly"), " "] : "", w(U, ne, se), se("typeParameter"), V.optional ? p(V.optional, "?") : "", V.typeAnnotation ? ": " : "", se("typeAnnotation"), h(oe)]), t(U, ne, true), ne.bracketSpacing ? u : a, "}"], { shouldBreak: Ee });
              }
              case "TSMethodSignature": {
                let Ee = V.kind && V.kind !== "method" ? "".concat(V.kind, " ") : "";
                K.push(V.accessibility ? [V.accessibility, " "] : "", Ee, V.export ? "export " : "", V.static ? "static " : "", V.readonly ? "readonly " : "", V.abstract ? "abstract " : "", V.declare ? "declare " : "", V.computed ? "[" : "", se("key"), V.computed ? "]" : "", S(U));
                let R = k(U, se, ne, false, true), le = V.returnType ? "returnType" : "typeAnnotation", ue = V[le], Q = ue ? se(le) : "", de = A(V, Q);
                return K.push(de ? o(R) : R), ue && K.push(": ", o(Q)), o(K);
              }
              case "TSNamespaceExportDeclaration":
                return K.push("export as namespace ", se("id")), ne.semi && K.push(";"), o(K);
              case "TSEnumDeclaration":
                return V.declare && K.push("declare "), V.modifiers && K.push(w(U, ne, se)), V.const && K.push("const "), K.push("enum ", se("id"), " "), V.members.length === 0 ? K.push(o(["{", t(U, ne), a, "}"])) : K.push(o(["{", D([n, d(U, ne, "members", se), m(ne, "es5") ? "," : ""]), t(U, ne, true), n, "}"])), K;
              case "TSEnumMember":
                return K.push(se("id")), V.initializer && K.push(" = ", se("initializer")), K;
              case "TSImportEqualsDeclaration":
                return V.isExport && K.push("export "), K.push("import "), V.importKind && V.importKind !== "value" && K.push(V.importKind, " "), K.push(se("id"), " = ", se("moduleReference")), ne.semi && K.push(";"), o(K);
              case "TSExternalModuleReference":
                return ["require(", se("expression"), ")"];
              case "TSModuleDeclaration": {
                let Ee = U.getParentNode(), R = v(V.id), le = Ee.type === "TSModuleDeclaration", ue = V.body && V.body.type === "TSModuleDeclaration";
                if (le)
                  K.push(".");
                else {
                  V.declare && K.push("declare "), K.push(w(U, ne, se));
                  let Q = ne.originalText.slice(b(V), b(V.id));
                  V.id.type === "Identifier" && V.id.name === "global" && !/namespace|module/.test(Q) || K.push(R || /(?:^|\s)module(?:\s|$)/.test(Q) ? "module " : "namespace ");
                }
                return K.push(se("id")), ue ? K.push(se("body")) : V.body ? K.push(" ", o(se("body"))) : K.push(oe), K;
              }
              case "TSConditionalType":
                return _(U, ne, se);
              case "TSInferType":
                return ["infer", " ", se("typeParameter")];
              case "TSIntersectionType":
                return I(U, ne, se);
              case "TSUnionType":
                return G(U, ne, se);
              case "TSFunctionType":
                return Z(U, ne, se);
              case "TSTupleType":
                return W(U, ne, se);
              case "TSTypeReference":
                return [se("typeName"), C(U, ne, se, "typeParameters")];
              case "TSTypeAnnotation":
                return se("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return L(U, ne, se);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return ["?", se("typeAnnotation")];
              case "TSJSDocNonNullableType":
                return ["!", se("typeAnnotation")];
              default:
                throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(V.type), "."));
            }
          }
          s.exports = { printTypescript: te };
        } }), cm = ee({ "src/language-js/print/comment.js"(e2, s) {
          "use strict";
          ae();
          var { hasNewline: t } = Ge(), { builders: { join: i, hardline: l }, utils: { replaceTextEndOfLine: u } } = Le(), { isLineComment: n } = Xe(), { locStart: a, locEnd: o } = nt(), D = wt();
          function F(p, m) {
            let E = p.getValue();
            if (n(E))
              return m.originalText.slice(a(E), o(E)).trimEnd();
            if (D(E)) {
              if (h(E)) {
                let b = v(E);
                return E.trailing && !t(m.originalText, a(E), { backwards: true }) ? [l, b] : b;
              }
              let P = o(E), N = m.originalText.slice(P - 3, P) === "*-/";
              return ["/*", u(E.value), N ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(E));
          }
          function h(p) {
            let m = "*".concat(p.value, "*").split(`
`);
            return m.length > 1 && m.every((E) => E.trim()[0] === "*");
          }
          function v(p) {
            let m = p.value.split(`
`);
            return ["/*", i(l, m.map((E, P) => P === 0 ? E.trimEnd() : " " + (P < m.length - 1 ? E.trim() : E.trimStart()))), "*/"];
          }
          s.exports = { printComment: F };
        } }), lm = ee({ "src/language-js/print/literal.js"(e2, s) {
          "use strict";
          ae();
          var { printString: t, printNumber: i } = Ge();
          function l(a, o) {
            let D = a.getNode();
            switch (D.type) {
              case "RegExpLiteral":
                return n(D);
              case "BigIntLiteral":
                return u(D.bigint || D.extra.raw);
              case "NumericLiteral":
                return i(D.extra.raw);
              case "StringLiteral":
                return t(D.extra.raw, o);
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(D.value);
              case "DecimalLiteral":
                return i(D.value) + "m";
              case "Literal": {
                if (D.regex)
                  return n(D.regex);
                if (D.bigint)
                  return u(D.raw);
                if (D.decimal)
                  return i(D.decimal) + "m";
                let { value: F } = D;
                return typeof F == "number" ? i(D.raw) : typeof F == "string" ? t(D.raw, o) : String(F);
              }
            }
          }
          function u(a) {
            return a.toLowerCase();
          }
          function n(a) {
            let { pattern: o, flags: D } = a;
            return D = [...D].sort().join(""), "/".concat(o, "/").concat(D);
          }
          s.exports = { printLiteral: l };
        } }), pm2 = ee({ "src/language-js/printer-estree.js"(e2, s) {
          "use strict";
          ae();
          var { printDanglingComments: t } = Qe(), { hasNewline: i } = Ge(), { builders: { join: l, line: u, hardline: n, softline: a, group: o, indent: D }, utils: { replaceTextEndOfLine: F } } = Le(), h = UD(), v = zD(), { insertPragma: p } = Xi(), m = Ki(), E = _t(), P = Yi(), { hasFlowShorthandAnnotationComment: N, hasComment: b, CommentCheckFlags: T, isTheOnlyJsxElementInMarkdown: S, isLineComment: w, isNextLineEmpty: _, needsHardlineAfterDanglingComment: k, rawText: A, hasIgnoreComment: f, isCallExpression: d, isMemberExpression: c, markerForIfWithoutBlockAndSameLineComment: r } = Xe(), { locStart: y, locEnd: g } = nt(), C = wt(), { printHtmlBinding: x, isVueEventBindingExpression: B } = rm(), { printAngular: L } = nm(), { printJsx: M, hasJsxIgnoreComment: j } = um(), { printFlow: H } = am(), { printTypescript: I } = om(), { printOptionalToken: G, printBindExpressionCallee: Z, printTypeAnnotation: W, adjustClause: $, printRestSpread: te, printDefiniteToken: U } = ot(), { printImportDeclaration: ne, printExportDeclaration: se, printExportAllDeclaration: V, printModuleSpecifier: oe } = ro(), { printTernary: K } = no(), { printTemplateLiteral: Ee } = Pt(), { printArray: R } = Gt(), { printObject: le } = Vn(), { printClass: ue, printClassMethod: Q, printClassProperty: de } = zt(), { printProperty: ge } = Ut(), { printFunction: ve, printArrowFunction: be, printMethod: we, printReturnStatement: fe, printThrowStatement: pe } = Tr(), { printCallExpression: me } = eo(), { printVariableDeclarator: ce, printAssignmentExpression: he } = Jt(), { printBinaryishExpression: J } = Mn(), { printSwitchCaseConsequent: ye } = uo(), { printMemberExpression: X } = Zi(), { printBlock: Y, printBlockBody: re } = so(), { printComment: z } = cm(), { printLiteral: q } = lm(), { printDecorators: Ce } = Rn();
          function Ne(Te, Pe, Fe, Ke) {
            let Se = je(Te, Pe, Fe, Ke);
            if (!Se)
              return "";
            let ze = Te.getValue(), { type: Be } = ze;
            if (Be === "ClassMethod" || Be === "ClassPrivateMethod" || Be === "ClassProperty" || Be === "ClassAccessorProperty" || Be === "PropertyDefinition" || Be === "TSAbstractPropertyDefinition" || Be === "ClassPrivateProperty" || Be === "MethodDefinition" || Be === "TSAbstractMethodDefinition" || Be === "TSDeclareMethod")
              return Se;
            let Ie = [Se], Re = Ce(Te, Pe, Fe), Ae = ze.type === "ClassExpression" && Re;
            if (Re && (Ie = [...Re, Se], !Ae))
              return o(Ie);
            if (!E(Te, Pe))
              return Ke && Ke.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === Se ? Se : Ie;
            if (Ae && (Ie = [D([u, ...Ie])]), Ie.unshift("("), Ke && Ke.needsSemi && Ie.unshift(";"), N(ze)) {
              let [_e] = ze.trailingComments;
              Ie.push(" /*", _e.value.trimStart(), "*/"), _e.printed = true;
            }
            return Ae && Ie.push(u), Ie.push(")"), Ie;
          }
          function je(Te, Pe, Fe, Ke) {
            let Se = Te.getValue(), ze = Pe.semi ? ";" : "";
            if (!Se)
              return "";
            if (typeof Se == "string")
              return Se;
            for (let Ie of [q, x, L, M, H, I]) {
              let Re = Ie(Te, Pe, Fe);
              if (typeof Re < "u")
                return Re;
            }
            let Be = [];
            switch (Se.type) {
              case "JsExpressionRoot":
                return Fe("node");
              case "JsonRoot":
                return [Fe("node"), n];
              case "File":
                return Se.program && Se.program.interpreter && Be.push(Fe(["program", "interpreter"])), Be.push(Fe("program")), Be;
              case "Program":
                return re(Te, Pe, Fe);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (Se.directive)
                  return [Ue(Se.expression, Pe), ze];
                if (Pe.parser === "__vue_event_binding") {
                  let Re = Te.getParentNode();
                  if (Re.type === "Program" && Re.body.length === 1 && Re.body[0] === Se)
                    return [Fe("expression"), B(Se.expression) ? ";" : ""];
                }
                let Ie = t(Te, Pe, true, (Re) => {
                  let { marker: Ae } = Re;
                  return Ae === r;
                });
                return [Fe("expression"), S(Pe, Te) ? "" : ze, Ie ? [" ", Ie] : ""];
              }
              case "ParenthesizedExpression":
                return !b(Se.expression) && (Se.expression.type === "ObjectExpression" || Se.expression.type === "ArrayExpression") ? ["(", Fe("expression"), ")"] : o(["(", D([a, Fe("expression")]), a, ")"]);
              case "AssignmentExpression":
                return he(Te, Pe, Fe);
              case "VariableDeclarator":
                return ce(Te, Pe, Fe);
              case "BinaryExpression":
              case "LogicalExpression":
                return J(Te, Pe, Fe);
              case "AssignmentPattern":
                return [Fe("left"), " = ", Fe("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return X(Te, Pe, Fe);
              case "MetaProperty":
                return [Fe("meta"), ".", Fe("property")];
              case "BindExpression":
                return Se.object && Be.push(Fe("object")), Be.push(o(D([a, Z(Te, Pe, Fe)]))), Be;
              case "Identifier":
                return [Se.name, G(Te), U(Te), W(Te, Pe, Fe)];
              case "V8IntrinsicIdentifier":
                return ["%", Se.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return te(Te, Pe, Fe);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ve(Te, Fe, Pe, Ke);
              case "ArrowFunctionExpression":
                return be(Te, Pe, Fe, Ke);
              case "YieldExpression":
                return Be.push("yield"), Se.delegate && Be.push("*"), Se.argument && Be.push(" ", Fe("argument")), Be;
              case "AwaitExpression": {
                if (Be.push("await"), Se.argument) {
                  Be.push(" ", Fe("argument"));
                  let Ie = Te.getParentNode();
                  if (d(Ie) && Ie.callee === Se || c(Ie) && Ie.object === Se) {
                    Be = [D([a, ...Be]), a];
                    let Re = Te.findAncestor((Ae) => Ae.type === "AwaitExpression" || Ae.type === "BlockStatement");
                    if (!Re || Re.type !== "AwaitExpression")
                      return o(Be);
                  }
                }
                return Be;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return se(Te, Pe, Fe);
              case "ExportAllDeclaration":
                return V(Te, Pe, Fe);
              case "ImportDeclaration":
                return ne(Te, Pe, Fe);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return oe(Te, Pe, Fe);
              case "ImportAttribute":
                return [Fe("key"), ": ", Fe("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return Y(Te, Pe, Fe);
              case "ThrowStatement":
                return pe(Te, Pe, Fe);
              case "ReturnStatement":
                return fe(Te, Pe, Fe);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return me(Te, Pe, Fe);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return le(Te, Pe, Fe);
              case "ObjectProperty":
              case "Property":
                return Se.method || Se.kind === "get" || Se.kind === "set" ? we(Te, Pe, Fe) : ge(Te, Pe, Fe);
              case "ObjectMethod":
                return we(Te, Pe, Fe);
              case "Decorator":
                return ["@", Fe("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return R(Te, Pe, Fe);
              case "SequenceExpression": {
                let Ie = Te.getParentNode(0);
                if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                  let Re = [];
                  return Te.each((Ae, Oe) => {
                    Oe === 0 ? Re.push(Fe()) : Re.push(",", D([u, Fe()]));
                  }, "expressions"), o(Re);
                }
                return o(l([",", u], Te.map(Fe, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Fe("value"), ze];
              case "DirectiveLiteral":
                return Ue(Se, Pe);
              case "UnaryExpression":
                return Be.push(Se.operator), /[a-z]$/.test(Se.operator) && Be.push(" "), b(Se.argument) ? Be.push(o(["(", D([a, Fe("argument")]), a, ")"])) : Be.push(Fe("argument")), Be;
              case "UpdateExpression":
                return Be.push(Fe("argument"), Se.operator), Se.prefix && Be.reverse(), Be;
              case "ConditionalExpression":
                return K(Te, Pe, Fe);
              case "VariableDeclaration": {
                let Ie = Te.map(Fe, "declarations"), Re = Te.getParentNode(), Ae = Re.type === "ForStatement" || Re.type === "ForInStatement" || Re.type === "ForOfStatement", Oe = Se.declarations.some((ie) => ie.init), _e;
                return Ie.length === 1 && !b(Se.declarations[0]) ? _e = Ie[0] : Ie.length > 0 && (_e = D(Ie[0])), Be = [Se.declare ? "declare " : "", Se.kind, _e ? [" ", _e] : "", D(Ie.slice(1).map((ie) => [",", Oe && !Ae ? n : u, ie]))], Ae && Re.body !== Se || Be.push(ze), o(Be);
              }
              case "WithStatement":
                return o(["with (", Fe("object"), ")", $(Se.body, Fe("body"))]);
              case "IfStatement": {
                let Ie = $(Se.consequent, Fe("consequent")), Re = o(["if (", o([D([a, Fe("test")]), a]), ")", Ie]);
                if (Be.push(Re), Se.alternate) {
                  let Ae = b(Se.consequent, T.Trailing | T.Line) || k(Se), Oe = Se.consequent.type === "BlockStatement" && !Ae;
                  Be.push(Oe ? " " : n), b(Se, T.Dangling) && Be.push(t(Te, Pe, true), Ae ? n : " "), Be.push("else", o($(Se.alternate, Fe("alternate"), Se.alternate.type === "IfStatement")));
                }
                return Be;
              }
              case "ForStatement": {
                let Ie = $(Se.body, Fe("body")), Re = t(Te, Pe, true), Ae = Re ? [Re, a] : "";
                return !Se.init && !Se.test && !Se.update ? [Ae, o(["for (;;)", Ie])] : [Ae, o(["for (", o([D([a, Fe("init"), ";", u, Fe("test"), ";", u, Fe("update")]), a]), ")", Ie])];
              }
              case "WhileStatement":
                return o(["while (", o([D([a, Fe("test")]), a]), ")", $(Se.body, Fe("body"))]);
              case "ForInStatement":
                return o(["for (", Fe("left"), " in ", Fe("right"), ")", $(Se.body, Fe("body"))]);
              case "ForOfStatement":
                return o(["for", Se.await ? " await" : "", " (", Fe("left"), " of ", Fe("right"), ")", $(Se.body, Fe("body"))]);
              case "DoWhileStatement": {
                let Ie = $(Se.body, Fe("body"));
                return Be = [o(["do", Ie])], Se.body.type === "BlockStatement" ? Be.push(" ") : Be.push(n), Be.push("while (", o([D([a, Fe("test")]), a]), ")", ze), Be;
              }
              case "DoExpression":
                return [Se.async ? "async " : "", "do ", Fe("body")];
              case "BreakStatement":
                return Be.push("break"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
              case "ContinueStatement":
                return Be.push("continue"), Se.label && Be.push(" ", Fe("label")), Be.push(ze), Be;
              case "LabeledStatement":
                return Se.body.type === "EmptyStatement" ? [Fe("label"), ":;"] : [Fe("label"), ": ", Fe("body")];
              case "TryStatement":
                return ["try ", Fe("block"), Se.handler ? [" ", Fe("handler")] : "", Se.finalizer ? [" finally ", Fe("finalizer")] : ""];
              case "CatchClause":
                if (Se.param) {
                  let Ie = b(Se.param, (Ae) => !C(Ae) || Ae.leading && i(Pe.originalText, g(Ae)) || Ae.trailing && i(Pe.originalText, y(Ae), { backwards: true })), Re = Fe("param");
                  return ["catch ", Ie ? ["(", D([a, Re]), a, ") "] : ["(", Re, ") "], Fe("body")];
                }
                return ["catch ", Fe("body")];
              case "SwitchStatement":
                return [o(["switch (", D([a, Fe("discriminant")]), a, ")"]), " {", Se.cases.length > 0 ? D([n, l(n, Te.map((Ie, Re, Ae) => {
                  let Oe = Ie.getValue();
                  return [Fe(), Re !== Ae.length - 1 && _(Oe, Pe) ? n : ""];
                }, "cases"))]) : "", n, "}"];
              case "SwitchCase": {
                Se.test ? Be.push("case ", Fe("test"), ":") : Be.push("default:"), b(Se, T.Dangling) && Be.push(" ", t(Te, Pe, true));
                let Ie = Se.consequent.filter((Re) => Re.type !== "EmptyStatement");
                if (Ie.length > 0) {
                  let Re = ye(Te, Pe, Fe);
                  Be.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Re] : D([n, Re]));
                }
                return Be;
              }
              case "DebuggerStatement":
                return ["debugger", ze];
              case "ClassDeclaration":
              case "ClassExpression":
                return ue(Te, Pe, Fe);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Q(Te, Pe, Fe);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
                return de(Te, Pe, Fe);
              case "TemplateElement":
                return F(Se.value.raw);
              case "TemplateLiteral":
                return Ee(Te, Fe, Pe);
              case "TaggedTemplateExpression":
                return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
              case "PrivateIdentifier":
                return ["#", Fe("name")];
              case "PrivateName":
                return ["#", Fe("id")];
              case "InterpreterDirective":
                return Be.push("#!", Se.value, n), _(Se, Pe) && Be.push(n), Be;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                Be.push("module {");
                let Ie = Fe("body");
                return Ie && Be.push(D([n, Ie]), n), Be.push("}"), Be;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(Se.type));
            }
          }
          function Ue(Te, Pe) {
            let Fe = A(Te), Ke = Fe.slice(1, -1);
            if (Ke.includes('"') || Ke.includes("'"))
              return Fe;
            let Se = Pe.singleQuote ? "'" : '"';
            return Se + Ke + Se;
          }
          function tt(Te) {
            return Te.type && !C(Te) && !w(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
          }
          s.exports = { preprocess: P, print: Ne, embed: h, insertPragma: p, massageAstNode: v, hasPrettierIgnore(Te) {
            return f(Te) || j(Te);
          }, willPrintOwnComments: m.willPrintOwnComments, canAttachComment: tt, printComment: z, isBlockComment: C, handleComments: { avoidAstMutation: true, ownLine: m.handleOwnLineComment, endOfLine: m.handleEndOfLineComment, remaining: m.handleRemainingComment }, getCommentChildNodes: m.getCommentChildNodes };
        } }), fm = ee({ "src/language-js/printer-estree-json.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { hardline: t, indent: i, join: l } } = Le(), u = Yi();
          function n(D, F, h) {
            let v = D.getValue();
            switch (v.type) {
              case "JsonRoot":
                return [h("node"), t];
              case "ArrayExpression": {
                if (v.elements.length === 0)
                  return "[]";
                let p = D.map(() => D.getValue() === null ? "null" : h(), "elements");
                return ["[", i([t, l([",", t], p)]), t, "]"];
              }
              case "ObjectExpression":
                return v.properties.length === 0 ? "{}" : ["{", i([t, l([",", t], D.map(h, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [h("key"), ": ", h("value")];
              case "UnaryExpression":
                return [v.operator === "+" ? "" : v.operator, h("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return v.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(v.value);
              case "Identifier": {
                let p = D.getParentNode();
                return p && p.type === "ObjectProperty" && p.key === v ? JSON.stringify(v.name) : v.name;
              }
              case "TemplateLiteral":
                return h(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(v.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(v.type));
            }
          }
          var a = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function o(D, F) {
            let { type: h } = D;
            if (h === "ObjectProperty" && D.key.type === "Identifier") {
              F.key = { type: "StringLiteral", value: D.key.name };
              return;
            }
            if (h === "UnaryExpression" && D.operator === "+")
              return F.argument;
            if (h === "ArrayExpression") {
              for (let [v, p] of D.elements.entries())
                p === null && F.elements.splice(v, 0, { type: "NullLiteral" });
              return;
            }
            if (h === "TemplateLiteral")
              return { type: "StringLiteral", value: D.quasis[0].value.cooked };
          }
          o.ignoredProperties = a, s.exports = { preprocess: u, print: n, massageAstNode: o };
        } }), It = ee({ "src/common/common-options.js"(e2, s) {
          "use strict";
          ae();
          var t = "Common";
          s.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Dm = ee({ "src/language-js/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It(), i = "JavaScript";
          s.exports = { arrowParens: { since: "1.9.0", category: i, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: i, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: i, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: i, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: i, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: i, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), mm = ee({ "src/language-js/parse/parsers.js"() {
          ae();
        } }), gn = ee({ "node_modules/linguist-languages/data/JavaScript.json"(e2, s) {
          s.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), dm = ee({ "node_modules/linguist-languages/data/TypeScript.json"(e2, s) {
          s.exports = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), gm = ee({ "node_modules/linguist-languages/data/TSX.json"(e2, s) {
          s.exports = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), oi = ee({ "node_modules/linguist-languages/data/JSON.json"(e2, s) {
          s.exports = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), ym = ee({ "node_modules/linguist-languages/data/JSON with Comments.json"(e2, s) {
          s.exports = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), hm = ee({ "node_modules/linguist-languages/data/JSON5.json"(e2, s) {
          s.exports = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), Cm = ee({ "src/language-js/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = pm2(), l = fm(), u = Dm(), n = mm(), a = [t(gn(), (D) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...D.interpreters, "zx"], extensions: [...D.extensions.filter((F) => F !== ".jsx"), ".wxs"] })), t(gn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(gn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(dm(), (D) => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"], extensions: [...D.extensions, ".mts", ".cts"] })), t(gm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(oi(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(oi(), (D) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: D.extensions.filter((F) => F !== ".jsonl") })), t(ym(), (D) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...D.filenames, ".eslintrc", ".swcrc"] })), t(hm(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], o = { estree: i, "estree-json": l };
          s.exports = { languages: a, options: u, printers: o, parsers: n };
        } }), Em = ee({ "src/language-css/clean.js"(e2, s) {
          "use strict";
          ae();
          var { isFrontMatterNode: t } = Ge(), i = st(), l = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function u(a, o, D) {
            if (t(a) && a.lang === "yaml" && delete o.value, a.type === "css-comment" && D.type === "css-root" && D.nodes.length > 0 && ((D.nodes[0] === a || t(D.nodes[0]) && D.nodes[1] === a) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(a.text)) || D.type === "css-root" && i(D.nodes) === a))
              return null;
            if (a.type === "value-root" && delete o.text, (a.type === "media-query" || a.type === "media-query-list" || a.type === "media-feature-expression") && delete o.value, a.type === "css-rule" && delete o.params, a.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), a.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (a.type === "value-word" && (a.isColor && a.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || a.type === "media-feature" || a.type === "selector-root-invalid" || a.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), a.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (a.type === "css-atrule" || a.type === "css-import") && (o.name = o.name.toLowerCase()), a.type === "value-number" && (o.unit = o.unit.toLowerCase()), (a.type === "media-feature" || a.type === "media-keyword" || a.type === "media-type" || a.type === "media-unknown" || a.type === "media-url" || a.type === "media-value" || a.type === "selector-attribute" || a.type === "selector-string" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "value-string") && o.value && (o.value = n(o.value)), a.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = true)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (a.type === "media-value" || a.type === "media-type" || a.type === "value-number" || a.type === "selector-root-invalid" || a.type === "selector-class" || a.type === "selector-combinator" || a.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (F, h, v) => {
              let p = Number(h);
              return Number.isNaN(p) ? F : p + v.toLowerCase();
            })), a.type === "selector-tag") {
              let F = a.value.toLowerCase();
              ["from", "to"].includes(F) && (o.value = F);
            }
            if (a.type === "css-atrule" && a.name.toLowerCase() === "supports" && delete o.value, a.type === "selector-unknown" && delete o.value, a.type === "value-comma_group") {
              let F = a.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
              F !== -1 && (o.groups[F].unit = "", o.groups.splice(F + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
          }
          u.ignoredProperties = l;
          function n(a) {
            return a.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          s.exports = u;
        } }), Wn = ee({ "src/utils/front-matter/print.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { hardline: t, markAsRoot: i } } = Le();
          function l(u, n) {
            if (u.lang === "yaml") {
              let a = u.value.trim(), o = a ? n(a, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return i([u.startDelimiter, t, o, o ? t : "", u.endDelimiter]);
            }
          }
          s.exports = l;
        } }), vm = ee({ "src/language-css/embed.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { hardline: t } } = Le(), i = Wn();
          function l(u, n, a) {
            let o = u.getValue();
            if (o.type === "front-matter") {
              let D = i(o, a);
              return D ? [D, t] : "";
            }
          }
          s.exports = l;
        } }), ao = ee({ "src/utils/front-matter/parse.js"(e2, s) {
          "use strict";
          ae();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function i(l) {
            let u = l.match(t);
            if (!u)
              return { content: l };
            let { startDelimiter: n, language: a, value: o = "", endDelimiter: D } = u.groups, F = a.trim() || "yaml";
            if (n === "+++" && (F = "toml"), F !== "yaml" && n !== D)
              return { content: l };
            let [h] = u;
            return { frontMatter: { type: "front-matter", lang: F, value: o, startDelimiter: n, endDelimiter: D, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + l.slice(h.length) };
          }
          s.exports = i;
        } }), Fm = ee({ "src/language-css/pragma.js"(e2, s) {
          "use strict";
          ae();
          var t = Xi(), i = ao();
          function l(n) {
            return t.hasPragma(i(n).content);
          }
          function u(n) {
            let { frontMatter: a, content: o } = i(n);
            return (a ? a.raw + `

` : "") + t.insertPragma(o);
          }
          s.exports = { hasPragma: l, insertPragma: u };
        } }), Am = ee({ "src/language-css/utils/index.js"(e2, s) {
          "use strict";
          ae();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function i(R, le) {
            let ue = Array.isArray(le) ? le : [le], Q = -1, de;
            for (; de = R.getParentNode(++Q); )
              if (ue.includes(de.type))
                return Q;
            return -1;
          }
          function l(R, le) {
            let ue = i(R, le);
            return ue === -1 ? null : R.getParentNode(ue);
          }
          function u(R) {
            let le = l(R, "css-decl");
            return le && le.prop && le.prop.toLowerCase();
          }
          function n(R) {
            return ["initial", "inherit", "unset", "revert"].includes(R.toLowerCase());
          }
          function a(R, le) {
            let ue = l(R, "css-atrule");
            return ue && ue.name && ue.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(le.toLowerCase());
          }
          function o(R) {
            return R.includes("$") || R.includes("@") || R.includes("#") || R.startsWith("%") || R.startsWith("--") || R.startsWith(":--") || R.includes("(") && R.includes(")") ? R : R.toLowerCase();
          }
          function D(R, le) {
            let ue = l(R, "value-func");
            return ue && ue.value && ue.value.toLowerCase() === le;
          }
          function F(R) {
            let le = l(R, "css-rule");
            return le && le.raws && le.raws.selector && (le.raws.selector.startsWith(":import") || le.raws.selector.startsWith(":export"));
          }
          function h(R, le) {
            let ue = Array.isArray(le) ? le : [le], Q = l(R, "css-atrule");
            return Q && ue.includes(Q.name.toLowerCase());
          }
          function v(R) {
            let le = R.getValue(), ue = l(R, "css-atrule");
            return ue && ue.name === "import" && le.groups[0].value === "url" && le.groups.length === 2;
          }
          function p(R) {
            return R.type === "value-func" && R.value.toLowerCase() === "url";
          }
          function m(R, le) {
            let ue = R.getParentNode();
            if (!ue)
              return false;
            let { nodes: Q } = ue;
            return Q && Q.indexOf(le) === Q.length - 1;
          }
          function E(R) {
            return R.selector ? typeof R.selector == "string" && /^@.+:.*$/.test(R.selector) || R.selector.value && /^@.+:.*$/.test(R.selector.value) : false;
          }
          function P(R) {
            return R.type === "value-word" && ["from", "through", "end"].includes(R.value);
          }
          function N(R) {
            return R.type === "value-word" && ["and", "or", "not"].includes(R.value);
          }
          function b(R) {
            return R.type === "value-word" && R.value === "in";
          }
          function T(R) {
            return R.type === "value-operator" && R.value === "*";
          }
          function S(R) {
            return R.type === "value-operator" && R.value === "/";
          }
          function w(R) {
            return R.type === "value-operator" && R.value === "+";
          }
          function _(R) {
            return R.type === "value-operator" && R.value === "-";
          }
          function k(R) {
            return R.type === "value-operator" && R.value === "%";
          }
          function A(R) {
            return T(R) || S(R) || w(R) || _(R) || k(R);
          }
          function f(R) {
            return R.type === "value-word" && ["==", "!="].includes(R.value);
          }
          function d(R) {
            return R.type === "value-word" && ["<", ">", "<=", ">="].includes(R.value);
          }
          function c(R) {
            return R.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(R.name);
          }
          function r(R) {
            return R.raws && R.raws.params && /^\(\s*\)$/.test(R.raws.params);
          }
          function y(R) {
            return R.name.startsWith("prettier-placeholder");
          }
          function g(R) {
            return R.prop.startsWith("@prettier-placeholder");
          }
          function C(R, le) {
            return R.value === "$$" && R.type === "value-func" && le && le.type === "value-word" && !le.raws.before;
          }
          function x(R) {
            return R.value && R.value.type === "value-root" && R.value.group && R.value.group.type === "value-value" && R.prop.toLowerCase() === "composes";
          }
          function B(R) {
            return R.value && R.value.group && R.value.group.group && R.value.group.group.type === "value-paren_group" && R.value.group.group.open !== null && R.value.group.group.close !== null;
          }
          function L(R) {
            return R.raws && R.raws.before === "";
          }
          function M(R) {
            return R.type === "value-comma_group" && R.groups && R.groups[1] && R.groups[1].type === "value-colon";
          }
          function j(R) {
            return R.type === "value-paren_group" && R.groups && R.groups[0] && M(R.groups[0]);
          }
          function H(R) {
            let le = R.getValue();
            if (le.groups.length === 0)
              return false;
            let ue = R.getParentNode(1);
            if (!j(le) && !(ue && j(ue)))
              return false;
            let Q = l(R, "css-decl");
            return !!(Q && Q.prop && Q.prop.startsWith("$") || j(ue) || ue.type === "value-func");
          }
          function I(R) {
            return R.type === "value-comment" && R.inline;
          }
          function G(R) {
            return R.type === "value-word" && R.value === "#";
          }
          function Z(R) {
            return R.type === "value-word" && R.value === "{";
          }
          function W(R) {
            return R.type === "value-word" && R.value === "}";
          }
          function $(R) {
            return ["value-word", "value-atword"].includes(R.type);
          }
          function te(R) {
            return R && R.type === "value-colon";
          }
          function U(R, le) {
            if (!M(le))
              return false;
            let { groups: ue } = le, Q = ue.indexOf(R);
            return Q === -1 ? false : te(ue[Q + 1]);
          }
          function ne(R) {
            return R.value && ["not", "and", "or"].includes(R.value.toLowerCase());
          }
          function se(R) {
            return R.type !== "value-func" ? false : t.has(R.value.toLowerCase());
          }
          function V(R) {
            return /\/\//.test(R.split(/[\n\r]/).pop());
          }
          function oe(R) {
            return R && R.type === "value-atword" && R.value.startsWith("prettier-placeholder-");
          }
          function K(R, le) {
            if (!R.open || R.open.value !== "(" || !R.close || R.close.value !== ")" || R.groups.some((ue) => ue.type !== "value-comma_group"))
              return false;
            if (le.type === "value-comma_group") {
              let ue = le.groups.indexOf(R) - 1, Q = le.groups[ue];
              if (Q && Q.type === "value-word" && Q.value === "with")
                return true;
            }
            return false;
          }
          function Ee(R) {
            return R.type === "value-paren_group" && R.open && R.open.value === "(" && R.close && R.close.value === ")";
          }
          s.exports = { getAncestorCounter: i, getAncestorNode: l, getPropOfDeclNode: u, maybeToLowerCase: o, insideValueFunctionNode: D, insideICSSRuleNode: F, insideAtRuleNode: h, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: a, isWideKeywords: n, isLastNode: m, isSCSSControlDirectiveNode: c, isDetachedRulesetDeclarationNode: E, isRelationalOperatorNode: d, isEqualityOperatorNode: f, isMultiplicationNode: T, isDivisionNode: S, isAdditionNode: w, isSubtractionNode: _, isModuloNode: k, isMathOperatorNode: A, isEachKeywordNode: b, isForKeywordNode: P, isURLFunctionNode: p, isIfElseKeywordNode: N, hasComposesNode: x, hasParensAroundNode: B, hasEmptyRawBefore: L, isDetachedRulesetCallNode: r, isTemplatePlaceholderNode: y, isTemplatePropNode: g, isPostcssSimpleVarNode: C, isKeyValuePairNode: M, isKeyValuePairInParenGroupNode: j, isKeyInValuePairNode: U, isSCSSMapItemNode: H, isInlineValueCommentNode: I, isHashNode: G, isLeftCurlyBraceNode: Z, isRightCurlyBraceNode: W, isWordNode: $, isColonNode: te, isMediaAndSupportsKeywords: ne, isColorAdjusterFuncNode: se, lastLineHasInlineComment: V, isAtWordPlaceholderNode: oe, isConfigurationNode: K, isParenGroupNode: Ee };
        } }), Sm = ee({ "src/utils/line-column-to-index.js"(e2, s) {
          "use strict";
          ae(), s.exports = function(t, i) {
            let l = 0;
            for (let u = 0; u < t.line - 1; ++u)
              l = i.indexOf(`
`, l) + 1;
            return l + t.column;
          };
        } }), bm = ee({ "src/language-css/loc.js"(e2, s) {
          "use strict";
          ae();
          var { skipEverythingButNewLine: t } = vr(), i = st(), l = Sm();
          function u(p, m) {
            return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? l(p.source.start, m) - 1 : null;
          }
          function n(p, m) {
            if (p.type === "css-comment" && p.inline)
              return t(m, p.source.startOffset);
            let E = p.nodes && i(p.nodes);
            return E && p.source && !p.source.end && (p = E), p.source && p.source.end ? l(p.source.end, m) : null;
          }
          function a(p, m) {
            p.source && (p.source.startOffset = u(p, m), p.source.endOffset = n(p, m));
            for (let E in p) {
              let P = p[E];
              E === "source" || !P || typeof P != "object" || (P.type === "value-root" || P.type === "value-unknown" ? o(P, D(p), P.text || P.value) : a(P, m));
            }
          }
          function o(p, m, E) {
            p.source && (p.source.startOffset = u(p, E) + m, p.source.endOffset = n(p, E) + m);
            for (let P in p) {
              let N = p[P];
              P === "source" || !N || typeof N != "object" || o(N, m, E);
            }
          }
          function D(p) {
            let m = p.source.startOffset;
            return typeof p.prop == "string" && (m += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (m += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (m += p.raws.between.length), m;
          }
          function F(p) {
            let m = "initial", E = "initial", P, N = false, b = [];
            for (let T = 0; T < p.length; T++) {
              let S = p[T];
              switch (m) {
                case "initial":
                  if (S === "'") {
                    m = "single-quotes";
                    continue;
                  }
                  if (S === '"') {
                    m = "double-quotes";
                    continue;
                  }
                  if ((S === "u" || S === "U") && p.slice(T, T + 4).toLowerCase() === "url(") {
                    m = "url", T += 3;
                    continue;
                  }
                  if (S === "*" && p[T - 1] === "/") {
                    m = "comment-block";
                    continue;
                  }
                  if (S === "/" && p[T - 1] === "/") {
                    m = "comment-inline", P = T - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (S === "'" && p[T - 1] !== "\\" && (m = E, E = "initial"), S === `
` || S === "\r")
                    return p;
                  continue;
                case "double-quotes":
                  if (S === '"' && p[T - 1] !== "\\" && (m = E, E = "initial"), S === `
` || S === "\r")
                    return p;
                  continue;
                case "url":
                  if (S === ")" && (m = "initial"), S === `
` || S === "\r")
                    return p;
                  if (S === "'") {
                    m = "single-quotes", E = "url";
                    continue;
                  }
                  if (S === '"') {
                    m = "double-quotes", E = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  S === "/" && p[T - 1] === "*" && (m = "initial");
                  continue;
                case "comment-inline":
                  (S === '"' || S === "'" || S === "*") && (N = true), (S === `
` || S === "\r") && (N && b.push([P, T]), m = "initial", N = false);
                  continue;
              }
            }
            for (let [T, S] of b)
              p = p.slice(0, T) + p.slice(T, S).replace(/["'*]/g, " ") + p.slice(S);
            return p;
          }
          function h(p) {
            return p.source.startOffset;
          }
          function v(p) {
            return p.source.endOffset;
          }
          s.exports = { locStart: h, locEnd: v, calculateLoc: a, replaceQuotesInInlineComments: F };
        } }), xm = ee({ "src/language-css/utils/is-less-parser.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            return i.parser === "css" || i.parser === "less";
          }
          s.exports = t;
        } }), Tm = ee({ "src/language-css/utils/is-scss.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l) {
            return i === "less" || i === "scss" ? i === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(l);
          }
          s.exports = t;
        } }), Bm = ee({ "src/language-css/utils/css-units.evaluate.js"(e2, s) {
          s.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", vh: "vh", vi: "vi", vb: "vb", vmin: "vmin", vmax: "vmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), Nm = ee({ "src/language-css/utils/print-unit.js"(e2, s) {
          "use strict";
          ae();
          var t = Bm();
          function i(l) {
            let u = l.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, u) ? t[u] : l;
          }
          s.exports = i;
        } }), wm = ee({ "src/language-css/printer-postcss.js"(e2, s) {
          "use strict";
          ae();
          var t = st(), { printNumber: i, printString: l, hasNewline: u, isFrontMatterNode: n, isNextLineEmpty: a, isNonEmptyArray: o } = Ge(), { builders: { join: D, line: F, hardline: h, softline: v, group: p, fill: m, indent: E, dedent: P, ifBreak: N, breakParent: b }, utils: { removeLines: T, getDocParts: S } } = Le(), w = Em(), _ = vm(), { insertPragma: k } = Fm(), { getAncestorNode: A, getPropOfDeclNode: f, maybeToLowerCase: d, insideValueFunctionNode: c, insideICSSRuleNode: r, insideAtRuleNode: y, insideURLFunctionInImportAtRuleNode: g, isKeyframeAtRuleKeywords: C, isWideKeywords: x, isLastNode: B, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: j, isEqualityOperatorNode: H, isMultiplicationNode: I, isDivisionNode: G, isAdditionNode: Z, isSubtractionNode: W, isMathOperatorNode: $, isEachKeywordNode: te, isForKeywordNode: U, isURLFunctionNode: ne, isIfElseKeywordNode: se, hasComposesNode: V, hasParensAroundNode: oe, hasEmptyRawBefore: K, isKeyValuePairNode: Ee, isKeyInValuePairNode: R, isDetachedRulesetCallNode: le, isTemplatePlaceholderNode: ue, isTemplatePropNode: Q, isPostcssSimpleVarNode: de, isSCSSMapItemNode: ge, isInlineValueCommentNode: ve, isHashNode: be, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: fe, isWordNode: pe, isColonNode: me, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: he, lastLineHasInlineComment: J, isAtWordPlaceholderNode: ye, isConfigurationNode: X, isParenGroupNode: Y } = Am(), { locStart: re, locEnd: z } = bm(), q = xm(), Ce = Tm(), Ne = Nm();
          function je(Ae) {
            return Ae.trailingComma === "es5" || Ae.trailingComma === "all";
          }
          function Ue(Ae, Oe, _e) {
            let ie = Ae.getValue();
            if (!ie)
              return "";
            if (typeof ie == "string")
              return ie;
            switch (ie.type) {
              case "front-matter":
                return [ie.raw, h];
              case "css-root": {
                let Me = tt(Ae, Oe, _e), qe = ie.raws.after.trim();
                return [Me, qe ? " ".concat(qe) : "", S(Me).length > 0 ? h : ""];
              }
              case "css-comment": {
                let Me = ie.inline || ie.raws.inline, qe = Oe.originalText.slice(re(ie), z(ie));
                return Me ? qe.trimEnd() : qe;
              }
              case "css-rule":
                return [_e("selector"), ie.important ? " !important" : "", ie.nodes ? [ie.selector && ie.selector.type === "selector-unknown" && J(ie.selector.value) ? F : " ", "{", ie.nodes.length > 0 ? E([h, tt(Ae, Oe, _e)]) : "", h, "}", M(ie) ? ";" : ""] : ";"];
              case "css-decl": {
                let Me = Ae.getParentNode(), { between: qe } = ie.raws, Je = qe.trim(), rt = Je === ":", Ze = V(ie) ? T(_e("value")) : _e("value");
                return !rt && J(Je) && (Ze = E([h, P(Ze)])), [ie.raws.before.replace(/[\s;]/g, ""), r(Ae) ? ie.prop : d(ie.prop), Je.startsWith("//") ? " " : "", Je, ie.extend ? "" : " ", q(Oe) && ie.extend && ie.selector ? ["extend(", _e("selector"), ")"] : "", Ze, ie.raws.important ? ie.raws.important.replace(/\s*!\s*important/i, " !important") : ie.important ? " !important" : "", ie.raws.scssDefault ? ie.raws.scssDefault.replace(/\s*!default/i, " !default") : ie.scssDefault ? " !default" : "", ie.raws.scssGlobal ? ie.raws.scssGlobal.replace(/\s*!global/i, " !global") : ie.scssGlobal ? " !global" : "", ie.nodes ? [" {", E([v, tt(Ae, Oe, _e)]), v, "}"] : Q(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";" ? "" : Oe.__isHTMLStyleAttribute && B(Ae, ie) ? N(";") : ";"];
              }
              case "css-atrule": {
                let Me = Ae.getParentNode(), qe = ue(ie) && !Me.raws.semicolon && Oe.originalText[z(ie) - 1] !== ";";
                if (q(Oe)) {
                  if (ie.mixin)
                    return [_e("selector"), ie.important ? " !important" : "", qe ? "" : ";"];
                  if (ie.function)
                    return [ie.name, _e("params"), qe ? "" : ";"];
                  if (ie.variable)
                    return ["@", ie.name, ": ", ie.value ? _e("value") : "", ie.raws.between.trim() ? ie.raws.between.trim() + " " : "", ie.nodes ? ["{", E([ie.nodes.length > 0 ? v : "", tt(Ae, Oe, _e)]), v, "}"] : "", qe ? "" : ";"];
                }
                return ["@", le(ie) || ie.name.endsWith(":") ? ie.name : d(ie.name), ie.params ? [le(ie) ? "" : ue(ie) ? ie.raws.afterName === "" ? "" : ie.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ie.raws.afterName) ? [h, h] : /^\s*\n/.test(ie.raws.afterName) ? h : " " : " ", _e("params")] : "", ie.selector ? E([" ", _e("selector")]) : "", ie.value ? p([" ", _e("value"), L(ie) ? oe(ie) ? " " : F : ""]) : ie.name === "else" ? " " : "", ie.nodes ? [L(ie) ? "" : ie.selector && !ie.selector.nodes && typeof ie.selector.value == "string" && J(ie.selector.value) || !ie.selector && typeof ie.params == "string" && J(ie.params) ? F : " ", "{", E([ie.nodes.length > 0 ? v : "", tt(Ae, Oe, _e)]), v, "}"] : qe ? "" : ";"];
              }
              case "media-query-list": {
                let Me = [];
                return Ae.each((qe) => {
                  let Je = qe.getValue();
                  Je.type === "media-query" && Je.value === "" || Me.push(_e());
                }, "nodes"), p(E(D(F, Me)));
              }
              case "media-query":
                return [D(" ", Ae.map(_e, "nodes")), B(Ae, ie) ? "" : ","];
              case "media-type":
                return Ie(ze(ie.value, Oe));
              case "media-feature-expression":
                return ie.nodes ? ["(", ...Ae.map(_e, "nodes"), ")"] : ie.value;
              case "media-feature":
                return d(ze(ie.value.replace(/ +/g, " "), Oe));
              case "media-colon":
                return [ie.value, " "];
              case "media-value":
                return Ie(ze(ie.value, Oe));
              case "media-keyword":
                return ze(ie.value, Oe);
              case "media-url":
                return ze(ie.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Oe);
              case "media-unknown":
                return ie.value;
              case "selector-root":
                return p([y(Ae, "custom-selector") ? [A(Ae, "css-atrule").customSelector, F] : "", D([",", y(Ae, ["extend", "custom-selector", "nest"]) ? F : h], Ae.map(_e, "nodes"))]);
              case "selector-selector":
                return p(E(Ae.map(_e, "nodes")));
              case "selector-comment":
                return ie.value;
              case "selector-string":
                return ze(ie.value, Oe);
              case "selector-tag": {
                let Me = Ae.getParentNode(), qe = Me && Me.nodes.indexOf(ie), Je = qe && Me.nodes[qe - 1];
                return [ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", Je.type === "selector-nesting" ? ie.value : Ie(C(Ae, ie.value) ? ie.value.toLowerCase() : ie.value)];
              }
              case "selector-id":
                return ["#", ie.value];
              case "selector-class":
                return [".", Ie(ze(ie.value, Oe))];
              case "selector-attribute":
                return ["[", ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", ie.attribute.trim(), ie.operator ? ie.operator : "", ie.value ? Be(ze(ie.value.trim(), Oe), Oe) : "", ie.insensitive ? " i" : "", "]"];
              case "selector-combinator": {
                if (ie.value === "+" || ie.value === ">" || ie.value === "~" || ie.value === ">>>") {
                  let Je = Ae.getParentNode();
                  return [Je.type === "selector-selector" && Je.nodes[0] === ie ? "" : F, ie.value, B(Ae, ie) ? "" : " "];
                }
                let Me = ie.value.trim().startsWith("(") ? F : "", qe = Ie(ze(ie.value.trim(), Oe)) || F;
                return [Me, qe];
              }
              case "selector-universal":
                return [ie.namespace ? [ie.namespace === true ? "" : ie.namespace.trim(), "|"] : "", ie.value];
              case "selector-pseudo":
                return [d(ie.value), o(ie.nodes) ? ["(", D(", ", Ae.map(_e, "nodes")), ")"] : ""];
              case "selector-nesting":
                return ie.value;
              case "selector-unknown": {
                let Me = A(Ae, "css-rule");
                if (Me && Me.isSCSSNesterProperty)
                  return Ie(ze(d(ie.value), Oe));
                let qe = Ae.getParentNode();
                if (qe.raws && qe.raws.selector) {
                  let rt = re(qe), Ze = rt + qe.raws.selector.length;
                  return Oe.originalText.slice(rt, Ze).trim();
                }
                let Je = Ae.getParentNode(1);
                if (qe.type === "value-paren_group" && Je && Je.type === "value-func" && Je.value === "selector") {
                  let rt = z(qe.open) + 1, Ze = re(qe.close), ct = Oe.originalText.slice(rt, Ze).trim();
                  return J(ct) ? [b, ct] : ct;
                }
                return ie.value;
              }
              case "value-value":
              case "value-root":
                return _e("group");
              case "value-comment":
                return Oe.originalText.slice(re(ie), z(ie));
              case "value-comma_group": {
                let Me = Ae.getParentNode(), qe = Ae.getParentNode(1), Je = f(Ae), rt = Je && Me.type === "value-value" && (Je === "grid" || Je.startsWith("grid-template")), Ze = A(Ae, "css-atrule"), ct = Ze && L(Ze), Ot = ie.groups.some((ut) => ve(ut)), O = Ae.map(_e, "groups"), De = [], ke = c(Ae, "url"), We = false, Ve = false;
                for (let ut = 0; ut < ie.groups.length; ++ut) {
                  De.push(O[ut]);
                  let et = ie.groups[ut - 1], $e = ie.groups[ut], He = ie.groups[ut + 1], Kt = ie.groups[ut + 2];
                  if (ke) {
                    (He && Z(He) || Z($e)) && De.push(" ");
                    continue;
                  }
                  if (y(Ae, "forward") && $e.type === "value-word" && $e.value && et !== void 0 && et.type === "value-word" && et.value === "as" && He.type === "value-operator" && He.value === "*" || !He || $e.type === "value-word" && $e.value.endsWith("-") && ye(He))
                    continue;
                  let fo = $e.type === "value-string" && $e.value.startsWith("#{"), Do = We && He.type === "value-string" && He.value.endsWith("}");
                  if (fo || Do) {
                    We = !We;
                    continue;
                  }
                  if (We || me($e) || me(He) || $e.type === "value-atword" && $e.value === "" || $e.value === "~" || $e.value && $e.value.includes("\\") && He && He.type !== "value-comment" || et && et.value && et.value.indexOf("\\") === et.value.length - 1 && $e.type === "value-operator" && $e.value === "/" || $e.value === "\\" || de($e, He) || be($e) || we($e) || fe(He) || we(He) && K(He) || fe($e) && K(He) || $e.value === "--" && be(He))
                    continue;
                  let Gn = $($e), Jn = $(He);
                  if ((Gn && be(He) || Jn && fe($e)) && K(He) || !et && G($e) || c(Ae, "calc") && (Z($e) || Z(He) || W($e) || W(He)) && K(He))
                    continue;
                  let mo = (Z($e) || W($e)) && ut === 0 && (He.type === "value-number" || He.isHex) && qe && he(qe) && !K(He), Un = Kt && Kt.type === "value-func" || Kt && pe(Kt) || $e.type === "value-func" || pe($e), zn = He.type === "value-func" || pe(He) || et && et.type === "value-func" || et && pe(et);
                  if (!(!(I(He) || I($e)) && !c(Ae, "calc") && !mo && (G(He) && !Un || G($e) && !zn || Z(He) && !Un || Z($e) && !zn || W(He) || W($e)) && (K(He) || Gn && (!et || et && $(et))))) {
                    if (ve($e)) {
                      if (Me.type === "value-paren_group") {
                        De.push(P(h));
                        continue;
                      }
                      De.push(h);
                      continue;
                    }
                    if (ct && (H(He) || j(He) || se(He) || te($e) || U($e))) {
                      De.push(" ");
                      continue;
                    }
                    if (Ze && Ze.name.toLowerCase() === "namespace") {
                      De.push(" ");
                      continue;
                    }
                    if (rt) {
                      $e.source && He.source && $e.source.start.line !== He.source.start.line ? (De.push(h), Ve = true) : De.push(" ");
                      continue;
                    }
                    if (Jn) {
                      De.push(" ");
                      continue;
                    }
                    if (!(He && He.value === "...") && !(ye($e) && ye(He) && z($e) === re(He))) {
                      if (ye($e) && Y(He) && z($e) === re(He.open)) {
                        De.push(v);
                        continue;
                      }
                      if ($e.value === "with" && Y(He)) {
                        De.push(" ");
                        continue;
                      }
                      De.push(F);
                    }
                  }
                }
                return Ot && De.push(b), Ve && De.unshift(h), ct ? p(E(De)) : g(Ae) ? p(m(De)) : p(E(m(De)));
              }
              case "value-paren_group": {
                let Me = Ae.getParentNode();
                if (Me && ne(Me) && (ie.groups.length === 1 || ie.groups.length > 0 && ie.groups[0].type === "value-comma_group" && ie.groups[0].groups.length > 0 && ie.groups[0].groups[0].type === "value-word" && ie.groups[0].groups[0].value.startsWith("data:")))
                  return [ie.open ? _e("open") : "", D(",", Ae.map(_e, "groups")), ie.close ? _e("close") : ""];
                if (!ie.open) {
                  let ke = Ae.map(_e, "groups"), We = [];
                  for (let Ve = 0; Ve < ke.length; Ve++)
                    Ve !== 0 && We.push([",", F]), We.push(ke[Ve]);
                  return p(E(m(We)));
                }
                let qe = ge(Ae), Je = t(ie.groups), rt = Je && Je.type === "value-comment", Ze = R(ie, Me), ct = X(ie, Me), Ot = ct || qe && !Ze, O = ct || Ze, De = p([ie.open ? _e("open") : "", E([v, D([F], Ae.map((ke, We) => {
                  let Ve = ke.getValue(), ut = We === ie.groups.length - 1, et = [_e(), ut ? "" : ","];
                  if (Ee(Ve) && Ve.type === "value-comma_group" && Ve.groups && Ve.groups[0].type !== "value-paren_group" && Ve.groups[2] && Ve.groups[2].type === "value-paren_group") {
                    let $e = S(et[0].contents.contents);
                    return $e[1] = p($e[1]), p(P(et));
                  }
                  return !ut && Ve.type === "value-comma_group" && Ve.groups && Ve.groups[0].type !== "value-paren_group" && a(Oe.originalText, t(Ve.groups), z) && et.push(h), et;
                }, "groups"))]), N(!rt && Ce(Oe.parser, Oe.originalText) && qe && je(Oe) ? "," : ""), v, ie.close ? _e("close") : ""], { shouldBreak: Ot });
                return O ? P(De) : De;
              }
              case "value-func":
                return [ie.value, y(Ae, "supports") && ce(ie) ? " " : "", _e("group")];
              case "value-paren":
                return ie.value;
              case "value-number":
                return [Re(ie.value), Ne(ie.unit)];
              case "value-operator":
                return ie.value;
              case "value-word":
                return ie.isColor && ie.isHex || x(ie.value) ? ie.value.toLowerCase() : ie.value;
              case "value-colon": {
                let Me = Ae.getParentNode(), qe = Me && Me.groups.indexOf(ie), Je = qe && Me.groups[qe - 1];
                return [ie.value, Je && typeof Je.value == "string" && t(Je.value) === "\\" || c(Ae, "url") ? "" : F];
              }
              case "value-comma":
                return [ie.value, " "];
              case "value-string":
                return l(ie.raws.quote + ie.value + ie.raws.quote, Oe);
              case "value-atword":
                return ["@", ie.value];
              case "value-unicode-range":
                return ie.value;
              case "value-unknown":
                return ie.value;
              default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(ie.type)));
            }
          }
          function tt(Ae, Oe, _e) {
            let ie = [];
            return Ae.each((Me, qe, Je) => {
              let rt = Je[qe - 1];
              if (rt && rt.type === "css-comment" && rt.text.trim() === "prettier-ignore") {
                let Ze = Me.getValue();
                ie.push(Oe.originalText.slice(re(Ze), z(Ze)));
              } else
                ie.push(_e());
              qe !== Je.length - 1 && (Je[qe + 1].type === "css-comment" && !u(Oe.originalText, re(Je[qe + 1]), { backwards: true }) && !n(Je[qe]) || Je[qe + 1].type === "css-atrule" && Je[qe + 1].name === "else" && Je[qe].type !== "css-comment" ? ie.push(" ") : (ie.push(Oe.__isHTMLStyleAttribute ? F : h), a(Oe.originalText, Me.getValue(), z) && !n(Je[qe]) && ie.push(h)));
            }, "nodes"), ie;
          }
          var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ke = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Se = new RegExp(Te.source + "|(".concat(Ke.source, ")?(").concat(Pe.source, ")(").concat(Fe.source, ")?"), "g");
          function ze(Ae, Oe) {
            return Ae.replace(Te, (_e) => l(_e, Oe));
          }
          function Be(Ae, Oe) {
            let _e = Oe.singleQuote ? "'" : '"';
            return Ae.includes('"') || Ae.includes("'") ? Ae : _e + Ae + _e;
          }
          function Ie(Ae) {
            return Ae.replace(Se, (Oe, _e, ie, Me, qe) => !ie && Me ? Re(Me) + d(qe || "") : Oe);
          }
          function Re(Ae) {
            return i(Ae).replace(/\.0(?=$|e)/, "");
          }
          s.exports = { print: Ue, embed: _, insertPragma: k, massageAstNode: w };
        } }), Pm = ee({ "src/language-css/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It();
          s.exports = { singleQuote: t.singleQuote };
        } }), _m = ee({ "src/language-css/parsers.js"() {
          ae();
        } }), Im = ee({ "node_modules/linguist-languages/data/CSS.json"(e2, s) {
          s.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), km = ee({ "node_modules/linguist-languages/data/PostCSS.json"(e2, s) {
          s.exports = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Lm = ee({ "node_modules/linguist-languages/data/Less.json"(e2, s) {
          s.exports = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Om = ee({ "node_modules/linguist-languages/data/SCSS.json"(e2, s) {
          s.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), jm = ee({ "src/language-css/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = wm(), l = Pm(), u = _m(), n = [t(Im(), (o) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...o.extensions, ".wxss"] })), t(km(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Lm(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Om(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], a = { postcss: i };
          s.exports = { languages: n, options: l, printers: a, parsers: u };
        } }), qm = ee({ "src/language-handlebars/loc.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return l.loc.start.offset;
          }
          function i(l) {
            return l.loc.end.offset;
          }
          s.exports = { locStart: t, locEnd: i };
        } }), Mm = ee({ "src/language-handlebars/clean.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l) {
            if (i.type === "TextNode") {
              let u = i.chars.trim();
              if (!u)
                return null;
              l.chars = u.replace(/[\t\n\f\r ]+/g, " ");
            }
            i.type === "AttrNode" && i.name.toLowerCase() === "class" && delete l.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), s.exports = t;
        } }), Rm = ee({ "node_modules/html-void-elements/index.json"(e2, s) {
          s.exports = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"];
        } }), Vm = ee({ "src/language-handlebars/utils.js"(e2, s) {
          "use strict";
          ae();
          var t = Rm(), i = st();
          function l(T) {
            let S = T.getValue(), w = T.getParentNode(0);
            return !!(h(T, ["ElementNode"]) && i(w.children) === S || h(T, ["Block"]) && i(w.body) === S);
          }
          function u(T) {
            return T.toUpperCase() === T;
          }
          function n(T) {
            return F(T, ["ElementNode"]) && typeof T.tag == "string" && T.tag[0] !== ":" && (u(T.tag[0]) || T.tag.includes("."));
          }
          var a = new Set(t);
          function o(T) {
            return n(T) && T.children.every((S) => D(S)) || a.has(T.tag);
          }
          function D(T) {
            return F(T, ["TextNode"]) && !/\S/.test(T.chars);
          }
          function F(T, S) {
            return T && S.includes(T.type);
          }
          function h(T, S) {
            let w = T.getParentNode(0);
            return F(w, S);
          }
          function v(T, S) {
            let w = E(T);
            return F(w, S);
          }
          function p(T, S) {
            let w = P(T);
            return F(w, S);
          }
          function m(T, S) {
            let w = T.getValue(), _ = T.getParentNode(0) || {}, k = _.children || _.body || _.parts || [], A = k.indexOf(w);
            return A !== -1 && k[A + S];
          }
          function E(T) {
            let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return m(T, -S);
          }
          function P(T) {
            return m(T, 1);
          }
          function N(T) {
            return F(T, ["MustacheCommentStatement"]) && typeof T.value == "string" && T.value.trim() === "prettier-ignore";
          }
          function b(T) {
            let S = T.getValue(), w = E(T, 2);
            return N(S) || N(w);
          }
          s.exports = { getNextNode: P, getPreviousNode: E, hasPrettierIgnore: b, isLastNodeOfSiblings: l, isNextNodeOfSomeType: p, isNodeOfSomeType: F, isParentOfSomeType: h, isPreviousNodeOfSomeType: v, isVoid: o, isWhitespaceNode: D };
        } }), Wm = ee({ "src/language-handlebars/printer-glimmer.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { dedent: t, fill: i, group: l, hardline: u, ifBreak: n, indent: a, join: o, line: D, softline: F }, utils: { getDocParts: h, replaceTextEndOfLine: v } } = Le(), { getPreferredQuote: p, isNonEmptyArray: m } = Ge(), { locStart: E, locEnd: P } = qm(), N = Mm(), { getNextNode: b, getPreviousNode: T, hasPrettierIgnore: S, isLastNodeOfSiblings: w, isNextNodeOfSomeType: _, isNodeOfSomeType: k, isParentOfSomeType: A, isPreviousNodeOfSomeType: f, isVoid: d, isWhitespaceNode: c } = Vm(), r = 2;
          function y(J, ye, X) {
            let Y = J.getValue();
            if (!Y)
              return "";
            if (S(J))
              return ye.originalText.slice(E(Y), P(Y));
            let re = ye.singleQuote ? "'" : '"';
            switch (Y.type) {
              case "Block":
              case "Program":
              case "Template":
                return l(J.map(X, "body"));
              case "ElementNode": {
                let z = l(C(J, X)), q = ye.htmlWhitespaceSensitivity === "ignore" && _(J, ["ElementNode"]) ? F : "";
                if (d(Y))
                  return [z, q];
                let Ce = ["</", Y.tag, ">"];
                return Y.children.length === 0 ? [z, a(Ce), q] : ye.htmlWhitespaceSensitivity === "ignore" ? [z, a(x(J, ye, X)), u, a(Ce), q] : [z, a(l(x(J, ye, X))), a(Ce), q];
              }
              case "BlockStatement": {
                let z = J.getParentNode(1);
                return z && z.inverse && z.inverse.body.length === 1 && z.inverse.body[0] === Y && z.inverse.body[0].path.parts[0] === "if" ? [U(J, X), K(J, X, ye), Ee(J, X, ye)] : [$(J, X), l([K(J, X, ye), Ee(J, X, ye), ne(J, X, ye)])];
              }
              case "ElementModifierStatement":
                return l(["{{", pe(J, X), "}}"]);
              case "MustacheStatement":
                return l([L(Y), pe(J, X), M(Y)]);
              case "SubExpression":
                return l(["(", fe(J, X), F, ")"]);
              case "AttrNode": {
                let z = Y.value.type === "TextNode";
                if (z && Y.value.chars === "" && E(Y.value) === P(Y.value))
                  return Y.name;
                let Ce = z ? p(Y.value.chars, re).quote : Y.value.type === "ConcatStatement" ? p(Y.value.parts.filter((je) => je.type === "TextNode").map((je) => je.chars).join(""), re).quote : "", Ne = X("value");
                return [Y.name, "=", Ce, Y.name === "class" && Ce ? l(a(Ne)) : Ne, Ce];
              }
              case "ConcatStatement":
                return J.map(X, "parts");
              case "Hash":
                return o(D, J.map(X, "pairs"));
              case "HashPair":
                return [Y.key, "=", X("value")];
              case "TextNode": {
                let z = Y.chars.replace(/{{/g, "\\{{"), q = ue(J);
                if (q) {
                  if (q === "class") {
                    let Se = z.trim().split(/\s+/).join(" "), ze = false, Be = false;
                    return A(J, ["ConcatStatement"]) && (f(J, ["MustacheStatement"]) && /^\s/.test(z) && (ze = true), _(J, ["MustacheStatement"]) && /\s$/.test(z) && Se !== "" && (Be = true)), [ze ? D : "", Se, Be ? D : ""];
                  }
                  return v(z);
                }
                let Ne = /^[\t\n\f\r ]*$/.test(z), je = !T(J), Ue = !b(J);
                if (ye.htmlWhitespaceSensitivity !== "ignore") {
                  let Se = /^[\t\n\f\r ]*/, ze = /[\t\n\f\r ]*$/, Be = Ue && A(J, ["Template"]), Ie = je && A(J, ["Template"]);
                  if (Ne) {
                    if (Ie || Be)
                      return "";
                    let ie = [D], Me = Q(z);
                    return Me && (ie = ve(Me)), w(J) && (ie = ie.map((qe) => t(qe))), ie;
                  }
                  let [Re] = z.match(Se), [Ae] = z.match(ze), Oe = [];
                  if (Re) {
                    Oe = [D];
                    let ie = Q(Re);
                    ie && (Oe = ve(ie)), z = z.replace(Se, "");
                  }
                  let _e = [];
                  if (Ae) {
                    if (!Be) {
                      _e = [D];
                      let ie = Q(Ae);
                      ie && (_e = ve(ie)), w(J) && (_e = _e.map((Me) => t(Me)));
                    }
                    z = z.replace(ze, "");
                  }
                  return [...Oe, i(R(z)), ..._e];
                }
                let tt = Q(z), Te = de(z), Pe = ge(z);
                if ((je || Ue) && Ne && A(J, ["Block", "ElementNode", "Template"]))
                  return "";
                Ne && tt ? (Te = Math.min(tt, r), Pe = 0) : (_(J, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), f(J, ["BlockStatement", "ElementNode"]) && (Te = Math.max(Te, 1)));
                let Fe = "", Ke = "";
                return Pe === 0 && _(J, ["MustacheStatement"]) && (Ke = " "), Te === 0 && f(J, ["MustacheStatement"]) && (Fe = " "), je && (Te = 0, Fe = ""), Ue && (Pe = 0, Ke = ""), z = z.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ke), [...ve(Te), i(R(z)), ...ve(Pe)];
              }
              case "MustacheCommentStatement": {
                let z = E(Y), q = P(Y), Ce = ye.originalText.charAt(z + 2) === "~", Ne = ye.originalText.charAt(q - 3) === "~", je = Y.value.includes("}}") ? "--" : "";
                return ["{{", Ce ? "~" : "", "!", je, Y.value, je, Ne ? "~" : "", "}}"];
              }
              case "PathExpression":
                return Y.original;
              case "BooleanLiteral":
                return String(Y.value);
              case "CommentStatement":
                return ["<!--", Y.value, "-->"];
              case "StringLiteral": {
                if (we(J)) {
                  let z = ye.singleQuote ? '"' : "'";
                  return be(Y.value, z);
                }
                return be(Y.value, re);
              }
              case "NumberLiteral":
                return String(Y.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(Y.type));
            }
          }
          function g(J, ye) {
            return E(J) - E(ye);
          }
          function C(J, ye) {
            let X = J.getValue(), Y = ["attributes", "modifiers", "comments"].filter((z) => m(X[z])), re = Y.flatMap((z) => X[z]).sort(g);
            for (let z of Y)
              J.each((q) => {
                let Ce = re.indexOf(q.getValue());
                re.splice(Ce, 1, [D, ye()]);
              }, z);
            return m(X.blockParams) && re.push(D, he(X)), ["<", X.tag, a(re), B(X)];
          }
          function x(J, ye, X) {
            let re = J.getValue().children.every((z) => c(z));
            return ye.htmlWhitespaceSensitivity === "ignore" && re ? "" : J.map((z, q) => {
              let Ce = X();
              return q === 0 && ye.htmlWhitespaceSensitivity === "ignore" ? [F, Ce] : Ce;
            }, "children");
          }
          function B(J) {
            return d(J) ? n([F, "/>"], [" />", F]) : n([F, ">"], ">");
          }
          function L(J) {
            let ye = J.escaped === false ? "{{{" : "{{", X = J.strip && J.strip.open ? "~" : "";
            return [ye, X];
          }
          function M(J) {
            let ye = J.escaped === false ? "}}}" : "}}";
            return [J.strip && J.strip.close ? "~" : "", ye];
          }
          function j(J) {
            let ye = L(J), X = J.openStrip.open ? "~" : "";
            return [ye, X, "#"];
          }
          function H(J) {
            let ye = M(J);
            return [J.openStrip.close ? "~" : "", ye];
          }
          function I(J) {
            let ye = L(J), X = J.closeStrip.open ? "~" : "";
            return [ye, X, "/"];
          }
          function G(J) {
            let ye = M(J);
            return [J.closeStrip.close ? "~" : "", ye];
          }
          function Z(J) {
            let ye = L(J), X = J.inverseStrip.open ? "~" : "";
            return [ye, X];
          }
          function W(J) {
            let ye = M(J);
            return [J.inverseStrip.close ? "~" : "", ye];
          }
          function $(J, ye) {
            let X = J.getValue(), Y = j(X), re = H(X), z = [me(J, ye)], q = ce(J, ye);
            if (q && z.push(D, q), m(X.program.blockParams)) {
              let Ce = he(X.program);
              z.push(D, Ce);
            }
            return l([Y, a(z), F, re]);
          }
          function te(J, ye) {
            return [ye.htmlWhitespaceSensitivity === "ignore" ? u : "", Z(J), "else", W(J)];
          }
          function U(J, ye) {
            let X = J.getParentNode(1);
            return [Z(X), "else if ", ce(J, ye), W(X)];
          }
          function ne(J, ye, X) {
            let Y = J.getValue();
            return X.htmlWhitespaceSensitivity === "ignore" ? [se(Y) ? F : u, I(Y), ye("path"), G(Y)] : [I(Y), ye("path"), G(Y)];
          }
          function se(J) {
            return k(J, ["BlockStatement"]) && J.program.body.every((ye) => c(ye));
          }
          function V(J) {
            return oe(J) && J.inverse.body.length === 1 && k(J.inverse.body[0], ["BlockStatement"]) && J.inverse.body[0].path.parts[0] === "if";
          }
          function oe(J) {
            return k(J, ["BlockStatement"]) && J.inverse;
          }
          function K(J, ye, X) {
            let Y = J.getValue();
            if (se(Y))
              return "";
            let re = ye("program");
            return X.htmlWhitespaceSensitivity === "ignore" ? a([u, re]) : a(re);
          }
          function Ee(J, ye, X) {
            let Y = J.getValue(), re = ye("inverse"), z = X.htmlWhitespaceSensitivity === "ignore" ? [u, re] : re;
            return V(Y) ? z : oe(Y) ? [te(Y, X), a(z)] : "";
          }
          function R(J) {
            return h(o(D, le(J)));
          }
          function le(J) {
            return J.split(/[\t\n\f\r ]+/);
          }
          function ue(J) {
            for (let ye = 0; ye < 2; ye++) {
              let X = J.getParentNode(ye);
              if (X && X.type === "AttrNode")
                return X.name.toLowerCase();
            }
          }
          function Q(J) {
            return J = typeof J == "string" ? J : "", J.split(`
`).length - 1;
          }
          function de(J) {
            J = typeof J == "string" ? J : "";
            let ye = (J.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Q(ye);
          }
          function ge(J) {
            J = typeof J == "string" ? J : "";
            let ye = (J.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Q(ye);
          }
          function ve() {
            let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(J, r) }).fill(u);
          }
          function be(J, ye) {
            let { quote: X, regex: Y } = p(J, ye);
            return [X, J.replace(Y, "\\".concat(X)), X];
          }
          function we(J) {
            let ye = 0, X = J.getParentNode(ye);
            for (; X && k(X, ["SubExpression"]); )
              ye++, X = J.getParentNode(ye);
            return !!(X && k(J.getParentNode(ye + 1), ["ConcatStatement"]) && k(J.getParentNode(ye + 2), ["AttrNode"]));
          }
          function fe(J, ye) {
            let X = me(J, ye), Y = ce(J, ye);
            return Y ? a([X, D, l(Y)]) : X;
          }
          function pe(J, ye) {
            let X = me(J, ye), Y = ce(J, ye);
            return Y ? [a([X, D, Y]), F] : X;
          }
          function me(J, ye) {
            return ye("path");
          }
          function ce(J, ye) {
            let X = J.getValue(), Y = [];
            if (X.params.length > 0) {
              let re = J.map(ye, "params");
              Y.push(...re);
            }
            if (X.hash && X.hash.pairs.length > 0) {
              let re = ye("hash");
              Y.push(re);
            }
            return Y.length === 0 ? "" : o(D, Y);
          }
          function he(J) {
            return ["as |", J.blockParams.join(" "), "|"];
          }
          s.exports = { print: y, massageAstNode: N };
        } }), $m = ee({ "src/language-handlebars/parsers.js"() {
          ae();
        } }), Hm = ee({ "node_modules/linguist-languages/data/Handlebars.json"(e2, s) {
          s.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), Gm = ee({ "src/language-handlebars/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = Wm(), l = $m(), u = [t(Hm(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], n = { glimmer: i };
          s.exports = { languages: u, printers: n, parsers: l };
        } }), Jm = ee({ "src/language-graphql/pragma.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(l);
          }
          function i(l) {
            return `# @format

` + l;
          }
          s.exports = { hasPragma: t, insertPragma: i };
        } }), Um = ee({ "src/language-graphql/loc.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return typeof l.start == "number" ? l.start : l.loc && l.loc.start;
          }
          function i(l) {
            return typeof l.end == "number" ? l.end : l.loc && l.loc.end;
          }
          s.exports = { locStart: t, locEnd: i };
        } }), zm = ee({ "src/language-graphql/printer-graphql.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { join: t, hardline: i, line: l, softline: u, group: n, indent: a, ifBreak: o } } = Le(), { isNextLineEmpty: D, isNonEmptyArray: F } = Ge(), { insertPragma: h } = Jm(), { locStart: v, locEnd: p } = Um();
          function m(_, k, A) {
            let f = _.getValue();
            if (!f)
              return "";
            if (typeof f == "string")
              return f;
            switch (f.kind) {
              case "Document": {
                let d = [];
                return _.each((c, r, y) => {
                  d.push(A()), r !== y.length - 1 && (d.push(i), D(k.originalText, c.getValue(), p) && d.push(i));
                }, "definitions"), [...d, i];
              }
              case "OperationDefinition": {
                let d = k.originalText[v(f)] !== "{", c = Boolean(f.name);
                return [d ? f.operation : "", d && c ? [" ", A("name")] : "", d && !c && F(f.variableDefinitions) ? " " : "", F(f.variableDefinitions) ? n(["(", a([u, t([o("", ", "), u], _.map(A, "variableDefinitions"))]), u, ")"]) : "", E(_, A, f), f.selectionSet ? !d && !c ? "" : " " : "", A("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", A("name"), F(f.variableDefinitions) ? n(["(", a([u, t([o("", ", "), u], _.map(A, "variableDefinitions"))]), u, ")"]) : "", " on ", A("typeCondition"), E(_, A, f), " ", A("selectionSet")];
              case "SelectionSet":
                return ["{", a([i, t(i, _.call((d) => P(d, k, A), "selections"))]), i, "}"];
              case "Field":
                return n([f.alias ? [A("alias"), ": "] : "", A("name"), f.arguments.length > 0 ? n(["(", a([u, t([o("", ", "), u], _.call((d) => P(d, k, A), "arguments"))]), u, ")"]) : "", E(_, A, f), f.selectionSet ? " " : "", A("selectionSet")]);
              case "Name":
                return f.value;
              case "StringValue":
                return f.block ? ['"""', i, t(i, f.value.replace(/"""/g, "\\$&").split(`
`)), i, '"""'] : ['"', f.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return f.value;
              case "BooleanValue":
                return f.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", A("name")];
              case "ListValue":
                return n(["[", a([u, t([o("", ", "), u], _.map(A, "values"))]), u, "]"]);
              case "ObjectValue":
                return n(["{", k.bracketSpacing && f.fields.length > 0 ? " " : "", a([u, t([o("", ", "), u], _.map(A, "fields"))]), u, o("", k.bracketSpacing && f.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [A("name"), ": ", A("value")];
              case "Directive":
                return ["@", A("name"), f.arguments.length > 0 ? n(["(", a([u, t([o("", ", "), u], _.call((d) => P(d, k, A), "arguments"))]), u, ")"]) : ""];
              case "NamedType":
                return A("name");
              case "VariableDefinition":
                return [A("variable"), ": ", A("type"), f.defaultValue ? [" = ", A("defaultValue")] : "", E(_, A, f)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [A("description"), f.description ? i : "", f.kind === "ObjectTypeExtension" ? "extend " : "", "type ", A("name"), f.interfaces.length > 0 ? [" implements ", ...T(_, k, A)] : "", E(_, A, f), f.fields.length > 0 ? [" {", a([i, t(i, _.call((d) => P(d, k, A), "fields"))]), i, "}"] : ""];
              case "FieldDefinition":
                return [A("description"), f.description ? i : "", A("name"), f.arguments.length > 0 ? n(["(", a([u, t([o("", ", "), u], _.call((d) => P(d, k, A), "arguments"))]), u, ")"]) : "", ": ", A("type"), E(_, A, f)];
              case "DirectiveDefinition":
                return [A("description"), f.description ? i : "", "directive ", "@", A("name"), f.arguments.length > 0 ? n(["(", a([u, t([o("", ", "), u], _.call((d) => P(d, k, A), "arguments"))]), u, ")"]) : "", f.repeatable ? " repeatable" : "", " on ", t(" | ", _.map(A, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [A("description"), f.description ? i : "", f.kind === "EnumTypeExtension" ? "extend " : "", "enum ", A("name"), E(_, A, f), f.values.length > 0 ? [" {", a([i, t(i, _.call((d) => P(d, k, A), "values"))]), i, "}"] : ""];
              case "EnumValueDefinition":
                return [A("description"), f.description ? i : "", A("name"), E(_, A, f)];
              case "InputValueDefinition":
                return [A("description"), f.description ? f.description.block ? i : l : "", A("name"), ": ", A("type"), f.defaultValue ? [" = ", A("defaultValue")] : "", E(_, A, f)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [A("description"), f.description ? i : "", f.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", A("name"), E(_, A, f), f.fields.length > 0 ? [" {", a([i, t(i, _.call((d) => P(d, k, A), "fields"))]), i, "}"] : ""];
              case "SchemaDefinition":
                return [A("description"), f.description ? i : "", "schema", E(_, A, f), " {", f.operationTypes.length > 0 ? a([i, t(i, _.call((d) => P(d, k, A), "operationTypes"))]) : "", i, "}"];
              case "OperationTypeDefinition":
                return [A("operation"), ": ", A("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [A("description"), f.description ? i : "", f.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", A("name"), f.interfaces.length > 0 ? [" implements ", ...T(_, k, A)] : "", E(_, A, f), f.fields.length > 0 ? [" {", a([i, t(i, _.call((d) => P(d, k, A), "fields"))]), i, "}"] : ""];
              case "FragmentSpread":
                return ["...", A("name"), E(_, A, f)];
              case "InlineFragment":
                return ["...", f.typeCondition ? [" on ", A("typeCondition")] : "", E(_, A, f), " ", A("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return n([A("description"), f.description ? i : "", n([f.kind === "UnionTypeExtension" ? "extend " : "", "union ", A("name"), E(_, A, f), f.types.length > 0 ? [" =", o("", " "), a([o([l, "  "]), t([l, "| "], _.map(A, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [A("description"), f.description ? i : "", f.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", A("name"), E(_, A, f)];
              case "NonNullType":
                return [A("type"), "!"];
              case "ListType":
                return ["[", A("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(f.kind));
            }
          }
          function E(_, k, A) {
            if (A.directives.length === 0)
              return "";
            let f = t(l, _.map(k, "directives"));
            return A.kind === "FragmentDefinition" || A.kind === "OperationDefinition" ? n([l, f]) : [" ", n(a([u, f]))];
          }
          function P(_, k, A) {
            let f = _.getValue().length;
            return _.map((d, c) => {
              let r = A();
              return D(k.originalText, d.getValue(), p) && c < f - 1 ? [r, i] : r;
            });
          }
          function N(_) {
            return _.kind && _.kind !== "Comment";
          }
          function b(_) {
            let k = _.getValue();
            if (k.kind === "Comment")
              return "#" + k.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(k));
          }
          function T(_, k, A) {
            let f = _.getNode(), d = [], { interfaces: c } = f, r = _.map((y) => A(y), "interfaces");
            for (let y = 0; y < c.length; y++) {
              let g = c[y];
              d.push(r[y]);
              let C = c[y + 1];
              if (C) {
                let x = k.originalText.slice(g.loc.end, C.loc.start), B = x.includes("#"), L = x.replace(/#.*/g, "").trim();
                d.push(L === "," ? "," : " &", B ? l : " ");
              }
            }
            return d;
          }
          function S() {
          }
          S.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function w(_) {
            let k = _.getValue();
            return k && Array.isArray(k.comments) && k.comments.some((A) => A.value.trim() === "prettier-ignore");
          }
          s.exports = { print: m, massageAstNode: S, hasPrettierIgnore: w, insertPragma: h, printComment: b, canAttachComment: N };
        } }), Xm = ee({ "src/language-graphql/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It();
          s.exports = { bracketSpacing: t.bracketSpacing };
        } }), Km = ee({ "src/language-graphql/parsers.js"() {
          ae();
        } }), Ym = ee({ "node_modules/linguist-languages/data/GraphQL.json"(e2, s) {
          s.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), Qm = ee({ "src/language-graphql/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = zm(), l = Xm(), u = Km(), n = [t(Ym(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], a = { graphql: i };
          s.exports = { languages: n, options: l, printers: a, parsers: u };
        } }), io = ee({ "src/language-markdown/loc.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return l.position.start.offset;
          }
          function i(l) {
            return l.position.end.offset;
          }
          s.exports = { locStart: t, locEnd: i };
        } }), Zm = ee({ "src/language-markdown/constants.evaluate.js"(e2, s) {
          s.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), $n = ee({ "src/language-markdown/utils.js"(e2, s) {
          "use strict";
          ae();
          var { getLast: t } = Ge(), { locStart: i, locEnd: l } = io(), { cjkPattern: u, kPattern: n, punctuationPattern: a } = Zm(), o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], D = [...o, "tableCell", "paragraph", "heading"], F = new RegExp(n), h = new RegExp(a);
          function v(b, T) {
            let S = "non-cjk", w = "cj-letter", _ = "k-letter", k = "cjk-punctuation", A = [], f = (T.proseWrap === "preserve" ? b : b.replace(new RegExp("(".concat(u, `)
(`).concat(u, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [c, r] of f.entries()) {
              if (c % 2 === 1) {
                A.push({ type: "whitespace", value: /\n/.test(r) ? `
` : " " });
                continue;
              }
              if ((c === 0 || c === f.length - 1) && r === "")
                continue;
              let y = r.split(new RegExp("(".concat(u, ")")));
              for (let [g, C] of y.entries())
                if (!((g === 0 || g === y.length - 1) && C === "")) {
                  if (g % 2 === 0) {
                    C !== "" && d({ type: "word", value: C, kind: S, hasLeadingPunctuation: h.test(C[0]), hasTrailingPunctuation: h.test(t(C)) });
                    continue;
                  }
                  d(h.test(C) ? { type: "word", value: C, kind: k, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: C, kind: F.test(C) ? _ : w, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return A;
            function d(c) {
              let r = t(A);
              r && r.type === "word" && (r.kind === S && c.kind === w && !r.hasTrailingPunctuation || r.kind === w && c.kind === S && !c.hasLeadingPunctuation ? A.push({ type: "whitespace", value: " " }) : !y(S, k) && ![r.value, c.value].some((g) => /\u3000/.test(g)) && A.push({ type: "whitespace", value: "" })), A.push(c);
              function y(g, C) {
                return r.kind === g && c.kind === C || r.kind === C && c.kind === g;
              }
            }
          }
          function p(b, T) {
            let [, S, w, _] = T.slice(b.position.start.offset, b.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: S, marker: w, leadingSpaces: _ };
          }
          function m(b, T) {
            if (!b.ordered || b.children.length < 2)
              return false;
            let S = Number(p(b.children[0], T.originalText).numberText), w = Number(p(b.children[1], T.originalText).numberText);
            if (S === 0 && b.children.length > 2) {
              let _ = Number(p(b.children[2], T.originalText).numberText);
              return w === 1 && _ === 1;
            }
            return w === 1;
          }
          function E(b, T) {
            let { value: S } = b;
            return b.position.end.offset === T.length && S.endsWith(`
`) && T.endsWith(`
`) ? S.slice(0, -1) : S;
          }
          function P(b, T) {
            return function S(w, _, k) {
              let A = Object.assign({}, T(w, _, k));
              return A.children && (A.children = A.children.map((f, d) => S(f, d, [A, ...k]))), A;
            }(b, null, []);
          }
          function N(b) {
            if (!b || b.type !== "link" || b.children.length !== 1)
              return false;
            let T = b.children[0];
            return T && i(b) === i(T) && l(b) === l(T);
          }
          s.exports = { mapAst: P, splitText: v, punctuationPattern: a, getFencedCodeBlockValue: E, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: m, INLINE_NODE_TYPES: o, INLINE_NODE_WRAPPER_TYPES: D, isAutolink: N };
        } }), ed = ee({ "src/language-markdown/embed.js"(e2, s) {
          "use strict";
          ae();
          var { inferParserByLanguage: t, getMaxContinuousCount: i } = Ge(), { builders: { hardline: l, markAsRoot: u }, utils: { replaceEndOfLine: n } } = Le(), a = Wn(), { getFencedCodeBlockValue: o } = $n();
          function D(F, h, v, p) {
            let m = F.getValue();
            if (m.type === "code" && m.lang !== null) {
              let E = t(m.lang, p);
              if (E) {
                let P = p.__inJsTemplate ? "~" : "`", N = P.repeat(Math.max(3, i(m.value, P) + 1)), b = { parser: E };
                m.lang === "tsx" && (b.filepath = "dummy.tsx");
                let T = v(o(m, p.originalText), b, { stripTrailingHardline: true });
                return u([N, m.lang, m.meta ? " " + m.meta : "", l, n(T), l, N]);
              }
            }
            switch (m.type) {
              case "front-matter":
                return a(m, v);
              case "importExport":
                return [v(m.value, { parser: "babel" }, { stripTrailingHardline: true }), l];
              case "jsx":
                return v("<$>".concat(m.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          s.exports = D;
        } }), oo = ee({ "src/language-markdown/pragma.js"(e2, s) {
          "use strict";
          ae();
          var t = ao(), i = ["format", "prettier"];
          function l(u) {
            let n = "@(".concat(i.join("|"), ")"), a = new RegExp(["<!--\\s*".concat(n, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(n, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(n, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), o = u.match(a);
            return o && o.index === 0;
          }
          s.exports = { startWithPragma: l, hasPragma: (u) => l(t(u).content.trimStart()), insertPragma: (u) => {
            let n = t(u), a = "<!-- @".concat(i[0], " -->");
            return n.frontMatter ? "".concat(n.frontMatter.raw, `

`).concat(a, `

`).concat(n.content) : "".concat(a, `

`).concat(n.content);
          } };
        } }), td = ee({ "src/language-markdown/print-preprocess.js"(e2, s) {
          "use strict";
          ae();
          var t = st(), { getOrderedListItemInfo: i, mapAst: l, splitText: u } = $n(), n = /^.$/su;
          function a(N, b) {
            return N = F(N, b), N = p(N), N = D(N), N = E(N, b), N = P(N, b), N = m(N, b), N = o(N), N = h(N), N;
          }
          function o(N) {
            return l(N, (b) => b.type !== "import" && b.type !== "export" ? b : Object.assign(Object.assign({}, b), {}, { type: "importExport" }));
          }
          function D(N) {
            return l(N, (b) => b.type !== "inlineCode" ? b : Object.assign(Object.assign({}, b), {}, { value: b.value.replace(/\s+/g, " ") }));
          }
          function F(N, b) {
            return l(N, (T) => T.type !== "text" || T.value === "*" || T.value === "_" || !n.test(T.value) || T.position.end.offset - T.position.start.offset === T.value.length ? T : Object.assign(Object.assign({}, T), {}, { value: b.originalText.slice(T.position.start.offset, T.position.end.offset) }));
          }
          function h(N) {
            return v(N, (b, T) => b.type === "importExport" && T.type === "importExport", (b, T) => ({ type: "importExport", value: b.value + `

` + T.value, position: { start: b.position.start, end: T.position.end } }));
          }
          function v(N, b, T) {
            return l(N, (S) => {
              if (!S.children)
                return S;
              let w = S.children.reduce((_, k) => {
                let A = t(_);
                return A && b(A, k) ? _.splice(-1, 1, T(A, k)) : _.push(k), _;
              }, []);
              return Object.assign(Object.assign({}, S), {}, { children: w });
            });
          }
          function p(N) {
            return v(N, (b, T) => b.type === "text" && T.type === "text", (b, T) => ({ type: "text", value: b.value + T.value, position: { start: b.position.start, end: T.position.end } }));
          }
          function m(N, b) {
            return l(N, (T, S, w) => {
              let [_] = w;
              if (T.type !== "text")
                return T;
              let { value: k } = T;
              return _.type === "paragraph" && (S === 0 && (k = k.trimStart()), S === _.children.length - 1 && (k = k.trimEnd())), { type: "sentence", position: T.position, children: u(k, b) };
            });
          }
          function E(N, b) {
            return l(N, (T, S, w) => {
              if (T.type === "code") {
                let _ = /^\n?(?: {4,}|\t)/.test(b.originalText.slice(T.position.start.offset, T.position.end.offset));
                if (T.isIndented = _, _)
                  for (let k = 0; k < w.length; k++) {
                    let A = w[k];
                    if (A.hasIndentedCodeblock)
                      break;
                    A.type === "list" && (A.hasIndentedCodeblock = true);
                  }
              }
              return T;
            });
          }
          function P(N, b) {
            return l(N, (w, _, k) => {
              if (w.type === "list" && w.children.length > 0) {
                for (let A = 0; A < k.length; A++) {
                  let f = k[A];
                  if (f.type === "list" && !f.isAligned)
                    return w.isAligned = false, w;
                }
                w.isAligned = S(w);
              }
              return w;
            });
            function T(w) {
              return w.children.length === 0 ? -1 : w.children[0].position.start.column - 1;
            }
            function S(w) {
              if (!w.ordered)
                return true;
              let [_, k] = w.children;
              if (i(_, b.originalText).leadingSpaces.length > 1)
                return true;
              let f = T(_);
              if (f === -1)
                return false;
              if (w.children.length === 1)
                return f % b.tabWidth === 0;
              let d = T(k);
              return f !== d ? false : f % b.tabWidth === 0 ? true : i(k, b.originalText).leadingSpaces.length > 1;
            }
          }
          s.exports = a;
        } }), rd = ee({ "src/language-markdown/clean.js"(e2, s) {
          "use strict";
          ae();
          var { isFrontMatterNode: t } = Ge(), { startWithPragma: i } = oo(), l = /* @__PURE__ */ new Set(["position", "raw"]);
          function u(n, a, o) {
            if ((n.type === "front-matter" || n.type === "code" || n.type === "yaml" || n.type === "import" || n.type === "export" || n.type === "jsx") && delete a.value, n.type === "list" && delete a.isAligned, (n.type === "list" || n.type === "listItem") && (delete a.spread, delete a.loose), n.type === "text" || (n.type === "inlineCode" && (a.value = n.value.replace(/[\t\n ]+/g, " ")), n.type === "wikiLink" && (a.value = n.value.trim().replace(/[\t\n]+/g, " ")), (n.type === "definition" || n.type === "linkReference") && (a.label = n.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (n.type === "definition" || n.type === "link" || n.type === "image") && n.title && (a.title = n.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === n || t(o.children[0]) && o.children[1] === n) && n.type === "html" && i(n.value)))
              return null;
          }
          u.ignoredProperties = l, s.exports = u;
        } }), nd = ee({ "src/language-markdown/printer-markdown.js"(e2, s) {
          "use strict";
          ae();
          var { getLast: t, getMinNotPresentContinuousCount: i, getMaxContinuousCount: l, getStringWidth: u, isNonEmptyArray: n } = Ge(), { builders: { breakParent: a, join: o, line: D, literalline: F, markAsRoot: h, hardline: v, softline: p, ifBreak: m, fill: E, align: P, indent: N, group: b, hardlineWithoutBreakParent: T }, utils: { normalizeDoc: S, replaceTextEndOfLine: w }, printer: { printDocToString: _ } } = Le(), k = ed(), { insertPragma: A } = oo(), { locStart: f, locEnd: d } = io(), c = td(), r = rd(), { getFencedCodeBlockValue: y, hasGitDiffFriendlyOrderedList: g, splitText: C, punctuationPattern: x, INLINE_NODE_TYPES: B, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: M } = $n(), j = /* @__PURE__ */ new Set(["importExport"]), H = ["heading", "tableCell", "link", "wikiLink"], I = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function G(fe, pe, me) {
            let ce = fe.getValue();
            if (de(fe))
              return C(pe.originalText.slice(ce.position.start.offset, ce.position.end.offset), pe).map((he) => he.type === "word" ? he.value : he.value === "" ? "" : se(fe, he.value, pe));
            switch (ce.type) {
              case "front-matter":
                return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
              case "root":
                return ce.children.length === 0 ? "" : [S(oe(fe, pe, me)), j.has(Ee(ce).type) ? "" : v];
              case "paragraph":
                return K(fe, pe, me, { postprocessor: E });
              case "sentence":
                return K(fe, pe, me);
              case "word": {
                let he = ce.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x, ")(_+)"), "(_+)(".concat(x, "|$)")].join("|"), "g"), (X, Y, re, z, q) => (re ? "".concat(Y).concat(re) : "".concat(z).concat(q)).replace(/_/g, "\\_")), J = (X, Y, re) => X.type === "sentence" && re === 0, ye = (X, Y, re) => M(X.children[re - 1]);
                return he !== ce.value && (fe.match(void 0, J, ye) || fe.match(void 0, J, (X, Y, re) => X.type === "emphasis" && re === 0, ye)) && (he = he.replace(/^(\\?[*_])+/, (X) => X.replace(/\\/g, ""))), he;
              }
              case "whitespace": {
                let he = fe.getParentNode(), J = he.children.indexOf(ce), ye = he.children[J + 1], X = ye && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(ye.value) ? "never" : pe.proseWrap;
                return se(fe, ce.value, { proseWrap: X });
              }
              case "emphasis": {
                let he;
                if (M(ce.children[0]))
                  he = pe.originalText[ce.position.start.offset];
                else {
                  let J = fe.getParentNode(), ye = J.children.indexOf(ce), X = J.children[ye - 1], Y = J.children[ye + 1];
                  he = X && X.type === "sentence" && X.children.length > 0 && t(X.children).type === "word" && !t(X.children).hasTrailingPunctuation || Y && Y.type === "sentence" && Y.children.length > 0 && Y.children[0].type === "word" && !Y.children[0].hasLeadingPunctuation || ne(fe, "emphasis") ? "*" : "_";
                }
                return [he, K(fe, pe, me), he];
              }
              case "strong":
                return ["**", K(fe, pe, me), "**"];
              case "delete":
                return ["~~", K(fe, pe, me), "~~"];
              case "inlineCode": {
                let he = i(ce.value, "`"), J = "`".repeat(he || 1), ye = he && !/^\s/.test(ce.value) ? " " : "";
                return [J, ye, ce.value, ye, J];
              }
              case "wikiLink": {
                let he = "";
                return pe.proseWrap === "preserve" ? he = ce.value : he = ce.value.replace(/[\t\n]+/g, " "), ["[[", he, "]]"];
              }
              case "link":
                switch (pe.originalText[ce.position.start.offset]) {
                  case "<": {
                    let he = "mailto:", J = ce.url.startsWith(he) && pe.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + he.length) !== he ? ce.url.slice(he.length) : ce.url;
                    return ["<", J, ">"];
                  }
                  case "[":
                    return ["[", K(fe, pe, me), "](", ge(ce.url, ")"), ve(ce.title, pe), ")"];
                  default:
                    return pe.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                }
              case "image":
                return ["![", ce.alt || "", "](", ge(ce.url, ")"), ve(ce.title, pe), ")"];
              case "blockquote":
                return ["> ", P("> ", K(fe, pe, me))];
              case "heading":
                return ["#".repeat(ce.depth) + " ", K(fe, pe, me)];
              case "code": {
                if (ce.isIndented) {
                  let ye = " ".repeat(4);
                  return P(ye, [ye, ...w(ce.value, v)]);
                }
                let he = pe.__inJsTemplate ? "~" : "`", J = he.repeat(Math.max(3, l(ce.value, he) + 1));
                return [J, ce.lang || "", ce.meta ? " " + ce.meta : "", v, ...w(y(ce, pe.originalText), v), v, J];
              }
              case "html": {
                let he = fe.getParentNode(), J = he.type === "root" && t(he.children) === ce ? ce.value.trimEnd() : ce.value, ye = /^<!--.*-->$/s.test(J);
                return w(J, ye ? v : h(F));
              }
              case "list": {
                let he = $(ce, fe.getParentNode()), J = g(ce, pe);
                return K(fe, pe, me, { processor: (ye, X) => {
                  let Y = z(), re = ye.getValue();
                  if (re.children.length === 2 && re.children[1].type === "html" && re.children[0].position.start.column !== re.children[1].position.start.column)
                    return [Y, Z(ye, pe, me, Y)];
                  return [Y, P(" ".repeat(Y.length), Z(ye, pe, me, Y))];
                  function z() {
                    let q = ce.ordered ? (X === 0 ? ce.start : J ? 1 : ce.start + X) + (he % 2 === 0 ? ". " : ") ") : he % 2 === 0 ? "- " : "* ";
                    return ce.isAligned || ce.hasIndentedCodeblock ? W(q, pe) : q;
                  }
                } });
              }
              case "thematicBreak": {
                let he = U(fe, "list");
                return he === -1 ? "---" : $(fe.getParentNode(he), fe.getParentNode(he + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", K(fe, pe, me), "]", ce.referenceType === "full" ? ["[", ce.identifier, "]"] : ce.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ce.referenceType) {
                  case "full":
                    return ["![", ce.alt || "", "][", ce.identifier, "]"];
                  default:
                    return ["![", ce.alt, "]", ce.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let he = pe.proseWrap === "always" ? D : " ";
                return b(["[", ce.identifier, "]:", N([he, ge(ce.url), ce.title === null ? "" : [he, ve(ce.title, pe, false)]])]);
              }
              case "footnote":
                return ["[^", K(fe, pe, me), "]"];
              case "footnoteReference":
                return ["[^", ce.identifier, "]"];
              case "footnoteDefinition": {
                let he = fe.getParentNode().children[fe.getName() + 1], J = ce.children.length === 1 && ce.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                return ["[^", ce.identifier, "]: ", J ? K(fe, pe, me) : b([P(" ".repeat(4), K(fe, pe, me, { processor: (ye, X) => X === 0 ? b([p, me()]) : me() })), he && he.type === "footnoteDefinition" ? p : ""])];
              }
              case "table":
                return V(fe, pe, me);
              case "tableCell":
                return K(fe, pe, me);
              case "break":
                return /\s/.test(pe.originalText[ce.position.start.offset]) ? ["  ", h(F)] : ["\\", v];
              case "liquidNode":
                return w(ce.value, v);
              case "importExport":
                return [ce.value, v];
              case "esComment":
                return ["{/* ", ce.value, " */}"];
              case "jsx":
                return ce.value;
              case "math":
                return ["$$", v, ce.value ? [...w(ce.value, v), v] : "", "$$"];
              case "inlineMath":
                return pe.originalText.slice(f(ce), d(ce));
              case "tableRow":
              case "listItem":
              default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(ce.type)));
            }
          }
          function Z(fe, pe, me, ce) {
            let he = fe.getValue(), J = he.checked === null ? "" : he.checked ? "[x] " : "[ ] ";
            return [J, K(fe, pe, me, { processor: (ye, X) => {
              if (X === 0 && ye.getValue().type !== "list")
                return P(" ".repeat(J.length), me());
              let Y = " ".repeat(be(pe.tabWidth - ce.length, 0, 3));
              return [Y, P(Y, me())];
            } })];
          }
          function W(fe, pe) {
            let me = ce();
            return fe + " ".repeat(me >= 4 ? 0 : me);
            function ce() {
              let he = fe.length % pe.tabWidth;
              return he === 0 ? 0 : pe.tabWidth - he;
            }
          }
          function $(fe, pe) {
            return te(fe, pe, (me) => me.ordered === fe.ordered);
          }
          function te(fe, pe, me) {
            let ce = -1;
            for (let he of pe.children)
              if (he.type === fe.type && me(he) ? ce++ : ce = -1, he === fe)
                return ce;
          }
          function U(fe, pe) {
            let me = Array.isArray(pe) ? pe : [pe], ce = -1, he;
            for (; he = fe.getParentNode(++ce); )
              if (me.includes(he.type))
                return ce;
            return -1;
          }
          function ne(fe, pe) {
            let me = U(fe, pe);
            return me === -1 ? null : fe.getParentNode(me);
          }
          function se(fe, pe, me) {
            if (me.proseWrap === "preserve" && pe === `
`)
              return v;
            let ce = me.proseWrap === "always" && !ne(fe, H);
            return pe !== "" ? ce ? D : " " : ce ? p : "";
          }
          function V(fe, pe, me) {
            let ce = fe.getValue(), he = [], J = fe.map((q) => q.map((Ce, Ne) => {
              let je = _(me(), pe).formatted, Ue = u(je);
              return he[Ne] = Math.max(he[Ne] || 3, Ue), { text: je, width: Ue };
            }, "children"), "children"), ye = Y(false);
            if (pe.proseWrap !== "never")
              return [a, ye];
            let X = Y(true);
            return [a, b(m(X, ye))];
            function Y(q) {
              let Ce = [z(J[0], q), re(q)];
              return J.length > 1 && Ce.push(o(T, J.slice(1).map((Ne) => z(Ne, q)))), o(T, Ce);
            }
            function re(q) {
              let Ce = he.map((Ne, je) => {
                let Ue = ce.align[je], tt = Ue === "center" || Ue === "left" ? ":" : "-", Te = Ue === "center" || Ue === "right" ? ":" : "-", Pe = q ? "-" : "-".repeat(Ne - 2);
                return "".concat(tt).concat(Pe).concat(Te);
              });
              return "| ".concat(Ce.join(" | "), " |");
            }
            function z(q, Ce) {
              let Ne = q.map((je, Ue) => {
                let { text: tt, width: Te } = je;
                if (Ce)
                  return tt;
                let Pe = he[Ue] - Te, Fe = ce.align[Ue], Ke = 0;
                Fe === "right" ? Ke = Pe : Fe === "center" && (Ke = Math.floor(Pe / 2));
                let Se = Pe - Ke;
                return "".concat(" ".repeat(Ke)).concat(tt).concat(" ".repeat(Se));
              });
              return "| ".concat(Ne.join(" | "), " |");
            }
          }
          function oe(fe, pe, me) {
            let ce = [], he = null, { children: J } = fe.getValue();
            for (let [ye, X] of J.entries())
              switch (R(X)) {
                case "start":
                  he === null && (he = { index: ye, offset: X.position.end.offset });
                  break;
                case "end":
                  he !== null && (ce.push({ start: he, end: { index: ye, offset: X.position.start.offset } }), he = null);
                  break;
                default:
                  break;
              }
            return K(fe, pe, me, { processor: (ye, X) => {
              if (ce.length > 0) {
                let Y = ce[0];
                if (X === Y.start.index)
                  return [J[Y.start.index].value, pe.originalText.slice(Y.start.offset, Y.end.offset), J[Y.end.index].value];
                if (Y.start.index < X && X < Y.end.index)
                  return false;
                if (X === Y.end.index)
                  return ce.shift(), false;
              }
              return me();
            } });
          }
          function K(fe, pe, me) {
            let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: he } = ce, J = ce.processor || (() => me()), ye = fe.getValue(), X = [], Y;
            return fe.each((re, z) => {
              let q = re.getValue(), Ce = J(re, z);
              if (Ce !== false) {
                let Ne = { parts: X, prevNode: Y, parentNode: ye, options: pe };
                le(q, Ne) && (X.push(v), Y && j.has(Y.type) || (ue(q, Ne) || Q(q, Ne)) && X.push(v), Q(q, Ne) && X.push(v)), X.push(Ce), Y = q;
              }
            }, "children"), he ? he(X) : X;
          }
          function Ee(fe) {
            let pe = fe;
            for (; n(pe.children); )
              pe = t(pe.children);
            return pe;
          }
          function R(fe) {
            let pe;
            if (fe.type === "html")
              pe = fe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let me;
              fe.type === "esComment" ? me = fe : fe.type === "paragraph" && fe.children.length === 1 && fe.children[0].type === "esComment" && (me = fe.children[0]), me && (pe = me.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return pe ? pe[1] ? pe[1] : "next" : false;
          }
          function le(fe, pe) {
            let me = pe.parts.length === 0, ce = B.includes(fe.type), he = fe.type === "html" && L.includes(pe.parentNode.type);
            return !me && !ce && !he;
          }
          function ue(fe, pe) {
            let ce = (pe.prevNode && pe.prevNode.type) === fe.type && I.has(fe.type), he = pe.parentNode.type === "listItem" && !pe.parentNode.loose, J = pe.prevNode && pe.prevNode.type === "listItem" && pe.prevNode.loose, ye = R(pe.prevNode) === "next", X = fe.type === "html" && pe.prevNode && pe.prevNode.type === "html" && pe.prevNode.position.end.line + 1 === fe.position.start.line, Y = fe.type === "html" && pe.parentNode.type === "listItem" && pe.prevNode && pe.prevNode.type === "paragraph" && pe.prevNode.position.end.line + 1 === fe.position.start.line;
            return J || !(ce || he || ye || X || Y);
          }
          function Q(fe, pe) {
            let me = pe.prevNode && pe.prevNode.type === "list", ce = fe.type === "code" && fe.isIndented;
            return me && ce;
          }
          function de(fe) {
            let pe = ne(fe, ["linkReference", "imageReference"]);
            return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
          }
          function ge(fe) {
            let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], me = [" ", ...Array.isArray(pe) ? pe : [pe]];
            return new RegExp(me.map((ce) => "\\".concat(ce)).join("|")).test(fe) ? "<".concat(fe, ">") : fe;
          }
          function ve(fe, pe) {
            let me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!fe)
              return "";
            if (me)
              return " " + ve(fe, pe, false);
            if (fe = fe.replace(/\\(["')])/g, "$1"), fe.includes('"') && fe.includes("'") && !fe.includes(")"))
              return "(".concat(fe, ")");
            let ce = fe.split("'").length - 1, he = fe.split('"').length - 1, J = ce > he ? '"' : he > ce || pe.singleQuote ? "'" : '"';
            return fe = fe.replace(/\\/, "\\\\"), fe = fe.replace(new RegExp("(".concat(J, ")"), "g"), "\\$1"), "".concat(J).concat(fe).concat(J);
          }
          function be(fe, pe, me) {
            return fe < pe ? pe : fe > me ? me : fe;
          }
          function we(fe) {
            let pe = Number(fe.getName());
            if (pe === 0)
              return false;
            let me = fe.getParentNode().children[pe - 1];
            return R(me) === "next";
          }
          s.exports = { preprocess: c, print: G, embed: k, massageAstNode: r, hasPrettierIgnore: we, insertPragma: A };
        } }), ud = ee({ "src/language-markdown/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It();
          s.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), sd = ee({ "src/language-markdown/parsers.js"() {
          ae();
        } }), ci = ee({ "node_modules/linguist-languages/data/Markdown.json"(e2, s) {
          s.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), ad = ee({ "src/language-markdown/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = nd(), l = ud(), u = sd(), n = [t(ci(), (o) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...o.filenames, "README"], extensions: o.extensions.filter((D) => D !== ".mdx") })), t(ci(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], a = { mdast: i };
          s.exports = { languages: n, options: l, printers: a, parsers: u };
        } }), id = ee({ "src/language-html/clean.js"(e2, s) {
          "use strict";
          ae();
          var { isFrontMatterNode: t } = Ge(), i = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "parent"]);
          function l(u, n) {
            if (u.type === "text" || u.type === "comment" || t(u) || u.type === "yaml" || u.type === "toml")
              return null;
            u.type === "attribute" && delete n.value, u.type === "docType" && delete n.value;
          }
          l.ignoredProperties = i, s.exports = l;
        } }), od = ee({ "src/language-html/constants.evaluate.js"(e2, s) {
          s.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), cd = ee({ "src/language-html/utils/is-unknown-namespace.js"(e2, s) {
          "use strict";
          ae();
          function t(i) {
            return i.type === "element" && !i.hasExplicitNamespace && !["html", "svg"].includes(i.namespace);
          }
          s.exports = t;
        } }), kt = ee({ "src/language-html/utils/index.js"(e2, s) {
          "use strict";
          ae();
          var { inferParserByLanguage: t, isFrontMatterNode: i } = Ge(), { builders: { line: l, hardline: u, join: n }, utils: { getDocParts: a, replaceTextEndOfLine: o } } = Le(), { CSS_DISPLAY_TAGS: D, CSS_DISPLAY_DEFAULT: F, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: v } = od(), p = cd(), m = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), E = (q) => q.replace(/^[\t\n\f\r ]+/, ""), P = (q) => q.replace(/[\t\n\f\r ]+$/, ""), N = (q) => E(P(q)), b = (q) => q.replace(/^[\t\f\r ]*\n/g, ""), T = (q) => b(P(q)), S = (q) => q.split(/[\t\n\f\r ]+/), w = (q) => q.match(/^[\t\n\f\r ]*/)[0], _ = (q) => {
            let [, Ce, Ne, je] = q.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: Ce, trailingWhitespace: je, text: Ne };
          }, k = (q) => /[\t\n\f\r ]/.test(q);
          function A(q, Ce) {
            return !!(q.type === "ieConditionalComment" && q.lastChild && !q.lastChild.isSelfClosing && !q.lastChild.endSourceSpan || q.type === "ieConditionalComment" && !q.complete || de(q) && q.children.some((Ne) => Ne.type !== "text" && Ne.type !== "interpolation") || X(q, Ce) && !r(q) && q.type !== "interpolation");
          }
          function f(q) {
            return q.type === "attribute" || !q.parent || !q.prev ? false : d(q.prev);
          }
          function d(q) {
            return q.type === "comment" && q.value.trim() === "prettier-ignore";
          }
          function c(q) {
            return q.type === "text" || q.type === "comment";
          }
          function r(q) {
            return q.type === "element" && (q.fullName === "script" || q.fullName === "style" || q.fullName === "svg:style" || p(q) && (q.name === "script" || q.name === "style"));
          }
          function y(q) {
            return q.children && !r(q);
          }
          function g(q) {
            return r(q) || q.type === "interpolation" || C(q);
          }
          function C(q) {
            return we(q).startsWith("pre");
          }
          function x(q, Ce) {
            let Ne = je();
            if (Ne && !q.prev && q.parent && q.parent.tagDefinition && q.parent.tagDefinition.ignoreFirstLf)
              return q.type === "interpolation";
            return Ne;
            function je() {
              return i(q) ? false : (q.type === "text" || q.type === "interpolation") && q.prev && (q.prev.type === "text" || q.prev.type === "interpolation") ? true : !q.parent || q.parent.cssDisplay === "none" ? false : de(q.parent) ? true : !(!q.prev && (q.parent.type === "root" || de(q) && q.parent || r(q.parent) || J(q.parent, Ce) || !Ee(q.parent.cssDisplay)) || q.prev && !ue(q.prev.cssDisplay));
            }
          }
          function B(q, Ce) {
            return i(q) ? false : (q.type === "text" || q.type === "interpolation") && q.next && (q.next.type === "text" || q.next.type === "interpolation") ? true : !q.parent || q.parent.cssDisplay === "none" ? false : de(q.parent) ? true : !(!q.next && (q.parent.type === "root" || de(q) && q.parent || r(q.parent) || J(q.parent, Ce) || !R(q.parent.cssDisplay)) || q.next && !le(q.next.cssDisplay));
          }
          function L(q) {
            return Q(q.cssDisplay) && !r(q);
          }
          function M(q) {
            return i(q) || q.next && q.sourceSpan.end && q.sourceSpan.end.line + 1 < q.next.sourceSpan.start.line;
          }
          function j(q) {
            return H(q) || q.type === "element" && q.children.length > 0 && (["body", "script", "style"].includes(q.name) || q.children.some((Ce) => ne(Ce))) || q.firstChild && q.firstChild === q.lastChild && q.firstChild.type !== "text" && W(q.firstChild) && (!q.lastChild.isTrailingSpaceSensitive || $(q.lastChild));
          }
          function H(q) {
            return q.type === "element" && q.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(q.name) || q.cssDisplay.startsWith("table") && q.cssDisplay !== "table-cell");
          }
          function I(q) {
            return te(q) || q.prev && G(q.prev) || Z(q);
          }
          function G(q) {
            return te(q) || q.type === "element" && q.fullName === "br" || Z(q);
          }
          function Z(q) {
            return W(q) && $(q);
          }
          function W(q) {
            return q.hasLeadingSpaces && (q.prev ? q.prev.sourceSpan.end.line < q.sourceSpan.start.line : q.parent.type === "root" || q.parent.startSourceSpan.end.line < q.sourceSpan.start.line);
          }
          function $(q) {
            return q.hasTrailingSpaces && (q.next ? q.next.sourceSpan.start.line > q.sourceSpan.end.line : q.parent.type === "root" || q.parent.endSourceSpan && q.parent.endSourceSpan.start.line > q.sourceSpan.end.line);
          }
          function te(q) {
            switch (q.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(q.name);
            }
            return false;
          }
          function U(q) {
            return q.lastChild ? U(q.lastChild) : q;
          }
          function ne(q) {
            return q.children && q.children.some((Ce) => Ce.type !== "text");
          }
          function se(q) {
            let { type: Ce, lang: Ne } = q.attrMap;
            if (Ce === "module" || Ce === "text/javascript" || Ce === "text/babel" || Ce === "application/javascript" || Ne === "jsx")
              return "babel";
            if (Ce === "application/x-typescript" || Ne === "ts" || Ne === "tsx")
              return "typescript";
            if (Ce === "text/markdown")
              return "markdown";
            if (Ce === "text/html")
              return "html";
            if (Ce && (Ce.endsWith("json") || Ce.endsWith("importmap")))
              return "json";
            if (Ce === "text/x-handlebars-template")
              return "glimmer";
          }
          function V(q) {
            let { lang: Ce } = q.attrMap;
            if (!Ce || Ce === "postcss" || Ce === "css")
              return "css";
            if (Ce === "scss")
              return "scss";
            if (Ce === "less")
              return "less";
          }
          function oe(q, Ce) {
            if (q.name === "script" && !q.attrMap.src)
              return !q.attrMap.lang && !q.attrMap.type ? "babel" : se(q);
            if (q.name === "style")
              return V(q);
            if (Ce && X(q, Ce))
              return se(q) || !("src" in q.attrMap) && t(q.attrMap.lang, Ce);
          }
          function K(q) {
            return q === "block" || q === "list-item" || q.startsWith("table");
          }
          function Ee(q) {
            return !K(q) && q !== "inline-block";
          }
          function R(q) {
            return !K(q) && q !== "inline-block";
          }
          function le(q) {
            return !K(q);
          }
          function ue(q) {
            return !K(q);
          }
          function Q(q) {
            return !K(q) && q !== "inline-block";
          }
          function de(q) {
            return we(q).startsWith("pre");
          }
          function ge(q, Ce) {
            let Ne = 0;
            for (let je = q.stack.length - 1; je >= 0; je--) {
              let Ue = q.stack[je];
              Ue && typeof Ue == "object" && !Array.isArray(Ue) && Ce(Ue) && Ne++;
            }
            return Ne;
          }
          function ve(q, Ce) {
            let Ne = q;
            for (; Ne; ) {
              if (Ce(Ne))
                return true;
              Ne = Ne.parent;
            }
            return false;
          }
          function be(q, Ce) {
            if (q.prev && q.prev.type === "comment") {
              let je = q.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (je)
                return je[1];
            }
            let Ne = false;
            if (q.type === "element" && q.namespace === "svg")
              if (ve(q, (je) => je.fullName === "svg:foreignObject"))
                Ne = true;
              else
                return q.name === "svg" ? "inline-block" : "block";
            switch (Ce.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return Ce.parser === "vue" && q.parent && q.parent.type === "root" ? "block" : q.type === "element" && (!q.namespace || Ne || p(q)) && D[q.name] || F;
            }
          }
          function we(q) {
            return q.type === "element" && (!q.namespace || p(q)) && h[q.name] || v;
          }
          function fe(q) {
            let Ce = Number.POSITIVE_INFINITY;
            for (let Ne of q.split(`
`)) {
              if (Ne.length === 0)
                continue;
              if (!m.has(Ne[0]))
                return 0;
              let je = w(Ne).length;
              Ne.length !== je && je < Ce && (Ce = je);
            }
            return Ce === Number.POSITIVE_INFINITY ? 0 : Ce;
          }
          function pe(q) {
            let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fe(q);
            return Ce === 0 ? q : q.split(`
`).map((Ne) => Ne.slice(Ce)).join(`
`);
          }
          function me(q, Ce) {
            let Ne = 0;
            for (let je = 0; je < q.length; je++)
              q[je] === Ce && Ne++;
            return Ne;
          }
          function ce(q) {
            return q.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var he = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function J(q, Ce) {
            return ye(q, Ce) && !he.has(q.fullName);
          }
          function ye(q, Ce) {
            return Ce.parser === "vue" && q.type === "element" && q.parent.type === "root" && q.fullName.toLowerCase() !== "html";
          }
          function X(q, Ce) {
            return ye(q, Ce) && (J(q, Ce) || q.attrMap.lang && q.attrMap.lang !== "html");
          }
          function Y(q) {
            let Ce = q.fullName;
            return Ce.charAt(0) === "#" || Ce === "slot-scope" || Ce === "v-slot" || Ce.startsWith("v-slot:");
          }
          function re(q, Ce) {
            let Ne = q.parent;
            if (!ye(Ne, Ce))
              return false;
            let je = Ne.fullName, Ue = q.fullName;
            return je === "script" && Ue === "setup" || je === "style" && Ue === "vars";
          }
          function z(q) {
            let Ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : q.value;
            return q.parent.isWhitespaceSensitive ? q.parent.isIndentationSensitive ? o(Ce) : o(pe(T(Ce)), u) : a(n(l, S(Ce)));
          }
          s.exports = { htmlTrim: N, htmlTrimPreserveIndentation: T, hasHtmlWhitespace: k, getLeadingAndTrailingHtmlWhitespace: _, canHaveInterpolation: y, countChars: me, countParents: ge, dedentString: pe, forceBreakChildren: H, forceBreakContent: j, forceNextEmptyLine: M, getLastDescendant: U, getNodeCssStyleDisplay: be, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: f, inferScriptParser: oe, isVueCustomBlock: J, isVueNonHtmlBlock: X, isVueSlotAttribute: Y, isVueSfcBindingsAttribute: re, isDanglingSpaceSensitiveNode: L, isIndentationSensitiveNode: C, isLeadingSpaceSensitiveNode: x, isPreLikeNode: de, isScriptLikeTag: r, isTextLikeNode: c, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: g, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: I, preferHardlineAsTrailingSpaces: G, shouldPreserveContent: A, unescapeQuoteEntities: ce, getTextValueParts: z };
        } }), ld = ee({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96;
          function s(a) {
            return a >= e2.$TAB && a <= e2.$SPACE || a == e2.$NBSP;
          }
          e2.isWhitespace = s;
          function t(a) {
            return e2.$0 <= a && a <= e2.$9;
          }
          e2.isDigit = t;
          function i(a) {
            return a >= e2.$a && a <= e2.$z || a >= e2.$A && a <= e2.$Z;
          }
          e2.isAsciiLetter = i;
          function l(a) {
            return a >= e2.$a && a <= e2.$f || a >= e2.$A && a <= e2.$F || t(a);
          }
          e2.isAsciiHexDigit = l;
          function u(a) {
            return a === e2.$LF || a === e2.$CR;
          }
          e2.isNewLine = u;
          function n(a) {
            return e2.$0 <= a && a <= e2.$7;
          }
          e2.isOctalDigit = n;
        } }), pd = ee({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = class {
            constructor(i, l, u) {
              this.filePath = i, this.name = l, this.members = u;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
            }
          };
          e2.StaticSymbol = s;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(i, l, u) {
              u = u || [];
              let n = u.length ? ".".concat(u.join(".")) : "", a = '"'.concat(i, '".').concat(l).concat(n), o = this.cache.get(a);
              return o || (o = new s(i, l, u), this.cache.set(a, o)), o;
            }
          };
          e2.StaticSymbolCache = t;
        } }), fd = ee({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = /-+([a-z0-9])/g;
          function t(r) {
            return r.replace(s, function() {
              for (var y = arguments.length, g = new Array(y), C = 0; C < y; C++)
                g[C] = arguments[C];
              return g[1].toUpperCase();
            });
          }
          e2.dashCaseToCamelCase = t;
          function i(r, y) {
            return u(r, ":", y);
          }
          e2.splitAtColon = i;
          function l(r, y) {
            return u(r, ".", y);
          }
          e2.splitAtPeriod = l;
          function u(r, y, g) {
            let C = r.indexOf(y);
            return C == -1 ? g : [r.slice(0, C).trim(), r.slice(C + 1).trim()];
          }
          function n(r, y, g) {
            return Array.isArray(r) ? y.visitArray(r, g) : b(r) ? y.visitStringMap(r, g) : r == null || typeof r == "string" || typeof r == "number" || typeof r == "boolean" ? y.visitPrimitive(r, g) : y.visitOther(r, g);
          }
          e2.visitValue = n;
          function a(r) {
            return r != null;
          }
          e2.isDefined = a;
          function o(r) {
            return r === void 0 ? null : r;
          }
          e2.noUndefined = o;
          var D = class {
            visitArray(r, y) {
              return r.map((g) => n(g, this, y));
            }
            visitStringMap(r, y) {
              let g = {};
              return Object.keys(r).forEach((C) => {
                g[C] = n(r[C], this, y);
              }), g;
            }
            visitPrimitive(r, y) {
              return r;
            }
            visitOther(r, y) {
              return r;
            }
          };
          e2.ValueTransformer = D, e2.SyncAsync = { assertSync: (r) => {
            if (_(r))
              throw new Error("Illegal state: value cannot be a promise");
            return r;
          }, then: (r, y) => _(r) ? r.then(y) : y(r), all: (r) => r.some(_) ? Promise.all(r) : r };
          function F(r) {
            throw new Error("Internal Error: ".concat(r));
          }
          e2.error = F;
          function h(r, y) {
            let g = Error(r);
            return g[v] = true, y && (g[p] = y), g;
          }
          e2.syntaxError = h;
          var v = "ngSyntaxError", p = "ngParseErrors";
          function m(r) {
            return r[v];
          }
          e2.isSyntaxError = m;
          function E(r) {
            return r[p] || [];
          }
          e2.getParseErrors = E;
          function P(r) {
            return r.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e2.escapeRegExp = P;
          var N = Object.getPrototypeOf({});
          function b(r) {
            return typeof r == "object" && r !== null && Object.getPrototypeOf(r) === N;
          }
          function T(r) {
            let y = "";
            for (let g = 0; g < r.length; g++) {
              let C = r.charCodeAt(g);
              if (C >= 55296 && C <= 56319 && r.length > g + 1) {
                let x = r.charCodeAt(g + 1);
                x >= 56320 && x <= 57343 && (g++, C = (C - 55296 << 10) + x - 56320 + 65536);
              }
              C <= 127 ? y += String.fromCharCode(C) : C <= 2047 ? y += String.fromCharCode(C >> 6 & 31 | 192, C & 63 | 128) : C <= 65535 ? y += String.fromCharCode(C >> 12 | 224, C >> 6 & 63 | 128, C & 63 | 128) : C <= 2097151 && (y += String.fromCharCode(C >> 18 & 7 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, C & 63 | 128));
            }
            return y;
          }
          e2.utf8Encode = T;
          function S(r) {
            if (typeof r == "string")
              return r;
            if (r instanceof Array)
              return "[" + r.map(S).join(", ") + "]";
            if (r == null)
              return "" + r;
            if (r.overriddenName)
              return "".concat(r.overriddenName);
            if (r.name)
              return "".concat(r.name);
            if (!r.toString)
              return "object";
            let y = r.toString();
            if (y == null)
              return "" + y;
            let g = y.indexOf(`
`);
            return g === -1 ? y : y.substring(0, g);
          }
          e2.stringify = S;
          function w(r) {
            return typeof r == "function" && r.hasOwnProperty("__forward_ref__") ? r() : r;
          }
          e2.resolveForwardRef = w;
          function _(r) {
            return !!r && typeof r.then == "function";
          }
          e2.isPromise = _;
          var k = class {
            constructor(r) {
              this.full = r;
              let y = r.split(".");
              this.major = y[0], this.minor = y[1], this.patch = y.slice(2).join(".");
            }
          };
          e2.Version = k;
          var A = typeof window < "u" && window, f = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, d = typeof globalThis < "u" && globalThis, c = d || A || f;
          e2.global = c;
        } }), Dd = ee({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = pd(), t = fd(), i = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function l(g) {
            return g.replace(/\W/g, "_");
          }
          e2.sanitizeIdentifier = l;
          var u = 0;
          function n(g) {
            if (!g || !g.reference)
              return null;
            let C = g.reference;
            if (C instanceof s.StaticSymbol)
              return C.name;
            if (C.__anonymousType)
              return C.__anonymousType;
            let x = t.stringify(C);
            return x.indexOf("(") >= 0 ? (x = "anonymous_".concat(u++), C.__anonymousType = x) : x = l(x), x;
          }
          e2.identifierName = n;
          function a(g) {
            let C = g.reference;
            return C instanceof s.StaticSymbol ? C.filePath : "./".concat(t.stringify(C));
          }
          e2.identifierModuleUrl = a;
          function o(g, C) {
            return "View_".concat(n({ reference: g }), "_").concat(C);
          }
          e2.viewClassName = o;
          function D(g) {
            return "RenderType_".concat(n({ reference: g }));
          }
          e2.rendererTypeName = D;
          function F(g) {
            return "HostView_".concat(n({ reference: g }));
          }
          e2.hostViewClassName = F;
          function h(g) {
            return "".concat(n({ reference: g }), "NgFactory");
          }
          e2.componentFactoryName = h;
          var v;
          (function(g) {
            g[g.Pipe = 0] = "Pipe", g[g.Directive = 1] = "Directive", g[g.NgModule = 2] = "NgModule", g[g.Injectable = 3] = "Injectable";
          })(v = e2.CompileSummaryKind || (e2.CompileSummaryKind = {}));
          function p(g) {
            return g.value != null ? l(g.value) : n(g.identifier);
          }
          e2.tokenName = p;
          function m(g) {
            return g.identifier != null ? g.identifier.reference : g.value;
          }
          e2.tokenReference = m;
          var E = class {
            constructor() {
              let { moduleUrl: g, styles: C, styleUrls: x } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = g || null, this.styles = _(C), this.styleUrls = _(x);
            }
          };
          e2.CompileStylesheetMetadata = E;
          var P = class {
            constructor(g) {
              let { encapsulation: C, template: x, templateUrl: B, htmlAst: L, styles: M, styleUrls: j, externalStylesheets: H, animations: I, ngContentSelectors: G, interpolation: Z, isInline: W, preserveWhitespaces: $ } = g;
              if (this.encapsulation = C, this.template = x, this.templateUrl = B, this.htmlAst = L, this.styles = _(M), this.styleUrls = _(j), this.externalStylesheets = _(H), this.animations = I ? A(I) : [], this.ngContentSelectors = G || [], Z && Z.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Z, this.isInline = W, this.preserveWhitespaces = $;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e2.CompileTemplateMetadata = P;
          var N = class {
            static create(g) {
              let { isHost: C, type: x, isComponent: B, selector: L, exportAs: M, changeDetection: j, inputs: H, outputs: I, host: G, providers: Z, viewProviders: W, queries: $, guards: te, viewQueries: U, entryComponents: ne, template: se, componentViewType: V, rendererType: oe, componentFactory: K } = g, Ee = {}, R = {}, le = {};
              G != null && Object.keys(G).forEach((de) => {
                let ge = G[de], ve = de.match(i);
                ve === null ? le[de] = ge : ve[1] != null ? R[ve[1]] = ge : ve[2] != null && (Ee[ve[2]] = ge);
              });
              let ue = {};
              H != null && H.forEach((de) => {
                let ge = t.splitAtColon(de, [de, de]);
                ue[ge[0]] = ge[1];
              });
              let Q = {};
              return I != null && I.forEach((de) => {
                let ge = t.splitAtColon(de, [de, de]);
                Q[ge[0]] = ge[1];
              }), new N({ isHost: C, type: x, isComponent: !!B, selector: L, exportAs: M, changeDetection: j, inputs: ue, outputs: Q, hostListeners: Ee, hostProperties: R, hostAttributes: le, providers: Z, viewProviders: W, queries: $, guards: te, viewQueries: U, entryComponents: ne, template: se, componentViewType: V, rendererType: oe, componentFactory: K });
            }
            constructor(g) {
              let { isHost: C, type: x, isComponent: B, selector: L, exportAs: M, changeDetection: j, inputs: H, outputs: I, hostListeners: G, hostProperties: Z, hostAttributes: W, providers: $, viewProviders: te, queries: U, guards: ne, viewQueries: se, entryComponents: V, template: oe, componentViewType: K, rendererType: Ee, componentFactory: R } = g;
              this.isHost = !!C, this.type = x, this.isComponent = B, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = H, this.outputs = I, this.hostListeners = G, this.hostProperties = Z, this.hostAttributes = W, this.providers = _($), this.viewProviders = _(te), this.queries = _(U), this.guards = ne, this.viewQueries = _(se), this.entryComponents = _(V), this.template = oe, this.componentViewType = K, this.rendererType = Ee, this.componentFactory = R;
            }
            toSummary() {
              return { summaryKind: v.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e2.CompileDirectiveMetadata = N;
          var b = class {
            constructor(g) {
              let { type: C, name: x, pure: B } = g;
              this.type = C, this.name = x, this.pure = !!B;
            }
            toSummary() {
              return { summaryKind: v.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e2.CompilePipeMetadata = b;
          var T = class {
          };
          e2.CompileShallowModuleMetadata = T;
          var S = class {
            constructor(g) {
              let { type: C, providers: x, declaredDirectives: B, exportedDirectives: L, declaredPipes: M, exportedPipes: j, entryComponents: H, bootstrapComponents: I, importedModules: G, exportedModules: Z, schemas: W, transitiveModule: $, id: te } = g;
              this.type = C || null, this.declaredDirectives = _(B), this.exportedDirectives = _(L), this.declaredPipes = _(M), this.exportedPipes = _(j), this.providers = _(x), this.entryComponents = _(H), this.bootstrapComponents = _(I), this.importedModules = _(G), this.exportedModules = _(Z), this.schemas = _(W), this.id = te || null, this.transitiveModule = $ || null;
            }
            toSummary() {
              let g = this.transitiveModule;
              return { summaryKind: v.NgModule, type: this.type, entryComponents: g.entryComponents, providers: g.providers, modules: g.modules, exportedDirectives: g.exportedDirectives, exportedPipes: g.exportedPipes };
            }
          };
          e2.CompileNgModuleMetadata = S;
          var w = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(g, C) {
              this.providers.push({ provider: g, module: C });
            }
            addDirective(g) {
              this.directivesSet.has(g.reference) || (this.directivesSet.add(g.reference), this.directives.push(g));
            }
            addExportedDirective(g) {
              this.exportedDirectivesSet.has(g.reference) || (this.exportedDirectivesSet.add(g.reference), this.exportedDirectives.push(g));
            }
            addPipe(g) {
              this.pipesSet.has(g.reference) || (this.pipesSet.add(g.reference), this.pipes.push(g));
            }
            addExportedPipe(g) {
              this.exportedPipesSet.has(g.reference) || (this.exportedPipesSet.add(g.reference), this.exportedPipes.push(g));
            }
            addModule(g) {
              this.modulesSet.has(g.reference) || (this.modulesSet.add(g.reference), this.modules.push(g));
            }
            addEntryComponent(g) {
              this.entryComponentsSet.has(g.componentType) || (this.entryComponentsSet.add(g.componentType), this.entryComponents.push(g));
            }
          };
          e2.TransitiveCompileNgModuleMetadata = w;
          function _(g) {
            return g || [];
          }
          var k = class {
            constructor(g, C) {
              let { useClass: x, useValue: B, useExisting: L, useFactory: M, deps: j, multi: H } = C;
              this.token = g, this.useClass = x || null, this.useValue = B, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!H;
            }
          };
          e2.ProviderMeta = k;
          function A(g) {
            return g.reduce((C, x) => {
              let B = Array.isArray(x) ? A(x) : x;
              return C.concat(B);
            }, []);
          }
          e2.flatten = A;
          function f(g) {
            return g.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function d(g, C, x) {
            let B;
            return x.isInline ? C.type.reference instanceof s.StaticSymbol ? B = "".concat(C.type.reference.filePath, ".").concat(C.type.reference.name, ".html") : B = "".concat(n(g), "/").concat(n(C.type), ".html") : B = x.templateUrl, C.type.reference instanceof s.StaticSymbol ? B : f(B);
          }
          e2.templateSourceUrl = d;
          function c(g, C) {
            let x = g.moduleUrl.split(/\/\\/g), B = x[x.length - 1];
            return f("css/".concat(C).concat(B, ".ngstyle.js"));
          }
          e2.sharedStylesheetJitUrl = c;
          function r(g) {
            return f("".concat(n(g.type), "/module.ngfactory.js"));
          }
          e2.ngModuleJitUrl = r;
          function y(g, C) {
            return f("".concat(n(g), "/").concat(n(C.type), ".ngfactory.js"));
          }
          e2.templateJitUrl = y;
        } }), md = ee({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e2) {
          "use strict";
          ae(), Object.defineProperty(e2, "__esModule", { value: true });
          var s = ld(), t = Dd(), i = class {
            constructor(F, h, v, p) {
              this.file = F, this.offset = h, this.line = v, this.col = p;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(F) {
              let h = this.file.content, v = h.length, p = this.offset, m = this.line, E = this.col;
              for (; p > 0 && F < 0; )
                if (p--, F++, h.charCodeAt(p) == s.$LF) {
                  m--;
                  let N = h.substr(0, p - 1).lastIndexOf(String.fromCharCode(s.$LF));
                  E = N > 0 ? p - N : p;
                } else
                  E--;
              for (; p < v && F > 0; ) {
                let P = h.charCodeAt(p);
                p++, F--, P == s.$LF ? (m++, E = 0) : E++;
              }
              return new i(this.file, p, m, E);
            }
            getContext(F, h) {
              let v = this.file.content, p = this.offset;
              if (p != null) {
                p > v.length - 1 && (p = v.length - 1);
                let m = p, E = 0, P = 0;
                for (; E < F && p > 0 && (p--, E++, !(v[p] == `
` && ++P == h)); )
                  ;
                for (E = 0, P = 0; E < F && m < v.length - 1 && (m++, E++, !(v[m] == `
` && ++P == h)); )
                  ;
                return { before: v.substring(p, this.offset), after: v.substring(this.offset, m + 1) };
              }
              return null;
            }
          };
          e2.ParseLocation = i;
          var l = class {
            constructor(F, h) {
              this.content = F, this.url = h;
            }
          };
          e2.ParseSourceFile = l;
          var u = class {
            constructor(F, h) {
              let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = F, this.end = h, this.details = v;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e2.ParseSourceSpan = u, e2.EMPTY_PARSE_LOCATION = new i(new l("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new u(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION);
          var n;
          (function(F) {
            F[F.WARNING = 0] = "WARNING", F[F.ERROR = 1] = "ERROR";
          })(n = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
          var a = class {
            constructor(F, h) {
              let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : n.ERROR;
              this.span = F, this.msg = h, this.level = v;
            }
            contextualMessage() {
              let F = this.span.start.getContext(100, 3);
              return F ? "".concat(this.msg, ' ("').concat(F.before, "[").concat(n[this.level], " ->]").concat(F.after, '")') : this.msg;
            }
            toString() {
              let F = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(F);
            }
          };
          e2.ParseError = a;
          function o(F, h) {
            let v = t.identifierModuleUrl(h), p = v != null ? "in ".concat(F, " ").concat(t.identifierName(h), " in ").concat(v) : "in ".concat(F, " ").concat(t.identifierName(h)), m = new l("", p);
            return new u(new i(m, -1, -1, -1), new i(m, -1, -1, -1));
          }
          e2.typeSourceSpan = o;
          function D(F, h, v) {
            let p = "in ".concat(F, " ").concat(h, " in ").concat(v), m = new l("", p);
            return new u(new i(m, -1, -1, -1), new i(m, -1, -1, -1));
          }
          e2.r3JitTypeSourceSpan = D;
        } }), dd = ee({ "src/language-html/print-preprocess.js"(e2, s) {
          "use strict";
          ae();
          var { ParseSourceSpan: t } = md(), { htmlTrim: i, getLeadingAndTrailingHtmlWhitespace: l, hasHtmlWhitespace: u, canHaveInterpolation: n, getNodeCssStyleDisplay: a, isDanglingSpaceSensitiveNode: o, isIndentationSensitiveNode: D, isLeadingSpaceSensitiveNode: F, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: v } = kt(), p = [E, P, b, S, w, A, _, k, f, T];
          function m(d, c) {
            for (let r of p)
              r(d, c);
            return d;
          }
          function E(d) {
            d.walk((c) => {
              if (c.type === "element" && c.tagDefinition.ignoreFirstLf && c.children.length > 0 && c.children[0].type === "text" && c.children[0].value[0] === `
`) {
                let r = c.children[0];
                r.value.length === 1 ? c.removeChild(r) : r.value = r.value.slice(1);
              }
            });
          }
          function P(d) {
            let c = (r) => r.type === "element" && r.prev && r.prev.type === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && r.firstChild && r.firstChild.type === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
            d.walk((r) => {
              if (r.children)
                for (let y = 0; y < r.children.length; y++) {
                  let g = r.children[y];
                  if (!c(g))
                    continue;
                  let C = g.prev, x = g.firstChild;
                  r.removeChild(C), y--;
                  let B = new t(C.sourceSpan.start, x.sourceSpan.end), L = new t(B.start, g.sourceSpan.end);
                  g.condition = C.condition, g.sourceSpan = L, g.startSourceSpan = B, g.removeChild(x);
                }
            });
          }
          function N(d, c, r) {
            d.walk((y) => {
              if (y.children)
                for (let g = 0; g < y.children.length; g++) {
                  let C = y.children[g];
                  if (C.type !== "text" && !c(C))
                    continue;
                  C.type !== "text" && (C.type = "text", C.value = r(C));
                  let x = C.prev;
                  !x || x.type !== "text" || (x.value += C.value, x.sourceSpan = new t(x.sourceSpan.start, C.sourceSpan.end), y.removeChild(C), g--);
                }
            });
          }
          function b(d) {
            return N(d, (c) => c.type === "cdata", (c) => "<![CDATA[".concat(c.value, "]]>"));
          }
          function T(d) {
            let c = (r) => r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !u(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && r.prev && r.prev.type === "text" && r.next && r.next.type === "text";
            d.walk((r) => {
              if (r.children)
                for (let y = 0; y < r.children.length; y++) {
                  let g = r.children[y];
                  if (!c(g))
                    continue;
                  let C = g.prev, x = g.next;
                  C.value += "<".concat(g.rawName, ">") + g.firstChild.value + "</".concat(g.rawName, ">") + x.value, C.sourceSpan = new t(C.sourceSpan.start, x.sourceSpan.end), C.isTrailingSpaceSensitive = x.isTrailingSpaceSensitive, C.hasTrailingSpaces = x.hasTrailingSpaces, r.removeChild(g), y--, r.removeChild(x);
                }
            });
          }
          function S(d, c) {
            if (c.parser === "html")
              return;
            let r = /{{(.+?)}}/s;
            d.walk((y) => {
              if (!!n(y))
                for (let g of y.children) {
                  if (g.type !== "text")
                    continue;
                  let C = g.sourceSpan.start, x = null, B = g.value.split(r);
                  for (let L = 0; L < B.length; L++, C = x) {
                    let M = B[L];
                    if (L % 2 === 0) {
                      x = C.moveBy(M.length), M.length > 0 && y.insertChildBefore(g, { type: "text", value: M, sourceSpan: new t(C, x) });
                      continue;
                    }
                    x = C.moveBy(M.length + 4), y.insertChildBefore(g, { type: "interpolation", sourceSpan: new t(C, x), children: M.length === 0 ? [] : [{ type: "text", value: M, sourceSpan: new t(C.moveBy(2), x.moveBy(-2)) }] });
                  }
                  y.removeChild(g);
                }
            });
          }
          function w(d) {
            d.walk((c) => {
              if (!c.children)
                return;
              if (c.children.length === 0 || c.children.length === 1 && c.children[0].type === "text" && i(c.children[0].value).length === 0) {
                c.hasDanglingSpaces = c.children.length > 0, c.children = [];
                return;
              }
              let r = v(c), y = D(c);
              if (!r)
                for (let g = 0; g < c.children.length; g++) {
                  let C = c.children[g];
                  if (C.type !== "text")
                    continue;
                  let { leadingWhitespace: x, text: B, trailingWhitespace: L } = l(C.value), M = C.prev, j = C.next;
                  B ? (C.value = B, C.sourceSpan = new t(C.sourceSpan.start.moveBy(x.length), C.sourceSpan.end.moveBy(-L.length)), x && (M && (M.hasTrailingSpaces = true), C.hasLeadingSpaces = true), L && (C.hasTrailingSpaces = true, j && (j.hasLeadingSpaces = true))) : (c.removeChild(C), g--, (x || L) && (M && (M.hasTrailingSpaces = true), j && (j.hasLeadingSpaces = true)));
                }
              c.isWhitespaceSensitive = r, c.isIndentationSensitive = y;
            });
          }
          function _(d) {
            d.walk((c) => {
              c.isSelfClosing = !c.children || c.type === "element" && (c.tagDefinition.isVoid || c.startSourceSpan === c.endSourceSpan);
            });
          }
          function k(d, c) {
            d.walk((r) => {
              r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(c.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
            });
          }
          function A(d, c) {
            d.walk((r) => {
              r.cssDisplay = a(r, c);
            });
          }
          function f(d, c) {
            d.walk((r) => {
              let { children: y } = r;
              if (!!y) {
                if (y.length === 0) {
                  r.isDanglingSpaceSensitive = o(r);
                  return;
                }
                for (let g of y)
                  g.isLeadingSpaceSensitive = F(g, c), g.isTrailingSpaceSensitive = h(g, c);
                for (let g = 0; g < y.length; g++) {
                  let C = y[g];
                  C.isLeadingSpaceSensitive = (g === 0 || C.prev.isTrailingSpaceSensitive) && C.isLeadingSpaceSensitive, C.isTrailingSpaceSensitive = (g === y.length - 1 || C.next.isLeadingSpaceSensitive) && C.isTrailingSpaceSensitive;
                }
              }
            });
          }
          s.exports = m;
        } }), gd = ee({ "src/language-html/pragma.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(l);
          }
          function i(l) {
            return `<!-- @format -->

` + l.replace(/^\s*\n/, "");
          }
          s.exports = { hasPragma: t, insertPragma: i };
        } }), Hn = ee({ "src/language-html/loc.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return l.sourceSpan.start.offset;
          }
          function i(l) {
            return l.sourceSpan.end.offset;
          }
          s.exports = { locStart: t, locEnd: i };
        } }), Xt = ee({ "src/language-html/print/tag.js"(e2, s) {
          "use strict";
          ae();
          var t = Ht(), { isNonEmptyArray: i } = Ge(), { builders: { indent: l, join: u, line: n, softline: a, hardline: o }, utils: { replaceTextEndOfLine: D } } = Le(), { locStart: F, locEnd: h } = Hn(), { isTextLikeNode: v, getLastDescendant: p, isPreLikeNode: m, hasPrettierIgnore: E, shouldPreserveContent: P } = kt();
          function N(I, G) {
            return [I.isSelfClosing ? "" : b(I, G), T(I, G)];
          }
          function b(I, G) {
            return I.lastChild && c(I.lastChild) ? "" : [S(I, G), _(I, G)];
          }
          function T(I, G) {
            return (I.next ? f(I.next) : d(I.parent)) ? "" : [k(I, G), w(I, G)];
          }
          function S(I, G) {
            return d(I) ? k(I.lastChild, G) : "";
          }
          function w(I, G) {
            return c(I) ? _(I.parent, G) : r(I) ? j(I.next) : "";
          }
          function _(I, G) {
            if (t(!I.isSelfClosing), A(I, G))
              return "";
            switch (I.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (I.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return "</".concat(I.rawName);
            }
          }
          function k(I, G) {
            if (A(I, G))
              return "";
            switch (I.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (I.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function A(I, G) {
            return !I.isSelfClosing && !I.endSourceSpan && (E(I) || P(I.parent, G));
          }
          function f(I) {
            return I.prev && I.prev.type !== "docType" && !v(I.prev) && I.isLeadingSpaceSensitive && !I.hasLeadingSpaces;
          }
          function d(I) {
            return I.lastChild && I.lastChild.isTrailingSpaceSensitive && !I.lastChild.hasTrailingSpaces && !v(p(I.lastChild)) && !m(I);
          }
          function c(I) {
            return !I.next && !I.hasTrailingSpaces && I.isTrailingSpaceSensitive && v(p(I));
          }
          function r(I) {
            return I.next && !v(I.next) && v(I) && I.isTrailingSpaceSensitive && !I.hasTrailingSpaces;
          }
          function y(I) {
            let G = I.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return G ? G[1] ? G[1].split(/\s+/) : true : false;
          }
          function g(I) {
            return !I.prev && I.isLeadingSpaceSensitive && !I.hasLeadingSpaces;
          }
          function C(I, G, Z) {
            let W = I.getValue();
            if (!i(W.attrs))
              return W.isSelfClosing ? " " : "";
            let $ = W.prev && W.prev.type === "comment" && y(W.prev.value), te = typeof $ == "boolean" ? () => $ : Array.isArray($) ? (oe) => $.includes(oe.rawName) : () => false, U = I.map((oe) => {
              let K = oe.getValue();
              return te(K) ? D(G.originalText.slice(F(K), h(K))) : Z();
            }, "attrs"), ne = W.type === "element" && W.fullName === "script" && W.attrs.length === 1 && W.attrs[0].fullName === "src" && W.children.length === 0, se = G.singleAttributePerLine && W.attrs.length > 1 ? o : n, V = [l([ne ? " " : n, u(se, U)])];
            return W.firstChild && g(W.firstChild) || W.isSelfClosing && d(W.parent) || ne ? V.push(W.isSelfClosing ? " " : "") : V.push(G.bracketSameLine ? W.isSelfClosing ? " " : "" : W.isSelfClosing ? n : a), V;
          }
          function x(I) {
            return I.firstChild && g(I.firstChild) ? "" : H(I);
          }
          function B(I, G, Z) {
            let W = I.getValue();
            return [L(W, G), C(I, G, Z), W.isSelfClosing ? "" : x(W)];
          }
          function L(I, G) {
            return I.prev && r(I.prev) ? "" : [M(I, G), j(I)];
          }
          function M(I, G) {
            return g(I) ? H(I.parent) : f(I) ? k(I.prev, G) : "";
          }
          function j(I) {
            switch (I.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return "<!--[if ".concat(I.condition);
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (I.condition)
                  return "<!--[if ".concat(I.condition, "]><!--><").concat(I.rawName);
              default:
                return "<".concat(I.rawName);
            }
          }
          function H(I) {
            switch (t(!I.isSelfClosing), I.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (I.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          s.exports = { printClosingTag: N, printClosingTagStart: b, printClosingTagStartMarker: _, printClosingTagEndMarker: k, printClosingTagSuffix: w, printClosingTagEnd: T, needsToBorrowLastChildClosingTagEndMarker: d, needsToBorrowParentClosingTagStartMarker: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTag: B, printOpeningTagStart: L, printOpeningTagPrefix: M, printOpeningTagStartMarker: j, printOpeningTagEndMarker: H, needsToBorrowNextOpeningTagStartMarker: r, needsToBorrowParentOpeningTagEndMarker: g };
        } }), yd = ee({ "node_modules/parse-srcset/src/parse-srcset.js"(e2, s) {
          ae(), function(t, i) {
            typeof define == "function" && define.amd ? define([], i) : typeof s == "object" && s.exports ? s.exports = i() : t.parseSrcset = i();
          }(e2, function() {
            return function(t, i) {
              var l = i && i.logger || console;
              function u(k) {
                return k === " " || k === "	" || k === `
` || k === "\f" || k === "\r";
              }
              function n(k) {
                var A, f = k.exec(t.substring(T));
                if (f)
                  return A = f[0], T += A.length, A;
              }
              for (var a = t.length, o = /^[ \t\n\r\u000c]+/, D = /^[, \t\n\r\u000c]+/, F = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, v = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, m, E, P, N, b, T = 0, S = []; ; ) {
                if (n(D), T >= a)
                  return S;
                m = n(F), E = [], m.slice(-1) === "," ? (m = m.replace(h, ""), _()) : w();
              }
              function w() {
                for (n(o), P = "", N = "in descriptor"; ; ) {
                  if (b = t.charAt(T), N === "in descriptor")
                    if (u(b))
                      P && (E.push(P), P = "", N = "after descriptor");
                    else if (b === ",") {
                      T += 1, P && E.push(P), _();
                      return;
                    } else if (b === "(")
                      P = P + b, N = "in parens";
                    else if (b === "") {
                      P && E.push(P), _();
                      return;
                    } else
                      P = P + b;
                  else if (N === "in parens")
                    if (b === ")")
                      P = P + b, N = "in descriptor";
                    else if (b === "") {
                      E.push(P), _();
                      return;
                    } else
                      P = P + b;
                  else if (N === "after descriptor" && !u(b))
                    if (b === "") {
                      _();
                      return;
                    } else
                      N = "in descriptor", T -= 1;
                  T += 1;
                }
              }
              function _() {
                var k = false, A, f, d, c, r = {}, y, g, C, x, B;
                for (c = 0; c < E.length; c++)
                  y = E[c], g = y[y.length - 1], C = y.substring(0, y.length - 1), x = parseInt(C, 10), B = parseFloat(C), v.test(C) && g === "w" ? ((A || f) && (k = true), x === 0 ? k = true : A = x) : p.test(C) && g === "x" ? ((A || f || d) && (k = true), B < 0 ? k = true : f = B) : v.test(C) && g === "h" ? ((d || f) && (k = true), x === 0 ? k = true : d = x) : k = true;
                k ? l && l.error && l.error("Invalid srcset descriptor found in '" + t + "' at '" + y + "'.") : (r.url = m, A && (r.w = A), f && (r.d = f), d && (r.h = d), S.push(r));
              }
            };
          });
        } }), hd = ee({ "src/language-html/syntax-attribute.js"(e2, s) {
          "use strict";
          ae();
          var t = yd(), { builders: { ifBreak: i, join: l, line: u } } = Le();
          function n(o) {
            let D = t(o, { logger: { error(w) {
              throw new Error(w);
            } } }), F = D.some((w) => {
              let { w: _ } = w;
              return _;
            }), h = D.some((w) => {
              let { h: _ } = w;
              return _;
            }), v = D.some((w) => {
              let { d: _ } = w;
              return _;
            });
            if (F + h + v > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let p = F ? "w" : h ? "h" : "d", m = F ? "w" : h ? "h" : "x", E = (w) => Math.max(...w), P = D.map((w) => w.url), N = E(P.map((w) => w.length)), b = D.map((w) => w[p]).map((w) => w ? w.toString() : ""), T = b.map((w) => {
              let _ = w.indexOf(".");
              return _ === -1 ? w.length : _;
            }), S = E(T);
            return l([",", u], P.map((w, _) => {
              let k = [w], A = b[_];
              if (A) {
                let f = N - w.length + 1, d = S - T[_], c = " ".repeat(f + d);
                k.push(i(c, " "), A + m);
              }
              return k;
            }));
          }
          function a(o) {
            return o.trim().split(/\s+/).join(" ");
          }
          s.exports = { printImgSrcset: n, printClassNames: a };
        } }), Cd = ee({ "src/language-html/syntax-vue.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { group: t } } = Le();
          function i(a, o) {
            let { left: D, operator: F, right: h } = l(a);
            return [t(o("function _(".concat(D, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", F, " ", o(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function l(a) {
            let o = /(.*?)\s+(in|of)\s+(.*)/s, D = /,([^,\]}]*)(?:,([^,\]}]*))?$/, F = /^\(|\)$/g, h = a.match(o);
            if (!h)
              return;
            let v = {};
            if (v.for = h[3].trim(), !v.for)
              return;
            let p = h[1].trim().replace(F, ""), m = p.match(D);
            m ? (v.alias = p.replace(D, ""), v.iterator1 = m[1].trim(), m[2] && (v.iterator2 = m[2].trim())) : v.alias = p;
            let E = [v.alias, v.iterator1, v.iterator2];
            if (!E.some((P, N) => !P && (N === 0 || E.slice(N + 1).some(Boolean))))
              return { left: E.filter(Boolean).join(","), operator: h[2], right: v.for };
          }
          function u(a, o) {
            return o("function _(".concat(a, ") {}"), { parser: "babel", __isVueBindings: true });
          }
          function n(a) {
            let o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, D = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, F = a.trim();
            return o.test(F) || D.test(F);
          }
          s.exports = { isVueEventBindingExpression: n, printVueFor: i, printVueBindings: u };
        } }), co = ee({ "src/language-html/get-node-content.js"(e2, s) {
          "use strict";
          ae();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: i, needsToBorrowLastChildClosingTagEndMarker: l, printClosingTagEndMarker: u, needsToBorrowParentOpeningTagEndMarker: n, printOpeningTagEndMarker: a } = Xt();
          function o(D, F) {
            let h = D.startSourceSpan.end.offset;
            D.firstChild && n(D.firstChild) && (h -= a(D).length);
            let v = D.endSourceSpan.start.offset;
            return D.lastChild && t(D.lastChild) ? v += i(D, F).length : l(D) && (v -= u(D.lastChild, F).length), F.originalText.slice(h, v);
          }
          s.exports = o;
        } }), Ed = ee({ "src/language-html/embed.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { breakParent: t, group: i, hardline: l, indent: u, line: n, fill: a, softline: o }, utils: { mapDoc: D, replaceTextEndOfLine: F } } = Le(), h = Wn(), { printClosingTag: v, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTagPrefix: E, printOpeningTag: P } = Xt(), { printImgSrcset: N, printClassNames: b } = hd(), { printVueFor: T, printVueBindings: S, isVueEventBindingExpression: w } = Cd(), { isScriptLikeTag: _, isVueNonHtmlBlock: k, inferScriptParser: A, htmlTrimPreserveIndentation: f, dedentString: d, unescapeQuoteEntities: c, isVueSlotAttribute: r, isVueSfcBindingsAttribute: y, getTextValueParts: g } = kt(), C = co();
          function x(L, M, j) {
            let H = (ne) => new RegExp(ne.join("|")).test(L.fullName), I = () => c(L.value), G = false, Z = (ne, se) => {
              let V = ne.type === "NGRoot" ? ne.node.type === "NGMicrosyntax" && ne.node.body.length === 1 && ne.node.body[0].type === "NGMicrosyntaxExpression" ? ne.node.body[0].expression : ne.node : ne.type === "JsExpressionRoot" ? ne.node : ne;
              V && (V.type === "ObjectExpression" || V.type === "ArrayExpression" || se.parser === "__vue_expression" && (V.type === "TemplateLiteral" || V.type === "StringLiteral")) && (G = true);
            }, W = (ne) => i(ne), $ = function(ne) {
              let se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return i([u([o, ne]), se ? o : ""]);
            }, te = (ne) => G ? W(ne) : $(ne), U = (ne, se) => M(ne, Object.assign({ __onHtmlBindingRoot: Z, __embeddedInHtml: true }, se));
            if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source"))
              return $(N(I()));
            if (L.fullName === "class" && !j.parentParser) {
              let ne = I();
              if (!ne.includes("{{"))
                return b(ne);
            }
            if (L.fullName === "style" && !j.parentParser) {
              let ne = I();
              if (!ne.includes("{{"))
                return $(U(ne, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (j.parser === "vue") {
              if (L.fullName === "v-for")
                return T(I(), U);
              if (r(L) || y(L, j))
                return S(I(), U);
              let ne = ["^@", "^v-on:"], se = ["^:", "^v-bind:"], V = ["^v-"];
              if (H(ne)) {
                let oe = I();
                return te(U(oe, { parser: w(oe) ? "__js_expression" : "__vue_event_binding" }));
              }
              if (H(se))
                return te(U(I(), { parser: "__vue_expression" }));
              if (H(V))
                return te(U(I(), { parser: "__js_expression" }));
            }
            if (j.parser === "angular") {
              let ne = (le, ue) => U(le, Object.assign(Object.assign({}, ue), {}, { trailingComma: "none" })), se = ["^\\*"], V = ["^\\(.+\\)$", "^on-"], oe = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], K = ["^i18n(-.+)?$"];
              if (H(V))
                return te(ne(I(), { parser: "__ng_action" }));
              if (H(oe))
                return te(ne(I(), { parser: "__ng_binding" }));
              if (H(K)) {
                let le = I().trim();
                return $(a(g(L, le)), !le.includes("@@"));
              }
              if (H(se))
                return te(ne(I(), { parser: "__ng_directive" }));
              let Ee = /{{(.+?)}}/s, R = I();
              if (Ee.test(R)) {
                let le = [];
                for (let [ue, Q] of R.split(Ee).entries())
                  if (ue % 2 === 0)
                    le.push(F(Q));
                  else
                    try {
                      le.push(i(["{{", u([n, ne(Q, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), n, "}}"]));
                    } catch {
                      le.push("{{", F(Q), "}}");
                    }
                return i(le);
              }
            }
            return null;
          }
          function B(L, M, j, H) {
            let I = L.getValue();
            switch (I.type) {
              case "element": {
                if (_(I) || I.type === "interpolation")
                  return;
                if (!I.isSelfClosing && k(I, H)) {
                  let G = A(I, H);
                  if (!G)
                    return;
                  let Z = C(I, H), W = /^\s*$/.test(Z), $ = "";
                  return W || ($ = j(f(Z), { parser: G, __embeddedInHtml: true }, { stripTrailingHardline: true }), W = $ === ""), [E(I, H), i(P(L, H, M)), W ? "" : l, $, W ? "" : l, v(I, H), p(I, H)];
                }
                break;
              }
              case "text": {
                if (_(I.parent)) {
                  let G = A(I.parent);
                  if (G) {
                    let Z = G === "markdown" ? d(I.value.replace(/^[^\S\n]*\n/, "")) : I.value, W = { parser: G, __embeddedInHtml: true };
                    if (H.parser === "html" && G === "babel") {
                      let $ = "script", { attrMap: te } = I.parent;
                      te && (te.type === "module" || te.type === "text/babel" && te["data-type"] === "module") && ($ = "module"), W.__babelSourceType = $;
                    }
                    return [t, E(I, H), j(Z, W, { stripTrailingHardline: true }), p(I, H)];
                  }
                } else if (I.parent.type === "interpolation") {
                  let G = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return H.parser === "angular" ? (G.parser = "__ng_interpolation", G.trailingComma = "none") : H.parser === "vue" ? G.parser = "__vue_expression" : G.parser = "__js_expression", [u([n, j(I.value, G, { stripTrailingHardline: true })]), I.parent.next && m(I.parent.next) ? " " : n];
                }
                break;
              }
              case "attribute": {
                if (!I.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(H.originalText.slice(I.valueSpan.start.offset, I.valueSpan.end.offset)))
                  return [I.rawName, "=", I.value];
                if (H.parser === "lwc" && /^{.*}$/s.test(H.originalText.slice(I.valueSpan.start.offset, I.valueSpan.end.offset)))
                  return [I.rawName, "=", I.value];
                let G = x(I, (Z, W) => j(Z, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, W), { stripTrailingHardline: true }), H);
                if (G)
                  return [I.rawName, '="', i(D(G, (Z) => typeof Z == "string" ? Z.replace(/"/g, "&quot;") : Z)), '"'];
                break;
              }
              case "front-matter":
                return h(I, j);
            }
          }
          s.exports = B;
        } }), lo = ee({ "src/language-html/print/children.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { breakParent: t, group: i, ifBreak: l, line: u, softline: n, hardline: a }, utils: { replaceTextEndOfLine: o } } = Le(), { locStart: D, locEnd: F } = Hn(), { forceBreakChildren: h, forceNextEmptyLine: v, isTextLikeNode: p, hasPrettierIgnore: m, preferHardlineAsLeadingSpaces: E } = kt(), { printOpeningTagPrefix: P, needsToBorrowNextOpeningTagStartMarker: N, printOpeningTagStartMarker: b, needsToBorrowPrevClosingTagEndMarker: T, printClosingTagEndMarker: S, printClosingTagSuffix: w, needsToBorrowParentClosingTagStartMarker: _ } = Xt();
          function k(d, c, r) {
            let y = d.getValue();
            return m(y) ? [P(y, c), ...o(c.originalText.slice(D(y) + (y.prev && N(y.prev) ? b(y).length : 0), F(y) - (y.next && T(y.next) ? S(y, c).length : 0))), w(y, c)] : r();
          }
          function A(d, c) {
            return p(d) && p(c) ? d.isTrailingSpaceSensitive ? d.hasTrailingSpaces ? E(c) ? a : u : "" : E(c) ? a : n : N(d) && (m(c) || c.firstChild || c.isSelfClosing || c.type === "element" && c.attrs.length > 0) || d.type === "element" && d.isSelfClosing && T(c) ? "" : !c.isLeadingSpaceSensitive || E(c) || T(c) && d.lastChild && _(d.lastChild) && d.lastChild.lastChild && _(d.lastChild.lastChild) ? a : c.hasLeadingSpaces ? u : n;
          }
          function f(d, c, r) {
            let y = d.getValue();
            if (h(y))
              return [t, ...d.map((C) => {
                let x = C.getValue(), B = x.prev ? A(x.prev, x) : "";
                return [B ? [B, v(x.prev) ? a : ""] : "", k(C, c, r)];
              }, "children")];
            let g = y.children.map(() => Symbol(""));
            return d.map((C, x) => {
              let B = C.getValue();
              if (p(B)) {
                if (B.prev && p(B.prev)) {
                  let Z = A(B.prev, B);
                  if (Z)
                    return v(B.prev) ? [a, a, k(C, c, r)] : [Z, k(C, c, r)];
                }
                return k(C, c, r);
              }
              let L = [], M = [], j = [], H = [], I = B.prev ? A(B.prev, B) : "", G = B.next ? A(B, B.next) : "";
              return I && (v(B.prev) ? L.push(a, a) : I === a ? L.push(a) : p(B.prev) ? M.push(I) : M.push(l("", n, { groupId: g[x - 1] }))), G && (v(B) ? p(B.next) && H.push(a, a) : G === a ? p(B.next) && H.push(a) : j.push(G)), [...L, i([...M, i([k(C, c, r), ...j], { id: g[x] })]), ...H];
            }, "children");
          }
          s.exports = { printChildren: f };
        } }), vd = ee({ "src/language-html/print/element.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { breakParent: t, dedentToRoot: i, group: l, ifBreak: u, indentIfBreak: n, indent: a, line: o, softline: D }, utils: { replaceTextEndOfLine: F } } = Le(), h = co(), { shouldPreserveContent: v, isScriptLikeTag: p, isVueCustomBlock: m, countParents: E, forceBreakContent: P } = kt(), { printOpeningTagPrefix: N, printOpeningTag: b, printClosingTagSuffix: T, printClosingTag: S, needsToBorrowPrevClosingTagEndMarker: w, needsToBorrowLastChildClosingTagEndMarker: _ } = Xt(), { printChildren: k } = lo();
          function A(f, d, c) {
            let r = f.getValue();
            if (v(r, d))
              return [N(r, d), l(b(f, d, c)), ...F(h(r, d)), ...S(r, d), T(r, d)];
            let y = r.children.length === 1 && r.firstChild.type === "interpolation" && r.firstChild.isLeadingSpaceSensitive && !r.firstChild.hasLeadingSpaces && r.lastChild.isTrailingSpaceSensitive && !r.lastChild.hasTrailingSpaces, g = Symbol("element-attr-group-id"), C = (M) => l([l(b(f, d, c), { id: g }), M, S(r, d)]), x = (M) => y ? n(M, { groupId: g }) : (p(r) || m(r, d)) && r.parent.type === "root" && d.parser === "vue" && !d.vueIndentScriptAndStyle ? M : a(M), B = () => y ? u(D, "", { groupId: g }) : r.firstChild.hasLeadingSpaces && r.firstChild.isLeadingSpaceSensitive ? o : r.firstChild.type === "text" && r.isWhitespaceSensitive && r.isIndentationSensitive ? i(D) : D, L = () => (r.next ? w(r.next) : _(r.parent)) ? r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? " " : "" : y ? u(D, "", { groupId: g }) : r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? o : (r.lastChild.type === "comment" || r.lastChild.type === "text" && r.isWhitespaceSensitive && r.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(d.tabWidth * E(f, (j) => j.parent && j.parent.type !== "root"), "}$")).test(r.lastChild.value) ? "" : D;
            return r.children.length === 0 ? C(r.hasDanglingSpaces && r.isDanglingSpaceSensitive ? o : "") : C([P(r) ? t : "", x([B(), k(f, d, c)]), L()]);
          }
          s.exports = { printElement: A };
        } }), Fd = ee({ "src/language-html/printer-html.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { fill: t, group: i, hardline: l, literalline: u }, utils: { cleanDoc: n, getDocParts: a, isConcat: o, replaceTextEndOfLine: D } } = Le(), F = id(), { countChars: h, unescapeQuoteEntities: v, getTextValueParts: p } = kt(), m = dd(), { insertPragma: E } = gd(), { locStart: P, locEnd: N } = Hn(), b = Ed(), { printClosingTagSuffix: T, printClosingTagEnd: S, printOpeningTagPrefix: w, printOpeningTagStart: _ } = Xt(), { printElement: k } = vd(), { printChildren: A } = lo();
          function f(d, c, r) {
            let y = d.getValue();
            switch (y.type) {
              case "front-matter":
                return D(y.raw);
              case "root":
                return c.__onHtmlRoot && c.__onHtmlRoot(y), [i(A(d, c, r)), l];
              case "element":
              case "ieConditionalComment":
                return k(d, c, r);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [_(y), S(y)];
              case "interpolation":
                return [_(y, c), ...d.map(r, "children"), S(y, c)];
              case "text": {
                if (y.parent.type === "interpolation") {
                  let C = /\n[^\S\n]*$/, x = C.test(y.value), B = x ? y.value.replace(C, "") : y.value;
                  return [...D(B), x ? l : ""];
                }
                let g = n([w(y, c), ...p(y), T(y, c)]);
                return o(g) || g.type === "fill" ? t(a(g)) : g;
              }
              case "docType":
                return [i([_(y, c), " ", y.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), S(y, c)];
              case "comment":
                return [w(y, c), ...D(c.originalText.slice(P(y), N(y)), u), T(y, c)];
              case "attribute": {
                if (y.value === null)
                  return y.rawName;
                let g = v(y.value), C = h(g, "'"), x = h(g, '"'), B = C < x ? "'" : '"';
                return [y.rawName, "=", B, ...D(B === '"' ? g.replace(/"/g, "&quot;") : g.replace(/'/g, "&apos;")), B];
              }
              default:
                throw new Error("Unexpected node type ".concat(y.type));
            }
          }
          s.exports = { preprocess: m, print: f, insertPragma: E, massageAstNode: F, embed: b };
        } }), Ad = ee({ "src/language-html/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It(), i = "HTML";
          s.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: i, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: i, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), Sd = ee({ "src/language-html/parsers.js"() {
          ae();
        } }), yn = ee({ "node_modules/linguist-languages/data/HTML.json"(e2, s) {
          s.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), bd = ee({ "node_modules/linguist-languages/data/Vue.json"(e2, s) {
          s.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), xd = ee({ "src/language-html/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = Fd(), l = Ad(), u = Sd(), n = [t(yn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(yn(), (o) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...o.extensions, ".mjml"] })), t(yn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(bd(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], a = { html: i };
          s.exports = { languages: n, printers: a, options: l, parsers: u };
        } }), Td = ee({ "src/language-yaml/pragma.js"(e2, s) {
          "use strict";
          ae();
          function t(u) {
            return /^\s*@(?:prettier|format)\s*$/.test(u);
          }
          function i(u) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(u);
          }
          function l(u) {
            return `# @format

`.concat(u);
          }
          s.exports = { isPragma: t, hasPragma: i, insertPragma: l };
        } }), Bd = ee({ "src/language-yaml/loc.js"(e2, s) {
          "use strict";
          ae();
          function t(l) {
            return l.position.start.offset;
          }
          function i(l) {
            return l.position.end.offset;
          }
          s.exports = { locStart: t, locEnd: i };
        } }), Nd = ee({ "src/language-yaml/embed.js"(e2, s) {
          "use strict";
          ae();
          function t(i, l, u, n) {
            if (i.getValue().type === "root" && n.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(n.filepath))
              return u(n.originalText, Object.assign(Object.assign({}, n), {}, { parser: "json" }));
          }
          s.exports = t;
        } }), Lt = ee({ "src/language-yaml/utils.js"(e2, s) {
          "use strict";
          ae();
          var { getLast: t, isNonEmptyArray: i } = Ge();
          function l(A, f) {
            let d = 0, c = A.stack.length - 1;
            for (let r = 0; r < c; r++) {
              let y = A.stack[r];
              u(y) && f(y) && d++;
            }
            return d;
          }
          function u(A, f) {
            return A && typeof A.type == "string" && (!f || f.includes(A.type));
          }
          function n(A, f, d) {
            return f("children" in A ? Object.assign(Object.assign({}, A), {}, { children: A.children.map((c) => n(c, f, A)) }) : A, d);
          }
          function a(A, f, d) {
            Object.defineProperty(A, f, { get: d, enumerable: false });
          }
          function o(A, f) {
            let d = 0, c = f.length;
            for (let r = A.position.end.offset - 1; r < c; r++) {
              let y = f[r];
              if (y === `
` && d++, d === 1 && /\S/.test(y))
                return false;
              if (d === 2)
                return true;
            }
            return false;
          }
          function D(A) {
            switch (A.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let d = A.stack.length;
            for (let c = 1; c < d; c++) {
              let r = A.stack[c], y = A.stack[c - 1];
              if (Array.isArray(y) && typeof r == "number" && r !== y.length - 1)
                return false;
            }
            return true;
          }
          function F(A) {
            return i(A.children) ? F(t(A.children)) : A;
          }
          function h(A) {
            return A.value.trim() === "prettier-ignore";
          }
          function v(A) {
            let f = A.getValue();
            if (f.type === "documentBody") {
              let d = A.getParentNode();
              return T(d.head) && h(t(d.head.endComments));
            }
            return E(f) && h(t(f.leadingComments));
          }
          function p(A) {
            return !i(A.children) && !m(A);
          }
          function m(A) {
            return E(A) || P(A) || N(A) || b(A) || T(A);
          }
          function E(A) {
            return A && i(A.leadingComments);
          }
          function P(A) {
            return A && i(A.middleComments);
          }
          function N(A) {
            return A && A.indicatorComment;
          }
          function b(A) {
            return A && A.trailingComment;
          }
          function T(A) {
            return A && i(A.endComments);
          }
          function S(A) {
            let f = [], d;
            for (let c of A.split(/( +)/))
              c !== " " ? d === " " ? f.push(c) : f.push((f.pop() || "") + c) : d === void 0 && f.unshift(""), d = c;
            return d === " " && f.push((f.pop() || "") + " "), f[0] === "" && (f.shift(), f.unshift(" " + (f.shift() || ""))), f;
          }
          function w(A, f, d) {
            let c = f.split(`
`).map((r, y, g) => y === 0 && y === g.length - 1 ? r : y !== 0 && y !== g.length - 1 ? r.trim() : y === 0 ? r.trimEnd() : r.trimStart());
            return d.proseWrap === "preserve" ? c.map((r) => r.length === 0 ? [] : [r]) : c.map((r) => r.length === 0 ? [] : S(r)).reduce((r, y, g) => g !== 0 && c[g - 1].length > 0 && y.length > 0 && !(A === "quoteDouble" && t(t(r)).endsWith("\\")) ? [...r.slice(0, -1), [...t(r), ...y]] : [...r, y], []).map((r) => d.proseWrap === "never" ? [r.join(" ")] : r);
          }
          function _(A, f) {
            let { parentIndent: d, isLastDescendant: c, options: r } = f, y = A.position.start.line === A.position.end.line ? "" : r.originalText.slice(A.position.start.offset, A.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], g;
            if (A.indent === null) {
              let B = y.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              g = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              g = A.indent - 1 + d;
            let C = y.split(`
`).map((B) => B.slice(g));
            if (r.proseWrap === "preserve" || A.type === "blockLiteral")
              return x(C.map((B) => B.length === 0 ? [] : [B]));
            return x(C.map((B) => B.length === 0 ? [] : S(B)).reduce((B, L, M) => M !== 0 && C[M - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...L]] : [...B, L], []).map((B) => B.reduce((L, M) => L.length > 0 && /\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + " " + M] : [...L, M], [])).map((B) => r.proseWrap === "never" ? [B.join(" ")] : B));
            function x(B) {
              if (A.chomping === "keep")
                return t(B).length === 0 ? B.slice(0, -1) : B;
              let L = 0;
              for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                L++;
              return L === 0 ? B : L >= 2 && !c ? B.slice(0, -(L - 1)) : B.slice(0, -L);
            }
          }
          function k(A) {
            if (!A)
              return true;
            switch (A.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          s.exports = { getLast: t, getAncestorCount: l, isNode: u, isEmptyNode: p, isInlineNode: k, mapNode: n, defineShortcut: a, isNextLineEmpty: o, isLastDescendantNode: D, getBlockValueLineContents: _, getFlowScalarLineContents: w, getLastDescendantNode: F, hasPrettierIgnore: v, hasLeadingComments: E, hasMiddleComments: P, hasIndicatorComment: N, hasTrailingComment: b, hasEndComments: T };
        } }), wd = ee({ "src/language-yaml/print-preprocess.js"(e2, s) {
          "use strict";
          ae();
          var { defineShortcut: t, mapNode: i } = Lt();
          function l(n) {
            return i(n, u);
          }
          function u(n) {
            switch (n.type) {
              case "document":
                t(n, "head", () => n.children[0]), t(n, "body", () => n.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(n, "content", () => n.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(n, "key", () => n.children[0]), t(n, "value", () => n.children[1]);
                break;
            }
            return n;
          }
          s.exports = l;
        } }), Br = ee({ "src/language-yaml/print/misc.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { softline: t, align: i } } = Le(), { hasEndComments: l, isNextLineEmpty: u, isNode: n } = Lt(), a = /* @__PURE__ */ new WeakMap();
          function o(h, v) {
            let p = h.getValue(), m = h.stack[0], E;
            return a.has(m) ? E = a.get(m) : (E = /* @__PURE__ */ new Set(), a.set(m, E)), !E.has(p.position.end.line) && (E.add(p.position.end.line), u(p, v) && !D(h.getParentNode())) ? t : "";
          }
          function D(h) {
            return l(h) && !n(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function F(h, v) {
            return i(" ".repeat(h), v);
          }
          s.exports = { alignWithSpaces: F, shouldPrintEndComments: D, printNextEmptyLine: o };
        } }), Pd = ee({ "src/language-yaml/print/flow-mapping-sequence.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { ifBreak: t, line: i, softline: l, hardline: u, join: n } } = Le(), { isEmptyNode: a, getLast: o, hasEndComments: D } = Lt(), { printNextEmptyLine: F, alignWithSpaces: h } = Br();
          function v(m, E, P) {
            let N = m.getValue(), b = N.type === "flowMapping", T = b ? "{" : "[", S = b ? "}" : "]", w = l;
            b && N.children.length > 0 && P.bracketSpacing && (w = i);
            let _ = o(N.children), k = _ && _.type === "flowMappingItem" && a(_.key) && a(_.value);
            return [T, h(P.tabWidth, [w, p(m, E, P), P.trailingComma === "none" ? "" : t(","), D(N) ? [u, n(u, m.map(E, "endComments"))] : ""]), k ? "" : w, S];
          }
          function p(m, E, P) {
            let N = m.getValue();
            return m.map((T, S) => [E(), S === N.children.length - 1 ? "" : [",", i, N.children[S].position.start.line !== N.children[S + 1].position.start.line ? F(T, P.originalText) : ""]], "children");
          }
          s.exports = { printFlowMapping: v, printFlowSequence: v };
        } }), _d = ee({ "src/language-yaml/print/mapping-item.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { conditionalGroup: t, group: i, hardline: l, ifBreak: u, join: n, line: a } } = Le(), { hasLeadingComments: o, hasMiddleComments: D, hasTrailingComment: F, hasEndComments: h, isNode: v, isEmptyNode: p, isInlineNode: m } = Lt(), { alignWithSpaces: E } = Br();
          function P(S, w, _, k, A) {
            let { key: f, value: d } = S, c = p(f), r = p(d);
            if (c && r)
              return ": ";
            let y = k("key"), g = b(S) ? " " : "";
            if (r)
              return S.type === "flowMappingItem" && w.type === "flowMapping" ? y : S.type === "mappingItem" && N(f.content, A) && !F(f.content) && (!w.tag || w.tag.value !== "tag:yaml.org,2002:set") ? [y, g, ":"] : ["? ", E(2, y)];
            let C = k("value");
            if (c)
              return [": ", E(2, C)];
            if (o(d) || !m(f.content))
              return ["? ", E(2, y), l, n("", _.map(k, "value", "leadingComments").map((H) => [H, l])), ": ", E(2, C)];
            if (T(f.content) && !o(f.content) && !D(f.content) && !F(f.content) && !h(f) && !o(d.content) && !D(d.content) && !h(d) && N(d.content, A))
              return [y, g, ": ", C];
            let x = Symbol("mappingKey"), B = i([u("? "), i(E(2, y), { id: x })]), L = [l, ": ", E(2, C)], M = [g, ":"];
            o(d.content) || h(d) && d.content && !v(d.content, ["mapping", "sequence"]) || w.type === "mapping" && F(f.content) && m(d.content) || v(d.content, ["mapping", "sequence"]) && d.content.tag === null && d.content.anchor === null ? M.push(l) : d.content && M.push(a), M.push(C);
            let j = E(A.tabWidth, M);
            return N(f.content, A) && !o(f.content) && !D(f.content) && !h(f) ? t([[y, j]]) : t([[B, u(L, j, { groupId: x })]]);
          }
          function N(S, w) {
            if (!S)
              return true;
            switch (S.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (w.proseWrap === "preserve")
              return S.position.start.line === S.position.end.line;
            if (/\\$/m.test(w.originalText.slice(S.position.start.offset, S.position.end.offset)))
              return false;
            switch (w.proseWrap) {
              case "never":
                return !S.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(S.value);
              default:
                return false;
            }
          }
          function b(S) {
            return S.key.content && S.key.content.type === "alias";
          }
          function T(S) {
            if (!S)
              return true;
            switch (S.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return S.position.start.line === S.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          s.exports = P;
        } }), Id = ee({ "src/language-yaml/print/block.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { dedent: t, dedentToRoot: i, fill: l, hardline: u, join: n, line: a, literalline: o, markAsRoot: D }, utils: { getDocParts: F } } = Le(), { getAncestorCount: h, getBlockValueLineContents: v, hasIndicatorComment: p, isLastDescendantNode: m, isNode: E } = Lt(), { alignWithSpaces: P } = Br();
          function N(b, T, S) {
            let w = b.getValue(), _ = h(b, (c) => E(c, ["sequence", "mapping"])), k = m(b), A = [w.type === "blockFolded" ? ">" : "|"];
            w.indent !== null && A.push(w.indent.toString()), w.chomping !== "clip" && A.push(w.chomping === "keep" ? "+" : "-"), p(w) && A.push(" ", T("indicatorComment"));
            let f = v(w, { parentIndent: _, isLastDescendant: k, options: S }), d = [];
            for (let [c, r] of f.entries())
              c === 0 && d.push(u), d.push(l(F(n(a, r)))), c !== f.length - 1 ? d.push(r.length === 0 ? u : D(o)) : w.chomping === "keep" && k && d.push(i(r.length === 0 ? u : o));
            return w.indent === null ? A.push(t(P(S.tabWidth, d))) : A.push(i(P(w.indent - 1 + _, d))), A;
          }
          s.exports = N;
        } }), kd = ee({ "src/language-yaml/printer-yaml.js"(e2, s) {
          "use strict";
          ae();
          var { builders: { breakParent: t, fill: i, group: l, hardline: u, join: n, line: a, lineSuffix: o, literalline: D }, utils: { getDocParts: F, replaceTextEndOfLine: h } } = Le(), { isPreviousLineEmpty: v } = Ge(), { insertPragma: p, isPragma: m } = Td(), { locStart: E } = Bd(), P = Nd(), { getFlowScalarLineContents: N, getLastDescendantNode: b, hasLeadingComments: T, hasMiddleComments: S, hasTrailingComment: w, hasEndComments: _, hasPrettierIgnore: k, isLastDescendantNode: A, isNode: f, isInlineNode: d } = Lt(), c = wd(), { alignWithSpaces: r, printNextEmptyLine: y, shouldPrintEndComments: g } = Br(), { printFlowMapping: C, printFlowSequence: x } = Pd(), B = _d(), L = Id();
          function M($, te, U) {
            let ne = $.getValue(), se = [];
            ne.type !== "mappingValue" && T(ne) && se.push([n(u, $.map(U, "leadingComments")), u]);
            let { tag: V, anchor: oe } = ne;
            V && se.push(U("tag")), V && oe && se.push(" "), oe && se.push(U("anchor"));
            let K = "";
            f(ne, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !A($) && (K = y($, te.originalText)), (V || oe) && (f(ne, ["sequence", "mapping"]) && !S(ne) ? se.push(u) : se.push(" ")), S(ne) && se.push([ne.middleComments.length === 1 ? "" : u, n(u, $.map(U, "middleComments")), u]);
            let Ee = $.getParentNode();
            return k($) ? se.push(h(te.originalText.slice(ne.position.start.offset, ne.position.end.offset).trimEnd(), D)) : se.push(l(j(ne, Ee, $, te, U))), w(ne) && !f(ne, ["document", "documentHead"]) && se.push(o([ne.type === "mappingValue" && !ne.content ? "" : " ", Ee.type === "mappingKey" && $.getParentNode(2).type === "mapping" && d(ne) ? "" : t, U("trailingComment")])), g(ne) && se.push(r(ne.type === "sequenceItem" ? 2 : 0, [u, n(u, $.map((R) => [v(te.originalText, R.getValue(), E) ? u : "", U()], "endComments"))])), se.push(K), se;
          }
          function j($, te, U, ne, se) {
            switch ($.type) {
              case "root": {
                let { children: V } = $, oe = [];
                U.each((Ee, R) => {
                  let le = V[R], ue = V[R + 1];
                  R !== 0 && oe.push(u), oe.push(se()), I(le, ue) ? (oe.push(u, "..."), w(le) && oe.push(" ", se("trailingComment"))) : ue && !w(ue.head) && oe.push(u, "---");
                }, "children");
                let K = b($);
                return (!f(K, ["blockLiteral", "blockFolded"]) || K.chomping !== "keep") && oe.push(u), oe;
              }
              case "document": {
                let V = te.children[U.getName() + 1], oe = [];
                return G($, V, te, ne) === "head" && (($.head.children.length > 0 || $.head.endComments.length > 0) && oe.push(se("head")), w($.head) ? oe.push(["---", " ", se(["head", "trailingComment"])]) : oe.push("---")), H($) && oe.push(se("body")), n(u, oe);
              }
              case "documentHead":
                return n(u, [...U.map(se, "children"), ...U.map(se, "endComments")]);
              case "documentBody": {
                let { children: V, endComments: oe } = $, K = "";
                if (V.length > 0 && oe.length > 0) {
                  let Ee = b($);
                  f(Ee, ["blockFolded", "blockLiteral"]) ? Ee.chomping !== "keep" && (K = [u, u]) : K = u;
                }
                return [n(u, U.map(se, "children")), K, n(u, U.map(se, "endComments"))];
              }
              case "directive":
                return ["%", n(" ", [$.name, ...$.parameters])];
              case "comment":
                return ["#", $.value];
              case "alias":
                return ["*", $.value];
              case "tag":
                return ne.originalText.slice($.position.start.offset, $.position.end.offset);
              case "anchor":
                return ["&", $.value];
              case "plain":
                return Z($.type, ne.originalText.slice($.position.start.offset, $.position.end.offset), ne);
              case "quoteDouble":
              case "quoteSingle": {
                let V = "'", oe = '"', K = ne.originalText.slice($.position.start.offset + 1, $.position.end.offset - 1);
                if ($.type === "quoteSingle" && K.includes("\\") || $.type === "quoteDouble" && /\\[^"]/.test(K)) {
                  let R = $.type === "quoteDouble" ? oe : V;
                  return [R, Z($.type, K, ne), R];
                }
                if (K.includes(oe))
                  return [V, Z($.type, $.type === "quoteDouble" ? K.replace(/\\"/g, oe).replace(/'/g, V.repeat(2)) : K, ne), V];
                if (K.includes(V))
                  return [oe, Z($.type, $.type === "quoteSingle" ? K.replace(/''/g, V) : K, ne), oe];
                let Ee = ne.singleQuote ? V : oe;
                return [Ee, Z($.type, K, ne), Ee];
              }
              case "blockFolded":
              case "blockLiteral":
                return L(U, se, ne);
              case "mapping":
              case "sequence":
                return n(u, U.map(se, "children"));
              case "sequenceItem":
                return ["- ", r(2, $.content ? se("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return $.content ? se("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return B($, te, U, se, ne);
              case "flowMapping":
                return C(U, se, ne);
              case "flowSequence":
                return x(U, se, ne);
              case "flowSequenceItem":
                return se("content");
              default:
                throw new Error("Unexpected node type ".concat($.type));
            }
          }
          function H($) {
            return $.body.children.length > 0 || _($.body);
          }
          function I($, te) {
            return w($) || te && (te.head.children.length > 0 || _(te.head));
          }
          function G($, te, U, ne) {
            return U.children[0] === $ && /---(?:\s|$)/.test(ne.originalText.slice(E($), E($) + 4)) || $.head.children.length > 0 || _($.head) || w($.head) ? "head" : I($, te) ? false : te ? "root" : false;
          }
          function Z($, te, U) {
            let ne = N($, te, U);
            return n(u, ne.map((se) => i(F(n(a, se)))));
          }
          function W($, te) {
            if (f(te))
              switch (delete te.position, te.type) {
                case "comment":
                  if (m(te.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  te.type = "quote";
                  break;
              }
          }
          s.exports = { preprocess: c, embed: P, print: M, massageAstNode: W, insertPragma: p };
        } }), Ld = ee({ "src/language-yaml/options.js"(e2, s) {
          "use strict";
          ae();
          var t = It();
          s.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Od = ee({ "src/language-yaml/parsers.js"() {
          ae();
        } }), jd = ee({ "node_modules/linguist-languages/data/YAML.json"(e2, s) {
          s.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), qd = ee({ "src/language-yaml/index.js"(e2, s) {
          "use strict";
          ae();
          var t = St(), i = kd(), l = Ld(), u = Od(), n = [t(jd(), (a) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...a.filenames.filter((o) => o !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
          s.exports = { languages: n, printers: { yaml: i }, options: l, parsers: u };
        } }), Md = ee({ "src/languages.js"(e2, s) {
          "use strict";
          ae(), s.exports = [Cm(), jm(), Gm(), Qm(), ad(), xd(), qd()];
        } });
        ae();
        var { version: Rd } = fi(), Nt = qD(), { getSupportInfo: Vd } = _n(), Wd = MD(), $d = Md(), Hd = Le();
        function At(e2) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, i = new Array(t), l = 0; l < t; l++)
              i[l] = arguments[l];
            let u = i[s] || {}, n = u.plugins || [];
            return i[s] = Object.assign(Object.assign({}, u), {}, { plugins: [...$d, ...Array.isArray(n) ? n : Object.values(n)] }), e2(...i);
          };
        }
        var hn = At(Nt.formatWithCursor);
        po.exports = { formatWithCursor: hn, format(e2, s) {
          return hn(e2, s).formatted;
        }, check(e2, s) {
          let { formatted: t } = hn(e2, s);
          return t === e2;
        }, doc: Hd, getSupportInfo: At(Vd, 0), version: Rd, util: Wd, __debug: { parse: At(Nt.parse), formatAST: At(Nt.formatAST), formatDoc: At(Nt.formatDoc), printToDoc: At(Nt.printToDoc), printDocToString: At(Nt.printDocToString) } };
      });
      "use strict";
      return Gd();
    });
  }
});

// ../../node_modules/.pnpm/prettier@2.6.0/node_modules/prettier/parser-postcss.js
var require_parser_postcss = __commonJS({
  "../../node_modules/.pnpm/prettier@2.6.0/node_modules/prettier/parser-postcss.js"(exports, module2) {
    (function(e2) {
      if (typeof exports == "object" && typeof module2 == "object")
        module2.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.postcss = e2();
      }
    })(function() {
      "use strict";
      var V = (e2, i) => () => (i || e2((i = { exports: {} }).exports, i), i.exports);
      var ee = V((Th, Wt) => {
        var rr = function(e2) {
          return e2 && e2.Math == Math && e2;
        };
        Wt.exports = rr(typeof globalThis == "object" && globalThis) || rr(typeof window == "object" && window) || rr(typeof self == "object" && self) || rr(typeof global == "object" && global) || function() {
          return this;
        }() || Function("return this")();
      });
      var xe = V((Ah, $t) => {
        $t.exports = function(e2) {
          try {
            return !!e2();
          } catch {
            return true;
          }
        };
      });
      var Ee = V((Ch, Vt) => {
        var wa = xe();
        Vt.exports = !wa(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Tr = V((qh, Qt) => {
        var ba = xe();
        Qt.exports = !ba(function() {
          var e2 = function() {
          }.bind();
          return typeof e2 != "function" || e2.hasOwnProperty("prototype");
        });
      });
      var nr = V((Mh, Jt) => {
        var Sa = Tr(), tr = Function.prototype.call;
        Jt.exports = Sa ? tr.bind(tr) : function() {
          return tr.apply(tr, arguments);
        };
      });
      var Xt = V((Ht) => {
        "use strict";
        var Kt = {}.propertyIsEnumerable, Yt = Object.getOwnPropertyDescriptor, xa = Yt && !Kt.call({ 1: 2 }, 1);
        Ht.f = xa ? function(i) {
          var s = Yt(this, i);
          return !!s && s.enumerable;
        } : Kt;
      });
      var Ar = V((Ih, Zt) => {
        Zt.exports = function(e2, i) {
          return { enumerable: !(e2 & 1), configurable: !(e2 & 2), writable: !(e2 & 4), value: i };
        };
      });
      var de = V((Nh, tn) => {
        var en = Tr(), rn = Function.prototype, Oa = rn.bind, Cr = rn.call, ka = en && Oa.bind(Cr, Cr);
        tn.exports = en ? function(e2) {
          return e2 && ka(e2);
        } : function(e2) {
          return e2 && function() {
            return Cr.apply(e2, arguments);
          };
        };
      });
      var on = V((Ph, sn) => {
        var nn = de(), Ea = nn({}.toString), Ta = nn("".slice);
        sn.exports = function(e2) {
          return Ta(Ea(e2), 8, -1);
        };
      });
      var un = V((Lh, an) => {
        var Aa = ee(), Ca = de(), qa = xe(), Ma = on(), qr = Aa.Object, Ra = Ca("".split);
        an.exports = qa(function() {
          return !qr("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return Ma(e2) == "String" ? Ra(e2, "") : qr(e2);
        } : qr;
      });
      var Mr = V((jh, ln) => {
        var Ia = ee(), Na = Ia.TypeError;
        ln.exports = function(e2) {
          if (e2 == null)
            throw Na("Can't call method on " + e2);
          return e2;
        };
      });
      var ir = V((Dh, cn) => {
        var Pa = un(), La = Mr();
        cn.exports = function(e2) {
          return Pa(La(e2));
        };
      });
      var ve = V((Bh, fn) => {
        fn.exports = function(e2) {
          return typeof e2 == "function";
        };
      });
      var je = V((zh, hn) => {
        var ja = ve();
        hn.exports = function(e2) {
          return typeof e2 == "object" ? e2 !== null : ja(e2);
        };
      });
      var sr = V((Fh, pn) => {
        var Rr = ee(), Da = ve(), Ba = function(e2) {
          return Da(e2) ? e2 : void 0;
        };
        pn.exports = function(e2, i) {
          return arguments.length < 2 ? Ba(Rr[e2]) : Rr[e2] && Rr[e2][i];
        };
      });
      var vn = V((Uh, dn) => {
        var za = de();
        dn.exports = za({}.isPrototypeOf);
      });
      var gn = V((Gh, mn) => {
        var Fa = sr();
        mn.exports = Fa("navigator", "userAgent") || "";
      });
      var On = V((Wh, xn) => {
        var Sn = ee(), Ir = gn(), yn = Sn.process, _n = Sn.Deno, wn = yn && yn.versions || _n && _n.version, bn = wn && wn.v8, pe, or;
        bn && (pe = bn.split("."), or = pe[0] > 0 && pe[0] < 4 ? 1 : +(pe[0] + pe[1]));
        !or && Ir && (pe = Ir.match(/Edge\/(\d+)/), (!pe || pe[1] >= 74) && (pe = Ir.match(/Chrome\/(\d+)/), pe && (or = +pe[1])));
        xn.exports = or;
      });
      var Nr = V(($h, En) => {
        var kn = On(), Ua = xe();
        En.exports = !!Object.getOwnPropertySymbols && !Ua(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && kn && kn < 41;
        });
      });
      var Pr = V((Vh, Tn) => {
        var Ga = Nr();
        Tn.exports = Ga && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Lr = V((Qh, An) => {
        var Wa = ee(), $a = sr(), Va = ve(), Qa = vn(), Ja = Pr(), Ka = Wa.Object;
        An.exports = Ja ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var i = $a("Symbol");
          return Va(i) && Qa(i.prototype, Ka(e2));
        };
      });
      var qn = V((Jh, Cn) => {
        var Ya = ee(), Ha = Ya.String;
        Cn.exports = function(e2) {
          try {
            return Ha(e2);
          } catch {
            return "Object";
          }
        };
      });
      var Rn = V((Kh, Mn) => {
        var Xa = ee(), Za = ve(), eu = qn(), ru = Xa.TypeError;
        Mn.exports = function(e2) {
          if (Za(e2))
            return e2;
          throw ru(eu(e2) + " is not a function");
        };
      });
      var Nn = V((Yh, In) => {
        var tu = Rn();
        In.exports = function(e2, i) {
          var s = e2[i];
          return s == null ? void 0 : tu(s);
        };
      });
      var Ln = V((Hh, Pn) => {
        var nu = ee(), jr = nr(), Dr = ve(), Br = je(), iu = nu.TypeError;
        Pn.exports = function(e2, i) {
          var s, f;
          if (i === "string" && Dr(s = e2.toString) && !Br(f = jr(s, e2)) || Dr(s = e2.valueOf) && !Br(f = jr(s, e2)) || i !== "string" && Dr(s = e2.toString) && !Br(f = jr(s, e2)))
            return f;
          throw iu("Can't convert object to primitive value");
        };
      });
      var Dn = V((Xh, jn) => {
        jn.exports = false;
      });
      var ar = V((Zh, zn) => {
        var Bn = ee(), su = Object.defineProperty;
        zn.exports = function(e2, i) {
          try {
            su(Bn, e2, { value: i, configurable: true, writable: true });
          } catch {
            Bn[e2] = i;
          }
          return i;
        };
      });
      var ur = V((ep, Un) => {
        var ou = ee(), au = ar(), Fn = "__core-js_shared__", uu = ou[Fn] || au(Fn, {});
        Un.exports = uu;
      });
      var zr = V((rp, Wn) => {
        var lu = Dn(), Gn = ur();
        (Wn.exports = function(e2, i) {
          return Gn[e2] || (Gn[e2] = i !== void 0 ? i : {});
        })("versions", []).push({ version: "3.21.1", mode: lu ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Vn = V((tp, $n) => {
        var cu = ee(), fu = Mr(), hu = cu.Object;
        $n.exports = function(e2) {
          return hu(fu(e2));
        };
      });
      var Oe = V((np, Qn) => {
        var pu = de(), du = Vn(), vu = pu({}.hasOwnProperty);
        Qn.exports = Object.hasOwn || function(i, s) {
          return vu(du(i), s);
        };
      });
      var Fr = V((ip, Jn) => {
        var mu = de(), gu = 0, yu = Math.random(), _u = mu(1 .toString);
        Jn.exports = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + _u(++gu + yu, 36);
        };
      });
      var ei = V((sp, Zn) => {
        var wu = ee(), bu = zr(), Kn = Oe(), Su = Fr(), Yn = Nr(), Xn = Pr(), De = bu("wks"), Te = wu.Symbol, Hn = Te && Te.for, xu = Xn ? Te : Te && Te.withoutSetter || Su;
        Zn.exports = function(e2) {
          if (!Kn(De, e2) || !(Yn || typeof De[e2] == "string")) {
            var i = "Symbol." + e2;
            Yn && Kn(Te, e2) ? De[e2] = Te[e2] : Xn && Hn ? De[e2] = Hn(i) : De[e2] = xu(i);
          }
          return De[e2];
        };
      });
      var ii = V((op, ni) => {
        var Ou = ee(), ku = nr(), ri = je(), ti = Lr(), Eu = Nn(), Tu = Ln(), Au = ei(), Cu = Ou.TypeError, qu = Au("toPrimitive");
        ni.exports = function(e2, i) {
          if (!ri(e2) || ti(e2))
            return e2;
          var s = Eu(e2, qu), f;
          if (s) {
            if (i === void 0 && (i = "default"), f = ku(s, e2, i), !ri(f) || ti(f))
              return f;
            throw Cu("Can't convert object to primitive value");
          }
          return i === void 0 && (i = "number"), Tu(e2, i);
        };
      });
      var Ur = V((ap, si) => {
        var Mu = ii(), Ru = Lr();
        si.exports = function(e2) {
          var i = Mu(e2, "string");
          return Ru(i) ? i : i + "";
        };
      });
      var ui = V((up, ai) => {
        var Iu = ee(), oi = je(), Gr = Iu.document, Nu = oi(Gr) && oi(Gr.createElement);
        ai.exports = function(e2) {
          return Nu ? Gr.createElement(e2) : {};
        };
      });
      var Wr = V((lp, li) => {
        var Pu = Ee(), Lu = xe(), ju = ui();
        li.exports = !Pu && !Lu(function() {
          return Object.defineProperty(ju("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var $r = V((fi) => {
        var Du = Ee(), Bu = nr(), zu = Xt(), Fu = Ar(), Uu = ir(), Gu = Ur(), Wu = Oe(), $u = Wr(), ci = Object.getOwnPropertyDescriptor;
        fi.f = Du ? ci : function(i, s) {
          if (i = Uu(i), s = Gu(s), $u)
            try {
              return ci(i, s);
            } catch {
            }
          if (Wu(i, s))
            return Fu(!Bu(zu.f, i, s), i[s]);
        };
      });
      var pi = V((fp, hi) => {
        var Vu = Ee(), Qu = xe();
        hi.exports = Vu && Qu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Vr = V((hp, vi) => {
        var di = ee(), Ju = je(), Ku = di.String, Yu = di.TypeError;
        vi.exports = function(e2) {
          if (Ju(e2))
            return e2;
          throw Yu(Ku(e2) + " is not an object");
        };
      });
      var Hr = V((gi) => {
        var Hu = ee(), Xu = Ee(), Zu = Wr(), el = pi(), lr = Vr(), mi = Ur(), rl = Hu.TypeError, Qr = Object.defineProperty, tl = Object.getOwnPropertyDescriptor, Jr = "enumerable", Kr = "configurable", Yr = "writable";
        gi.f = Xu ? el ? function(i, s, f) {
          if (lr(i), s = mi(s), lr(f), typeof i == "function" && s === "prototype" && "value" in f && Yr in f && !f[Yr]) {
            var a = tl(i, s);
            a && a[Yr] && (i[s] = f.value, f = { configurable: Kr in f ? f[Kr] : a[Kr], enumerable: Jr in f ? f[Jr] : a[Jr], writable: false });
          }
          return Qr(i, s, f);
        } : Qr : function(i, s, f) {
          if (lr(i), s = mi(s), lr(f), Zu)
            try {
              return Qr(i, s, f);
            } catch {
            }
          if ("get" in f || "set" in f)
            throw rl("Accessors not supported");
          return "value" in f && (i[s] = f.value), i;
        };
      });
      var cr = V((dp, yi) => {
        var nl = Ee(), il = Hr(), sl = Ar();
        yi.exports = nl ? function(e2, i, s) {
          return il.f(e2, i, sl(1, s));
        } : function(e2, i, s) {
          return e2[i] = s, e2;
        };
      });
      var Zr = V((vp, _i) => {
        var ol = de(), al = ve(), Xr = ur(), ul = ol(Function.toString);
        al(Xr.inspectSource) || (Xr.inspectSource = function(e2) {
          return ul(e2);
        });
        _i.exports = Xr.inspectSource;
      });
      var Si = V((mp, bi) => {
        var ll = ee(), cl = ve(), fl = Zr(), wi = ll.WeakMap;
        bi.exports = cl(wi) && /native code/.test(fl(wi));
      });
      var ki = V((gp, Oi) => {
        var hl = zr(), pl = Fr(), xi = hl("keys");
        Oi.exports = function(e2) {
          return xi[e2] || (xi[e2] = pl(e2));
        };
      });
      var et = V((yp, Ei) => {
        Ei.exports = {};
      });
      var Ri = V((_p, Mi) => {
        var dl = Si(), qi = ee(), rt = de(), vl = je(), ml = cr(), tt = Oe(), nt = ur(), gl = ki(), yl = et(), Ti = "Object already initialized", st = qi.TypeError, _l = qi.WeakMap, fr, Fe, hr, wl = function(e2) {
          return hr(e2) ? Fe(e2) : fr(e2, {});
        }, bl = function(e2) {
          return function(i) {
            var s;
            if (!vl(i) || (s = Fe(i)).type !== e2)
              throw st("Incompatible receiver, " + e2 + " required");
            return s;
          };
        };
        dl || nt.state ? (ke = nt.state || (nt.state = new _l()), Ai = rt(ke.get), it = rt(ke.has), Ci = rt(ke.set), fr = function(e2, i) {
          if (it(ke, e2))
            throw new st(Ti);
          return i.facade = e2, Ci(ke, e2, i), i;
        }, Fe = function(e2) {
          return Ai(ke, e2) || {};
        }, hr = function(e2) {
          return it(ke, e2);
        }) : (Ae = gl("state"), yl[Ae] = true, fr = function(e2, i) {
          if (tt(e2, Ae))
            throw new st(Ti);
          return i.facade = e2, ml(e2, Ae, i), i;
        }, Fe = function(e2) {
          return tt(e2, Ae) ? e2[Ae] : {};
        }, hr = function(e2) {
          return tt(e2, Ae);
        });
        var ke, Ai, it, Ci, Ae;
        Mi.exports = { set: fr, get: Fe, has: hr, enforce: wl, getterFor: bl };
      });
      var Pi = V((wp, Ni) => {
        var ot = Ee(), Sl = Oe(), Ii = Function.prototype, xl = ot && Object.getOwnPropertyDescriptor, at = Sl(Ii, "name"), Ol = at && function() {
        }.name === "something", kl = at && (!ot || ot && xl(Ii, "name").configurable);
        Ni.exports = { EXISTS: at, PROPER: Ol, CONFIGURABLE: kl };
      });
      var zi = V((bp, Bi) => {
        var El = ee(), Li = ve(), Tl = Oe(), ji = cr(), Al = ar(), Cl = Zr(), Di = Ri(), ql = Pi().CONFIGURABLE, Ml = Di.get, Rl = Di.enforce, Il = String(String).split("String");
        (Bi.exports = function(e2, i, s, f) {
          var a = f ? !!f.unsafe : false, p = f ? !!f.enumerable : false, c = f ? !!f.noTargetGet : false, h = f && f.name !== void 0 ? f.name : i, g;
          if (Li(s) && (String(h).slice(0, 7) === "Symbol(" && (h = "[" + String(h).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Tl(s, "name") || ql && s.name !== h) && ji(s, "name", h), g = Rl(s), g.source || (g.source = Il.join(typeof h == "string" ? h : ""))), e2 === El) {
            p ? e2[i] = s : Al(i, s);
            return;
          } else
            a ? !c && e2[i] && (p = true) : delete e2[i];
          p ? e2[i] = s : ji(e2, i, s);
        })(Function.prototype, "toString", function() {
          return Li(this) && Ml(this).source || Cl(this);
        });
      });
      var ut = V((Sp, Fi) => {
        var Nl = Math.ceil, Pl = Math.floor;
        Fi.exports = function(e2) {
          var i = +e2;
          return i !== i || i === 0 ? 0 : (i > 0 ? Pl : Nl)(i);
        };
      });
      var Gi = V((xp, Ui) => {
        var Ll = ut(), jl = Math.max, Dl = Math.min;
        Ui.exports = function(e2, i) {
          var s = Ll(e2);
          return s < 0 ? jl(s + i, 0) : Dl(s, i);
        };
      });
      var $i = V((Op, Wi) => {
        var Bl = ut(), zl = Math.min;
        Wi.exports = function(e2) {
          return e2 > 0 ? zl(Bl(e2), 9007199254740991) : 0;
        };
      });
      var Qi = V((kp, Vi) => {
        var Fl = $i();
        Vi.exports = function(e2) {
          return Fl(e2.length);
        };
      });
      var Yi = V((Ep, Ki) => {
        var Ul = ir(), Gl = Gi(), Wl = Qi(), Ji = function(e2) {
          return function(i, s, f) {
            var a = Ul(i), p = Wl(a), c = Gl(f, p), h;
            if (e2 && s != s) {
              for (; p > c; )
                if (h = a[c++], h != h)
                  return true;
            } else
              for (; p > c; c++)
                if ((e2 || c in a) && a[c] === s)
                  return e2 || c || 0;
            return !e2 && -1;
          };
        };
        Ki.exports = { includes: Ji(true), indexOf: Ji(false) };
      });
      var Zi = V((Tp, Xi) => {
        var $l = de(), lt = Oe(), Vl = ir(), Ql = Yi().indexOf, Jl = et(), Hi = $l([].push);
        Xi.exports = function(e2, i) {
          var s = Vl(e2), f = 0, a = [], p;
          for (p in s)
            !lt(Jl, p) && lt(s, p) && Hi(a, p);
          for (; i.length > f; )
            lt(s, p = i[f++]) && (~Ql(a, p) || Hi(a, p));
          return a;
        };
      });
      var rs = V((Ap, es) => {
        es.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ns = V((ts) => {
        var Kl = Zi(), Yl = rs(), Hl = Yl.concat("length", "prototype");
        ts.f = Object.getOwnPropertyNames || function(i) {
          return Kl(i, Hl);
        };
      });
      var ss = V((is) => {
        is.f = Object.getOwnPropertySymbols;
      });
      var as = V((Mp, os) => {
        var Xl = sr(), Zl = de(), ec = ns(), rc = ss(), tc = Vr(), nc = Zl([].concat);
        os.exports = Xl("Reflect", "ownKeys") || function(i) {
          var s = ec.f(tc(i)), f = rc.f;
          return f ? nc(s, f(i)) : s;
        };
      });
      var cs = V((Rp, ls) => {
        var us = Oe(), ic = as(), sc = $r(), oc = Hr();
        ls.exports = function(e2, i, s) {
          for (var f = ic(i), a = oc.f, p = sc.f, c = 0; c < f.length; c++) {
            var h = f[c];
            !us(e2, h) && !(s && us(s, h)) && a(e2, h, p(i, h));
          }
        };
      });
      var hs = V((Ip, fs3) => {
        var ac = xe(), uc = ve(), lc = /#|\.prototype\./, Ue = function(e2, i) {
          var s = fc[cc(e2)];
          return s == pc ? true : s == hc ? false : uc(i) ? ac(i) : !!i;
        }, cc = Ue.normalize = function(e2) {
          return String(e2).replace(lc, ".").toLowerCase();
        }, fc = Ue.data = {}, hc = Ue.NATIVE = "N", pc = Ue.POLYFILL = "P";
        fs3.exports = Ue;
      });
      var ds = V((Np, ps) => {
        var ct = ee(), dc = $r().f, vc = cr(), mc = zi(), gc = ar(), yc = cs(), _c = hs();
        ps.exports = function(e2, i) {
          var s = e2.target, f = e2.global, a = e2.stat, p, c, h, g, u, t;
          if (f ? c = ct : a ? c = ct[s] || gc(s, {}) : c = (ct[s] || {}).prototype, c)
            for (h in i) {
              if (u = i[h], e2.noTargetGet ? (t = dc(c, h), g = t && t.value) : g = c[h], p = _c(f ? h : s + (a ? "." : "#") + h, e2.forced), !p && g !== void 0) {
                if (typeof u == typeof g)
                  continue;
                yc(u, g);
              }
              (e2.sham || g && g.sham) && vc(u, "sham", true), mc(c, h, u, e2);
            }
        };
      });
      var vs = V(() => {
        var wc = ds(), bc = ee();
        wc({ global: true }, { globalThis: bc });
      });
      var ms = V(() => {
        vs();
      });
      var kh = V(($p, _a) => {
        ms();
        var Et = Object.defineProperty, Sc = Object.getOwnPropertyDescriptor, Tt = Object.getOwnPropertyNames, xc = Object.prototype.hasOwnProperty, Pe = (e2, i) => function() {
          return e2 && (i = (0, e2[Tt(e2)[0]])(e2 = 0)), i;
        }, M = (e2, i) => function() {
          return i || (0, e2[Tt(e2)[0]])((i = { exports: {} }).exports, i), i.exports;
        }, yr = (e2, i) => {
          for (var s in i)
            Et(e2, s, { get: i[s], enumerable: true });
        }, Oc = (e2, i, s, f) => {
          if (i && typeof i == "object" || typeof i == "function")
            for (let a of Tt(i))
              !xc.call(e2, a) && a !== s && Et(e2, a, { get: () => i[a], enumerable: !(f = Sc(i, a)) || f.enumerable });
          return e2;
        }, _r = (e2) => Oc(Et({}, "__esModule", { value: true }), e2), A = Pe({ "<define:process>"() {
        } }), kc = M({ "src/common/parser-create-error.js"(e2, i) {
          "use strict";
          A();
          function s(f, a) {
            let p = new SyntaxError(f + " (" + a.start.line + ":" + a.start.column + ")");
            return p.loc = a, p;
          }
          i.exports = s;
        } }), Ps = M({ "src/utils/get-last.js"(e2, i) {
          "use strict";
          A();
          var s = (f) => f[f.length - 1];
          i.exports = s;
        } }), Ls = M({ "src/utils/front-matter/parse.js"(e2, i) {
          "use strict";
          A();
          var s = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function f(a) {
            let p = a.match(s);
            if (!p)
              return { content: a };
            let { startDelimiter: c, language: h, value: g = "", endDelimiter: u } = p.groups, t = h.trim() || "yaml";
            if (c === "+++" && (t = "toml"), t !== "yaml" && c !== u)
              return { content: a };
            let [r] = p;
            return { frontMatter: { type: "front-matter", lang: t, value: g, startDelimiter: c, endDelimiter: u, raw: r.replace(/\n$/, "") }, content: r.replace(/[^\n]/g, " ") + a.slice(r.length) };
          }
          i.exports = f;
        } }), js = {};
        yr(js, { EOL: () => wt, arch: () => Ec, cpus: () => Ws, default: () => Ks, endianness: () => Ds, freemem: () => Us, getNetworkInterfaces: () => Js, hostname: () => Bs, loadavg: () => zs, networkInterfaces: () => Qs, platform: () => Tc, release: () => Vs, tmpDir: () => yt, tmpdir: () => _t, totalmem: () => Gs, type: () => $s, uptime: () => Fs });
        function Ds() {
          if (typeof pr > "u") {
            var e2 = new ArrayBuffer(2), i = new Uint8Array(e2), s = new Uint16Array(e2);
            if (i[0] = 1, i[1] = 2, s[0] === 258)
              pr = "BE";
            else if (s[0] === 513)
              pr = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return pr;
        }
        function Bs() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function zs() {
          return [];
        }
        function Fs() {
          return 0;
        }
        function Us() {
          return Number.MAX_VALUE;
        }
        function Gs() {
          return Number.MAX_VALUE;
        }
        function Ws() {
          return [];
        }
        function $s() {
          return "Browser";
        }
        function Vs() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function Qs() {
        }
        function Js() {
        }
        function Ec() {
          return "javascript";
        }
        function Tc() {
          return "browser";
        }
        function yt() {
          return "/tmp";
        }
        var pr, _t, wt, Ks, Ac = Pe({ "node-modules-polyfills:os"() {
          A(), _t = yt, wt = `
`, Ks = { EOL: wt, tmpdir: _t, tmpDir: yt, networkInterfaces: Qs, getNetworkInterfaces: Js, release: Vs, type: $s, cpus: Ws, totalmem: Gs, freemem: Us, uptime: Fs, loadavg: zs, hostname: Bs, endianness: Ds };
        } }), Cc = M({ "node-modules-polyfills-commonjs:os"(e2, i) {
          A();
          var s = (Ac(), _r(js));
          if (s && s.default) {
            i.exports = s.default;
            for (let f in s)
              i.exports[f] = s[f];
          } else
            s && (i.exports = s);
        } }), qc = M({ "node_modules/detect-newline/index.js"(e2, i) {
          "use strict";
          A();
          var s = (f) => {
            if (typeof f != "string")
              throw new TypeError("Expected a string");
            let a = f.match(/(?:\r?\n)/g) || [];
            if (a.length === 0)
              return;
            let p = a.filter((h) => h === `\r
`).length, c = a.length - p;
            return p > c ? `\r
` : `
`;
          };
          i.exports = s, i.exports.graceful = (f) => typeof f == "string" && s(f) || `
`;
        } }), Mc = M({ "node_modules/jest-docblock/build/index.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.extract = n, e2.parse = v, e2.parseWithComments = d, e2.print = _, e2.strip = l;
          function i() {
            let m = Cc();
            return i = function() {
              return m;
            }, m;
          }
          function s() {
            let m = f(qc());
            return s = function() {
              return m;
            }, m;
          }
          function f(m) {
            return m && m.__esModule ? m : { default: m };
          }
          var a = /\*\/$/, p = /^\/\*\*/, c = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, h = /(^|\s+)\/\/([^\r\n]*)/g, g = /^(\r?\n)+/, u = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, r = /(\r?\n|^) *\* ?/g, o = [];
          function n(m) {
            let y = m.match(c);
            return y ? y[0].trimLeft() : "";
          }
          function l(m) {
            let y = m.match(c);
            return y && y[0] ? m.substring(y[0].length) : m;
          }
          function v(m) {
            return d(m).pragmas;
          }
          function d(m) {
            let y = (0, s().default)(m) || i().EOL;
            m = m.replace(p, "").replace(a, "").replace(r, "$1");
            let b = "";
            for (; b !== m; )
              b = m, m = m.replace(u, "".concat(y, "$1 $2").concat(y));
            m = m.replace(g, "").trimRight();
            let S = /* @__PURE__ */ Object.create(null), E = m.replace(t, "").replace(g, "").trimRight(), q;
            for (; q = t.exec(m); ) {
              let P = q[2].replace(h, "");
              typeof S[q[1]] == "string" || Array.isArray(S[q[1]]) ? S[q[1]] = o.concat(S[q[1]], P) : S[q[1]] = P;
            }
            return { comments: E, pragmas: S };
          }
          function _(m) {
            let { comments: y = "", pragmas: b = {} } = m, S = (0, s().default)(y) || i().EOL, E = "/**", q = " *", P = " */", z = Object.keys(b), B = z.map(($) => w($, b[$])).reduce(($, G) => $.concat(G), []).map(($) => q + " " + $ + S).join("");
            if (!y) {
              if (z.length === 0)
                return "";
              if (z.length === 1 && !Array.isArray(b[z[0]])) {
                let $ = b[z[0]];
                return "".concat(E, " ").concat(w(z[0], $)[0]).concat(P);
              }
            }
            let L = y.split(S).map(($) => "".concat(q, " ").concat($)).join(S) + S;
            return E + S + (y ? L : "") + (y && z.length ? q + S : "") + B + P;
          }
          function w(m, y) {
            return o.concat(y).map((b) => "@".concat(m, " ").concat(b).trim());
          }
        } }), Rc = M({ "src/common/end-of-line.js"(e2, i) {
          "use strict";
          A();
          function s(c) {
            let h = c.indexOf("\r");
            return h >= 0 ? c.charAt(h + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function f(c) {
            switch (c) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(c, h) {
            let g;
            switch (h) {
              case `
`:
                g = /\n/g;
                break;
              case "\r":
                g = /\r/g;
                break;
              case `\r
`:
                g = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(h), "."));
            }
            let u = c.match(g);
            return u ? u.length : 0;
          }
          function p(c) {
            return c.replace(/\r\n?/g, `
`);
          }
          i.exports = { guessEndOfLine: s, convertEndOfLineToChars: f, countEndOfLineChars: a, normalizeEndOfLine: p };
        } }), Ic = M({ "src/language-js/utils/get-shebang.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            if (!f.startsWith("#!"))
              return "";
            let a = f.indexOf(`
`);
            return a === -1 ? f : f.slice(0, a);
          }
          i.exports = s;
        } }), Nc = M({ "src/language-js/pragma.js"(e2, i) {
          "use strict";
          A();
          var { parseWithComments: s, strip: f, extract: a, print: p } = Mc(), { normalizeEndOfLine: c } = Rc(), h = Ic();
          function g(r) {
            let o = h(r);
            o && (r = r.slice(o.length + 1));
            let n = a(r), { pragmas: l, comments: v } = s(n);
            return { shebang: o, text: r, pragmas: l, comments: v };
          }
          function u(r) {
            let o = Object.keys(g(r).pragmas);
            return o.includes("prettier") || o.includes("format");
          }
          function t(r) {
            let { shebang: o, text: n, pragmas: l, comments: v } = g(r), d = f(n), _ = p({ pragmas: Object.assign({ format: "" }, l), comments: v.trimStart() });
            return (o ? "".concat(o, `
`) : "") + c(_) + (d.startsWith(`
`) ? `
` : `

`) + d;
          }
          i.exports = { hasPragma: u, insertPragma: t };
        } }), Pc = M({ "src/language-css/pragma.js"(e2, i) {
          "use strict";
          A();
          var s = Nc(), f = Ls();
          function a(c) {
            return s.hasPragma(f(c).content);
          }
          function p(c) {
            let { frontMatter: h, content: g } = f(c);
            return (h ? h.raw + `

` : "") + s.insertPragma(g);
          }
          i.exports = { hasPragma: a, insertPragma: p };
        } }), Lc = M({ "src/utils/text/skip.js"(e2, i) {
          "use strict";
          A();
          function s(h) {
            return (g, u, t) => {
              let r = t && t.backwards;
              if (u === false)
                return false;
              let { length: o } = g, n = u;
              for (; n >= 0 && n < o; ) {
                let l = g.charAt(n);
                if (h instanceof RegExp) {
                  if (!h.test(l))
                    return n;
                } else if (!h.includes(l))
                  return n;
                r ? n-- : n++;
              }
              return n === -1 || n === o ? n : false;
            };
          }
          var f = s(/\s/), a = s(" 	"), p = s(",; 	"), c = s(/[^\n\r]/);
          i.exports = { skipWhitespace: f, skipSpaces: a, skipToLineEnd: p, skipEverythingButNewLine: c };
        } }), jc = M({ "src/utils/line-column-to-index.js"(e2, i) {
          "use strict";
          A(), i.exports = function(s, f) {
            let a = 0;
            for (let p = 0; p < s.line - 1; ++p)
              a = f.indexOf(`
`, a) + 1;
            return a + s.column;
          };
        } }), Ys = M({ "src/language-css/loc.js"(e2, i) {
          "use strict";
          A();
          var { skipEverythingButNewLine: s } = Lc(), f = Ps(), a = jc();
          function p(n, l) {
            return typeof n.sourceIndex == "number" ? n.sourceIndex : n.source ? a(n.source.start, l) - 1 : null;
          }
          function c(n, l) {
            if (n.type === "css-comment" && n.inline)
              return s(l, n.source.startOffset);
            let v = n.nodes && f(n.nodes);
            return v && n.source && !n.source.end && (n = v), n.source && n.source.end ? a(n.source.end, l) : null;
          }
          function h(n, l) {
            n.source && (n.source.startOffset = p(n, l), n.source.endOffset = c(n, l));
            for (let v in n) {
              let d = n[v];
              v === "source" || !d || typeof d != "object" || (d.type === "value-root" || d.type === "value-unknown" ? g(d, u(n), d.text || d.value) : h(d, l));
            }
          }
          function g(n, l, v) {
            n.source && (n.source.startOffset = p(n, v) + l, n.source.endOffset = c(n, v) + l);
            for (let d in n) {
              let _ = n[d];
              d === "source" || !_ || typeof _ != "object" || g(_, l, v);
            }
          }
          function u(n) {
            let l = n.source.startOffset;
            return typeof n.prop == "string" && (l += n.prop.length), n.type === "css-atrule" && typeof n.name == "string" && (l += 1 + n.name.length + n.raws.afterName.match(/^\s*:?\s*/)[0].length), n.type !== "css-atrule" && n.raws && typeof n.raws.between == "string" && (l += n.raws.between.length), l;
          }
          function t(n) {
            let l = "initial", v = "initial", d, _ = false, w = [];
            for (let m = 0; m < n.length; m++) {
              let y = n[m];
              switch (l) {
                case "initial":
                  if (y === "'") {
                    l = "single-quotes";
                    continue;
                  }
                  if (y === '"') {
                    l = "double-quotes";
                    continue;
                  }
                  if ((y === "u" || y === "U") && n.slice(m, m + 4).toLowerCase() === "url(") {
                    l = "url", m += 3;
                    continue;
                  }
                  if (y === "*" && n[m - 1] === "/") {
                    l = "comment-block";
                    continue;
                  }
                  if (y === "/" && n[m - 1] === "/") {
                    l = "comment-inline", d = m - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (y === "'" && n[m - 1] !== "\\" && (l = v, v = "initial"), y === `
` || y === "\r")
                    return n;
                  continue;
                case "double-quotes":
                  if (y === '"' && n[m - 1] !== "\\" && (l = v, v = "initial"), y === `
` || y === "\r")
                    return n;
                  continue;
                case "url":
                  if (y === ")" && (l = "initial"), y === `
` || y === "\r")
                    return n;
                  if (y === "'") {
                    l = "single-quotes", v = "url";
                    continue;
                  }
                  if (y === '"') {
                    l = "double-quotes", v = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  y === "/" && n[m - 1] === "*" && (l = "initial");
                  continue;
                case "comment-inline":
                  (y === '"' || y === "'" || y === "*") && (_ = true), (y === `
` || y === "\r") && (_ && w.push([d, m]), l = "initial", _ = false);
                  continue;
              }
            }
            for (let [m, y] of w)
              n = n.slice(0, m) + n.slice(m, y).replace(/["'*]/g, " ") + n.slice(y);
            return n;
          }
          function r(n) {
            return n.source.startOffset;
          }
          function o(n) {
            return n.source.endOffset;
          }
          i.exports = { locStart: r, locEnd: o, calculateLoc: h, replaceQuotesInInlineComments: t };
        } }), Hs = M({ "src/utils/is-non-empty-array.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            return Array.isArray(f) && f.length > 0;
          }
          i.exports = s;
        } }), Dc = M({ "src/language-css/utils/has-scss-interpolation.js"(e2, i) {
          "use strict";
          A();
          var s = Hs();
          function f(a) {
            if (s(a)) {
              for (let p = a.length - 1; p > 0; p--)
                if (a[p].type === "word" && a[p].value === "{" && a[p - 1].type === "word" && a[p - 1].value.endsWith("#"))
                  return true;
            }
            return false;
          }
          i.exports = f;
        } }), Bc = M({ "src/language-css/utils/has-string-or-function.js"(e2, i) {
          "use strict";
          A();
          var s = Hs();
          function f(a) {
            if (s(a)) {
              for (let p = 0; p < a.length; p++)
                if (a[p].type === "string" || a[p].type === "func")
                  return true;
            }
            return false;
          }
          i.exports = f;
        } }), zc = M({ "src/language-css/utils/is-less-parser.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            return f.parser === "css" || f.parser === "less";
          }
          i.exports = s;
        } }), Fc = M({ "src/language-css/utils/is-scss.js"(e2, i) {
          "use strict";
          A();
          function s(f, a) {
            return f === "less" || f === "scss" ? f === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          i.exports = s;
        } }), Uc = M({ "src/language-css/utils/is-scss-nested-property-node.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            return f.selector ? f.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
          }
          i.exports = s;
        } }), Gc = M({ "src/language-css/utils/is-scss-variable.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            return Boolean(f && f.type === "word" && f.value.startsWith("$"));
          }
          i.exports = s;
        } }), Wc = M({ "src/language-css/utils/stringify-node.js"(e2, i) {
          "use strict";
          A();
          function s(f) {
            if (f.groups) {
              let r = f.open && f.open.value ? f.open.value : "", o = f.groups.reduce((l, v, d) => l + s(v) + (f.groups[0].type === "comma_group" && d !== f.groups.length - 1 ? "," : ""), ""), n = f.close && f.close.value ? f.close.value : "";
              return r + o + n;
            }
            let a = f.raws && f.raws.before ? f.raws.before : "", p = f.raws && f.raws.quote ? f.raws.quote : "", c = f.type === "atword" ? "@" : "", h = f.value ? f.value : "", g = f.unit ? f.unit : "", u = f.group ? s(f.group) : "", t = f.raws && f.raws.after ? f.raws.after : "";
            return a + p + c + h + p + g + u + t;
          }
          i.exports = s;
        } }), $c = M({ "src/language-css/utils/is-module-rule-name.js"(e2, i) {
          "use strict";
          A();
          var s = /* @__PURE__ */ new Set(["import", "use", "forward"]);
          function f(a) {
            return s.has(a);
          }
          i.exports = f;
        } }), _e = M({ "node_modules/postcss-values-parser/lib/node.js"(e2, i) {
          "use strict";
          A();
          var s = function(f, a) {
            let p = new f.constructor();
            for (let c in f) {
              if (!f.hasOwnProperty(c))
                continue;
              let h = f[c], g = typeof h;
              c === "parent" && g === "object" ? a && (p[c] = a) : c === "source" ? p[c] = h : h instanceof Array ? p[c] = h.map((u) => s(u, p)) : c !== "before" && c !== "after" && c !== "between" && c !== "semicolon" && (g === "object" && h !== null && (h = s(h)), p[c] = h);
            }
            return p;
          };
          i.exports = class {
            constructor(a) {
              a = a || {}, this.raws = { before: "", after: "" };
              for (let p in a)
                this[p] = a[p];
            }
            remove() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }
            toString() {
              return [this.raws.before, String(this.value), this.raws.after].join("");
            }
            clone(a) {
              a = a || {};
              let p = s(this);
              for (let c in a)
                p[c] = a[c];
              return p;
            }
            cloneBefore(a) {
              a = a || {};
              let p = this.clone(a);
              return this.parent.insertBefore(this, p), p;
            }
            cloneAfter(a) {
              a = a || {};
              let p = this.clone(a);
              return this.parent.insertAfter(this, p), p;
            }
            replaceWith() {
              let a = Array.prototype.slice.call(arguments);
              if (this.parent) {
                for (let p of a)
                  this.parent.insertBefore(this, p);
                this.remove();
              }
              return this;
            }
            moveTo(a) {
              return this.cleanRaws(this.root() === a.root()), this.remove(), a.append(this), this;
            }
            moveBefore(a) {
              return this.cleanRaws(this.root() === a.root()), this.remove(), a.parent.insertBefore(a, this), this;
            }
            moveAfter(a) {
              return this.cleanRaws(this.root() === a.root()), this.remove(), a.parent.insertAfter(a, this), this;
            }
            next() {
              let a = this.parent.index(this);
              return this.parent.nodes[a + 1];
            }
            prev() {
              let a = this.parent.index(this);
              return this.parent.nodes[a - 1];
            }
            toJSON() {
              let a = {};
              for (let p in this) {
                if (!this.hasOwnProperty(p) || p === "parent")
                  continue;
                let c = this[p];
                c instanceof Array ? a[p] = c.map((h) => typeof h == "object" && h.toJSON ? h.toJSON() : h) : typeof c == "object" && c.toJSON ? a[p] = c.toJSON() : a[p] = c;
              }
              return a;
            }
            root() {
              let a = this;
              for (; a.parent; )
                a = a.parent;
              return a;
            }
            cleanRaws(a) {
              delete this.raws.before, delete this.raws.after, a || delete this.raws.between;
            }
            positionInside(a) {
              let p = this.toString(), c = this.source.start.column, h = this.source.start.line;
              for (let g = 0; g < a; g++)
                p[g] === `
` ? (c = 1, h += 1) : c += 1;
              return { line: h, column: c };
            }
            positionBy(a) {
              let p = this.source.start;
              if (Object(a).index)
                p = this.positionInside(a.index);
              else if (Object(a).word) {
                let c = this.toString().indexOf(a.word);
                c !== -1 && (p = this.positionInside(c));
              }
              return p;
            }
          };
        } }), ue = M({ "node_modules/postcss-values-parser/lib/container.js"(e2, i) {
          "use strict";
          A();
          var s = _e(), f = class extends s {
            constructor(a) {
              super(a);
              this.nodes || (this.nodes = []);
            }
            push(a) {
              return a.parent = this, this.nodes.push(a), this;
            }
            each(a) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              let p = this.lastEach, c, h;
              if (this.indexes[p] = 0, !!this.nodes) {
                for (; this.indexes[p] < this.nodes.length && (c = this.indexes[p], h = a(this.nodes[c], c), h !== false); )
                  this.indexes[p] += 1;
                return delete this.indexes[p], h;
              }
            }
            walk(a) {
              return this.each((p, c) => {
                let h = a(p, c);
                return h !== false && p.walk && (h = p.walk(a)), h;
              });
            }
            walkType(a, p) {
              if (!a || !p)
                throw new Error("Parameters {type} and {callback} are required.");
              let c = typeof a == "function";
              return this.walk((h, g) => {
                if (c && h instanceof a || !c && h.type === a)
                  return p.call(this, h, g);
              });
            }
            append(a) {
              return a.parent = this, this.nodes.push(a), this;
            }
            prepend(a) {
              return a.parent = this, this.nodes.unshift(a), this;
            }
            cleanRaws(a) {
              if (super.cleanRaws(a), this.nodes)
                for (let p of this.nodes)
                  p.cleanRaws(a);
            }
            insertAfter(a, p) {
              let c = this.index(a), h;
              this.nodes.splice(c + 1, 0, p);
              for (let g in this.indexes)
                h = this.indexes[g], c <= h && (this.indexes[g] = h + this.nodes.length);
              return this;
            }
            insertBefore(a, p) {
              let c = this.index(a), h;
              this.nodes.splice(c, 0, p);
              for (let g in this.indexes)
                h = this.indexes[g], c <= h && (this.indexes[g] = h + this.nodes.length);
              return this;
            }
            removeChild(a) {
              a = this.index(a), this.nodes[a].parent = void 0, this.nodes.splice(a, 1);
              let p;
              for (let c in this.indexes)
                p = this.indexes[c], p >= a && (this.indexes[c] = p - 1);
              return this;
            }
            removeAll() {
              for (let a of this.nodes)
                a.parent = void 0;
              return this.nodes = [], this;
            }
            every(a) {
              return this.nodes.every(a);
            }
            some(a) {
              return this.nodes.some(a);
            }
            index(a) {
              return typeof a == "number" ? a : this.nodes.indexOf(a);
            }
            get first() {
              if (!!this.nodes)
                return this.nodes[0];
            }
            get last() {
              if (!!this.nodes)
                return this.nodes[this.nodes.length - 1];
            }
            toString() {
              let a = this.nodes.map(String).join("");
              return this.value && (a = this.value + a), this.raws.before && (a = this.raws.before + a), this.raws.after && (a += this.raws.after), a;
            }
          };
          f.registerWalker = (a) => {
            let p = "walk" + a.name;
            p.lastIndexOf("s") !== p.length - 1 && (p += "s"), !f.prototype[p] && (f.prototype[p] = function(c) {
              return this.walkType(a, c);
            });
          }, i.exports = f;
        } }), Vc = M({ "node_modules/postcss-values-parser/lib/root.js"(e2, i) {
          "use strict";
          A();
          var s = ue();
          i.exports = class extends s {
            constructor(a) {
              super(a);
              this.type = "root";
            }
          };
        } }), Xs = M({ "node_modules/postcss-values-parser/lib/value.js"(e2, i) {
          "use strict";
          A();
          var s = ue();
          i.exports = class extends s {
            constructor(a) {
              super(a);
              this.type = "value", this.unbalanced = 0;
            }
          };
        } }), Zs = M({ "node_modules/postcss-values-parser/lib/atword.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = class extends s {
            constructor(a) {
              super(a);
              this.type = "atword";
            }
            toString() {
              let a = this.quoted ? this.raws.quote : "";
              return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
            }
          };
          s.registerWalker(f), i.exports = f;
        } }), eo = M({ "node_modules/postcss-values-parser/lib/colon.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "colon";
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), ro = M({ "node_modules/postcss-values-parser/lib/comma.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "comma";
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), to = M({ "node_modules/postcss-values-parser/lib/comment.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "comment", this.inline = Object(p).inline || false;
            }
            toString() {
              return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), no = M({ "node_modules/postcss-values-parser/lib/function.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = class extends s {
            constructor(a) {
              super(a);
              this.type = "func", this.unbalanced = -1;
            }
          };
          s.registerWalker(f), i.exports = f;
        } }), io = M({ "node_modules/postcss-values-parser/lib/number.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "number", this.unit = Object(p).unit || "";
            }
            toString() {
              return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), so = M({ "node_modules/postcss-values-parser/lib/operator.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "operator";
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), oo = M({ "node_modules/postcss-values-parser/lib/paren.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "paren", this.parenType = "";
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), ao = M({ "node_modules/postcss-values-parser/lib/string.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "string";
            }
            toString() {
              let p = this.quoted ? this.raws.quote : "";
              return [this.raws.before, p, this.value + "", p, this.raws.after].join("");
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), uo = M({ "node_modules/postcss-values-parser/lib/word.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "word";
            }
          };
          s.registerWalker(a), i.exports = a;
        } }), lo = M({ "node_modules/postcss-values-parser/lib/unicode-range.js"(e2, i) {
          "use strict";
          A();
          var s = ue(), f = _e(), a = class extends f {
            constructor(p) {
              super(p);
              this.type = "unicode-range";
            }
          };
          s.registerWalker(a), i.exports = a;
        } });
        function co() {
          throw new Error("setTimeout has not been defined");
        }
        function fo() {
          throw new Error("clearTimeout has not been defined");
        }
        function ho(e2) {
          if (be === setTimeout)
            return setTimeout(e2, 0);
          if ((be === co || !be) && setTimeout)
            return be = setTimeout, setTimeout(e2, 0);
          try {
            return be(e2, 0);
          } catch {
            try {
              return be.call(null, e2, 0);
            } catch {
              return be.call(this, e2, 0);
            }
          }
        }
        function Qc(e2) {
          if (Se === clearTimeout)
            return clearTimeout(e2);
          if ((Se === fo || !Se) && clearTimeout)
            return Se = clearTimeout, clearTimeout(e2);
          try {
            return Se(e2);
          } catch {
            try {
              return Se.call(null, e2);
            } catch {
              return Se.call(this, e2);
            }
          }
        }
        function Jc() {
          !Ne || !Ie || (Ne = false, Ie.length ? me = Ie.concat(me) : We = -1, me.length && po());
        }
        function po() {
          if (!Ne) {
            var e2 = ho(Jc);
            Ne = true;
            for (var i = me.length; i; ) {
              for (Ie = me, me = []; ++We < i; )
                Ie && Ie[We].run();
              We = -1, i = me.length;
            }
            Ie = null, Ne = false, Qc(e2);
          }
        }
        function Kc(e2) {
          var i = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var s = 1; s < arguments.length; s++)
              i[s - 1] = arguments[s];
          me.push(new vo(e2, i)), me.length === 1 && !Ne && ho(po);
        }
        function vo(e2, i) {
          this.fun = e2, this.array = i;
        }
        function Ce() {
        }
        function Yc(e2) {
          throw new Error("process.binding is not supported");
        }
        function Hc() {
          return "/";
        }
        function Xc(e2) {
          throw new Error("process.chdir is not supported");
        }
        function Zc() {
          return 0;
        }
        function ef(e2) {
          var i = mo.call(Me) * 1e-3, s = Math.floor(i), f = Math.floor(i % 1 * 1e9);
          return e2 && (s = s - e2[0], f = f - e2[1], f < 0 && (s--, f += 1e9)), [s, f];
        }
        function rf() {
          var e2 = new Date(), i = e2 - go;
          return i / 1e3;
        }
        var be, Se, me, Ne, Ie, We, gs, ys, _s, ws, bs, Ss, xs, Os, ks, Es, Ts, As, Cs, qs, Ms, Rs, Me, mo, go, Is, $e, tf = Pe({ "node-modules-polyfills:process"() {
          A(), be = co, Se = fo, typeof globalThis.setTimeout == "function" && (be = setTimeout), typeof globalThis.clearTimeout == "function" && (Se = clearTimeout), me = [], Ne = false, We = -1, vo.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, gs = "browser", ys = "browser", _s = true, ws = {}, bs = [], Ss = "", xs = {}, Os = {}, ks = {}, Es = Ce, Ts = Ce, As = Ce, Cs = Ce, qs = Ce, Ms = Ce, Rs = Ce, Me = globalThis.performance || {}, mo = Me.now || Me.mozNow || Me.msNow || Me.oNow || Me.webkitNow || function() {
            return new Date().getTime();
          }, go = new Date(), Is = { nextTick: Kc, title: gs, browser: _s, env: ws, argv: bs, version: Ss, versions: xs, on: Es, addListener: Ts, once: As, off: Cs, removeListener: qs, removeAllListeners: Ms, emit: Rs, binding: Yc, cwd: Hc, chdir: Xc, umask: Zc, hrtime: ef, platform: ys, release: Os, config: ks, uptime: rf }, $e = Is;
        } }), ft, At, nf = Pe({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
          A(), typeof Object.create == "function" ? ft = function(i, s) {
            i.super_ = s, i.prototype = Object.create(s.prototype, { constructor: { value: i, enumerable: false, writable: true, configurable: true } });
          } : ft = function(i, s) {
            i.super_ = s;
            var f = function() {
            };
            f.prototype = s.prototype, i.prototype = new f(), i.prototype.constructor = i;
          }, At = ft;
        } }), yo = {};
        yr(yo, { _extend: () => It, debuglog: () => _o, default: () => Ao, deprecate: () => Ct, format: () => wr, inherits: () => At, inspect: () => ye, isArray: () => qt, isBoolean: () => br, isBuffer: () => xo, isDate: () => mr, isError: () => Qe, isFunction: () => Je, isNull: () => Ke, isNullOrUndefined: () => wo, isNumber: () => Mt, isObject: () => Le, isPrimitive: () => So, isRegExp: () => Ve, isString: () => Ye, isSymbol: () => bo, isUndefined: () => ge, log: () => Oo });
        function wr(e2) {
          if (!Ye(e2)) {
            for (var i = [], s = 0; s < arguments.length; s++)
              i.push(ye(arguments[s]));
            return i.join(" ");
          }
          for (var s = 1, f = arguments, a = f.length, p = String(e2).replace(Eo, function(h) {
            if (h === "%%")
              return "%";
            if (s >= a)
              return h;
            switch (h) {
              case "%s":
                return String(f[s++]);
              case "%d":
                return Number(f[s++]);
              case "%j":
                try {
                  return JSON.stringify(f[s++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return h;
            }
          }), c = f[s]; s < a; c = f[++s])
            Ke(c) || !Le(c) ? p += " " + c : p += " " + ye(c);
          return p;
        }
        function Ct(e2, i) {
          if (ge(globalThis.process))
            return function() {
              return Ct(e2, i).apply(this, arguments);
            };
          if ($e.noDeprecation === true)
            return e2;
          var s = false;
          function f() {
            if (!s) {
              if ($e.throwDeprecation)
                throw new Error(i);
              $e.traceDeprecation ? console.trace(i) : console.error(i), s = true;
            }
            return e2.apply(this, arguments);
          }
          return f;
        }
        function _o(e2) {
          if (ge(dt) && (dt = $e.env.NODE_DEBUG || ""), e2 = e2.toUpperCase(), !Ge[e2])
            if (new RegExp("\\b" + e2 + "\\b", "i").test(dt)) {
              var i = 0;
              Ge[e2] = function() {
                var s = wr.apply(null, arguments);
                console.error("%s %d: %s", e2, i, s);
              };
            } else
              Ge[e2] = function() {
              };
          return Ge[e2];
        }
        function ye(e2, i) {
          var s = { seen: [], stylize: of };
          return arguments.length >= 3 && (s.depth = arguments[2]), arguments.length >= 4 && (s.colors = arguments[3]), br(i) ? s.showHidden = i : i && It(s, i), ge(s.showHidden) && (s.showHidden = false), ge(s.depth) && (s.depth = 2), ge(s.colors) && (s.colors = false), ge(s.customInspect) && (s.customInspect = true), s.colors && (s.stylize = sf), vr(s, e2, s.depth);
        }
        function sf(e2, i) {
          var s = ye.styles[i];
          return s ? "\x1B[" + ye.colors[s][0] + "m" + e2 + "\x1B[" + ye.colors[s][1] + "m" : e2;
        }
        function of(e2, i) {
          return e2;
        }
        function af(e2) {
          var i = {};
          return e2.forEach(function(s, f) {
            i[s] = true;
          }), i;
        }
        function vr(e2, i, s) {
          if (e2.customInspect && i && Je(i.inspect) && i.inspect !== ye && !(i.constructor && i.constructor.prototype === i)) {
            var f = i.inspect(s, e2);
            return Ye(f) || (f = vr(e2, f, s)), f;
          }
          var a = uf(e2, i);
          if (a)
            return a;
          var p = Object.keys(i), c = af(p);
          if (e2.showHidden && (p = Object.getOwnPropertyNames(i)), Qe(i) && (p.indexOf("message") >= 0 || p.indexOf("description") >= 0))
            return ht(i);
          if (p.length === 0) {
            if (Je(i)) {
              var h = i.name ? ": " + i.name : "";
              return e2.stylize("[Function" + h + "]", "special");
            }
            if (Ve(i))
              return e2.stylize(RegExp.prototype.toString.call(i), "regexp");
            if (mr(i))
              return e2.stylize(Date.prototype.toString.call(i), "date");
            if (Qe(i))
              return ht(i);
          }
          var g = "", u = false, t = ["{", "}"];
          if (qt(i) && (u = true, t = ["[", "]"]), Je(i)) {
            var r = i.name ? ": " + i.name : "";
            g = " [Function" + r + "]";
          }
          if (Ve(i) && (g = " " + RegExp.prototype.toString.call(i)), mr(i) && (g = " " + Date.prototype.toUTCString.call(i)), Qe(i) && (g = " " + ht(i)), p.length === 0 && (!u || i.length == 0))
            return t[0] + g + t[1];
          if (s < 0)
            return Ve(i) ? e2.stylize(RegExp.prototype.toString.call(i), "regexp") : e2.stylize("[Object]", "special");
          e2.seen.push(i);
          var o;
          return u ? o = lf(e2, i, s, c, p) : o = p.map(function(n) {
            return bt(e2, i, s, c, n, u);
          }), e2.seen.pop(), cf(o, g, t);
        }
        function uf(e2, i) {
          if (ge(i))
            return e2.stylize("undefined", "undefined");
          if (Ye(i)) {
            var s = "'" + JSON.stringify(i).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e2.stylize(s, "string");
          }
          if (Mt(i))
            return e2.stylize("" + i, "number");
          if (br(i))
            return e2.stylize("" + i, "boolean");
          if (Ke(i))
            return e2.stylize("null", "null");
        }
        function ht(e2) {
          return "[" + Error.prototype.toString.call(e2) + "]";
        }
        function lf(e2, i, s, f, a) {
          for (var p = [], c = 0, h = i.length; c < h; ++c)
            ko(i, String(c)) ? p.push(bt(e2, i, s, f, String(c), true)) : p.push("");
          return a.forEach(function(g) {
            g.match(/^\d+$/) || p.push(bt(e2, i, s, f, g, true));
          }), p;
        }
        function bt(e2, i, s, f, a, p) {
          var c, h, g;
          if (g = Object.getOwnPropertyDescriptor(i, a) || { value: i[a] }, g.get ? g.set ? h = e2.stylize("[Getter/Setter]", "special") : h = e2.stylize("[Getter]", "special") : g.set && (h = e2.stylize("[Setter]", "special")), ko(f, a) || (c = "[" + a + "]"), h || (e2.seen.indexOf(g.value) < 0 ? (Ke(s) ? h = vr(e2, g.value, null) : h = vr(e2, g.value, s - 1), h.indexOf(`
`) > -1 && (p ? h = h.split(`
`).map(function(u) {
            return "  " + u;
          }).join(`
`).substr(2) : h = `
` + h.split(`
`).map(function(u) {
            return "   " + u;
          }).join(`
`))) : h = e2.stylize("[Circular]", "special")), ge(c)) {
            if (p && a.match(/^\d+$/))
              return h;
            c = JSON.stringify("" + a), c.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (c = c.substr(1, c.length - 2), c = e2.stylize(c, "name")) : (c = c.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), c = e2.stylize(c, "string"));
          }
          return c + ": " + h;
        }
        function cf(e2, i, s) {
          var f = 0, a = e2.reduce(function(p, c) {
            return f++, c.indexOf(`
`) >= 0 && f++, p + c.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return a > 60 ? s[0] + (i === "" ? "" : i + `
 `) + " " + e2.join(`,
  `) + " " + s[1] : s[0] + i + " " + e2.join(", ") + " " + s[1];
        }
        function qt(e2) {
          return Array.isArray(e2);
        }
        function br(e2) {
          return typeof e2 == "boolean";
        }
        function Ke(e2) {
          return e2 === null;
        }
        function wo(e2) {
          return e2 == null;
        }
        function Mt(e2) {
          return typeof e2 == "number";
        }
        function Ye(e2) {
          return typeof e2 == "string";
        }
        function bo(e2) {
          return typeof e2 == "symbol";
        }
        function ge(e2) {
          return e2 === void 0;
        }
        function Ve(e2) {
          return Le(e2) && Rt(e2) === "[object RegExp]";
        }
        function Le(e2) {
          return typeof e2 == "object" && e2 !== null;
        }
        function mr(e2) {
          return Le(e2) && Rt(e2) === "[object Date]";
        }
        function Qe(e2) {
          return Le(e2) && (Rt(e2) === "[object Error]" || e2 instanceof Error);
        }
        function Je(e2) {
          return typeof e2 == "function";
        }
        function So(e2) {
          return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || typeof e2 > "u";
        }
        function xo(e2) {
          return Buffer.isBuffer(e2);
        }
        function Rt(e2) {
          return Object.prototype.toString.call(e2);
        }
        function pt(e2) {
          return e2 < 10 ? "0" + e2.toString(10) : e2.toString(10);
        }
        function ff() {
          var e2 = new Date(), i = [pt(e2.getHours()), pt(e2.getMinutes()), pt(e2.getSeconds())].join(":");
          return [e2.getDate(), To[e2.getMonth()], i].join(" ");
        }
        function Oo() {
          console.log("%s - %s", ff(), wr.apply(null, arguments));
        }
        function It(e2, i) {
          if (!i || !Le(i))
            return e2;
          for (var s = Object.keys(i), f = s.length; f--; )
            e2[s[f]] = i[s[f]];
          return e2;
        }
        function ko(e2, i) {
          return Object.prototype.hasOwnProperty.call(e2, i);
        }
        var Eo, Ge, dt, To, Ao, hf = Pe({ "node-modules-polyfills:util"() {
          A(), tf(), nf(), Eo = /%[sdj%]/g, Ge = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, To = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Ao = { inherits: At, _extend: It, log: Oo, isBuffer: xo, isPrimitive: So, isFunction: Je, isError: Qe, isDate: mr, isObject: Le, isRegExp: Ve, isUndefined: ge, isSymbol: bo, isString: Ye, isNumber: Mt, isNullOrUndefined: wo, isNull: Ke, isBoolean: br, isArray: qt, inspect: ye, deprecate: Ct, format: wr, debuglog: _o };
        } }), pf = M({ "node-modules-polyfills-commonjs:util"(e2, i) {
          A();
          var s = (hf(), _r(yo));
          if (s && s.default) {
            i.exports = s.default;
            for (let f in s)
              i.exports[f] = s[f];
          } else
            s && (i.exports = s);
        } }), df = M({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(e2, i) {
          "use strict";
          A();
          var s = class extends Error {
            constructor(f) {
              super(f);
              this.name = this.constructor.name, this.message = f || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(f).stack;
            }
          };
          i.exports = s;
        } }), vf = M({ "node_modules/postcss-values-parser/lib/tokenize.js"(e2, i) {
          "use strict";
          A();
          var s = "{".charCodeAt(0), f = "}".charCodeAt(0), a = "(".charCodeAt(0), p = ")".charCodeAt(0), c = "'".charCodeAt(0), h = '"'.charCodeAt(0), g = "\\".charCodeAt(0), u = "/".charCodeAt(0), t = ".".charCodeAt(0), r = ",".charCodeAt(0), o = ":".charCodeAt(0), n = "*".charCodeAt(0), l = "-".charCodeAt(0), v = "+".charCodeAt(0), d = "#".charCodeAt(0), _ = `
`.charCodeAt(0), w = " ".charCodeAt(0), m = "\f".charCodeAt(0), y = "	".charCodeAt(0), b = "\r".charCodeAt(0), S = "@".charCodeAt(0), E = "e".charCodeAt(0), q = "E".charCodeAt(0), P = "0".charCodeAt(0), z = "9".charCodeAt(0), B = "u".charCodeAt(0), L = "U".charCodeAt(0), $ = /[ \n\t\r\{\(\)'"\\;,/]/g, G = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, k = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, j = /^[a-z0-9]/i, N = /^[a-f0-9?\-]/i, I = pf(), X = df();
          i.exports = function(Y, K) {
            K = K || {};
            let J = [], D = Y.valueOf(), H = D.length, Q = -1, C = 1, O = 0, x = 0, F = null, R, T, W, U, re, ne, le, fe, te, ie, ae, se;
            function ce(er) {
              let we = I.format("Unclosed %s at line: %d, column: %d, token: %d", er, C, O - Q, O);
              throw new X(we);
            }
            function he() {
              let er = I.format("Syntax error at line: %d, column: %d, token: %d", C, O - Q, O);
              throw new X(er);
            }
            for (; O < H; ) {
              switch (R = D.charCodeAt(O), R === _ && (Q = O, C += 1), R) {
                case _:
                case w:
                case y:
                case b:
                case m:
                  T = O;
                  do
                    T += 1, R = D.charCodeAt(T), R === _ && (Q = T, C += 1);
                  while (R === w || R === _ || R === y || R === b || R === m);
                  J.push(["space", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  break;
                case o:
                  T = O + 1, J.push(["colon", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  break;
                case r:
                  T = O + 1, J.push(["comma", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  break;
                case s:
                  J.push(["{", "{", C, O - Q, C, T - Q, O]);
                  break;
                case f:
                  J.push(["}", "}", C, O - Q, C, T - Q, O]);
                  break;
                case a:
                  x++, F = !F && x === 1 && J.length > 0 && J[J.length - 1][0] === "word" && J[J.length - 1][1] === "url", J.push(["(", "(", C, O - Q, C, T - Q, O]);
                  break;
                case p:
                  x--, F = F && x > 0, J.push([")", ")", C, O - Q, C, T - Q, O]);
                  break;
                case c:
                case h:
                  W = R === c ? "'" : '"', T = O;
                  do
                    for (ie = false, T = D.indexOf(W, T + 1), T === -1 && ce("quote", W), ae = T; D.charCodeAt(ae - 1) === g; )
                      ae -= 1, ie = !ie;
                  while (ie);
                  J.push(["string", D.slice(O, T + 1), C, O - Q, C, T - Q, O]), O = T;
                  break;
                case S:
                  $.lastIndex = O + 1, $.test(D), $.lastIndex === 0 ? T = D.length - 1 : T = $.lastIndex - 2, J.push(["atword", D.slice(O, T + 1), C, O - Q, C, T - Q, O]), O = T;
                  break;
                case g:
                  T = O, R = D.charCodeAt(T + 1), le && R !== u && R !== w && R !== _ && R !== y && R !== b && R !== m && (T += 1), J.push(["word", D.slice(O, T + 1), C, O - Q, C, T - Q, O]), O = T;
                  break;
                case v:
                case l:
                case n:
                  T = O + 1, se = D.slice(O + 1, T + 1);
                  let er = D.slice(O - 1, O);
                  if (R === l && se.charCodeAt(0) === l) {
                    T++, J.push(["word", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                    break;
                  }
                  J.push(["operator", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  break;
                default:
                  if (R === u && (D.charCodeAt(O + 1) === n || K.loose && !F && D.charCodeAt(O + 1) === u)) {
                    if (D.charCodeAt(O + 1) === n)
                      T = D.indexOf("*/", O + 2) + 1, T === 0 && ce("comment", "*/");
                    else {
                      let ze = D.indexOf(`
`, O + 2);
                      T = ze !== -1 ? ze - 1 : H;
                    }
                    ne = D.slice(O, T + 1), U = ne.split(`
`), re = U.length - 1, re > 0 ? (fe = C + re, te = T - U[re].length) : (fe = C, te = Q), J.push(["comment", ne, C, O - Q, fe, T - te, O]), Q = te, C = fe, O = T;
                  } else if (R === d && !j.test(D.slice(O + 1, O + 2)))
                    T = O + 1, J.push(["#", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  else if ((R === B || R === L) && D.charCodeAt(O + 1) === v) {
                    T = O + 2;
                    do
                      T += 1, R = D.charCodeAt(T);
                    while (T < H && N.test(D.slice(T, T + 1)));
                    J.push(["unicoderange", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  } else if (R === u)
                    T = O + 1, J.push(["operator", D.slice(O, T), C, O - Q, C, T - Q, O]), O = T - 1;
                  else {
                    let we = G;
                    if (R >= P && R <= z && (we = k), we.lastIndex = O + 1, we.test(D), we.lastIndex === 0 ? T = D.length - 1 : T = we.lastIndex - 2, we === k || R === t) {
                      let ze = D.charCodeAt(T), Ut = D.charCodeAt(T + 1), Gt = D.charCodeAt(T + 2);
                      (ze === E || ze === q) && (Ut === l || Ut === v) && Gt >= P && Gt <= z && (k.lastIndex = T + 2, k.test(D), k.lastIndex === 0 ? T = D.length - 1 : T = k.lastIndex - 2);
                    }
                    J.push(["word", D.slice(O, T + 1), C, O - Q, C, T - Q, O]), O = T;
                  }
                  break;
              }
              O++;
            }
            return J;
          };
        } }), Co = M({ "node_modules/flatten/index.js"(e2, i) {
          A(), i.exports = function(f, a) {
            if (a = typeof a == "number" ? a : 1 / 0, !a)
              return Array.isArray(f) ? f.map(function(c) {
                return c;
              }) : f;
            return p(f, 1);
            function p(c, h) {
              return c.reduce(function(g, u) {
                return Array.isArray(u) && h < a ? g.concat(p(u, h + 1)) : g.concat(u);
              }, []);
            }
          };
        } }), qo = M({ "node_modules/indexes-of/index.js"(e2, i) {
          A(), i.exports = function(s, f) {
            for (var a = -1, p = []; (a = s.indexOf(f, a + 1)) !== -1; )
              p.push(a);
            return p;
          };
        } }), Mo = M({ "node_modules/uniq/uniq.js"(e2, i) {
          "use strict";
          A();
          function s(p, c) {
            for (var h = 1, g = p.length, u = p[0], t = p[0], r = 1; r < g; ++r)
              if (t = u, u = p[r], c(u, t)) {
                if (r === h) {
                  h++;
                  continue;
                }
                p[h++] = u;
              }
            return p.length = h, p;
          }
          function f(p) {
            for (var c = 1, h = p.length, g = p[0], u = p[0], t = 1; t < h; ++t, u = g)
              if (u = g, g = p[t], g !== u) {
                if (t === c) {
                  c++;
                  continue;
                }
                p[c++] = g;
              }
            return p.length = c, p;
          }
          function a(p, c, h) {
            return p.length === 0 ? p : c ? (h || p.sort(c), s(p, c)) : (h || p.sort(), f(p));
          }
          i.exports = a;
        } }), mf = M({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(e2, i) {
          "use strict";
          A();
          var s = class extends Error {
            constructor(f) {
              super(f);
              this.name = this.constructor.name, this.message = f || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(f).stack;
            }
          };
          i.exports = s;
        } }), gf = M({ "node_modules/postcss-values-parser/lib/parser.js"(e2, i) {
          "use strict";
          A();
          var s = Vc(), f = Xs(), a = Zs(), p = eo(), c = ro(), h = to(), g = no(), u = io(), t = so(), r = oo(), o = ao(), n = uo(), l = lo(), v = vf(), d = Co(), _ = qo(), w = Mo(), m = mf();
          function y(b) {
            return b.sort((S, E) => S - E);
          }
          i.exports = class {
            constructor(S, E) {
              let q = { loose: false };
              this.cache = [], this.input = S, this.options = Object.assign({}, q, E), this.position = 0, this.unbalanced = 0, this.root = new s();
              let P = new f();
              this.root.append(P), this.current = P, this.tokens = v(S, this.options);
            }
            parse() {
              return this.loop();
            }
            colon() {
              let S = this.currToken;
              this.newNode(new p({ value: S[1], source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6] })), this.position++;
            }
            comma() {
              let S = this.currToken;
              this.newNode(new c({ value: S[1], source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6] })), this.position++;
            }
            comment() {
              let S = false, E = this.currToken[1].replace(/\/\*|\*\//g, ""), q;
              this.options.loose && E.startsWith("//") && (E = E.substring(2), S = true), q = new h({ value: E, inline: S, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(q), this.position++;
            }
            error(S, E) {
              throw new m(S + " at line: ".concat(E[2], ", column ").concat(E[3]));
            }
            loop() {
              for (; this.position < this.tokens.length; )
                this.parseTokens();
              return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
            }
            operator() {
              let S = this.currToken[1], E;
              if (S === "+" || S === "-") {
                if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
                  if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                    return this.word();
                } else if (this.nextToken[0] === "word")
                  return this.word();
              }
              return E = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(E);
            }
            parseTokens() {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "colon":
                  this.colon();
                  break;
                case "comma":
                  this.comma();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parenOpen();
                  break;
                case ")":
                  this.parenClose();
                  break;
                case "atword":
                case "word":
                  this.word();
                  break;
                case "operator":
                  this.operator();
                  break;
                case "string":
                  this.string();
                  break;
                case "unicoderange":
                  this.unicodeRange();
                  break;
                default:
                  this.word();
                  break;
              }
            }
            parenOpen() {
              let S = 1, E = this.position + 1, q = this.currToken, P;
              for (; E < this.tokens.length && S; ) {
                let z = this.tokens[E];
                z[0] === "(" && S++, z[0] === ")" && S--, E++;
              }
              if (S && this.error("Expected closing parenthesis", q), P = this.current.last, P && P.type === "func" && P.unbalanced < 0 && (P.unbalanced = 0, this.current = P), this.current.unbalanced++, this.newNode(new r({ value: q[1], source: { start: { line: q[2], column: q[3] }, end: { line: q[4], column: q[5] } }, sourceIndex: q[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
                let z = this.nextToken, B = this.currToken[1], L = { line: this.currToken[2], column: this.currToken[3] };
                for (; z && z[0] !== ")" && this.current.unbalanced; )
                  this.position++, B += this.currToken[1], z = this.nextToken;
                this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new n({ value: B, source: { start: L, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
              }
            }
            parenClose() {
              let S = this.currToken;
              this.newNode(new r({ value: S[1], source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", S), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
            }
            space() {
              let S = this.currToken;
              this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += S[1], this.position++) : (this.spaces = S[1], this.position++);
            }
            unicodeRange() {
              let S = this.currToken;
              this.newNode(new l({ value: S[1], source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6] })), this.position++;
            }
            splitWord() {
              let S = this.nextToken, E = this.currToken[1], q = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, P = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, z, B;
              if (!P.test(E))
                for (; S && S[0] === "word"; )
                  this.position++, E += this.currToken[1], S = this.nextToken;
              z = _(E, "@"), B = y(w(d([[0], z]))), B.forEach((L, $) => {
                let G = B[$ + 1] || E.length, k = E.slice(L, G), j;
                if (~z.indexOf(L))
                  j = new a({ value: k.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + L }, end: { line: this.currToken[4], column: this.currToken[3] + (G - 1) } }, sourceIndex: this.currToken[6] + B[$] });
                else if (q.test(this.currToken[1])) {
                  let N = k.replace(q, "");
                  j = new u({ value: k.replace(N, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + L }, end: { line: this.currToken[4], column: this.currToken[3] + (G - 1) } }, sourceIndex: this.currToken[6] + B[$], unit: N });
                } else
                  j = new (S && S[0] === "(" ? g : n)({ value: k, source: { start: { line: this.currToken[2], column: this.currToken[3] + L }, end: { line: this.currToken[4], column: this.currToken[3] + (G - 1) } }, sourceIndex: this.currToken[6] + B[$] }), j.type === "word" ? (j.isHex = /^#(.+)/.test(k), j.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(k)) : this.cache.push(this.current);
                this.newNode(j);
              }), this.position++;
            }
            string() {
              let S = this.currToken, E = this.currToken[1], q = /^(\"|\')/, P = q.test(E), z = "", B;
              P && (z = E.match(q)[0], E = E.slice(1, E.length - 1)), B = new o({ value: E, source: { start: { line: S[2], column: S[3] }, end: { line: S[4], column: S[5] } }, sourceIndex: S[6], quoted: P }), B.raws.quote = z, this.newNode(B), this.position++;
            }
            word() {
              return this.splitWord();
            }
            newNode(S) {
              return this.spaces && (S.raws.before += this.spaces, this.spaces = ""), this.current.append(S);
            }
            get currToken() {
              return this.tokens[this.position];
            }
            get nextToken() {
              return this.tokens[this.position + 1];
            }
            get prevToken() {
              return this.tokens[this.position - 1];
            }
          };
        } }), yf = M({ "node_modules/postcss-values-parser/lib/index.js"(e2, i) {
          "use strict";
          A();
          var s = gf(), f = Zs(), a = eo(), p = ro(), c = to(), h = no(), g = io(), u = so(), t = oo(), r = ao(), o = lo(), n = Xs(), l = uo(), v = function(d, _) {
            return new s(d, _);
          };
          v.atword = function(d) {
            return new f(d);
          }, v.colon = function(d) {
            return new a(Object.assign({ value: ":" }, d));
          }, v.comma = function(d) {
            return new p(Object.assign({ value: "," }, d));
          }, v.comment = function(d) {
            return new c(d);
          }, v.func = function(d) {
            return new h(d);
          }, v.number = function(d) {
            return new g(d);
          }, v.operator = function(d) {
            return new u(d);
          }, v.paren = function(d) {
            return new t(Object.assign({ value: "(" }, d));
          }, v.string = function(d) {
            return new r(Object.assign({ quote: "'" }, d));
          }, v.value = function(d) {
            return new n(d);
          }, v.word = function(d) {
            return new l(d);
          }, v.unicodeRange = function(d) {
            return new o(d);
          }, i.exports = v;
        } }), Be = M({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(c) {
            return typeof c;
          } : function(c) {
            return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
          };
          function f(c, h) {
            if (!(c instanceof h))
              throw new TypeError("Cannot call a class as a function");
          }
          var a = function c(h, g) {
            if ((typeof h > "u" ? "undefined" : s(h)) !== "object")
              return h;
            var u = new h.constructor();
            for (var t in h)
              if (!!h.hasOwnProperty(t)) {
                var r = h[t], o = typeof r > "u" ? "undefined" : s(r);
                t === "parent" && o === "object" ? g && (u[t] = g) : r instanceof Array ? u[t] = r.map(function(n) {
                  return c(n, u);
                }) : u[t] = c(r, u);
              }
            return u;
          }, p = function() {
            function c() {
              var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              f(this, c);
              for (var g in h)
                this[g] = h[g];
              var u = h.spaces;
              u = u === void 0 ? {} : u;
              var t = u.before, r = t === void 0 ? "" : t, o = u.after, n = o === void 0 ? "" : o;
              this.spaces = { before: r, after: n };
            }
            return c.prototype.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, c.prototype.replaceWith = function() {
              if (this.parent) {
                for (var g in arguments)
                  this.parent.insertBefore(this, arguments[g]);
                this.remove();
              }
              return this;
            }, c.prototype.next = function() {
              return this.parent.at(this.parent.index(this) + 1);
            }, c.prototype.prev = function() {
              return this.parent.at(this.parent.index(this) - 1);
            }, c.prototype.clone = function() {
              var g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = a(this);
              for (var t in g)
                u[t] = g[t];
              return u;
            }, c.prototype.toString = function() {
              return [this.spaces.before, String(this.value), this.spaces.after].join("");
            }, c;
          }();
          e2.default = p, i.exports = e2.default;
        } }), oe = M({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(e2) {
          "use strict";
          A(), e2.__esModule = true;
          var i = e2.TAG = "tag", s = e2.STRING = "string", f = e2.SELECTOR = "selector", a = e2.ROOT = "root", p = e2.PSEUDO = "pseudo", c = e2.NESTING = "nesting", h = e2.ID = "id", g = e2.COMMENT = "comment", u = e2.COMBINATOR = "combinator", t = e2.CLASS = "class", r = e2.ATTRIBUTE = "attribute", o = e2.UNIVERSAL = "universal";
        } }), Nt = M({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = function() {
            function n(l, v) {
              for (var d = 0; d < v.length; d++) {
                var _ = v[d];
                _.enumerable = _.enumerable || false, _.configurable = true, "value" in _ && (_.writable = true), Object.defineProperty(l, _.key, _);
              }
            }
            return function(l, v, d) {
              return v && n(l.prototype, v), d && n(l, d), l;
            };
          }(), f = Be(), a = g(f), p = oe(), c = h(p);
          function h(n) {
            if (n && n.__esModule)
              return n;
            var l = {};
            if (n != null)
              for (var v in n)
                Object.prototype.hasOwnProperty.call(n, v) && (l[v] = n[v]);
            return l.default = n, l;
          }
          function g(n) {
            return n && n.__esModule ? n : { default: n };
          }
          function u(n, l) {
            if (!(n instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function t(n, l) {
            if (!n)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : n;
          }
          function r(n, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            n.prototype = Object.create(l && l.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } }), l && (Object.setPrototypeOf ? Object.setPrototypeOf(n, l) : n.__proto__ = l);
          }
          var o = function(n) {
            r(l, n);
            function l(v) {
              u(this, l);
              var d = t(this, n.call(this, v));
              return d.nodes || (d.nodes = []), d;
            }
            return l.prototype.append = function(d) {
              return d.parent = this, this.nodes.push(d), this;
            }, l.prototype.prepend = function(d) {
              return d.parent = this, this.nodes.unshift(d), this;
            }, l.prototype.at = function(d) {
              return this.nodes[d];
            }, l.prototype.index = function(d) {
              return typeof d == "number" ? d : this.nodes.indexOf(d);
            }, l.prototype.removeChild = function(d) {
              d = this.index(d), this.at(d).parent = void 0, this.nodes.splice(d, 1);
              var _ = void 0;
              for (var w in this.indexes)
                _ = this.indexes[w], _ >= d && (this.indexes[w] = _ - 1);
              return this;
            }, l.prototype.removeAll = function() {
              for (var w = this.nodes, d = Array.isArray(w), _ = 0, w = d ? w : w[Symbol.iterator](); ; ) {
                var m;
                if (d) {
                  if (_ >= w.length)
                    break;
                  m = w[_++];
                } else {
                  if (_ = w.next(), _.done)
                    break;
                  m = _.value;
                }
                var y = m;
                y.parent = void 0;
              }
              return this.nodes = [], this;
            }, l.prototype.empty = function() {
              return this.removeAll();
            }, l.prototype.insertAfter = function(d, _) {
              var w = this.index(d);
              this.nodes.splice(w + 1, 0, _);
              var m = void 0;
              for (var y in this.indexes)
                m = this.indexes[y], w <= m && (this.indexes[y] = m + this.nodes.length);
              return this;
            }, l.prototype.insertBefore = function(d, _) {
              var w = this.index(d);
              this.nodes.splice(w, 0, _);
              var m = void 0;
              for (var y in this.indexes)
                m = this.indexes[y], w <= m && (this.indexes[y] = m + this.nodes.length);
              return this;
            }, l.prototype.each = function(d) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
              var _ = this.lastEach;
              if (this.indexes[_] = 0, !!this.length) {
                for (var w = void 0, m = void 0; this.indexes[_] < this.length && (w = this.indexes[_], m = d(this.at(w), w), m !== false); )
                  this.indexes[_] += 1;
                if (delete this.indexes[_], m === false)
                  return false;
              }
            }, l.prototype.walk = function(d) {
              return this.each(function(_, w) {
                var m = d(_, w);
                if (m !== false && _.length && (m = _.walk(d)), m === false)
                  return false;
              });
            }, l.prototype.walkAttributes = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.ATTRIBUTE)
                  return d.call(_, w);
              });
            }, l.prototype.walkClasses = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.CLASS)
                  return d.call(_, w);
              });
            }, l.prototype.walkCombinators = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.COMBINATOR)
                  return d.call(_, w);
              });
            }, l.prototype.walkComments = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.COMMENT)
                  return d.call(_, w);
              });
            }, l.prototype.walkIds = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.ID)
                  return d.call(_, w);
              });
            }, l.prototype.walkNesting = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.NESTING)
                  return d.call(_, w);
              });
            }, l.prototype.walkPseudos = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.PSEUDO)
                  return d.call(_, w);
              });
            }, l.prototype.walkTags = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.TAG)
                  return d.call(_, w);
              });
            }, l.prototype.walkUniversals = function(d) {
              var _ = this;
              return this.walk(function(w) {
                if (w.type === c.UNIVERSAL)
                  return d.call(_, w);
              });
            }, l.prototype.split = function(d) {
              var _ = this, w = [];
              return this.reduce(function(m, y, b) {
                var S = d.call(_, y);
                return w.push(y), S ? (m.push(w), w = []) : b === _.length - 1 && m.push(w), m;
              }, []);
            }, l.prototype.map = function(d) {
              return this.nodes.map(d);
            }, l.prototype.reduce = function(d, _) {
              return this.nodes.reduce(d, _);
            }, l.prototype.every = function(d) {
              return this.nodes.every(d);
            }, l.prototype.some = function(d) {
              return this.nodes.some(d);
            }, l.prototype.filter = function(d) {
              return this.nodes.filter(d);
            }, l.prototype.sort = function(d) {
              return this.nodes.sort(d);
            }, l.prototype.toString = function() {
              return this.map(String).join("");
            }, s(l, [{ key: "first", get: function() {
              return this.at(0);
            } }, { key: "last", get: function() {
              return this.at(this.length - 1);
            } }, { key: "length", get: function() {
              return this.nodes.length;
            } }]), l;
          }(a.default);
          e2.default = o, i.exports = e2.default;
        } }), Ro = M({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Nt(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.ROOT, n;
            }
            return r.prototype.toString = function() {
              var n = this.reduce(function(l, v) {
                var d = String(v);
                return d ? l + d + "," : "";
              }, "").slice(0, -1);
              return this.trailingComma ? n + "," : n;
            }, r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Io = M({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Nt(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.SELECTOR, n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), He = M({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = function() {
            function t(r, o) {
              for (var n = 0; n < o.length; n++) {
                var l = o[n];
                l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(r, l.key, l);
              }
            }
            return function(r, o, n) {
              return o && t(r.prototype, o), n && t(r, n), r;
            };
          }(), f = Be(), a = p(f);
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r() {
              return c(this, r), h(this, t.apply(this, arguments));
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
            }, s(r, [{ key: "ns", get: function() {
              var n = this.namespace;
              return n ? (typeof n == "string" ? n : "") + "|" : "";
            } }]), r;
          }(a.default);
          e2.default = u, i.exports = e2.default;
        } }), No = M({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = He(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.CLASS, n;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
            }, r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Po = M({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Be(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.COMMENT, n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Lo = M({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = He(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.ID, n;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
            }, r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), jo = M({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = He(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.TAG, n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Do = M({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Be(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.STRING, n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Bo = M({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Nt(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.PSEUDO, n;
            }
            return r.prototype.toString = function() {
              var n = this.length ? "(" + this.map(String).join(",") + ")" : "";
              return [this.spaces.before, String(this.value), n, this.spaces.after].join("");
            }, r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), zo = M({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = He(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.ATTRIBUTE, n.raws = {}, n;
            }
            return r.prototype.toString = function() {
              var n = [this.spaces.before, "[", this.ns, this.attribute];
              return this.operator && n.push(this.operator), this.value && n.push(this.value), this.raws.insensitive ? n.push(this.raws.insensitive) : this.insensitive && n.push(" i"), n.push("]"), n.concat(this.spaces.after).join("");
            }, r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Fo = M({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = He(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.UNIVERSAL, n.value = "*", n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Uo = M({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Be(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.COMBINATOR, n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), Go = M({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Be(), f = p(s), a = oe();
          function p(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function c(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var u = function(t) {
            g(r, t);
            function r(o) {
              c(this, r);
              var n = h(this, t.call(this, o));
              return n.type = a.NESTING, n.value = "&", n;
            }
            return r;
          }(f.default);
          e2.default = u, i.exports = e2.default;
        } }), _f = M({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = s;
          function s(f) {
            return f.sort(function(a, p) {
              return a - p;
            });
          }
          i.exports = e2.default;
        } }), wf = M({ "node_modules/postcss-selector-parser/dist/tokenize.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = B;
          var s = 39, f = 34, a = 92, p = 47, c = 10, h = 32, g = 12, u = 9, t = 13, r = 43, o = 62, n = 126, l = 124, v = 44, d = 40, _ = 41, w = 91, m = 93, y = 59, b = 42, S = 58, E = 38, q = 64, P = /[ \n\t\r\{\(\)'"\\;/]/g, z = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
          function B(L) {
            for (var $ = [], G = L.css.valueOf(), k = void 0, j = void 0, N = void 0, I = void 0, X = void 0, Z = void 0, Y = void 0, K = void 0, J = void 0, D = void 0, H = void 0, Q = G.length, C = -1, O = 1, x = 0, F = function(T, W) {
              if (L.safe)
                G += W, j = G.length - 1;
              else
                throw L.error("Unclosed " + T, O, x - C, x);
            }; x < Q; ) {
              switch (k = G.charCodeAt(x), k === c && (C = x, O += 1), k) {
                case c:
                case h:
                case u:
                case t:
                case g:
                  j = x;
                  do
                    j += 1, k = G.charCodeAt(j), k === c && (C = j, O += 1);
                  while (k === h || k === c || k === u || k === t || k === g);
                  $.push(["space", G.slice(x, j), O, x - C, x]), x = j - 1;
                  break;
                case r:
                case o:
                case n:
                case l:
                  j = x;
                  do
                    j += 1, k = G.charCodeAt(j);
                  while (k === r || k === o || k === n || k === l);
                  $.push(["combinator", G.slice(x, j), O, x - C, x]), x = j - 1;
                  break;
                case b:
                  $.push(["*", "*", O, x - C, x]);
                  break;
                case E:
                  $.push(["&", "&", O, x - C, x]);
                  break;
                case v:
                  $.push([",", ",", O, x - C, x]);
                  break;
                case w:
                  $.push(["[", "[", O, x - C, x]);
                  break;
                case m:
                  $.push(["]", "]", O, x - C, x]);
                  break;
                case S:
                  $.push([":", ":", O, x - C, x]);
                  break;
                case y:
                  $.push([";", ";", O, x - C, x]);
                  break;
                case d:
                  $.push(["(", "(", O, x - C, x]);
                  break;
                case _:
                  $.push([")", ")", O, x - C, x]);
                  break;
                case s:
                case f:
                  N = k === s ? "'" : '"', j = x;
                  do
                    for (D = false, j = G.indexOf(N, j + 1), j === -1 && F("quote", N), H = j; G.charCodeAt(H - 1) === a; )
                      H -= 1, D = !D;
                  while (D);
                  $.push(["string", G.slice(x, j + 1), O, x - C, O, j - C, x]), x = j;
                  break;
                case q:
                  P.lastIndex = x + 1, P.test(G), P.lastIndex === 0 ? j = G.length - 1 : j = P.lastIndex - 2, $.push(["at-word", G.slice(x, j + 1), O, x - C, O, j - C, x]), x = j;
                  break;
                case a:
                  for (j = x, Y = true; G.charCodeAt(j + 1) === a; )
                    j += 1, Y = !Y;
                  k = G.charCodeAt(j + 1), Y && k !== p && k !== h && k !== c && k !== u && k !== t && k !== g && (j += 1), $.push(["word", G.slice(x, j + 1), O, x - C, O, j - C, x]), x = j;
                  break;
                default:
                  k === p && G.charCodeAt(x + 1) === b ? (j = G.indexOf("*/", x + 2) + 1, j === 0 && F("comment", "*/"), Z = G.slice(x, j + 1), I = Z.split(`
`), X = I.length - 1, X > 0 ? (K = O + X, J = j - I[X].length) : (K = O, J = C), $.push(["comment", Z, O, x - C, K, j - J, x]), C = J, O = K, x = j) : (z.lastIndex = x + 1, z.test(G), z.lastIndex === 0 ? j = G.length - 1 : j = z.lastIndex - 2, $.push(["word", G.slice(x, j + 1), O, x - C, O, j - C, x]), x = j);
                  break;
              }
              x++;
            }
            return $;
          }
          i.exports = e2.default;
        } }), bf = M({ "node_modules/postcss-selector-parser/dist/parser.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = function() {
            function C(O, x) {
              for (var F = 0; F < x.length; F++) {
                var R = x[F];
                R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(O, R.key, R);
              }
            }
            return function(O, x, F) {
              return x && C(O.prototype, x), F && C(O, F), O;
            };
          }(), f = Co(), a = D(f), p = qo(), c = D(p), h = Mo(), g = D(h), u = Ro(), t = D(u), r = Io(), o = D(r), n = No(), l = D(n), v = Po(), d = D(v), _ = Lo(), w = D(_), m = jo(), y = D(m), b = Do(), S = D(b), E = Bo(), q = D(E), P = zo(), z = D(P), B = Fo(), L = D(B), $ = Uo(), G = D($), k = Go(), j = D(k), N = _f(), I = D(N), X = wf(), Z = D(X), Y = oe(), K = J(Y);
          function J(C) {
            if (C && C.__esModule)
              return C;
            var O = {};
            if (C != null)
              for (var x in C)
                Object.prototype.hasOwnProperty.call(C, x) && (O[x] = C[x]);
            return O.default = C, O;
          }
          function D(C) {
            return C && C.__esModule ? C : { default: C };
          }
          function H(C, O) {
            if (!(C instanceof O))
              throw new TypeError("Cannot call a class as a function");
          }
          var Q = function() {
            function C(O) {
              H(this, C), this.input = O, this.lossy = O.options.lossless === false, this.position = 0, this.root = new t.default();
              var x = new o.default();
              return this.root.append(x), this.current = x, this.lossy ? this.tokens = (0, Z.default)({ safe: O.safe, css: O.css.trim() }) : this.tokens = (0, Z.default)(O), this.loop();
            }
            return C.prototype.attribute = function() {
              var x = "", F = void 0, R = this.currToken;
              for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
                x += this.tokens[this.position][1], this.position++;
              this.position === this.tokens.length && !~x.indexOf("]") && this.error("Expected a closing square bracket.");
              var T = x.split(/((?:[*~^$|]?=))([^]*)/), W = T[0].split(/(\|)/g), U = { operator: T[1], value: T[2], source: { start: { line: R[2], column: R[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: R[4] };
              if (W.length > 1 ? (W[0] === "" && (W[0] = true), U.attribute = this.parseValue(W[2]), U.namespace = this.parseNamespace(W[0])) : U.attribute = this.parseValue(T[0]), F = new z.default(U), T[2]) {
                var re = T[2].split(/(\s+i\s*?)$/), ne = re[0].trim();
                F.value = this.lossy ? ne : re[0], re[1] && (F.insensitive = true, this.lossy || (F.raws.insensitive = re[1])), F.quoted = ne[0] === "'" || ne[0] === '"', F.raws.unquoted = F.quoted ? ne.slice(1, -1) : ne;
              }
              this.newNode(F), this.position++;
            }, C.prototype.combinator = function() {
              if (this.currToken[1] === "|")
                return this.namespace();
              for (var x = new G.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
                this.nextToken && this.nextToken[0] === "combinator" ? (x.spaces.before = this.parseSpace(this.currToken[1]), x.source.start.line = this.nextToken[2], x.source.start.column = this.nextToken[3], x.source.end.column = this.nextToken[3], x.source.end.line = this.nextToken[2], x.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? x.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? x.value = this.currToken[1] : this.currToken[0] === "space" && (x.value = this.parseSpace(this.currToken[1], " ")), this.position++;
              return this.newNode(x);
            }, C.prototype.comma = function() {
              if (this.position === this.tokens.length - 1) {
                this.root.trailingComma = true, this.position++;
                return;
              }
              var x = new o.default();
              this.current.parent.append(x), this.current = x, this.position++;
            }, C.prototype.comment = function() {
              var x = new d.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
              this.newNode(x), this.position++;
            }, C.prototype.error = function(x) {
              throw new this.input.error(x);
            }, C.prototype.missingBackslash = function() {
              return this.error("Expected a backslash preceding the semicolon.");
            }, C.prototype.missingParenthesis = function() {
              return this.error("Expected opening parenthesis.");
            }, C.prototype.missingSquareBracket = function() {
              return this.error("Expected opening square bracket.");
            }, C.prototype.namespace = function() {
              var x = this.prevToken && this.prevToken[1] || true;
              if (this.nextToken[0] === "word")
                return this.position++, this.word(x);
              if (this.nextToken[0] === "*")
                return this.position++, this.universal(x);
            }, C.prototype.nesting = function() {
              this.newNode(new j.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
            }, C.prototype.parentheses = function() {
              var x = this.current.last;
              if (x && x.type === K.PSEUDO) {
                var F = new o.default(), R = this.current;
                x.append(F), this.current = F;
                var T = 1;
                for (this.position++; this.position < this.tokens.length && T; )
                  this.currToken[0] === "(" && T++, this.currToken[0] === ")" && T--, T ? this.parse() : (F.parent.source.end.line = this.currToken[2], F.parent.source.end.column = this.currToken[3], this.position++);
                T && this.error("Expected closing parenthesis."), this.current = R;
              } else {
                var W = 1;
                for (this.position++, x.value += "("; this.position < this.tokens.length && W; )
                  this.currToken[0] === "(" && W++, this.currToken[0] === ")" && W--, x.value += this.parseParenthesisToken(this.currToken), this.position++;
                W && this.error("Expected closing parenthesis.");
              }
            }, C.prototype.pseudo = function() {
              for (var x = this, F = "", R = this.currToken; this.currToken && this.currToken[0] === ":"; )
                F += this.currToken[1], this.position++;
              if (!this.currToken)
                return this.error("Expected pseudo-class or pseudo-element");
              if (this.currToken[0] === "word") {
                var T = void 0;
                this.splitWord(false, function(W, U) {
                  F += W, T = new q.default({ value: F, source: { start: { line: R[2], column: R[3] }, end: { line: x.currToken[4], column: x.currToken[5] } }, sourceIndex: R[4] }), x.newNode(T), U > 1 && x.nextToken && x.nextToken[0] === "(" && x.error("Misplaced parenthesis.");
                });
              } else
                this.error('Unexpected "' + this.currToken[0] + '" found.');
            }, C.prototype.space = function() {
              var x = this.currToken;
              this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(x[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(x[1]), this.position++) : this.combinator();
            }, C.prototype.string = function() {
              var x = this.currToken;
              this.newNode(new S.default({ value: this.currToken[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }, C.prototype.universal = function(x) {
              var F = this.nextToken;
              if (F && F[1] === "|")
                return this.position++, this.namespace();
              this.newNode(new L.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), x), this.position++;
            }, C.prototype.splitWord = function(x, F) {
              for (var R = this, T = this.nextToken, W = this.currToken[1]; T && T[0] === "word"; ) {
                this.position++;
                var U = this.currToken[1];
                if (W += U, U.lastIndexOf("\\") === U.length - 1) {
                  var re = this.nextToken;
                  re && re[0] === "space" && (W += this.parseSpace(re[1], " "), this.position++);
                }
                T = this.nextToken;
              }
              var ne = (0, c.default)(W, "."), le = (0, c.default)(W, "#"), fe = (0, c.default)(W, "#{");
              fe.length && (le = le.filter(function(ie) {
                return !~fe.indexOf(ie);
              }));
              var te = (0, I.default)((0, g.default)((0, a.default)([[0], ne, le])));
              te.forEach(function(ie, ae) {
                var se = te[ae + 1] || W.length, ce = W.slice(ie, se);
                if (ae === 0 && F)
                  return F.call(R, ce, te.length);
                var he = void 0;
                ~ne.indexOf(ie) ? he = new l.default({ value: ce.slice(1), source: { start: { line: R.currToken[2], column: R.currToken[3] + ie }, end: { line: R.currToken[4], column: R.currToken[3] + (se - 1) } }, sourceIndex: R.currToken[6] + te[ae] }) : ~le.indexOf(ie) ? he = new w.default({ value: ce.slice(1), source: { start: { line: R.currToken[2], column: R.currToken[3] + ie }, end: { line: R.currToken[4], column: R.currToken[3] + (se - 1) } }, sourceIndex: R.currToken[6] + te[ae] }) : he = new y.default({ value: ce, source: { start: { line: R.currToken[2], column: R.currToken[3] + ie }, end: { line: R.currToken[4], column: R.currToken[3] + (se - 1) } }, sourceIndex: R.currToken[6] + te[ae] }), R.newNode(he, x);
              }), this.position++;
            }, C.prototype.word = function(x) {
              var F = this.nextToken;
              return F && F[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(x);
            }, C.prototype.loop = function() {
              for (; this.position < this.tokens.length; )
                this.parse(true);
              return this.root;
            }, C.prototype.parse = function(x) {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parentheses();
                  break;
                case ")":
                  x && this.missingParenthesis();
                  break;
                case "[":
                  this.attribute();
                  break;
                case "]":
                  this.missingSquareBracket();
                  break;
                case "at-word":
                case "word":
                  this.word();
                  break;
                case ":":
                  this.pseudo();
                  break;
                case ";":
                  this.missingBackslash();
                  break;
                case ",":
                  this.comma();
                  break;
                case "*":
                  this.universal();
                  break;
                case "&":
                  this.nesting();
                  break;
                case "combinator":
                  this.combinator();
                  break;
                case "string":
                  this.string();
                  break;
              }
            }, C.prototype.parseNamespace = function(x) {
              if (this.lossy && typeof x == "string") {
                var F = x.trim();
                return F.length ? F : true;
              }
              return x;
            }, C.prototype.parseSpace = function(x, F) {
              return this.lossy ? F || "" : x;
            }, C.prototype.parseValue = function(x) {
              return this.lossy && x && typeof x == "string" ? x.trim() : x;
            }, C.prototype.parseParenthesisToken = function(x) {
              return this.lossy ? x[0] === "space" ? this.parseSpace(x[1], " ") : this.parseValue(x[1]) : x[1];
            }, C.prototype.newNode = function(x, F) {
              return F && (x.namespace = this.parseNamespace(F)), this.spaces && (x.spaces.before = this.spaces, this.spaces = ""), this.current.append(x);
            }, s(C, [{ key: "currToken", get: function() {
              return this.tokens[this.position];
            } }, { key: "nextToken", get: function() {
              return this.tokens[this.position + 1];
            } }, { key: "prevToken", get: function() {
              return this.tokens[this.position - 1];
            } }]), C;
          }();
          e2.default = Q, i.exports = e2.default;
        } }), Sf = M({ "node_modules/postcss-selector-parser/dist/processor.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = function() {
            function g(u, t) {
              for (var r = 0; r < t.length; r++) {
                var o = t[r];
                o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(u, o.key, o);
              }
            }
            return function(u, t, r) {
              return t && g(u.prototype, t), r && g(u, r), u;
            };
          }(), f = bf(), a = p(f);
          function p(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function c(g, u) {
            if (!(g instanceof u))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = function() {
            function g(u) {
              return c(this, g), this.func = u || function() {
              }, this;
            }
            return g.prototype.process = function(t) {
              var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = new a.default({ css: t, error: function(l) {
                throw new Error(l);
              }, options: r });
              return this.res = o, this.func(o), this;
            }, s(g, [{ key: "result", get: function() {
              return String(this.res);
            } }]), g;
          }();
          e2.default = h, i.exports = e2.default;
        } }), xf = M({ "node_modules/postcss-selector-parser/dist/index.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true;
          var s = Sf(), f = k(s), a = zo(), p = k(a), c = No(), h = k(c), g = Uo(), u = k(g), t = Po(), r = k(t), o = Lo(), n = k(o), l = Go(), v = k(l), d = Bo(), _ = k(d), w = Ro(), m = k(w), y = Io(), b = k(y), S = Do(), E = k(S), q = jo(), P = k(q), z = Fo(), B = k(z), L = oe(), $ = G(L);
          function G(N) {
            if (N && N.__esModule)
              return N;
            var I = {};
            if (N != null)
              for (var X in N)
                Object.prototype.hasOwnProperty.call(N, X) && (I[X] = N[X]);
            return I.default = N, I;
          }
          function k(N) {
            return N && N.__esModule ? N : { default: N };
          }
          var j = function(I) {
            return new f.default(I);
          };
          j.attribute = function(N) {
            return new p.default(N);
          }, j.className = function(N) {
            return new h.default(N);
          }, j.combinator = function(N) {
            return new u.default(N);
          }, j.comment = function(N) {
            return new r.default(N);
          }, j.id = function(N) {
            return new n.default(N);
          }, j.nesting = function(N) {
            return new v.default(N);
          }, j.pseudo = function(N) {
            return new _.default(N);
          }, j.root = function(N) {
            return new m.default(N);
          }, j.selector = function(N) {
            return new b.default(N);
          }, j.string = function(N) {
            return new E.default(N);
          }, j.tag = function(N) {
            return new P.default(N);
          }, j.universal = function(N) {
            return new B.default(N);
          }, Object.keys($).forEach(function(N) {
            N !== "__esModule" && (j[N] = $[N]);
          }), e2.default = j, i.exports = e2.default;
        } }), Wo = M({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true });
          function i(s) {
            this.after = s.after, this.before = s.before, this.type = s.type, this.value = s.value, this.sourceIndex = s.sourceIndex;
          }
          e2.default = i;
        } }), $o = M({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true });
          var i = Wo(), s = f(i);
          function f(p) {
            return p && p.__esModule ? p : { default: p };
          }
          function a(p) {
            var c = this;
            this.constructor(p), this.nodes = p.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(h) {
              h.parent = c;
            });
          }
          a.prototype = Object.create(s.default.prototype), a.constructor = s.default, a.prototype.walk = function(c, h) {
            for (var g = typeof c == "string" || c instanceof RegExp, u = g ? h : c, t = typeof c == "string" ? new RegExp(c) : c, r = 0; r < this.nodes.length; r++) {
              var o = this.nodes[r], n = g ? t.test(o.type) : true;
              if (n && u && u(o, r, this.nodes) === false || o.nodes && o.walk(c, h) === false)
                return false;
            }
            return true;
          }, a.prototype.each = function() {
            for (var c = arguments.length <= 0 || arguments[0] === void 0 ? function() {
            } : arguments[0], h = 0; h < this.nodes.length; h++) {
              var g = this.nodes[h];
              if (c(g, h, this.nodes) === false)
                return false;
            }
            return true;
          }, e2.default = a;
        } }), Of = M({ "node_modules/postcss-media-query-parser/dist/parsers.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.parseMediaFeature = c, e2.parseMediaQuery = h, e2.parseMediaList = g;
          var i = Wo(), s = p(i), f = $o(), a = p(f);
          function p(u) {
            return u && u.__esModule ? u : { default: u };
          }
          function c(u) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [{ mode: "normal", character: null }], o = [], n = 0, l = "", v = null, d = null, _ = t, w = u;
            u[0] === "(" && u[u.length - 1] === ")" && (w = u.substring(1, u.length - 1), _++);
            for (var m = 0; m < w.length; m++) {
              var y = w[m];
              if ((y === "'" || y === '"') && (r[n].isCalculationEnabled === true ? (r.push({ mode: "string", isCalculationEnabled: false, character: y }), n++) : r[n].mode === "string" && r[n].character === y && w[m - 1] !== "\\" && (r.pop(), n--)), y === "{" ? (r.push({ mode: "interpolation", isCalculationEnabled: true }), n++) : y === "}" && (r.pop(), n--), r[n].mode === "normal" && y === ":") {
                var b = w.substring(m + 1);
                d = { type: "value", before: /^(\s*)/.exec(b)[1], after: /(\s*)$/.exec(b)[1], value: b.trim() }, d.sourceIndex = d.before.length + m + 1 + _, v = { type: "colon", sourceIndex: m + _, after: d.before, value: ":" };
                break;
              }
              l += y;
            }
            return l = { type: "media-feature", before: /^(\s*)/.exec(l)[1], after: /(\s*)$/.exec(l)[1], value: l.trim() }, l.sourceIndex = l.before.length + _, o.push(l), v !== null && (v.before = l.after, o.push(v)), d !== null && o.push(d), o;
          }
          function h(u) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [], o = 0, n = false, l = void 0;
            function v() {
              return { before: "", after: "", value: "" };
            }
            l = v();
            for (var d = 0; d < u.length; d++) {
              var _ = u[d];
              n ? (l.value += _, (_ === "{" || _ === "(") && o++, (_ === ")" || _ === "}") && o--) : _.search(/\s/) !== -1 ? l.before += _ : (_ === "(" && (l.type = "media-feature-expression", o++), l.value = _, l.sourceIndex = t + d, n = true), n && o === 0 && (_ === ")" || d === u.length - 1 || u[d + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(l.value) !== -1 && (l.type = "keyword"), l.type === "media-feature-expression" && (l.nodes = c(l.value, l.sourceIndex)), r.push(Array.isArray(l.nodes) ? new a.default(l) : new s.default(l)), l = v(), n = false);
            }
            for (var w = 0; w < r.length; w++)
              if (l = r[w], w > 0 && (r[w - 1].after = l.before), l.type === void 0) {
                if (w > 0) {
                  if (r[w - 1].type === "media-feature-expression") {
                    l.type = "keyword";
                    continue;
                  }
                  if (r[w - 1].value === "not" || r[w - 1].value === "only") {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w - 1].value === "and") {
                    l.type = "media-feature-expression";
                    continue;
                  }
                  r[w - 1].type === "media-type" && (r[w + 1] ? l.type = r[w + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : l.type = "media-feature-expression");
                }
                if (w === 0) {
                  if (!r[w + 1]) {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w + 1] && (r[w + 1].type === "media-feature-expression" || r[w + 1].type === "keyword")) {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w + 2]) {
                    if (r[w + 2].type === "media-feature-expression") {
                      l.type = "media-type", r[w + 1].type = "keyword";
                      continue;
                    }
                    if (r[w + 2].type === "keyword") {
                      l.type = "keyword", r[w + 1].type = "media-type";
                      continue;
                    }
                  }
                  if (r[w + 3] && r[w + 3].type === "media-feature-expression") {
                    l.type = "keyword", r[w + 1].type = "media-type", r[w + 2].type = "keyword";
                    continue;
                  }
                }
              }
            return r;
          }
          function g(u) {
            var t = [], r = 0, o = 0, n = /^(\s*)url\s*\(/.exec(u);
            if (n !== null) {
              for (var l = n[0].length, v = 1; v > 0; ) {
                var d = u[l];
                d === "(" && v++, d === ")" && v--, l++;
              }
              t.unshift(new s.default({ type: "url", value: u.substring(0, l).trim(), sourceIndex: n[1].length, before: n[1], after: /^(\s*)/.exec(u.substring(l))[1] })), r = l;
            }
            for (var _ = r; _ < u.length; _++) {
              var w = u[_];
              if (w === "(" && o++, w === ")" && o--, o === 0 && w === ",") {
                var m = u.substring(r, _), y = /^(\s*)/.exec(m)[1];
                t.push(new a.default({ type: "media-query", value: m.trim(), sourceIndex: r + y.length, nodes: h(m, r), before: y, after: /(\s*)$/.exec(m)[1] })), r = _ + 1;
              }
            }
            var b = u.substring(r), S = /^(\s*)/.exec(b)[1];
            return t.push(new a.default({ type: "media-query", value: b.trim(), sourceIndex: r + S.length, nodes: h(b, r), before: S, after: /(\s*)$/.exec(b)[1] })), t;
          }
        } }), kf = M({ "node_modules/postcss-media-query-parser/dist/index.js"(e2) {
          "use strict";
          A(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = p;
          var i = $o(), s = a(i), f = Of();
          function a(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function p(c) {
            return new s.default({ nodes: (0, f.parseMediaList)(c), type: "media-query-list", value: c.trim() });
          }
        } }), Vo = {};
        yr(Vo, { basename: () => Ho, default: () => Zo, delimiter: () => xt, dirname: () => Yo, extname: () => Xo, isAbsolute: () => Lt, join: () => Jo, normalize: () => Pt, relative: () => Ko, resolve: () => gr, sep: () => St });
        function Qo(e2, i) {
          for (var s = 0, f = e2.length - 1; f >= 0; f--) {
            var a = e2[f];
            a === "." ? e2.splice(f, 1) : a === ".." ? (e2.splice(f, 1), s++) : s && (e2.splice(f, 1), s--);
          }
          if (i)
            for (; s--; s)
              e2.unshift("..");
          return e2;
        }
        function gr() {
          for (var e2 = "", i = false, s = arguments.length - 1; s >= -1 && !i; s--) {
            var f = s >= 0 ? arguments[s] : "/";
            if (typeof f != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!f)
              continue;
            e2 = f + "/" + e2, i = f.charAt(0) === "/";
          }
          return e2 = Qo(jt(e2.split("/"), function(a) {
            return !!a;
          }), !i).join("/"), (i ? "/" : "") + e2 || ".";
        }
        function Pt(e2) {
          var i = Lt(e2), s = ea(e2, -1) === "/";
          return e2 = Qo(jt(e2.split("/"), function(f) {
            return !!f;
          }), !i).join("/"), !e2 && !i && (e2 = "."), e2 && s && (e2 += "/"), (i ? "/" : "") + e2;
        }
        function Lt(e2) {
          return e2.charAt(0) === "/";
        }
        function Jo() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return Pt(jt(e2, function(i, s) {
            if (typeof i != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return i;
          }).join("/"));
        }
        function Ko(e2, i) {
          e2 = gr(e2).substr(1), i = gr(i).substr(1);
          function s(u) {
            for (var t = 0; t < u.length && u[t] === ""; t++)
              ;
            for (var r = u.length - 1; r >= 0 && u[r] === ""; r--)
              ;
            return t > r ? [] : u.slice(t, r - t + 1);
          }
          for (var f = s(e2.split("/")), a = s(i.split("/")), p = Math.min(f.length, a.length), c = p, h = 0; h < p; h++)
            if (f[h] !== a[h]) {
              c = h;
              break;
            }
          for (var g = [], h = c; h < f.length; h++)
            g.push("..");
          return g = g.concat(a.slice(c)), g.join("/");
        }
        function Yo(e2) {
          var i = Sr(e2), s = i[0], f = i[1];
          return !s && !f ? "." : (f && (f = f.substr(0, f.length - 1)), s + f);
        }
        function Ho(e2, i) {
          var s = Sr(e2)[2];
          return i && s.substr(-1 * i.length) === i && (s = s.substr(0, s.length - i.length)), s;
        }
        function Xo(e2) {
          return Sr(e2)[3];
        }
        function jt(e2, i) {
          if (e2.filter)
            return e2.filter(i);
          for (var s = [], f = 0; f < e2.length; f++)
            i(e2[f], f, e2) && s.push(e2[f]);
          return s;
        }
        var Ns, Sr, St, xt, Zo, ea, Ef = Pe({ "node-modules-polyfills:path"() {
          A(), Ns = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Sr = function(e2) {
            return Ns.exec(e2).slice(1);
          }, St = "/", xt = ":", Zo = { extname: Xo, basename: Ho, dirname: Yo, sep: St, delimiter: xt, relative: Ko, join: Jo, isAbsolute: Lt, normalize: Pt, resolve: gr }, ea = "ab".substr(-1) === "b" ? function(e2, i, s) {
            return e2.substr(i, s);
          } : function(e2, i, s) {
            return i < 0 && (i = e2.length + i), e2.substr(i, s);
          };
        } }), Dt = M({ "node-modules-polyfills-commonjs:path"(e2, i) {
          A();
          var s = (Ef(), _r(Vo));
          if (s && s.default) {
            i.exports = s.default;
            for (let f in s)
              i.exports[f] = s[f];
          } else
            s && (i.exports = s);
        } }), Tf = M({ "node_modules/picocolors/picocolors.browser.js"(e2, i) {
          A();
          var s = String, f = function() {
            return { isColorSupported: false, reset: s, bold: s, dim: s, italic: s, underline: s, inverse: s, hidden: s, strikethrough: s, black: s, red: s, green: s, yellow: s, blue: s, magenta: s, cyan: s, white: s, gray: s, bgBlack: s, bgRed: s, bgGreen: s, bgYellow: s, bgBlue: s, bgMagenta: s, bgCyan: s, bgWhite: s };
          };
          i.exports = f(), i.exports.createColors = f;
        } }), Af = M({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
          A();
        } }), ra = M({ "node_modules/postcss/lib/css-syntax-error.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = a(Tf()), f = a(Af());
          function a(v) {
            return v && v.__esModule ? v : { default: v };
          }
          function p(v) {
            if (v === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return v;
          }
          function c(v, d) {
            v.prototype = Object.create(d.prototype), v.prototype.constructor = v, v.__proto__ = d;
          }
          function h(v) {
            var d = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
            return h = function(w) {
              if (w === null || !t(w))
                return w;
              if (typeof w != "function")
                throw new TypeError("Super expression must either be null or a function");
              if (typeof d < "u") {
                if (d.has(w))
                  return d.get(w);
                d.set(w, m);
              }
              function m() {
                return g(w, arguments, o(this).constructor);
              }
              return m.prototype = Object.create(w.prototype, { constructor: { value: m, enumerable: false, writable: true, configurable: true } }), r(m, w);
            }, h(v);
          }
          function g(v, d, _) {
            return u() ? g = Reflect.construct : g = function(m, y, b) {
              var S = [null];
              S.push.apply(S, y);
              var E = Function.bind.apply(m, S), q = new E();
              return b && r(q, b.prototype), q;
            }, g.apply(null, arguments);
          }
          function u() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch {
              return false;
            }
          }
          function t(v) {
            return Function.toString.call(v).indexOf("[native code]") !== -1;
          }
          function r(v, d) {
            return r = Object.setPrototypeOf || function(w, m) {
              return w.__proto__ = m, w;
            }, r(v, d);
          }
          function o(v) {
            return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(_) {
              return _.__proto__ || Object.getPrototypeOf(_);
            }, o(v);
          }
          var n = function(v) {
            c(d, v);
            function d(w, m, y, b, S, E) {
              var q;
              return q = v.call(this, w) || this, q.name = "CssSyntaxError", q.reason = w, S && (q.file = S), b && (q.source = b), E && (q.plugin = E), typeof m < "u" && typeof y < "u" && (q.line = m, q.column = y), q.setMessage(), Error.captureStackTrace && Error.captureStackTrace(p(q), d), q;
            }
            var _ = d.prototype;
            return _.setMessage = function() {
              this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
            }, _.showSourceCode = function(m) {
              var y = this;
              if (!this.source)
                return "";
              var b = this.source;
              f.default && (typeof m > "u" && (m = s.default.isColorSupported), m && (b = (0, f.default)(b)));
              var S = b.split(/\r?\n/), E = Math.max(this.line - 3, 0), q = Math.min(this.line + 2, S.length), P = String(q).length;
              function z(L) {
                return m && s.default.red ? s.default.red(s.default.bold(L)) : L;
              }
              function B(L) {
                return m && s.default.gray ? s.default.gray(L) : L;
              }
              return S.slice(E, q).map(function(L, $) {
                var G = E + 1 + $, k = " " + (" " + G).slice(-P) + " | ";
                if (G === y.line) {
                  var j = B(k.replace(/\d/g, " ")) + L.slice(0, y.column - 1).replace(/[^\t]/g, " ");
                  return z(">") + B(k) + L + `
 ` + j + z("^");
                }
                return " " + B(k) + L;
              }).join(`
`);
            }, _.toString = function() {
              var m = this.showSourceCode();
              return m && (m = `

` + m + `
`), this.name + ": " + this.message + m;
            }, d;
          }(h(Error)), l = n;
          e2.default = l, i.exports = e2.default;
        } }), Cf = M({ "node_modules/source-map/lib/base64.js"(e2) {
          A();
          var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
          e2.encode = function(s) {
            if (0 <= s && s < i.length)
              return i[s];
            throw new TypeError("Must be between 0 and 63: " + s);
          }, e2.decode = function(s) {
            var f = 65, a = 90, p = 97, c = 122, h = 48, g = 57, u = 43, t = 47, r = 26, o = 52;
            return f <= s && s <= a ? s - f : p <= s && s <= c ? s - p + r : h <= s && s <= g ? s - h + o : s == u ? 62 : s == t ? 63 : -1;
          };
        } }), ta = M({ "node_modules/source-map/lib/base64-vlq.js"(e2) {
          A();
          var i = Cf(), s = 5, f = 1 << s, a = f - 1, p = f;
          function c(g) {
            return g < 0 ? (-g << 1) + 1 : (g << 1) + 0;
          }
          function h(g) {
            var u = (g & 1) === 1, t = g >> 1;
            return u ? -t : t;
          }
          e2.encode = function(u) {
            var t = "", r, o = c(u);
            do
              r = o & a, o >>>= s, o > 0 && (r |= p), t += i.encode(r);
            while (o > 0);
            return t;
          }, e2.decode = function(u, t, r) {
            var o = u.length, n = 0, l = 0, v, d;
            do {
              if (t >= o)
                throw new Error("Expected more digits in base 64 VLQ value.");
              if (d = i.decode(u.charCodeAt(t++)), d === -1)
                throw new Error("Invalid base64 digit: " + u.charAt(t - 1));
              v = !!(d & p), d &= a, n = n + (d << l), l += s;
            } while (v);
            r.value = h(n), r.rest = t;
          };
        } }), Xe = M({ "node_modules/source-map/lib/util.js"(e2) {
          A();
          function i(y, b, S) {
            if (b in y)
              return y[b];
            if (arguments.length === 3)
              return S;
            throw new Error('"' + b + '" is a required argument.');
          }
          e2.getArg = i;
          var s = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, f = /^data:.+\,.+$/;
          function a(y) {
            var b = y.match(s);
            return b ? { scheme: b[1], auth: b[2], host: b[3], port: b[4], path: b[5] } : null;
          }
          e2.urlParse = a;
          function p(y) {
            var b = "";
            return y.scheme && (b += y.scheme + ":"), b += "//", y.auth && (b += y.auth + "@"), y.host && (b += y.host), y.port && (b += ":" + y.port), y.path && (b += y.path), b;
          }
          e2.urlGenerate = p;
          function c(y) {
            var b = y, S = a(y);
            if (S) {
              if (!S.path)
                return y;
              b = S.path;
            }
            for (var E = e2.isAbsolute(b), q = b.split(/\/+/), P, z = 0, B = q.length - 1; B >= 0; B--)
              P = q[B], P === "." ? q.splice(B, 1) : P === ".." ? z++ : z > 0 && (P === "" ? (q.splice(B + 1, z), z = 0) : (q.splice(B, 2), z--));
            return b = q.join("/"), b === "" && (b = E ? "/" : "."), S ? (S.path = b, p(S)) : b;
          }
          e2.normalize = c;
          function h(y, b) {
            y === "" && (y = "."), b === "" && (b = ".");
            var S = a(b), E = a(y);
            if (E && (y = E.path || "/"), S && !S.scheme)
              return E && (S.scheme = E.scheme), p(S);
            if (S || b.match(f))
              return b;
            if (E && !E.host && !E.path)
              return E.host = b, p(E);
            var q = b.charAt(0) === "/" ? b : c(y.replace(/\/+$/, "") + "/" + b);
            return E ? (E.path = q, p(E)) : q;
          }
          e2.join = h, e2.isAbsolute = function(y) {
            return y.charAt(0) === "/" || s.test(y);
          };
          function g(y, b) {
            y === "" && (y = "."), y = y.replace(/\/$/, "");
            for (var S = 0; b.indexOf(y + "/") !== 0; ) {
              var E = y.lastIndexOf("/");
              if (E < 0 || (y = y.slice(0, E), y.match(/^([^\/]+:\/)?\/*$/)))
                return b;
              ++S;
            }
            return Array(S + 1).join("../") + b.substr(y.length + 1);
          }
          e2.relative = g;
          var u = function() {
            var y = /* @__PURE__ */ Object.create(null);
            return !("__proto__" in y);
          }();
          function t(y) {
            return y;
          }
          function r(y) {
            return n(y) ? "$" + y : y;
          }
          e2.toSetString = u ? t : r;
          function o(y) {
            return n(y) ? y.slice(1) : y;
          }
          e2.fromSetString = u ? t : o;
          function n(y) {
            if (!y)
              return false;
            var b = y.length;
            if (b < 9 || y.charCodeAt(b - 1) !== 95 || y.charCodeAt(b - 2) !== 95 || y.charCodeAt(b - 3) !== 111 || y.charCodeAt(b - 4) !== 116 || y.charCodeAt(b - 5) !== 111 || y.charCodeAt(b - 6) !== 114 || y.charCodeAt(b - 7) !== 112 || y.charCodeAt(b - 8) !== 95 || y.charCodeAt(b - 9) !== 95)
              return false;
            for (var S = b - 10; S >= 0; S--)
              if (y.charCodeAt(S) !== 36)
                return false;
            return true;
          }
          function l(y, b, S) {
            var E = d(y.source, b.source);
            return E !== 0 || (E = y.originalLine - b.originalLine, E !== 0) || (E = y.originalColumn - b.originalColumn, E !== 0 || S) || (E = y.generatedColumn - b.generatedColumn, E !== 0) || (E = y.generatedLine - b.generatedLine, E !== 0) ? E : d(y.name, b.name);
          }
          e2.compareByOriginalPositions = l;
          function v(y, b, S) {
            var E = y.generatedLine - b.generatedLine;
            return E !== 0 || (E = y.generatedColumn - b.generatedColumn, E !== 0 || S) || (E = d(y.source, b.source), E !== 0) || (E = y.originalLine - b.originalLine, E !== 0) || (E = y.originalColumn - b.originalColumn, E !== 0) ? E : d(y.name, b.name);
          }
          e2.compareByGeneratedPositionsDeflated = v;
          function d(y, b) {
            return y === b ? 0 : y === null ? 1 : b === null ? -1 : y > b ? 1 : -1;
          }
          function _(y, b) {
            var S = y.generatedLine - b.generatedLine;
            return S !== 0 || (S = y.generatedColumn - b.generatedColumn, S !== 0) || (S = d(y.source, b.source), S !== 0) || (S = y.originalLine - b.originalLine, S !== 0) || (S = y.originalColumn - b.originalColumn, S !== 0) ? S : d(y.name, b.name);
          }
          e2.compareByGeneratedPositionsInflated = _;
          function w(y) {
            return JSON.parse(y.replace(/^\)]}'[^\n]*\n/, ""));
          }
          e2.parseSourceMapInput = w;
          function m(y, b, S) {
            if (b = b || "", y && (y[y.length - 1] !== "/" && b[0] !== "/" && (y += "/"), b = y + b), S) {
              var E = a(S);
              if (!E)
                throw new Error("sourceMapURL could not be parsed");
              if (E.path) {
                var q = E.path.lastIndexOf("/");
                q >= 0 && (E.path = E.path.substring(0, q + 1));
              }
              b = h(p(E), b);
            }
            return c(b);
          }
          e2.computeSourceURL = m;
        } }), na = M({ "node_modules/source-map/lib/array-set.js"(e2) {
          A();
          var i = Xe(), s = Object.prototype.hasOwnProperty, f = typeof Map < "u";
          function a() {
            this._array = [], this._set = f ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
          }
          a.fromArray = function(c, h) {
            for (var g = new a(), u = 0, t = c.length; u < t; u++)
              g.add(c[u], h);
            return g;
          }, a.prototype.size = function() {
            return f ? this._set.size : Object.getOwnPropertyNames(this._set).length;
          }, a.prototype.add = function(c, h) {
            var g = f ? c : i.toSetString(c), u = f ? this.has(c) : s.call(this._set, g), t = this._array.length;
            (!u || h) && this._array.push(c), u || (f ? this._set.set(c, t) : this._set[g] = t);
          }, a.prototype.has = function(c) {
            if (f)
              return this._set.has(c);
            var h = i.toSetString(c);
            return s.call(this._set, h);
          }, a.prototype.indexOf = function(c) {
            if (f) {
              var h = this._set.get(c);
              if (h >= 0)
                return h;
            } else {
              var g = i.toSetString(c);
              if (s.call(this._set, g))
                return this._set[g];
            }
            throw new Error('"' + c + '" is not in the set.');
          }, a.prototype.at = function(c) {
            if (c >= 0 && c < this._array.length)
              return this._array[c];
            throw new Error("No element indexed by " + c);
          }, a.prototype.toArray = function() {
            return this._array.slice();
          }, e2.ArraySet = a;
        } }), qf = M({ "node_modules/source-map/lib/mapping-list.js"(e2) {
          A();
          var i = Xe();
          function s(a, p) {
            var c = a.generatedLine, h = p.generatedLine, g = a.generatedColumn, u = p.generatedColumn;
            return h > c || h == c && u >= g || i.compareByGeneratedPositionsInflated(a, p) <= 0;
          }
          function f() {
            this._array = [], this._sorted = true, this._last = { generatedLine: -1, generatedColumn: 0 };
          }
          f.prototype.unsortedForEach = function(p, c) {
            this._array.forEach(p, c);
          }, f.prototype.add = function(p) {
            s(this._last, p) ? (this._last = p, this._array.push(p)) : (this._sorted = false, this._array.push(p));
          }, f.prototype.toArray = function() {
            return this._sorted || (this._array.sort(i.compareByGeneratedPositionsInflated), this._sorted = true), this._array;
          }, e2.MappingList = f;
        } }), ia = M({ "node_modules/source-map/lib/source-map-generator.js"(e2) {
          A();
          var i = ta(), s = Xe(), f = na().ArraySet, a = qf().MappingList;
          function p(c) {
            c || (c = {}), this._file = s.getArg(c, "file", null), this._sourceRoot = s.getArg(c, "sourceRoot", null), this._skipValidation = s.getArg(c, "skipValidation", false), this._sources = new f(), this._names = new f(), this._mappings = new a(), this._sourcesContents = null;
          }
          p.prototype._version = 3, p.fromSourceMap = function(h) {
            var g = h.sourceRoot, u = new p({ file: h.file, sourceRoot: g });
            return h.eachMapping(function(t) {
              var r = { generated: { line: t.generatedLine, column: t.generatedColumn } };
              t.source != null && (r.source = t.source, g != null && (r.source = s.relative(g, r.source)), r.original = { line: t.originalLine, column: t.originalColumn }, t.name != null && (r.name = t.name)), u.addMapping(r);
            }), h.sources.forEach(function(t) {
              var r = t;
              g !== null && (r = s.relative(g, t)), u._sources.has(r) || u._sources.add(r);
              var o = h.sourceContentFor(t);
              o != null && u.setSourceContent(t, o);
            }), u;
          }, p.prototype.addMapping = function(h) {
            var g = s.getArg(h, "generated"), u = s.getArg(h, "original", null), t = s.getArg(h, "source", null), r = s.getArg(h, "name", null);
            this._skipValidation || this._validateMapping(g, u, t, r), t != null && (t = String(t), this._sources.has(t) || this._sources.add(t)), r != null && (r = String(r), this._names.has(r) || this._names.add(r)), this._mappings.add({ generatedLine: g.line, generatedColumn: g.column, originalLine: u != null && u.line, originalColumn: u != null && u.column, source: t, name: r });
          }, p.prototype.setSourceContent = function(h, g) {
            var u = h;
            this._sourceRoot != null && (u = s.relative(this._sourceRoot, u)), g != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[s.toSetString(u)] = g) : this._sourcesContents && (delete this._sourcesContents[s.toSetString(u)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
          }, p.prototype.applySourceMap = function(h, g, u) {
            var t = g;
            if (g == null) {
              if (h.file == null)
                throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
              t = h.file;
            }
            var r = this._sourceRoot;
            r != null && (t = s.relative(r, t));
            var o = new f(), n = new f();
            this._mappings.unsortedForEach(function(l) {
              if (l.source === t && l.originalLine != null) {
                var v = h.originalPositionFor({ line: l.originalLine, column: l.originalColumn });
                v.source != null && (l.source = v.source, u != null && (l.source = s.join(u, l.source)), r != null && (l.source = s.relative(r, l.source)), l.originalLine = v.line, l.originalColumn = v.column, v.name != null && (l.name = v.name));
              }
              var d = l.source;
              d != null && !o.has(d) && o.add(d);
              var _ = l.name;
              _ != null && !n.has(_) && n.add(_);
            }, this), this._sources = o, this._names = n, h.sources.forEach(function(l) {
              var v = h.sourceContentFor(l);
              v != null && (u != null && (l = s.join(u, l)), r != null && (l = s.relative(r, l)), this.setSourceContent(l, v));
            }, this);
          }, p.prototype._validateMapping = function(h, g, u, t) {
            if (g && typeof g.line != "number" && typeof g.column != "number")
              throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
            if (!(h && "line" in h && "column" in h && h.line > 0 && h.column >= 0 && !g && !u && !t)) {
              if (h && "line" in h && "column" in h && g && "line" in g && "column" in g && h.line > 0 && h.column >= 0 && g.line > 0 && g.column >= 0 && u)
                return;
              throw new Error("Invalid mapping: " + JSON.stringify({ generated: h, source: u, original: g, name: t }));
            }
          }, p.prototype._serializeMappings = function() {
            for (var h = 0, g = 1, u = 0, t = 0, r = 0, o = 0, n = "", l, v, d, _, w = this._mappings.toArray(), m = 0, y = w.length; m < y; m++) {
              if (v = w[m], l = "", v.generatedLine !== g)
                for (h = 0; v.generatedLine !== g; )
                  l += ";", g++;
              else if (m > 0) {
                if (!s.compareByGeneratedPositionsInflated(v, w[m - 1]))
                  continue;
                l += ",";
              }
              l += i.encode(v.generatedColumn - h), h = v.generatedColumn, v.source != null && (_ = this._sources.indexOf(v.source), l += i.encode(_ - o), o = _, l += i.encode(v.originalLine - 1 - t), t = v.originalLine - 1, l += i.encode(v.originalColumn - u), u = v.originalColumn, v.name != null && (d = this._names.indexOf(v.name), l += i.encode(d - r), r = d)), n += l;
            }
            return n;
          }, p.prototype._generateSourcesContent = function(h, g) {
            return h.map(function(u) {
              if (!this._sourcesContents)
                return null;
              g != null && (u = s.relative(g, u));
              var t = s.toSetString(u);
              return Object.prototype.hasOwnProperty.call(this._sourcesContents, t) ? this._sourcesContents[t] : null;
            }, this);
          }, p.prototype.toJSON = function() {
            var h = { version: this._version, sources: this._sources.toArray(), names: this._names.toArray(), mappings: this._serializeMappings() };
            return this._file != null && (h.file = this._file), this._sourceRoot != null && (h.sourceRoot = this._sourceRoot), this._sourcesContents && (h.sourcesContent = this._generateSourcesContent(h.sources, h.sourceRoot)), h;
          }, p.prototype.toString = function() {
            return JSON.stringify(this.toJSON());
          }, e2.SourceMapGenerator = p;
        } }), Mf = M({ "node_modules/source-map/lib/binary-search.js"(e2) {
          A(), e2.GREATEST_LOWER_BOUND = 1, e2.LEAST_UPPER_BOUND = 2;
          function i(s, f, a, p, c, h) {
            var g = Math.floor((f - s) / 2) + s, u = c(a, p[g], true);
            return u === 0 ? g : u > 0 ? f - g > 1 ? i(g, f, a, p, c, h) : h == e2.LEAST_UPPER_BOUND ? f < p.length ? f : -1 : g : g - s > 1 ? i(s, g, a, p, c, h) : h == e2.LEAST_UPPER_BOUND ? g : s < 0 ? -1 : s;
          }
          e2.search = function(f, a, p, c) {
            if (a.length === 0)
              return -1;
            var h = i(-1, a.length, f, a, p, c || e2.GREATEST_LOWER_BOUND);
            if (h < 0)
              return -1;
            for (; h - 1 >= 0 && p(a[h], a[h - 1], true) === 0; )
              --h;
            return h;
          };
        } }), Rf = M({ "node_modules/source-map/lib/quick-sort.js"(e2) {
          A();
          function i(a, p, c) {
            var h = a[p];
            a[p] = a[c], a[c] = h;
          }
          function s(a, p) {
            return Math.round(a + Math.random() * (p - a));
          }
          function f(a, p, c, h) {
            if (c < h) {
              var g = s(c, h), u = c - 1;
              i(a, g, h);
              for (var t = a[h], r = c; r < h; r++)
                p(a[r], t) <= 0 && (u += 1, i(a, u, r));
              i(a, u + 1, r);
              var o = u + 1;
              f(a, p, c, o - 1), f(a, p, o + 1, h);
            }
          }
          e2.quickSort = function(a, p) {
            f(a, p, 0, a.length - 1);
          };
        } }), If = M({ "node_modules/source-map/lib/source-map-consumer.js"(e2) {
          A();
          var i = Xe(), s = Mf(), f = na().ArraySet, a = ta(), p = Rf().quickSort;
          function c(t, r) {
            var o = t;
            return typeof t == "string" && (o = i.parseSourceMapInput(t)), o.sections != null ? new u(o, r) : new h(o, r);
          }
          c.fromSourceMap = function(t, r) {
            return h.fromSourceMap(t, r);
          }, c.prototype._version = 3, c.prototype.__generatedMappings = null, Object.defineProperty(c.prototype, "_generatedMappings", { configurable: true, enumerable: true, get: function() {
            return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
          } }), c.prototype.__originalMappings = null, Object.defineProperty(c.prototype, "_originalMappings", { configurable: true, enumerable: true, get: function() {
            return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
          } }), c.prototype._charIsMappingSeparator = function(r, o) {
            var n = r.charAt(o);
            return n === ";" || n === ",";
          }, c.prototype._parseMappings = function(r, o) {
            throw new Error("Subclasses must implement _parseMappings");
          }, c.GENERATED_ORDER = 1, c.ORIGINAL_ORDER = 2, c.GREATEST_LOWER_BOUND = 1, c.LEAST_UPPER_BOUND = 2, c.prototype.eachMapping = function(r, o, n) {
            var l = o || null, v = n || c.GENERATED_ORDER, d;
            switch (v) {
              case c.GENERATED_ORDER:
                d = this._generatedMappings;
                break;
              case c.ORIGINAL_ORDER:
                d = this._originalMappings;
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
            var _ = this.sourceRoot;
            d.map(function(w) {
              var m = w.source === null ? null : this._sources.at(w.source);
              return m = i.computeSourceURL(_, m, this._sourceMapURL), { source: m, generatedLine: w.generatedLine, generatedColumn: w.generatedColumn, originalLine: w.originalLine, originalColumn: w.originalColumn, name: w.name === null ? null : this._names.at(w.name) };
            }, this).forEach(r, l);
          }, c.prototype.allGeneratedPositionsFor = function(r) {
            var o = i.getArg(r, "line"), n = { source: i.getArg(r, "source"), originalLine: o, originalColumn: i.getArg(r, "column", 0) };
            if (n.source = this._findSourceIndex(n.source), n.source < 0)
              return [];
            var l = [], v = this._findMapping(n, this._originalMappings, "originalLine", "originalColumn", i.compareByOriginalPositions, s.LEAST_UPPER_BOUND);
            if (v >= 0) {
              var d = this._originalMappings[v];
              if (r.column === void 0)
                for (var _ = d.originalLine; d && d.originalLine === _; )
                  l.push({ line: i.getArg(d, "generatedLine", null), column: i.getArg(d, "generatedColumn", null), lastColumn: i.getArg(d, "lastGeneratedColumn", null) }), d = this._originalMappings[++v];
              else
                for (var w = d.originalColumn; d && d.originalLine === o && d.originalColumn == w; )
                  l.push({ line: i.getArg(d, "generatedLine", null), column: i.getArg(d, "generatedColumn", null), lastColumn: i.getArg(d, "lastGeneratedColumn", null) }), d = this._originalMappings[++v];
            }
            return l;
          }, e2.SourceMapConsumer = c;
          function h(t, r) {
            var o = t;
            typeof t == "string" && (o = i.parseSourceMapInput(t));
            var n = i.getArg(o, "version"), l = i.getArg(o, "sources"), v = i.getArg(o, "names", []), d = i.getArg(o, "sourceRoot", null), _ = i.getArg(o, "sourcesContent", null), w = i.getArg(o, "mappings"), m = i.getArg(o, "file", null);
            if (n != this._version)
              throw new Error("Unsupported version: " + n);
            d && (d = i.normalize(d)), l = l.map(String).map(i.normalize).map(function(y) {
              return d && i.isAbsolute(d) && i.isAbsolute(y) ? i.relative(d, y) : y;
            }), this._names = f.fromArray(v.map(String), true), this._sources = f.fromArray(l, true), this._absoluteSources = this._sources.toArray().map(function(y) {
              return i.computeSourceURL(d, y, r);
            }), this.sourceRoot = d, this.sourcesContent = _, this._mappings = w, this._sourceMapURL = r, this.file = m;
          }
          h.prototype = Object.create(c.prototype), h.prototype.consumer = c, h.prototype._findSourceIndex = function(t) {
            var r = t;
            if (this.sourceRoot != null && (r = i.relative(this.sourceRoot, r)), this._sources.has(r))
              return this._sources.indexOf(r);
            var o;
            for (o = 0; o < this._absoluteSources.length; ++o)
              if (this._absoluteSources[o] == t)
                return o;
            return -1;
          }, h.fromSourceMap = function(r, o) {
            var n = Object.create(h.prototype), l = n._names = f.fromArray(r._names.toArray(), true), v = n._sources = f.fromArray(r._sources.toArray(), true);
            n.sourceRoot = r._sourceRoot, n.sourcesContent = r._generateSourcesContent(n._sources.toArray(), n.sourceRoot), n.file = r._file, n._sourceMapURL = o, n._absoluteSources = n._sources.toArray().map(function(E) {
              return i.computeSourceURL(n.sourceRoot, E, o);
            });
            for (var d = r._mappings.toArray().slice(), _ = n.__generatedMappings = [], w = n.__originalMappings = [], m = 0, y = d.length; m < y; m++) {
              var b = d[m], S = new g();
              S.generatedLine = b.generatedLine, S.generatedColumn = b.generatedColumn, b.source && (S.source = v.indexOf(b.source), S.originalLine = b.originalLine, S.originalColumn = b.originalColumn, b.name && (S.name = l.indexOf(b.name)), w.push(S)), _.push(S);
            }
            return p(n.__originalMappings, i.compareByOriginalPositions), n;
          }, h.prototype._version = 3, Object.defineProperty(h.prototype, "sources", { get: function() {
            return this._absoluteSources.slice();
          } });
          function g() {
            this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
          }
          h.prototype._parseMappings = function(r, o) {
            for (var n = 1, l = 0, v = 0, d = 0, _ = 0, w = 0, m = r.length, y = 0, b = {}, S = {}, E = [], q = [], P, z, B, L, $; y < m; )
              if (r.charAt(y) === ";")
                n++, y++, l = 0;
              else if (r.charAt(y) === ",")
                y++;
              else {
                for (P = new g(), P.generatedLine = n, L = y; L < m && !this._charIsMappingSeparator(r, L); L++)
                  ;
                if (z = r.slice(y, L), B = b[z], B)
                  y += z.length;
                else {
                  for (B = []; y < L; )
                    a.decode(r, y, S), $ = S.value, y = S.rest, B.push($);
                  if (B.length === 2)
                    throw new Error("Found a source, but no line and column");
                  if (B.length === 3)
                    throw new Error("Found a source and line, but no column");
                  b[z] = B;
                }
                P.generatedColumn = l + B[0], l = P.generatedColumn, B.length > 1 && (P.source = _ + B[1], _ += B[1], P.originalLine = v + B[2], v = P.originalLine, P.originalLine += 1, P.originalColumn = d + B[3], d = P.originalColumn, B.length > 4 && (P.name = w + B[4], w += B[4])), q.push(P), typeof P.originalLine == "number" && E.push(P);
              }
            p(q, i.compareByGeneratedPositionsDeflated), this.__generatedMappings = q, p(E, i.compareByOriginalPositions), this.__originalMappings = E;
          }, h.prototype._findMapping = function(r, o, n, l, v, d) {
            if (r[n] <= 0)
              throw new TypeError("Line must be greater than or equal to 1, got " + r[n]);
            if (r[l] < 0)
              throw new TypeError("Column must be greater than or equal to 0, got " + r[l]);
            return s.search(r, o, v, d);
          }, h.prototype.computeColumnSpans = function() {
            for (var r = 0; r < this._generatedMappings.length; ++r) {
              var o = this._generatedMappings[r];
              if (r + 1 < this._generatedMappings.length) {
                var n = this._generatedMappings[r + 1];
                if (o.generatedLine === n.generatedLine) {
                  o.lastGeneratedColumn = n.generatedColumn - 1;
                  continue;
                }
              }
              o.lastGeneratedColumn = 1 / 0;
            }
          }, h.prototype.originalPositionFor = function(r) {
            var o = { generatedLine: i.getArg(r, "line"), generatedColumn: i.getArg(r, "column") }, n = this._findMapping(o, this._generatedMappings, "generatedLine", "generatedColumn", i.compareByGeneratedPositionsDeflated, i.getArg(r, "bias", c.GREATEST_LOWER_BOUND));
            if (n >= 0) {
              var l = this._generatedMappings[n];
              if (l.generatedLine === o.generatedLine) {
                var v = i.getArg(l, "source", null);
                v !== null && (v = this._sources.at(v), v = i.computeSourceURL(this.sourceRoot, v, this._sourceMapURL));
                var d = i.getArg(l, "name", null);
                return d !== null && (d = this._names.at(d)), { source: v, line: i.getArg(l, "originalLine", null), column: i.getArg(l, "originalColumn", null), name: d };
              }
            }
            return { source: null, line: null, column: null, name: null };
          }, h.prototype.hasContentsOfAllSources = function() {
            return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(r) {
              return r == null;
            }) : false;
          }, h.prototype.sourceContentFor = function(r, o) {
            if (!this.sourcesContent)
              return null;
            var n = this._findSourceIndex(r);
            if (n >= 0)
              return this.sourcesContent[n];
            var l = r;
            this.sourceRoot != null && (l = i.relative(this.sourceRoot, l));
            var v;
            if (this.sourceRoot != null && (v = i.urlParse(this.sourceRoot))) {
              var d = l.replace(/^file:\/\//, "");
              if (v.scheme == "file" && this._sources.has(d))
                return this.sourcesContent[this._sources.indexOf(d)];
              if ((!v.path || v.path == "/") && this._sources.has("/" + l))
                return this.sourcesContent[this._sources.indexOf("/" + l)];
            }
            if (o)
              return null;
            throw new Error('"' + l + '" is not in the SourceMap.');
          }, h.prototype.generatedPositionFor = function(r) {
            var o = i.getArg(r, "source");
            if (o = this._findSourceIndex(o), o < 0)
              return { line: null, column: null, lastColumn: null };
            var n = { source: o, originalLine: i.getArg(r, "line"), originalColumn: i.getArg(r, "column") }, l = this._findMapping(n, this._originalMappings, "originalLine", "originalColumn", i.compareByOriginalPositions, i.getArg(r, "bias", c.GREATEST_LOWER_BOUND));
            if (l >= 0) {
              var v = this._originalMappings[l];
              if (v.source === n.source)
                return { line: i.getArg(v, "generatedLine", null), column: i.getArg(v, "generatedColumn", null), lastColumn: i.getArg(v, "lastGeneratedColumn", null) };
            }
            return { line: null, column: null, lastColumn: null };
          }, e2.BasicSourceMapConsumer = h;
          function u(t, r) {
            var o = t;
            typeof t == "string" && (o = i.parseSourceMapInput(t));
            var n = i.getArg(o, "version"), l = i.getArg(o, "sections");
            if (n != this._version)
              throw new Error("Unsupported version: " + n);
            this._sources = new f(), this._names = new f();
            var v = { line: -1, column: 0 };
            this._sections = l.map(function(d) {
              if (d.url)
                throw new Error("Support for url field in sections not implemented.");
              var _ = i.getArg(d, "offset"), w = i.getArg(_, "line"), m = i.getArg(_, "column");
              if (w < v.line || w === v.line && m < v.column)
                throw new Error("Section offsets must be ordered and non-overlapping.");
              return v = _, { generatedOffset: { generatedLine: w + 1, generatedColumn: m + 1 }, consumer: new c(i.getArg(d, "map"), r) };
            });
          }
          u.prototype = Object.create(c.prototype), u.prototype.constructor = c, u.prototype._version = 3, Object.defineProperty(u.prototype, "sources", { get: function() {
            for (var t = [], r = 0; r < this._sections.length; r++)
              for (var o = 0; o < this._sections[r].consumer.sources.length; o++)
                t.push(this._sections[r].consumer.sources[o]);
            return t;
          } }), u.prototype.originalPositionFor = function(r) {
            var o = { generatedLine: i.getArg(r, "line"), generatedColumn: i.getArg(r, "column") }, n = s.search(o, this._sections, function(v, d) {
              var _ = v.generatedLine - d.generatedOffset.generatedLine;
              return _ || v.generatedColumn - d.generatedOffset.generatedColumn;
            }), l = this._sections[n];
            return l ? l.consumer.originalPositionFor({ line: o.generatedLine - (l.generatedOffset.generatedLine - 1), column: o.generatedColumn - (l.generatedOffset.generatedLine === o.generatedLine ? l.generatedOffset.generatedColumn - 1 : 0), bias: r.bias }) : { source: null, line: null, column: null, name: null };
          }, u.prototype.hasContentsOfAllSources = function() {
            return this._sections.every(function(r) {
              return r.consumer.hasContentsOfAllSources();
            });
          }, u.prototype.sourceContentFor = function(r, o) {
            for (var n = 0; n < this._sections.length; n++) {
              var l = this._sections[n], v = l.consumer.sourceContentFor(r, true);
              if (v)
                return v;
            }
            if (o)
              return null;
            throw new Error('"' + r + '" is not in the SourceMap.');
          }, u.prototype.generatedPositionFor = function(r) {
            for (var o = 0; o < this._sections.length; o++) {
              var n = this._sections[o];
              if (n.consumer._findSourceIndex(i.getArg(r, "source")) !== -1) {
                var l = n.consumer.generatedPositionFor(r);
                if (l) {
                  var v = { line: l.line + (n.generatedOffset.generatedLine - 1), column: l.column + (n.generatedOffset.generatedLine === l.line ? n.generatedOffset.generatedColumn - 1 : 0) };
                  return v;
                }
              }
            }
            return { line: null, column: null };
          }, u.prototype._parseMappings = function(r, o) {
            this.__generatedMappings = [], this.__originalMappings = [];
            for (var n = 0; n < this._sections.length; n++)
              for (var l = this._sections[n], v = l.consumer._generatedMappings, d = 0; d < v.length; d++) {
                var _ = v[d], w = l.consumer._sources.at(_.source);
                w = i.computeSourceURL(l.consumer.sourceRoot, w, this._sourceMapURL), this._sources.add(w), w = this._sources.indexOf(w);
                var m = null;
                _.name && (m = l.consumer._names.at(_.name), this._names.add(m), m = this._names.indexOf(m));
                var y = { source: w, generatedLine: _.generatedLine + (l.generatedOffset.generatedLine - 1), generatedColumn: _.generatedColumn + (l.generatedOffset.generatedLine === _.generatedLine ? l.generatedOffset.generatedColumn - 1 : 0), originalLine: _.originalLine, originalColumn: _.originalColumn, name: m };
                this.__generatedMappings.push(y), typeof y.originalLine == "number" && this.__originalMappings.push(y);
              }
            p(this.__generatedMappings, i.compareByGeneratedPositionsDeflated), p(this.__originalMappings, i.compareByOriginalPositions);
          }, e2.IndexedSourceMapConsumer = u;
        } }), Nf = M({ "node_modules/source-map/lib/source-node.js"(e2) {
          A();
          var i = ia().SourceMapGenerator, s = Xe(), f = /(\r?\n)/, a = 10, p = "$$$isSourceNode$$$";
          function c(h, g, u, t, r) {
            this.children = [], this.sourceContents = {}, this.line = h == null ? null : h, this.column = g == null ? null : g, this.source = u == null ? null : u, this.name = r == null ? null : r, this[p] = true, t != null && this.add(t);
          }
          c.fromStringWithSourceMap = function(g, u, t) {
            var r = new c(), o = g.split(f), n = 0, l = function() {
              var m = b(), y = b() || "";
              return m + y;
              function b() {
                return n < o.length ? o[n++] : void 0;
              }
            }, v = 1, d = 0, _ = null;
            return u.eachMapping(function(m) {
              if (_ !== null)
                if (v < m.generatedLine)
                  w(_, l()), v++, d = 0;
                else {
                  var y = o[n] || "", b = y.substr(0, m.generatedColumn - d);
                  o[n] = y.substr(m.generatedColumn - d), d = m.generatedColumn, w(_, b), _ = m;
                  return;
                }
              for (; v < m.generatedLine; )
                r.add(l()), v++;
              if (d < m.generatedColumn) {
                var y = o[n] || "";
                r.add(y.substr(0, m.generatedColumn)), o[n] = y.substr(m.generatedColumn), d = m.generatedColumn;
              }
              _ = m;
            }, this), n < o.length && (_ && w(_, l()), r.add(o.splice(n).join(""))), u.sources.forEach(function(m) {
              var y = u.sourceContentFor(m);
              y != null && (t != null && (m = s.join(t, m)), r.setSourceContent(m, y));
            }), r;
            function w(m, y) {
              if (m === null || m.source === void 0)
                r.add(y);
              else {
                var b = t ? s.join(t, m.source) : m.source;
                r.add(new c(m.originalLine, m.originalColumn, b, y, m.name));
              }
            }
          }, c.prototype.add = function(g) {
            if (Array.isArray(g))
              g.forEach(function(u) {
                this.add(u);
              }, this);
            else if (g[p] || typeof g == "string")
              g && this.children.push(g);
            else
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + g);
            return this;
          }, c.prototype.prepend = function(g) {
            if (Array.isArray(g))
              for (var u = g.length - 1; u >= 0; u--)
                this.prepend(g[u]);
            else if (g[p] || typeof g == "string")
              this.children.unshift(g);
            else
              throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + g);
            return this;
          }, c.prototype.walk = function(g) {
            for (var u, t = 0, r = this.children.length; t < r; t++)
              u = this.children[t], u[p] ? u.walk(g) : u !== "" && g(u, { source: this.source, line: this.line, column: this.column, name: this.name });
          }, c.prototype.join = function(g) {
            var u, t, r = this.children.length;
            if (r > 0) {
              for (u = [], t = 0; t < r - 1; t++)
                u.push(this.children[t]), u.push(g);
              u.push(this.children[t]), this.children = u;
            }
            return this;
          }, c.prototype.replaceRight = function(g, u) {
            var t = this.children[this.children.length - 1];
            return t[p] ? t.replaceRight(g, u) : typeof t == "string" ? this.children[this.children.length - 1] = t.replace(g, u) : this.children.push("".replace(g, u)), this;
          }, c.prototype.setSourceContent = function(g, u) {
            this.sourceContents[s.toSetString(g)] = u;
          }, c.prototype.walkSourceContents = function(g) {
            for (var u = 0, t = this.children.length; u < t; u++)
              this.children[u][p] && this.children[u].walkSourceContents(g);
            for (var r = Object.keys(this.sourceContents), u = 0, t = r.length; u < t; u++)
              g(s.fromSetString(r[u]), this.sourceContents[r[u]]);
          }, c.prototype.toString = function() {
            var g = "";
            return this.walk(function(u) {
              g += u;
            }), g;
          }, c.prototype.toStringWithSourceMap = function(g) {
            var u = { code: "", line: 1, column: 0 }, t = new i(g), r = false, o = null, n = null, l = null, v = null;
            return this.walk(function(d, _) {
              u.code += d, _.source !== null && _.line !== null && _.column !== null ? ((o !== _.source || n !== _.line || l !== _.column || v !== _.name) && t.addMapping({ source: _.source, original: { line: _.line, column: _.column }, generated: { line: u.line, column: u.column }, name: _.name }), o = _.source, n = _.line, l = _.column, v = _.name, r = true) : r && (t.addMapping({ generated: { line: u.line, column: u.column } }), o = null, r = false);
              for (var w = 0, m = d.length; w < m; w++)
                d.charCodeAt(w) === a ? (u.line++, u.column = 0, w + 1 === m ? (o = null, r = false) : r && t.addMapping({ source: _.source, original: { line: _.line, column: _.column }, generated: { line: u.line, column: u.column }, name: _.name })) : u.column++;
            }), this.walkSourceContents(function(d, _) {
              t.setSourceContent(d, _);
            }), { code: u.code, map: t };
          }, e2.SourceNode = c;
        } }), sa = M({ "node_modules/source-map/source-map.js"(e2) {
          A(), e2.SourceMapGenerator = ia().SourceMapGenerator, e2.SourceMapConsumer = If().SourceMapConsumer, e2.SourceNode = Nf().SourceNode;
        } }), oa = {};
        yr(oa, { default: () => aa });
        var aa, Pf = Pe({ "node-modules-polyfills:fs"() {
          A(), aa = {};
        } }), Lf = M({ "node-modules-polyfills-commonjs:fs"(e2, i) {
          A();
          var s = (Pf(), _r(oa));
          if (s && s.default) {
            i.exports = s.default;
            for (let f in s)
              i.exports[f] = s[f];
          } else
            s && (i.exports = s);
        } }), jf = M({ "node_modules/postcss/lib/previous-map.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = p(sa()), f = p(Dt()), a = p(Lf());
          function p(u) {
            return u && u.__esModule ? u : { default: u };
          }
          function c(u) {
            return Buffer ? Buffer.from(u, "base64").toString() : window.atob(u);
          }
          var h = function() {
            function u(r, o) {
              this.loadAnnotation(r), this.inline = this.startWith(this.annotation, "data:");
              var n = o.map ? o.map.prev : void 0, l = this.loadMap(o.from, n);
              l && (this.text = l);
            }
            var t = u.prototype;
            return t.consumer = function() {
              return this.consumerCache || (this.consumerCache = new s.default.SourceMapConsumer(this.text)), this.consumerCache;
            }, t.withContent = function() {
              return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
            }, t.startWith = function(o, n) {
              return o ? o.substr(0, n.length) === n : false;
            }, t.getAnnotationURL = function(o) {
              return o.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
            }, t.loadAnnotation = function(o) {
              var n = o.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
              if (n && n.length > 0) {
                var l = n[n.length - 1];
                l && (this.annotation = this.getAnnotationURL(l));
              }
            }, t.decodeInline = function(o) {
              var n = /^data:application\/json;charset=utf-?8;base64,/, l = /^data:application\/json;base64,/, v = "data:application/json,";
              if (this.startWith(o, v))
                return decodeURIComponent(o.substr(v.length));
              if (n.test(o) || l.test(o))
                return c(o.substr(RegExp.lastMatch.length));
              var d = o.match(/data:application\/json;([^,]+),/)[1];
              throw new Error("Unsupported source map encoding " + d);
            }, t.loadMap = function(o, n) {
              if (n === false)
                return false;
              if (n) {
                if (typeof n == "string")
                  return n;
                if (typeof n == "function") {
                  var l = n(o);
                  if (l && a.default.existsSync && a.default.existsSync(l))
                    return a.default.readFileSync(l, "utf-8").toString().trim();
                  throw new Error("Unable to load previous source map: " + l.toString());
                } else {
                  if (n instanceof s.default.SourceMapConsumer)
                    return s.default.SourceMapGenerator.fromSourceMap(n).toString();
                  if (n instanceof s.default.SourceMapGenerator)
                    return n.toString();
                  if (this.isMap(n))
                    return JSON.stringify(n);
                  throw new Error("Unsupported previous source map format: " + n.toString());
                }
              } else {
                if (this.inline)
                  return this.decodeInline(this.annotation);
                if (this.annotation) {
                  var v = this.annotation;
                  return o && (v = f.default.join(f.default.dirname(o), v)), this.root = f.default.dirname(v), a.default.existsSync && a.default.existsSync(v) ? a.default.readFileSync(v, "utf-8").toString().trim() : false;
                }
              }
            }, t.isMap = function(o) {
              return typeof o != "object" ? false : typeof o.mappings == "string" || typeof o._mappings == "string";
            }, u;
          }(), g = h;
          e2.default = g, i.exports = e2.default;
        } }), xr = M({ "node_modules/postcss/lib/input.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = p(Dt()), f = p(ra()), a = p(jf());
          function p(r) {
            return r && r.__esModule ? r : { default: r };
          }
          function c(r, o) {
            for (var n = 0; n < o.length; n++) {
              var l = o[n];
              l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(r, l.key, l);
            }
          }
          function h(r, o, n) {
            return o && c(r.prototype, o), n && c(r, n), r;
          }
          var g = 0, u = function() {
            function r(n, l) {
              if (l === void 0 && (l = {}), n === null || typeof n > "u" || typeof n == "object" && !n.toString)
                throw new Error("PostCSS received " + n + " instead of CSS string");
              this.css = n.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, l.from && (/^\w+:\/\//.test(l.from) || s.default.isAbsolute(l.from) ? this.file = l.from : this.file = s.default.resolve(l.from));
              var v = new a.default(this.css, l);
              if (v.text) {
                this.map = v;
                var d = v.consumer().file;
                !this.file && d && (this.file = this.mapResolve(d));
              }
              this.file || (g += 1, this.id = "<input css " + g + ">"), this.map && (this.map.file = this.from);
            }
            var o = r.prototype;
            return o.error = function(l, v, d, _) {
              _ === void 0 && (_ = {});
              var w, m = this.origin(v, d);
              return m ? w = new f.default(l, m.line, m.column, m.source, m.file, _.plugin) : w = new f.default(l, v, d, this.css, this.file, _.plugin), w.input = { line: v, column: d, source: this.css }, this.file && (w.input.file = this.file), w;
            }, o.origin = function(l, v) {
              if (!this.map)
                return false;
              var d = this.map.consumer(), _ = d.originalPositionFor({ line: l, column: v });
              if (!_.source)
                return false;
              var w = { file: this.mapResolve(_.source), line: _.line, column: _.column }, m = d.sourceContentFor(_.source);
              return m && (w.source = m), w;
            }, o.mapResolve = function(l) {
              return /^\w+:\/\//.test(l) ? l : s.default.resolve(this.map.consumer().sourceRoot || ".", l);
            }, h(r, [{ key: "from", get: function() {
              return this.file || this.id;
            } }]), r;
          }(), t = u;
          e2.default = t, i.exports = e2.default;
        } }), Or = M({ "node_modules/postcss/lib/stringifier.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
          function f(c) {
            return c[0].toUpperCase() + c.slice(1);
          }
          var a = function() {
            function c(g) {
              this.builder = g;
            }
            var h = c.prototype;
            return h.stringify = function(u, t) {
              this[u.type](u, t);
            }, h.root = function(u) {
              this.body(u), u.raws.after && this.builder(u.raws.after);
            }, h.comment = function(u) {
              var t = this.raw(u, "left", "commentLeft"), r = this.raw(u, "right", "commentRight");
              this.builder("/*" + t + u.text + r + "*/", u);
            }, h.decl = function(u, t) {
              var r = this.raw(u, "between", "colon"), o = u.prop + r + this.rawValue(u, "value");
              u.important && (o += u.raws.important || " !important"), t && (o += ";"), this.builder(o, u);
            }, h.rule = function(u) {
              this.block(u, this.rawValue(u, "selector")), u.raws.ownSemicolon && this.builder(u.raws.ownSemicolon, u, "end");
            }, h.atrule = function(u, t) {
              var r = "@" + u.name, o = u.params ? this.rawValue(u, "params") : "";
              if (typeof u.raws.afterName < "u" ? r += u.raws.afterName : o && (r += " "), u.nodes)
                this.block(u, r + o);
              else {
                var n = (u.raws.between || "") + (t ? ";" : "");
                this.builder(r + o + n, u);
              }
            }, h.body = function(u) {
              for (var t = u.nodes.length - 1; t > 0 && u.nodes[t].type === "comment"; )
                t -= 1;
              for (var r = this.raw(u, "semicolon"), o = 0; o < u.nodes.length; o++) {
                var n = u.nodes[o], l = this.raw(n, "before");
                l && this.builder(l), this.stringify(n, t !== o || r);
              }
            }, h.block = function(u, t) {
              var r = this.raw(u, "between", "beforeOpen");
              this.builder(t + r + "{", u, "start");
              var o;
              u.nodes && u.nodes.length ? (this.body(u), o = this.raw(u, "after")) : o = this.raw(u, "after", "emptyBody"), o && this.builder(o), this.builder("}", u, "end");
            }, h.raw = function(u, t, r) {
              var o;
              if (r || (r = t), t && (o = u.raws[t], typeof o < "u"))
                return o;
              var n = u.parent;
              if (r === "before" && (!n || n.type === "root" && n.first === u))
                return "";
              if (!n)
                return s[r];
              var l = u.root();
              if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[r] < "u")
                return l.rawCache[r];
              if (r === "before" || r === "after")
                return this.beforeAfter(u, r);
              var v = "raw" + f(r);
              return this[v] ? o = this[v](l, u) : l.walk(function(d) {
                if (o = d.raws[t], typeof o < "u")
                  return false;
              }), typeof o > "u" && (o = s[r]), l.rawCache[r] = o, o;
            }, h.rawSemicolon = function(u) {
              var t;
              return u.walk(function(r) {
                if (r.nodes && r.nodes.length && r.last.type === "decl" && (t = r.raws.semicolon, typeof t < "u"))
                  return false;
              }), t;
            }, h.rawEmptyBody = function(u) {
              var t;
              return u.walk(function(r) {
                if (r.nodes && r.nodes.length === 0 && (t = r.raws.after, typeof t < "u"))
                  return false;
              }), t;
            }, h.rawIndent = function(u) {
              if (u.raws.indent)
                return u.raws.indent;
              var t;
              return u.walk(function(r) {
                var o = r.parent;
                if (o && o !== u && o.parent && o.parent === u && typeof r.raws.before < "u") {
                  var n = r.raws.before.split(`
`);
                  return t = n[n.length - 1], t = t.replace(/[^\s]/g, ""), false;
                }
              }), t;
            }, h.rawBeforeComment = function(u, t) {
              var r;
              return u.walkComments(function(o) {
                if (typeof o.raws.before < "u")
                  return r = o.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeDecl") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, h.rawBeforeDecl = function(u, t) {
              var r;
              return u.walkDecls(function(o) {
                if (typeof o.raws.before < "u")
                  return r = o.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeRule") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, h.rawBeforeRule = function(u) {
              var t;
              return u.walk(function(r) {
                if (r.nodes && (r.parent !== u || u.first !== r) && typeof r.raws.before < "u")
                  return t = r.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, h.rawBeforeClose = function(u) {
              var t;
              return u.walk(function(r) {
                if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u")
                  return t = r.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, h.rawBeforeOpen = function(u) {
              var t;
              return u.walk(function(r) {
                if (r.type !== "decl" && (t = r.raws.between, typeof t < "u"))
                  return false;
              }), t;
            }, h.rawColon = function(u) {
              var t;
              return u.walkDecls(function(r) {
                if (typeof r.raws.between < "u")
                  return t = r.raws.between.replace(/[^\s:]/g, ""), false;
              }), t;
            }, h.beforeAfter = function(u, t) {
              var r;
              u.type === "decl" ? r = this.raw(u, null, "beforeDecl") : u.type === "comment" ? r = this.raw(u, null, "beforeComment") : t === "before" ? r = this.raw(u, null, "beforeRule") : r = this.raw(u, null, "beforeClose");
              for (var o = u.parent, n = 0; o && o.type !== "root"; )
                n += 1, o = o.parent;
              if (r.indexOf(`
`) !== -1) {
                var l = this.raw(u, null, "indent");
                if (l.length)
                  for (var v = 0; v < n; v++)
                    r += l;
              }
              return r;
            }, h.rawValue = function(u, t) {
              var r = u[t], o = u.raws[t];
              return o && o.value === r ? o.raw : r;
            }, c;
          }(), p = a;
          e2.default = p, i.exports = e2.default;
        } }), ua = M({ "node_modules/postcss/lib/stringify.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Or());
          function f(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function a(c, h) {
            var g = new s.default(h);
            g.stringify(c);
          }
          var p = a;
          e2.default = p, i.exports = e2.default;
        } }), Bt = M({ "node_modules/postcss/lib/node.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = p(ra()), f = p(Or()), a = p(ua());
          function p(u) {
            return u && u.__esModule ? u : { default: u };
          }
          function c(u, t) {
            var r = new u.constructor();
            for (var o in u)
              if (!!u.hasOwnProperty(o)) {
                var n = u[o], l = typeof n;
                o === "parent" && l === "object" ? t && (r[o] = t) : o === "source" ? r[o] = n : n instanceof Array ? r[o] = n.map(function(v) {
                  return c(v, r);
                }) : (l === "object" && n !== null && (n = c(n)), r[o] = n);
              }
            return r;
          }
          var h = function() {
            function u(r) {
              r === void 0 && (r = {}), this.raws = {};
              for (var o in r)
                this[o] = r[o];
            }
            var t = u.prototype;
            return t.error = function(o, n) {
              if (n === void 0 && (n = {}), this.source) {
                var l = this.positionBy(n);
                return this.source.input.error(o, l.line, l.column, n);
              }
              return new s.default(o);
            }, t.warn = function(o, n, l) {
              var v = { node: this };
              for (var d in l)
                v[d] = l[d];
              return o.warn(n, v);
            }, t.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, t.toString = function(o) {
              o === void 0 && (o = a.default), o.stringify && (o = o.stringify);
              var n = "";
              return o(this, function(l) {
                n += l;
              }), n;
            }, t.clone = function(o) {
              o === void 0 && (o = {});
              var n = c(this);
              for (var l in o)
                n[l] = o[l];
              return n;
            }, t.cloneBefore = function(o) {
              o === void 0 && (o = {});
              var n = this.clone(o);
              return this.parent.insertBefore(this, n), n;
            }, t.cloneAfter = function(o) {
              o === void 0 && (o = {});
              var n = this.clone(o);
              return this.parent.insertAfter(this, n), n;
            }, t.replaceWith = function() {
              if (this.parent) {
                for (var o = arguments.length, n = new Array(o), l = 0; l < o; l++)
                  n[l] = arguments[l];
                for (var v = 0, d = n; v < d.length; v++) {
                  var _ = d[v];
                  this.parent.insertBefore(this, _);
                }
                this.remove();
              }
              return this;
            }, t.next = function() {
              if (!!this.parent) {
                var o = this.parent.index(this);
                return this.parent.nodes[o + 1];
              }
            }, t.prev = function() {
              if (!!this.parent) {
                var o = this.parent.index(this);
                return this.parent.nodes[o - 1];
              }
            }, t.before = function(o) {
              return this.parent.insertBefore(this, o), this;
            }, t.after = function(o) {
              return this.parent.insertAfter(this, o), this;
            }, t.toJSON = function() {
              var o = {};
              for (var n in this)
                if (!!this.hasOwnProperty(n) && n !== "parent") {
                  var l = this[n];
                  l instanceof Array ? o[n] = l.map(function(v) {
                    return typeof v == "object" && v.toJSON ? v.toJSON() : v;
                  }) : typeof l == "object" && l.toJSON ? o[n] = l.toJSON() : o[n] = l;
                }
              return o;
            }, t.raw = function(o, n) {
              var l = new f.default();
              return l.raw(this, o, n);
            }, t.root = function() {
              for (var o = this; o.parent; )
                o = o.parent;
              return o;
            }, t.cleanRaws = function(o) {
              delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
            }, t.positionInside = function(o) {
              for (var n = this.toString(), l = this.source.start.column, v = this.source.start.line, d = 0; d < o; d++)
                n[d] === `
` ? (l = 1, v += 1) : l += 1;
              return { line: v, column: l };
            }, t.positionBy = function(o) {
              var n = this.source.start;
              if (o.index)
                n = this.positionInside(o.index);
              else if (o.word) {
                var l = this.toString().indexOf(o.word);
                l !== -1 && (n = this.positionInside(l));
              }
              return n;
            }, u;
          }(), g = h;
          e2.default = g, i.exports = e2.default;
        } }), kr = M({ "node_modules/postcss/lib/comment.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Bt());
          function f(h) {
            return h && h.__esModule ? h : { default: h };
          }
          function a(h, g) {
            h.prototype = Object.create(g.prototype), h.prototype.constructor = h, h.__proto__ = g;
          }
          var p = function(h) {
            a(g, h);
            function g(u) {
              var t;
              return t = h.call(this, u) || this, t.type = "comment", t;
            }
            return g;
          }(s.default), c = p;
          e2.default = c, i.exports = e2.default;
        } }), la = M({ "node_modules/postcss/lib/declaration.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Bt());
          function f(h) {
            return h && h.__esModule ? h : { default: h };
          }
          function a(h, g) {
            h.prototype = Object.create(g.prototype), h.prototype.constructor = h, h.__proto__ = g;
          }
          var p = function(h) {
            a(g, h);
            function g(u) {
              var t;
              return t = h.call(this, u) || this, t.type = "decl", t;
            }
            return g;
          }(s.default), c = p;
          e2.default = c, i.exports = e2.default;
        } }), zt = M({ "node_modules/postcss/lib/tokenize.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = P;
          var s = "'".charCodeAt(0), f = '"'.charCodeAt(0), a = "\\".charCodeAt(0), p = "/".charCodeAt(0), c = `
`.charCodeAt(0), h = " ".charCodeAt(0), g = "\f".charCodeAt(0), u = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), o = "]".charCodeAt(0), n = "(".charCodeAt(0), l = ")".charCodeAt(0), v = "{".charCodeAt(0), d = "}".charCodeAt(0), _ = ";".charCodeAt(0), w = "*".charCodeAt(0), m = ":".charCodeAt(0), y = "@".charCodeAt(0), b = /[ \n\t\r\f{}()'"\\;/[\]#]/g, S = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, E = /.[\\/("'\n]/, q = /[a-f0-9]/i;
          function P(z, B) {
            B === void 0 && (B = {});
            var L = z.css.valueOf(), $ = B.ignoreErrors, G, k, j, N, I, X, Z, Y, K, J, D, H, Q, C, O = L.length, x = -1, F = 1, R = 0, T = [], W = [];
            function U() {
              return R;
            }
            function re(te) {
              throw z.error("Unclosed " + te, F, R - x);
            }
            function ne() {
              return W.length === 0 && R >= O;
            }
            function le(te) {
              if (W.length)
                return W.pop();
              if (!(R >= O)) {
                var ie = te ? te.ignoreUnclosed : false;
                switch (G = L.charCodeAt(R), (G === c || G === g || G === t && L.charCodeAt(R + 1) !== c) && (x = R, F += 1), G) {
                  case c:
                  case h:
                  case u:
                  case t:
                  case g:
                    k = R;
                    do
                      k += 1, G = L.charCodeAt(k), G === c && (x = k, F += 1);
                    while (G === h || G === c || G === u || G === t || G === g);
                    C = ["space", L.slice(R, k)], R = k - 1;
                    break;
                  case r:
                  case o:
                  case v:
                  case d:
                  case m:
                  case _:
                  case l:
                    var ae = String.fromCharCode(G);
                    C = [ae, ae, F, R - x];
                    break;
                  case n:
                    if (H = T.length ? T.pop()[1] : "", Q = L.charCodeAt(R + 1), H === "url" && Q !== s && Q !== f && Q !== h && Q !== c && Q !== u && Q !== g && Q !== t) {
                      k = R;
                      do {
                        if (J = false, k = L.indexOf(")", k + 1), k === -1)
                          if ($ || ie) {
                            k = R;
                            break;
                          } else
                            re("bracket");
                        for (D = k; L.charCodeAt(D - 1) === a; )
                          D -= 1, J = !J;
                      } while (J);
                      C = ["brackets", L.slice(R, k + 1), F, R - x, F, k - x], R = k;
                    } else
                      k = L.indexOf(")", R + 1), X = L.slice(R, k + 1), k === -1 || E.test(X) ? C = ["(", "(", F, R - x] : (C = ["brackets", X, F, R - x, F, k - x], R = k);
                    break;
                  case s:
                  case f:
                    j = G === s ? "'" : '"', k = R;
                    do {
                      if (J = false, k = L.indexOf(j, k + 1), k === -1)
                        if ($ || ie) {
                          k = R + 1;
                          break;
                        } else
                          re("string");
                      for (D = k; L.charCodeAt(D - 1) === a; )
                        D -= 1, J = !J;
                    } while (J);
                    X = L.slice(R, k + 1), N = X.split(`
`), I = N.length - 1, I > 0 ? (Y = F + I, K = k - N[I].length) : (Y = F, K = x), C = ["string", L.slice(R, k + 1), F, R - x, Y, k - K], x = K, F = Y, R = k;
                    break;
                  case y:
                    b.lastIndex = R + 1, b.test(L), b.lastIndex === 0 ? k = L.length - 1 : k = b.lastIndex - 2, C = ["at-word", L.slice(R, k + 1), F, R - x, F, k - x], R = k;
                    break;
                  case a:
                    for (k = R, Z = true; L.charCodeAt(k + 1) === a; )
                      k += 1, Z = !Z;
                    if (G = L.charCodeAt(k + 1), Z && G !== p && G !== h && G !== c && G !== u && G !== t && G !== g && (k += 1, q.test(L.charAt(k)))) {
                      for (; q.test(L.charAt(k + 1)); )
                        k += 1;
                      L.charCodeAt(k + 1) === h && (k += 1);
                    }
                    C = ["word", L.slice(R, k + 1), F, R - x, F, k - x], R = k;
                    break;
                  default:
                    G === p && L.charCodeAt(R + 1) === w ? (k = L.indexOf("*/", R + 2) + 1, k === 0 && ($ || ie ? k = L.length : re("comment")), X = L.slice(R, k + 1), N = X.split(`
`), I = N.length - 1, I > 0 ? (Y = F + I, K = k - N[I].length) : (Y = F, K = x), C = ["comment", X, F, R - x, Y, k - K], x = K, F = Y, R = k) : (S.lastIndex = R + 1, S.test(L), S.lastIndex === 0 ? k = L.length - 1 : k = S.lastIndex - 2, C = ["word", L.slice(R, k + 1), F, R - x, F, k - x], T.push(C), R = k);
                    break;
                }
                return R++, C;
              }
            }
            function fe(te) {
              W.push(te);
            }
            return { back: fe, nextToken: le, endOfFile: ne, position: U };
          }
          i.exports = e2.default;
        } }), ca = M({ "node_modules/postcss/lib/parse.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = a(Ft()), f = a(xr());
          function a(h) {
            return h && h.__esModule ? h : { default: h };
          }
          function p(h, g) {
            var u = new f.default(h, g), t = new s.default(u);
            try {
              t.parse();
            } catch (r) {
              throw r;
            }
            return t.root;
          }
          var c = p;
          e2.default = c, i.exports = e2.default;
        } }), Df = M({ "node_modules/postcss/lib/list.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = { split: function(p, c, h) {
            for (var g = [], u = "", t = false, r = 0, o = false, n = false, l = 0; l < p.length; l++) {
              var v = p[l];
              o ? n ? n = false : v === "\\" ? n = true : v === o && (o = false) : v === '"' || v === "'" ? o = v : v === "(" ? r += 1 : v === ")" ? r > 0 && (r -= 1) : r === 0 && c.indexOf(v) !== -1 && (t = true), t ? (u !== "" && g.push(u.trim()), u = "", t = false) : u += v;
            }
            return (h || u !== "") && g.push(u.trim()), g;
          }, space: function(p) {
            var c = [" ", `
`, "	"];
            return s.split(p, c);
          }, comma: function(p) {
            return s.split(p, [","], true);
          } }, f = s;
          e2.default = f, i.exports = e2.default;
        } }), fa = M({ "node_modules/postcss/lib/rule.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = a(Er()), f = a(Df());
          function a(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p(t, r) {
            for (var o = 0; o < r.length; o++) {
              var n = r[o];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
            }
          }
          function c(t, r, o) {
            return r && p(t.prototype, r), o && p(t, o), t;
          }
          function h(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var g = function(t) {
            h(r, t);
            function r(o) {
              var n;
              return n = t.call(this, o) || this, n.type = "rule", n.nodes || (n.nodes = []), n;
            }
            return c(r, [{ key: "selectors", get: function() {
              return f.default.comma(this.selector);
            }, set: function(n) {
              var l = this.selector ? this.selector.match(/,\s*/) : null, v = l ? l[0] : "," + this.raw("between", "beforeOpen");
              this.selector = n.join(v);
            } }]), r;
          }(s.default), u = g;
          e2.default = u, i.exports = e2.default;
        } }), Er = M({ "node_modules/postcss/lib/container.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = p(la()), f = p(kr()), a = p(Bt());
          function p(v) {
            return v && v.__esModule ? v : { default: v };
          }
          function c(v, d) {
            var _;
            if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
              if (Array.isArray(v) || (_ = h(v)) || d && v && typeof v.length == "number") {
                _ && (v = _);
                var w = 0;
                return function() {
                  return w >= v.length ? { done: true } : { done: false, value: v[w++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return _ = v[Symbol.iterator](), _.next.bind(_);
          }
          function h(v, d) {
            if (!!v) {
              if (typeof v == "string")
                return g(v, d);
              var _ = Object.prototype.toString.call(v).slice(8, -1);
              if (_ === "Object" && v.constructor && (_ = v.constructor.name), _ === "Map" || _ === "Set")
                return Array.from(v);
              if (_ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_))
                return g(v, d);
            }
          }
          function g(v, d) {
            (d == null || d > v.length) && (d = v.length);
            for (var _ = 0, w = new Array(d); _ < d; _++)
              w[_] = v[_];
            return w;
          }
          function u(v, d) {
            for (var _ = 0; _ < d.length; _++) {
              var w = d[_];
              w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(v, w.key, w);
            }
          }
          function t(v, d, _) {
            return d && u(v.prototype, d), _ && u(v, _), v;
          }
          function r(v, d) {
            v.prototype = Object.create(d.prototype), v.prototype.constructor = v, v.__proto__ = d;
          }
          function o(v) {
            return v.map(function(d) {
              return d.nodes && (d.nodes = o(d.nodes)), delete d.source, d;
            });
          }
          var n = function(v) {
            r(d, v);
            function d() {
              return v.apply(this, arguments) || this;
            }
            var _ = d.prototype;
            return _.push = function(m) {
              return m.parent = this, this.nodes.push(m), this;
            }, _.each = function(m) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              var y = this.lastEach;
              if (this.indexes[y] = 0, !!this.nodes) {
                for (var b, S; this.indexes[y] < this.nodes.length && (b = this.indexes[y], S = m(this.nodes[b], b), S !== false); )
                  this.indexes[y] += 1;
                return delete this.indexes[y], S;
              }
            }, _.walk = function(m) {
              return this.each(function(y, b) {
                var S;
                try {
                  S = m(y, b);
                } catch (q) {
                  if (q.postcssNode = y, q.stack && y.source && /\n\s{4}at /.test(q.stack)) {
                    var E = y.source;
                    q.stack = q.stack.replace(/\n\s{4}at /, "$&" + E.input.from + ":" + E.start.line + ":" + E.start.column + "$&");
                  }
                  throw q;
                }
                return S !== false && y.walk && (S = y.walk(m)), S;
              });
            }, _.walkDecls = function(m, y) {
              return y ? m instanceof RegExp ? this.walk(function(b, S) {
                if (b.type === "decl" && m.test(b.prop))
                  return y(b, S);
              }) : this.walk(function(b, S) {
                if (b.type === "decl" && b.prop === m)
                  return y(b, S);
              }) : (y = m, this.walk(function(b, S) {
                if (b.type === "decl")
                  return y(b, S);
              }));
            }, _.walkRules = function(m, y) {
              return y ? m instanceof RegExp ? this.walk(function(b, S) {
                if (b.type === "rule" && m.test(b.selector))
                  return y(b, S);
              }) : this.walk(function(b, S) {
                if (b.type === "rule" && b.selector === m)
                  return y(b, S);
              }) : (y = m, this.walk(function(b, S) {
                if (b.type === "rule")
                  return y(b, S);
              }));
            }, _.walkAtRules = function(m, y) {
              return y ? m instanceof RegExp ? this.walk(function(b, S) {
                if (b.type === "atrule" && m.test(b.name))
                  return y(b, S);
              }) : this.walk(function(b, S) {
                if (b.type === "atrule" && b.name === m)
                  return y(b, S);
              }) : (y = m, this.walk(function(b, S) {
                if (b.type === "atrule")
                  return y(b, S);
              }));
            }, _.walkComments = function(m) {
              return this.walk(function(y, b) {
                if (y.type === "comment")
                  return m(y, b);
              });
            }, _.append = function() {
              for (var m = arguments.length, y = new Array(m), b = 0; b < m; b++)
                y[b] = arguments[b];
              for (var S = 0, E = y; S < E.length; S++)
                for (var q = E[S], P = this.normalize(q, this.last), z = c(P), B; !(B = z()).done; ) {
                  var L = B.value;
                  this.nodes.push(L);
                }
              return this;
            }, _.prepend = function() {
              for (var m = arguments.length, y = new Array(m), b = 0; b < m; b++)
                y[b] = arguments[b];
              y = y.reverse();
              for (var S = c(y), E; !(E = S()).done; ) {
                for (var q = E.value, P = this.normalize(q, this.first, "prepend").reverse(), z = c(P), B; !(B = z()).done; ) {
                  var L = B.value;
                  this.nodes.unshift(L);
                }
                for (var $ in this.indexes)
                  this.indexes[$] = this.indexes[$] + P.length;
              }
              return this;
            }, _.cleanRaws = function(m) {
              if (v.prototype.cleanRaws.call(this, m), this.nodes)
                for (var y = c(this.nodes), b; !(b = y()).done; ) {
                  var S = b.value;
                  S.cleanRaws(m);
                }
            }, _.insertBefore = function(m, y) {
              m = this.index(m);
              for (var b = m === 0 ? "prepend" : false, S = this.normalize(y, this.nodes[m], b).reverse(), E = c(S), q; !(q = E()).done; ) {
                var P = q.value;
                this.nodes.splice(m, 0, P);
              }
              var z;
              for (var B in this.indexes)
                z = this.indexes[B], m <= z && (this.indexes[B] = z + S.length);
              return this;
            }, _.insertAfter = function(m, y) {
              m = this.index(m);
              for (var b = this.normalize(y, this.nodes[m]).reverse(), S = c(b), E; !(E = S()).done; ) {
                var q = E.value;
                this.nodes.splice(m + 1, 0, q);
              }
              var P;
              for (var z in this.indexes)
                P = this.indexes[z], m < P && (this.indexes[z] = P + b.length);
              return this;
            }, _.removeChild = function(m) {
              m = this.index(m), this.nodes[m].parent = void 0, this.nodes.splice(m, 1);
              var y;
              for (var b in this.indexes)
                y = this.indexes[b], y >= m && (this.indexes[b] = y - 1);
              return this;
            }, _.removeAll = function() {
              for (var m = c(this.nodes), y; !(y = m()).done; ) {
                var b = y.value;
                b.parent = void 0;
              }
              return this.nodes = [], this;
            }, _.replaceValues = function(m, y, b) {
              return b || (b = y, y = {}), this.walkDecls(function(S) {
                y.props && y.props.indexOf(S.prop) === -1 || y.fast && S.value.indexOf(y.fast) === -1 || (S.value = S.value.replace(m, b));
              }), this;
            }, _.every = function(m) {
              return this.nodes.every(m);
            }, _.some = function(m) {
              return this.nodes.some(m);
            }, _.index = function(m) {
              return typeof m == "number" ? m : this.nodes.indexOf(m);
            }, _.normalize = function(m, y) {
              var b = this;
              if (typeof m == "string") {
                var S = ca();
                m = o(S(m).nodes);
              } else if (Array.isArray(m)) {
                m = m.slice(0);
                for (var E = c(m), q; !(q = E()).done; ) {
                  var P = q.value;
                  P.parent && P.parent.removeChild(P, "ignore");
                }
              } else if (m.type === "root") {
                m = m.nodes.slice(0);
                for (var z = c(m), B; !(B = z()).done; ) {
                  var L = B.value;
                  L.parent && L.parent.removeChild(L, "ignore");
                }
              } else if (m.type)
                m = [m];
              else if (m.prop) {
                if (typeof m.value > "u")
                  throw new Error("Value field is missed in node creation");
                typeof m.value != "string" && (m.value = String(m.value)), m = [new s.default(m)];
              } else if (m.selector) {
                var $ = fa();
                m = [new $(m)];
              } else if (m.name) {
                var G = ha();
                m = [new G(m)];
              } else if (m.text)
                m = [new f.default(m)];
              else
                throw new Error("Unknown node type in node creation");
              var k = m.map(function(j) {
                return j.parent && j.parent.removeChild(j), typeof j.raws.before > "u" && y && typeof y.raws.before < "u" && (j.raws.before = y.raws.before.replace(/[^\s]/g, "")), j.parent = b, j;
              });
              return k;
            }, t(d, [{ key: "first", get: function() {
              if (!!this.nodes)
                return this.nodes[0];
            } }, { key: "last", get: function() {
              if (!!this.nodes)
                return this.nodes[this.nodes.length - 1];
            } }]), d;
          }(a.default), l = n;
          e2.default = l, i.exports = e2.default;
        } }), ha = M({ "node_modules/postcss/lib/at-rule.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Er());
          function f(h) {
            return h && h.__esModule ? h : { default: h };
          }
          function a(h, g) {
            h.prototype = Object.create(g.prototype), h.prototype.constructor = h, h.__proto__ = g;
          }
          var p = function(h) {
            a(g, h);
            function g(t) {
              var r;
              return r = h.call(this, t) || this, r.type = "atrule", r;
            }
            var u = g.prototype;
            return u.append = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var o = arguments.length, n = new Array(o), l = 0; l < o; l++)
                n[l] = arguments[l];
              return (r = h.prototype.append).call.apply(r, [this].concat(n));
            }, u.prepend = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var o = arguments.length, n = new Array(o), l = 0; l < o; l++)
                n[l] = arguments[l];
              return (r = h.prototype.prepend).call.apply(r, [this].concat(n));
            }, g;
          }(s.default), c = p;
          e2.default = c, i.exports = e2.default;
        } }), Bf = M({ "node_modules/postcss/lib/map-generator.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = a(sa()), f = a(Dt());
          function a(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p(t, r) {
            var o;
            if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
              if (Array.isArray(t) || (o = c(t)) || r && t && typeof t.length == "number") {
                o && (t = o);
                var n = 0;
                return function() {
                  return n >= t.length ? { done: true } : { done: false, value: t[n++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return o = t[Symbol.iterator](), o.next.bind(o);
          }
          function c(t, r) {
            if (!!t) {
              if (typeof t == "string")
                return h(t, r);
              var o = Object.prototype.toString.call(t).slice(8, -1);
              if (o === "Object" && t.constructor && (o = t.constructor.name), o === "Map" || o === "Set")
                return Array.from(t);
              if (o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))
                return h(t, r);
            }
          }
          function h(t, r) {
            (r == null || r > t.length) && (r = t.length);
            for (var o = 0, n = new Array(r); o < r; o++)
              n[o] = t[o];
            return n;
          }
          var g = function() {
            function t(o, n, l) {
              this.stringify = o, this.mapOpts = l.map || {}, this.root = n, this.opts = l;
            }
            var r = t.prototype;
            return r.isMap = function() {
              return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
            }, r.previous = function() {
              var n = this;
              return this.previousMaps || (this.previousMaps = [], this.root.walk(function(l) {
                if (l.source && l.source.input.map) {
                  var v = l.source.input.map;
                  n.previousMaps.indexOf(v) === -1 && n.previousMaps.push(v);
                }
              })), this.previousMaps;
            }, r.isInline = function() {
              if (typeof this.mapOpts.inline < "u")
                return this.mapOpts.inline;
              var n = this.mapOpts.annotation;
              return typeof n < "u" && n !== true ? false : this.previous().length ? this.previous().some(function(l) {
                return l.inline;
              }) : true;
            }, r.isSourcesContent = function() {
              return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some(function(n) {
                return n.withContent();
              }) : true;
            }, r.clearAnnotation = function() {
              if (this.mapOpts.annotation !== false)
                for (var n, l = this.root.nodes.length - 1; l >= 0; l--)
                  n = this.root.nodes[l], n.type === "comment" && n.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(l);
            }, r.setSourcesContent = function() {
              var n = this, l = {};
              this.root.walk(function(v) {
                if (v.source) {
                  var d = v.source.input.from;
                  if (d && !l[d]) {
                    l[d] = true;
                    var _ = n.relative(d);
                    n.map.setSourceContent(_, v.source.input.css);
                  }
                }
              });
            }, r.applyPrevMaps = function() {
              for (var n = p(this.previous()), l; !(l = n()).done; ) {
                var v = l.value, d = this.relative(v.file), _ = v.root || f.default.dirname(v.file), w = void 0;
                this.mapOpts.sourcesContent === false ? (w = new s.default.SourceMapConsumer(v.text), w.sourcesContent && (w.sourcesContent = w.sourcesContent.map(function() {
                  return null;
                }))) : w = v.consumer(), this.map.applySourceMap(w, d, this.relative(_));
              }
            }, r.isAnnotation = function() {
              return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some(function(n) {
                return n.annotation;
              }) : true;
            }, r.toBase64 = function(n) {
              return Buffer ? Buffer.from(n).toString("base64") : window.btoa(unescape(encodeURIComponent(n)));
            }, r.addAnnotation = function() {
              var n;
              this.isInline() ? n = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? n = this.mapOpts.annotation : n = this.outputFile() + ".map";
              var l = `
`;
              this.css.indexOf(`\r
`) !== -1 && (l = `\r
`), this.css += l + "/*# sourceMappingURL=" + n + " */";
            }, r.outputFile = function() {
              return this.opts.to ? this.relative(this.opts.to) : this.opts.from ? this.relative(this.opts.from) : "to.css";
            }, r.generateMap = function() {
              return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
            }, r.relative = function(n) {
              if (n.indexOf("<") === 0 || /^\w+:\/\//.test(n))
                return n;
              var l = this.opts.to ? f.default.dirname(this.opts.to) : ".";
              return typeof this.mapOpts.annotation == "string" && (l = f.default.dirname(f.default.resolve(l, this.mapOpts.annotation))), n = f.default.relative(l, n), f.default.sep === "\\" ? n.replace(/\\/g, "/") : n;
            }, r.sourcePath = function(n) {
              return this.mapOpts.from ? this.mapOpts.from : this.relative(n.source.input.from);
            }, r.generateString = function() {
              var n = this;
              this.css = "", this.map = new s.default.SourceMapGenerator({ file: this.outputFile() });
              var l = 1, v = 1, d, _;
              this.stringify(this.root, function(w, m, y) {
                if (n.css += w, m && y !== "end" && (m.source && m.source.start ? n.map.addMapping({ source: n.sourcePath(m), generated: { line: l, column: v - 1 }, original: { line: m.source.start.line, column: m.source.start.column - 1 } }) : n.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line: l, column: v - 1 } })), d = w.match(/\n/g), d ? (l += d.length, _ = w.lastIndexOf(`
`), v = w.length - _) : v += w.length, m && y !== "start") {
                  var b = m.parent || { raws: {} };
                  (m.type !== "decl" || m !== b.last || b.raws.semicolon) && (m.source && m.source.end ? n.map.addMapping({ source: n.sourcePath(m), generated: { line: l, column: v - 2 }, original: { line: m.source.end.line, column: m.source.end.column - 1 } }) : n.map.addMapping({ source: "<no source>", original: { line: 1, column: 0 }, generated: { line: l, column: v - 1 } }));
                }
              });
            }, r.generate = function() {
              if (this.clearAnnotation(), this.isMap())
                return this.generateMap();
              var n = "";
              return this.stringify(this.root, function(l) {
                n += l;
              }), [n];
            }, t;
          }(), u = g;
          e2.default = u, i.exports = e2.default;
        } }), zf = M({ "node_modules/postcss/lib/warn-once.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = f;
          var s = {};
          function f(a) {
            s[a] || (s[a] = true, typeof console < "u" && console.warn && console.warn(a));
          }
          i.exports = e2.default;
        } }), Ff = M({ "node_modules/postcss/lib/warning.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = function() {
            function a(c, h) {
              if (h === void 0 && (h = {}), this.type = "warning", this.text = c, h.node && h.node.source) {
                var g = h.node.positionBy(h);
                this.line = g.line, this.column = g.column;
              }
              for (var u in h)
                this[u] = h[u];
            }
            var p = a.prototype;
            return p.toString = function() {
              return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
            }, a;
          }(), f = s;
          e2.default = f, i.exports = e2.default;
        } }), Uf = M({ "node_modules/postcss/lib/result.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Ff());
          function f(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function a(g, u) {
            for (var t = 0; t < u.length; t++) {
              var r = u[t];
              r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(g, r.key, r);
            }
          }
          function p(g, u, t) {
            return u && a(g.prototype, u), t && a(g, t), g;
          }
          var c = function() {
            function g(t, r, o) {
              this.processor = t, this.messages = [], this.root = r, this.opts = o, this.css = void 0, this.map = void 0;
            }
            var u = g.prototype;
            return u.toString = function() {
              return this.css;
            }, u.warn = function(r, o) {
              o === void 0 && (o = {}), o.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (o.plugin = this.lastPlugin.postcssPlugin);
              var n = new s.default(r, o);
              return this.messages.push(n), n;
            }, u.warnings = function() {
              return this.messages.filter(function(r) {
                return r.type === "warning";
              });
            }, p(g, [{ key: "content", get: function() {
              return this.css;
            } }]), g;
          }(), h = c;
          e2.default = h, i.exports = e2.default;
        } }), pa = M({ "node_modules/postcss/lib/lazy-result.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = h(Bf()), f = h(ua()), a = h(zf()), p = h(Uf()), c = h(ca());
          function h(d) {
            return d && d.__esModule ? d : { default: d };
          }
          function g(d, _) {
            var w;
            if (typeof Symbol > "u" || d[Symbol.iterator] == null) {
              if (Array.isArray(d) || (w = u(d)) || _ && d && typeof d.length == "number") {
                w && (d = w);
                var m = 0;
                return function() {
                  return m >= d.length ? { done: true } : { done: false, value: d[m++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return w = d[Symbol.iterator](), w.next.bind(w);
          }
          function u(d, _) {
            if (!!d) {
              if (typeof d == "string")
                return t(d, _);
              var w = Object.prototype.toString.call(d).slice(8, -1);
              if (w === "Object" && d.constructor && (w = d.constructor.name), w === "Map" || w === "Set")
                return Array.from(d);
              if (w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w))
                return t(d, _);
            }
          }
          function t(d, _) {
            (_ == null || _ > d.length) && (_ = d.length);
            for (var w = 0, m = new Array(_); w < _; w++)
              m[w] = d[w];
            return m;
          }
          function r(d, _) {
            for (var w = 0; w < _.length; w++) {
              var m = _[w];
              m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(d, m.key, m);
            }
          }
          function o(d, _, w) {
            return _ && r(d.prototype, _), w && r(d, w), d;
          }
          function n(d) {
            return typeof d == "object" && typeof d.then == "function";
          }
          var l = function() {
            function d(w, m, y) {
              this.stringified = false, this.processed = false;
              var b;
              if (typeof m == "object" && m !== null && m.type === "root")
                b = m;
              else if (m instanceof d || m instanceof p.default)
                b = m.root, m.map && (typeof y.map > "u" && (y.map = {}), y.map.inline || (y.map.inline = false), y.map.prev = m.map);
              else {
                var S = c.default;
                y.syntax && (S = y.syntax.parse), y.parser && (S = y.parser), S.parse && (S = S.parse);
                try {
                  b = S(m, y);
                } catch (E) {
                  this.error = E;
                }
              }
              this.result = new p.default(w, b, y);
            }
            var _ = d.prototype;
            return _.warnings = function() {
              return this.sync().warnings();
            }, _.toString = function() {
              return this.css;
            }, _.then = function(m, y) {
              return this.async().then(m, y);
            }, _.catch = function(m) {
              return this.async().catch(m);
            }, _.finally = function(m) {
              return this.async().then(m, m);
            }, _.handleError = function(m, y) {
              try {
                if (this.error = m, m.name === "CssSyntaxError" && !m.plugin)
                  m.plugin = y.postcssPlugin, m.setMessage();
                else if (y.postcssVersion && false)
                  var b, S, E, q, P;
              } catch (z) {
                console && console.error && console.error(z);
              }
            }, _.asyncTick = function(m, y) {
              var b = this;
              if (this.plugin >= this.processor.plugins.length)
                return this.processed = true, m();
              try {
                var S = this.processor.plugins[this.plugin], E = this.run(S);
                this.plugin += 1, n(E) ? E.then(function() {
                  b.asyncTick(m, y);
                }).catch(function(q) {
                  b.handleError(q, S), b.processed = true, y(q);
                }) : this.asyncTick(m, y);
              } catch (q) {
                this.processed = true, y(q);
              }
            }, _.async = function() {
              var m = this;
              return this.processed ? new Promise(function(y, b) {
                m.error ? b(m.error) : y(m.stringify());
              }) : this.processing ? this.processing : (this.processing = new Promise(function(y, b) {
                if (m.error)
                  return b(m.error);
                m.plugin = 0, m.asyncTick(y, b);
              }).then(function() {
                return m.processed = true, m.stringify();
              }), this.processing);
            }, _.sync = function() {
              if (this.processed)
                return this.result;
              if (this.processed = true, this.processing)
                throw new Error("Use process(css).then(cb) to work with async plugins");
              if (this.error)
                throw this.error;
              for (var m = g(this.result.processor.plugins), y; !(y = m()).done; ) {
                var b = y.value, S = this.run(b);
                if (n(S))
                  throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              return this.result;
            }, _.run = function(m) {
              this.result.lastPlugin = m;
              try {
                return m(this.result.root, this.result);
              } catch (y) {
                throw this.handleError(y, m), y;
              }
            }, _.stringify = function() {
              if (this.stringified)
                return this.result;
              this.stringified = true, this.sync();
              var m = this.result.opts, y = f.default;
              m.syntax && (y = m.syntax.stringify), m.stringifier && (y = m.stringifier), y.stringify && (y = y.stringify);
              var b = new s.default(y, this.result.root, this.result.opts), S = b.generate();
              return this.result.css = S[0], this.result.map = S[1], this.result;
            }, o(d, [{ key: "processor", get: function() {
              return this.result.processor;
            } }, { key: "opts", get: function() {
              return this.result.opts;
            } }, { key: "css", get: function() {
              return this.stringify().css;
            } }, { key: "content", get: function() {
              return this.stringify().content;
            } }, { key: "map", get: function() {
              return this.stringify().map;
            } }, { key: "root", get: function() {
              return this.sync().root;
            } }, { key: "messages", get: function() {
              return this.sync().messages;
            } }]), d;
          }(), v = l;
          e2.default = v, i.exports = e2.default;
        } }), Gf = M({ "node_modules/postcss/lib/processor.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(pa());
          function f(u) {
            return u && u.__esModule ? u : { default: u };
          }
          function a(u, t) {
            var r;
            if (typeof Symbol > "u" || u[Symbol.iterator] == null) {
              if (Array.isArray(u) || (r = p(u)) || t && u && typeof u.length == "number") {
                r && (u = r);
                var o = 0;
                return function() {
                  return o >= u.length ? { done: true } : { done: false, value: u[o++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return r = u[Symbol.iterator](), r.next.bind(r);
          }
          function p(u, t) {
            if (!!u) {
              if (typeof u == "string")
                return c(u, t);
              var r = Object.prototype.toString.call(u).slice(8, -1);
              if (r === "Object" && u.constructor && (r = u.constructor.name), r === "Map" || r === "Set")
                return Array.from(u);
              if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
                return c(u, t);
            }
          }
          function c(u, t) {
            (t == null || t > u.length) && (t = u.length);
            for (var r = 0, o = new Array(t); r < t; r++)
              o[r] = u[r];
            return o;
          }
          var h = function() {
            function u(r) {
              r === void 0 && (r = []), this.version = "7.0.39", this.plugins = this.normalize(r);
            }
            var t = u.prototype;
            return t.use = function(o) {
              return this.plugins = this.plugins.concat(this.normalize([o])), this;
            }, t.process = function(r) {
              function o(n) {
                return r.apply(this, arguments);
              }
              return o.toString = function() {
                return r.toString();
              }, o;
            }(function(r, o) {
              return o === void 0 && (o = {}), this.plugins.length === 0 && (o.parser, o.stringifier), new s.default(this, r, o);
            }), t.normalize = function(o) {
              for (var n = [], l = a(o), v; !(v = l()).done; ) {
                var d = v.value;
                if (d.postcss === true) {
                  var _ = d();
                  throw new Error("PostCSS plugin " + _.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
                }
                if (d.postcss && (d = d.postcss), typeof d == "object" && Array.isArray(d.plugins))
                  n = n.concat(d.plugins);
                else if (typeof d == "function")
                  n.push(d);
                else if (!(typeof d == "object" && (d.parse || d.stringify)))
                  throw typeof d == "object" && d.postcssPlugin ? new Error("PostCSS plugin " + d.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(d + " is not a PostCSS plugin");
              }
              return n;
            }, u;
          }(), g = h;
          e2.default = g, i.exports = e2.default;
        } }), Wf = M({ "node_modules/postcss/lib/root.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = f(Er());
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function a(t, r) {
            var o;
            if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
              if (Array.isArray(t) || (o = p(t)) || r && t && typeof t.length == "number") {
                o && (t = o);
                var n = 0;
                return function() {
                  return n >= t.length ? { done: true } : { done: false, value: t[n++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return o = t[Symbol.iterator](), o.next.bind(o);
          }
          function p(t, r) {
            if (!!t) {
              if (typeof t == "string")
                return c(t, r);
              var o = Object.prototype.toString.call(t).slice(8, -1);
              if (o === "Object" && t.constructor && (o = t.constructor.name), o === "Map" || o === "Set")
                return Array.from(t);
              if (o === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))
                return c(t, r);
            }
          }
          function c(t, r) {
            (r == null || r > t.length) && (r = t.length);
            for (var o = 0, n = new Array(r); o < r; o++)
              n[o] = t[o];
            return n;
          }
          function h(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var g = function(t) {
            h(r, t);
            function r(n) {
              var l;
              return l = t.call(this, n) || this, l.type = "root", l.nodes || (l.nodes = []), l;
            }
            var o = r.prototype;
            return o.removeChild = function(l, v) {
              var d = this.index(l);
              return !v && d === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[d].raws.before), t.prototype.removeChild.call(this, l);
            }, o.normalize = function(l, v, d) {
              var _ = t.prototype.normalize.call(this, l);
              if (v) {
                if (d === "prepend")
                  this.nodes.length > 1 ? v.raws.before = this.nodes[1].raws.before : delete v.raws.before;
                else if (this.first !== v)
                  for (var w = a(_), m; !(m = w()).done; ) {
                    var y = m.value;
                    y.raws.before = v.raws.before;
                  }
              }
              return _;
            }, o.toResult = function(l) {
              l === void 0 && (l = {});
              var v = pa(), d = Gf(), _ = new v(new d(), this, l);
              return _.stringify();
            }, r;
          }(s.default), u = g;
          e2.default = u, i.exports = e2.default;
        } }), Ft = M({ "node_modules/postcss/lib/parser.js"(e2, i) {
          "use strict";
          A(), e2.__esModule = true, e2.default = void 0;
          var s = g(la()), f = g(zt()), a = g(kr()), p = g(ha()), c = g(Wf()), h = g(fa());
          function g(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var u = function() {
            function t(o) {
              this.input = o, this.root = new c.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: o, start: { line: 1, column: 1 } };
            }
            var r = t.prototype;
            return r.createTokenizer = function() {
              this.tokenizer = (0, f.default)(this.input);
            }, r.parse = function() {
              for (var n; !this.tokenizer.endOfFile(); )
                switch (n = this.tokenizer.nextToken(), n[0]) {
                  case "space":
                    this.spaces += n[1];
                    break;
                  case ";":
                    this.freeSemicolon(n);
                    break;
                  case "}":
                    this.end(n);
                    break;
                  case "comment":
                    this.comment(n);
                    break;
                  case "at-word":
                    this.atrule(n);
                    break;
                  case "{":
                    this.emptyRule(n);
                    break;
                  default:
                    this.other(n);
                    break;
                }
              this.endFile();
            }, r.comment = function(n) {
              var l = new a.default();
              this.init(l, n[2], n[3]), l.source.end = { line: n[4], column: n[5] };
              var v = n[1].slice(2, -2);
              if (/^\s*$/.test(v))
                l.text = "", l.raws.left = v, l.raws.right = "";
              else {
                var d = v.match(/^(\s*)([^]*[^\s])(\s*)$/);
                l.text = d[2], l.raws.left = d[1], l.raws.right = d[3];
              }
            }, r.emptyRule = function(n) {
              var l = new h.default();
              this.init(l, n[2], n[3]), l.selector = "", l.raws.between = "", this.current = l;
            }, r.other = function(n) {
              for (var l = false, v = null, d = false, _ = null, w = [], m = [], y = n; y; ) {
                if (v = y[0], m.push(y), v === "(" || v === "[")
                  _ || (_ = y), w.push(v === "(" ? ")" : "]");
                else if (w.length === 0)
                  if (v === ";")
                    if (d) {
                      this.decl(m);
                      return;
                    } else
                      break;
                  else if (v === "{") {
                    this.rule(m);
                    return;
                  } else if (v === "}") {
                    this.tokenizer.back(m.pop()), l = true;
                    break;
                  } else
                    v === ":" && (d = true);
                else
                  v === w[w.length - 1] && (w.pop(), w.length === 0 && (_ = null));
                y = this.tokenizer.nextToken();
              }
              if (this.tokenizer.endOfFile() && (l = true), w.length > 0 && this.unclosedBracket(_), l && d) {
                for (; m.length && (y = m[m.length - 1][0], !(y !== "space" && y !== "comment")); )
                  this.tokenizer.back(m.pop());
                this.decl(m);
              } else
                this.unknownWord(m);
            }, r.rule = function(n) {
              n.pop();
              var l = new h.default();
              this.init(l, n[0][2], n[0][3]), l.raws.between = this.spacesAndCommentsFromEnd(n), this.raw(l, "selector", n), this.current = l;
            }, r.decl = function(n) {
              var l = new s.default();
              this.init(l);
              var v = n[n.length - 1];
              for (v[0] === ";" && (this.semicolon = true, n.pop()), v[4] ? l.source.end = { line: v[4], column: v[5] } : l.source.end = { line: v[2], column: v[3] }; n[0][0] !== "word"; )
                n.length === 1 && this.unknownWord(n), l.raws.before += n.shift()[1];
              for (l.source.start = { line: n[0][2], column: n[0][3] }, l.prop = ""; n.length; ) {
                var d = n[0][0];
                if (d === ":" || d === "space" || d === "comment")
                  break;
                l.prop += n.shift()[1];
              }
              l.raws.between = "";
              for (var _; n.length; )
                if (_ = n.shift(), _[0] === ":") {
                  l.raws.between += _[1];
                  break;
                } else
                  _[0] === "word" && /\w/.test(_[1]) && this.unknownWord([_]), l.raws.between += _[1];
              (l.prop[0] === "_" || l.prop[0] === "*") && (l.raws.before += l.prop[0], l.prop = l.prop.slice(1)), l.raws.between += this.spacesAndCommentsFromStart(n), this.precheckMissedSemicolon(n);
              for (var w = n.length - 1; w > 0; w--) {
                if (_ = n[w], _[1].toLowerCase() === "!important") {
                  l.important = true;
                  var m = this.stringFrom(n, w);
                  m = this.spacesFromEnd(n) + m, m !== " !important" && (l.raws.important = m);
                  break;
                } else if (_[1].toLowerCase() === "important") {
                  for (var y = n.slice(0), b = "", S = w; S > 0; S--) {
                    var E = y[S][0];
                    if (b.trim().indexOf("!") === 0 && E !== "space")
                      break;
                    b = y.pop()[1] + b;
                  }
                  b.trim().indexOf("!") === 0 && (l.important = true, l.raws.important = b, n = y);
                }
                if (_[0] !== "space" && _[0] !== "comment")
                  break;
              }
              this.raw(l, "value", n), l.value.indexOf(":") !== -1 && this.checkMissedSemicolon(n);
            }, r.atrule = function(n) {
              var l = new p.default();
              l.name = n[1].slice(1), l.name === "" && this.unnamedAtrule(l, n), this.init(l, n[2], n[3]);
              for (var v, d, _ = false, w = false, m = []; !this.tokenizer.endOfFile(); ) {
                if (n = this.tokenizer.nextToken(), n[0] === ";") {
                  l.source.end = { line: n[2], column: n[3] }, this.semicolon = true;
                  break;
                } else if (n[0] === "{") {
                  w = true;
                  break;
                } else if (n[0] === "}") {
                  if (m.length > 0) {
                    for (d = m.length - 1, v = m[d]; v && v[0] === "space"; )
                      v = m[--d];
                    v && (l.source.end = { line: v[4], column: v[5] });
                  }
                  this.end(n);
                  break;
                } else
                  m.push(n);
                if (this.tokenizer.endOfFile()) {
                  _ = true;
                  break;
                }
              }
              l.raws.between = this.spacesAndCommentsFromEnd(m), m.length ? (l.raws.afterName = this.spacesAndCommentsFromStart(m), this.raw(l, "params", m), _ && (n = m[m.length - 1], l.source.end = { line: n[4], column: n[5] }, this.spaces = l.raws.between, l.raws.between = "")) : (l.raws.afterName = "", l.params = ""), w && (l.nodes = [], this.current = l);
            }, r.end = function(n) {
              this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: n[2], column: n[3] }, this.current = this.current.parent) : this.unexpectedClose(n);
            }, r.endFile = function() {
              this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
            }, r.freeSemicolon = function(n) {
              if (this.spaces += n[1], this.current.nodes) {
                var l = this.current.nodes[this.current.nodes.length - 1];
                l && l.type === "rule" && !l.raws.ownSemicolon && (l.raws.ownSemicolon = this.spaces, this.spaces = "");
              }
            }, r.init = function(n, l, v) {
              this.current.push(n), n.source = { start: { line: l, column: v }, input: this.input }, n.raws.before = this.spaces, this.spaces = "", n.type !== "comment" && (this.semicolon = false);
            }, r.raw = function(n, l, v) {
              for (var d, _, w = v.length, m = "", y = true, b, S, E = /^([.|#])?([\w])+/i, q = 0; q < w; q += 1) {
                if (d = v[q], _ = d[0], _ === "comment" && n.type === "rule") {
                  S = v[q - 1], b = v[q + 1], S[0] !== "space" && b[0] !== "space" && E.test(S[1]) && E.test(b[1]) ? m += d[1] : y = false;
                  continue;
                }
                _ === "comment" || _ === "space" && q === w - 1 ? y = false : m += d[1];
              }
              if (!y) {
                var P = v.reduce(function(z, B) {
                  return z + B[1];
                }, "");
                n.raws[l] = { value: m, raw: P };
              }
              n[l] = m;
            }, r.spacesAndCommentsFromEnd = function(n) {
              for (var l, v = ""; n.length && (l = n[n.length - 1][0], !(l !== "space" && l !== "comment")); )
                v = n.pop()[1] + v;
              return v;
            }, r.spacesAndCommentsFromStart = function(n) {
              for (var l, v = ""; n.length && (l = n[0][0], !(l !== "space" && l !== "comment")); )
                v += n.shift()[1];
              return v;
            }, r.spacesFromEnd = function(n) {
              for (var l, v = ""; n.length && (l = n[n.length - 1][0], l === "space"); )
                v = n.pop()[1] + v;
              return v;
            }, r.stringFrom = function(n, l) {
              for (var v = "", d = l; d < n.length; d++)
                v += n[d][1];
              return n.splice(l, n.length - l), v;
            }, r.colon = function(n) {
              for (var l = 0, v, d, _, w = 0; w < n.length; w++) {
                if (v = n[w], d = v[0], d === "(" && (l += 1), d === ")" && (l -= 1), l === 0 && d === ":")
                  if (!_)
                    this.doubleColon(v);
                  else {
                    if (_[0] === "word" && _[1] === "progid")
                      continue;
                    return w;
                  }
                _ = v;
              }
              return false;
            }, r.unclosedBracket = function(n) {
              throw this.input.error("Unclosed bracket", n[2], n[3]);
            }, r.unknownWord = function(n) {
              throw this.input.error("Unknown word", n[0][2], n[0][3]);
            }, r.unexpectedClose = function(n) {
              throw this.input.error("Unexpected }", n[2], n[3]);
            }, r.unclosedBlock = function() {
              var n = this.current.source.start;
              throw this.input.error("Unclosed block", n.line, n.column);
            }, r.doubleColon = function(n) {
              throw this.input.error("Double colon", n[2], n[3]);
            }, r.unnamedAtrule = function(n, l) {
              throw this.input.error("At-rule without name", l[2], l[3]);
            }, r.precheckMissedSemicolon = function() {
            }, r.checkMissedSemicolon = function(n) {
              var l = this.colon(n);
              if (l !== false) {
                for (var v = 0, d, _ = l - 1; _ >= 0 && (d = n[_], !(d[0] !== "space" && (v += 1, v === 2))); _--)
                  ;
                throw this.input.error("Missed semicolon", d[2], d[3]);
              }
            }, t;
          }();
          e2.default = u, i.exports = e2.default;
        } }), $f = M({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(e2, i) {
          A();
          var s = zt(), f = xr();
          i.exports = { isInlineComment(a) {
            if (a[0] === "word" && a[1].slice(0, 2) === "//") {
              let p = a, c = [], h;
              for (; a; ) {
                if (/\r?\n/.test(a[1])) {
                  if (/['"].*\r?\n/.test(a[1])) {
                    c.push(a[1].substring(0, a[1].indexOf(`
`)));
                    let u = a[1].substring(a[1].indexOf(`
`));
                    u += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new f(u), this.tokenizer = s(this.input);
                  } else
                    this.tokenizer.back(a);
                  break;
                }
                c.push(a[1]), h = a, a = this.tokenizer.nextToken({ ignoreUnclosed: true });
              }
              let g = ["comment", c.join(""), p[2], p[3], h[2], h[3]];
              return this.inlineComment(g), true;
            } else if (a[1] === "/") {
              let p = this.tokenizer.nextToken({ ignoreUnclosed: true });
              if (p[0] === "comment" && /^\/\*/.test(p[1]))
                return p[0] = "word", p[1] = p[1].slice(1), a[1] = "//", this.tokenizer.back(p), i.exports.isInlineComment.bind(this)(a);
            }
            return false;
          } };
        } }), Vf = M({ "node_modules/postcss-less/lib/nodes/interpolation.js"(e2, i) {
          A(), i.exports = { interpolation(s) {
            let f = s, a = [s], p = ["word", "{", "}"];
            if (s = this.tokenizer.nextToken(), f[1].length > 1 || s[0] !== "{")
              return this.tokenizer.back(s), false;
            for (; s && p.includes(s[0]); )
              a.push(s), s = this.tokenizer.nextToken();
            let c = a.map((r) => r[1]);
            [f] = a;
            let h = a.pop(), g = [f[2], f[3]], u = [h[4] || h[2], h[5] || h[3]], t = ["word", c.join("")].concat(g, u);
            return this.tokenizer.back(s), this.tokenizer.back(t), true;
          } };
        } }), Qf = M({ "node_modules/postcss-less/lib/nodes/mixin.js"(e2, i) {
          A();
          var s = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, f = /\.[0-9]/, a = (p) => {
            let [, c] = p, [h] = c;
            return (h === "." || h === "#") && s.test(c) === false && f.test(c) === false;
          };
          i.exports = { isMixinToken: a };
        } }), Jf = M({ "node_modules/postcss-less/lib/nodes/import.js"(e2, i) {
          A();
          var s = zt(), f = /^url\((.+)\)/;
          i.exports = (a) => {
            let { name: p, params: c = "" } = a;
            if (p === "import" && c.length) {
              a.import = true;
              let h = s({ css: c });
              for (a.filename = c.replace(f, "$1"); !h.endOfFile(); ) {
                let [g, u] = h.nextToken();
                if (g === "word" && u === "url")
                  return;
                if (g === "brackets") {
                  a.options = u, a.filename = c.replace(u, "").trim();
                  break;
                }
              }
            }
          };
        } }), Kf = M({ "node_modules/postcss-less/lib/nodes/variable.js"(e2, i) {
          A();
          var s = /:$/, f = /^:(\s+)?/;
          i.exports = (a) => {
            let { name: p, params: c = "" } = a;
            if (a.name.slice(-1) === ":") {
              if (s.test(p)) {
                let [h] = p.match(s);
                a.name = p.replace(h, ""), a.raws.afterName = h + (a.raws.afterName || ""), a.variable = true, a.value = a.params;
              }
              if (f.test(c)) {
                let [h] = c.match(f);
                a.value = c.replace(h, ""), a.raws.afterName = (a.raws.afterName || "") + h, a.variable = true;
              }
            }
          };
        } }), Yf = M({ "node_modules/postcss-less/lib/LessParser.js"(e2, i) {
          A();
          var s = kr(), f = Ft(), { isInlineComment: a } = $f(), { interpolation: p } = Vf(), { isMixinToken: c } = Qf(), h = Jf(), g = Kf(), u = /(!\s*important)$/i;
          i.exports = class extends f {
            constructor() {
              super(...arguments);
              this.lastNode = null;
            }
            atrule(r) {
              p.bind(this)(r) || (super.atrule(r), h(this.lastNode), g(this.lastNode));
            }
            decl() {
              super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
            }
            each(r) {
              r[0][1] = " ".concat(r[0][1]);
              let o = r.findIndex((_) => _[0] === "("), n = r.reverse().find((_) => _[0] === ")"), l = r.reverse().indexOf(n), d = r.splice(o, l).map((_) => _[1]).join("");
              for (let _ of r.reverse())
                this.tokenizer.back(_);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = d;
            }
            init(r, o, n) {
              super.init(r, o, n), this.lastNode = r;
            }
            inlineComment(r) {
              let o = new s(), n = r[1].slice(2);
              if (this.init(o, r[2], r[3]), o.source.end = { line: r[4], column: r[5] }, o.inline = true, o.raws.begin = "//", /^\s*$/.test(n))
                o.text = "", o.raws.left = n, o.raws.right = "";
              else {
                let l = n.match(/^(\s*)([^]*[^\s])(\s*)$/);
                [, o.raws.left, o.text, o.raws.right] = l;
              }
            }
            mixin(r) {
              let [o] = r, n = o[1].slice(0, 1), l = r.findIndex((m) => m[0] === "brackets"), v = r.findIndex((m) => m[0] === "("), d = "";
              if ((l < 0 || l > 3) && v > 0) {
                let m = r.reduce(($, G, k) => G[0] === ")" ? k : $), b = r.slice(v, m + v).map(($) => $[1]).join(""), [S] = r.slice(v), E = [S[2], S[3]], [q] = r.slice(m, m + 1), P = [q[2], q[3]], z = ["brackets", b].concat(E, P), B = r.slice(0, v), L = r.slice(m + 1);
                r = B, r.push(z), r = r.concat(L);
              }
              let _ = [];
              for (let m of r)
                if ((m[1] === "!" || _.length) && _.push(m), m[1] === "important")
                  break;
              if (_.length) {
                let [m] = _, y = r.indexOf(m), b = _[_.length - 1], S = [m[2], m[3]], E = [b[4], b[5]], q = _.map((z) => z[1]).join(""), P = ["word", q].concat(S, E);
                r.splice(y, _.length, P);
              }
              let w = r.findIndex((m) => u.test(m[1]));
              w > 0 && ([, d] = r[w], r.splice(w, 1));
              for (let m of r.reverse())
                this.tokenizer.back(m);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = n, d && (this.lastNode.important = true, this.lastNode.raws.important = d);
            }
            other(r) {
              a.bind(this)(r) || super.other(r);
            }
            rule(r) {
              let o = r[r.length - 1], n = r[r.length - 2];
              if (n[0] === "at-word" && o[0] === "{" && (this.tokenizer.back(o), p.bind(this)(n))) {
                let v = this.tokenizer.nextToken();
                r = r.slice(0, r.length - 2).concat([v]);
                for (let d of r.reverse())
                  this.tokenizer.back(d);
                return;
              }
              super.rule(r), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
            }
            unknownWord(r) {
              let [o] = r;
              if (r[0][1] === "each" && r[1][0] === "(") {
                this.each(r);
                return;
              }
              if (c(o)) {
                this.mixin(r);
                return;
              }
              super.unknownWord(r);
            }
          };
        } }), Hf = M({ "node_modules/postcss-less/lib/LessStringifier.js"(e2, i) {
          A();
          var s = Or();
          i.exports = class extends s {
            atrule(a, p) {
              if (!a.mixin && !a.variable && !a.function) {
                super.atrule(a, p);
                return;
              }
              let c = a.function ? "" : a.raws.identifier || "@", h = "".concat(c).concat(a.name), g = a.params ? this.rawValue(a, "params") : "", u = a.raws.important || "";
              if (a.variable && (g = a.value), typeof a.raws.afterName < "u" ? h += a.raws.afterName : g && (h += " "), a.nodes)
                this.block(a, h + g + u);
              else {
                let t = (a.raws.between || "") + u + (p ? ";" : "");
                this.builder(h + g + t, a);
              }
            }
            comment(a) {
              if (a.inline) {
                let p = this.raw(a, "left", "commentLeft"), c = this.raw(a, "right", "commentRight");
                this.builder("//".concat(p).concat(a.text).concat(c), a);
              } else
                super.comment(a);
            }
          };
        } }), Xf = M({ "node_modules/postcss-less/lib/index.js"(e2, i) {
          A();
          var s = xr(), f = Yf(), a = Hf();
          i.exports = { parse(p, c) {
            let h = new s(p, c), g = new f(h);
            return g.parse(), g.root;
          }, stringify(p, c) {
            new a(c).stringify(p);
          }, nodeToString(p) {
            let c = "";
            return i.exports.stringify(p, (h) => {
              c += h;
            }), c;
          } };
        } }), Zf = M({ "node_modules/postcss-scss/lib/scss-stringifier.js"(e2, i) {
          "use strict";
          A();
          function s(p, c) {
            p.prototype = Object.create(c.prototype), p.prototype.constructor = p, p.__proto__ = c;
          }
          var f = Or(), a = function(p) {
            s(c, p);
            function c() {
              return p.apply(this, arguments) || this;
            }
            var h = c.prototype;
            return h.comment = function(u) {
              var t = this.raw(u, "left", "commentLeft"), r = this.raw(u, "right", "commentRight");
              if (u.raws.inline) {
                var o = u.raws.text || u.text;
                this.builder("//" + t + o + r, u);
              } else
                this.builder("/*" + t + u.text + r + "*/", u);
            }, h.decl = function(u, t) {
              if (!u.isNested)
                p.prototype.decl.call(this, u, t);
              else {
                var r = this.raw(u, "between", "colon"), o = u.prop + r + this.rawValue(u, "value");
                u.important && (o += u.raws.important || " !important"), this.builder(o + "{", u, "start");
                var n;
                u.nodes && u.nodes.length ? (this.body(u), n = this.raw(u, "after")) : n = this.raw(u, "after", "emptyBody"), n && this.builder(n), this.builder("}", u, "end");
              }
            }, h.rawValue = function(u, t) {
              var r = u[t], o = u.raws[t];
              return o && o.value === r ? o.scss ? o.scss : o.raw : r;
            }, c;
          }(f);
          i.exports = a;
        } }), eh = M({ "node_modules/postcss-scss/lib/scss-stringify.js"(e2, i) {
          "use strict";
          A();
          var s = Zf();
          i.exports = function(a, p) {
            var c = new s(p);
            c.stringify(a);
          };
        } }), rh = M({ "node_modules/postcss-scss/lib/nested-declaration.js"(e2, i) {
          "use strict";
          A();
          function s(p, c) {
            p.prototype = Object.create(c.prototype), p.prototype.constructor = p, p.__proto__ = c;
          }
          var f = Er(), a = function(p) {
            s(c, p);
            function c(h) {
              var g;
              return g = p.call(this, h) || this, g.type = "decl", g.isNested = true, g.nodes || (g.nodes = []), g;
            }
            return c;
          }(f);
          i.exports = a;
        } }), th = M({ "node_modules/postcss-scss/lib/scss-tokenize.js"(e2, i) {
          "use strict";
          A();
          var s = "'".charCodeAt(0), f = '"'.charCodeAt(0), a = "\\".charCodeAt(0), p = "/".charCodeAt(0), c = `
`.charCodeAt(0), h = " ".charCodeAt(0), g = "\f".charCodeAt(0), u = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), o = "]".charCodeAt(0), n = "(".charCodeAt(0), l = ")".charCodeAt(0), v = "{".charCodeAt(0), d = "}".charCodeAt(0), _ = ";".charCodeAt(0), w = "*".charCodeAt(0), m = ":".charCodeAt(0), y = "@".charCodeAt(0), b = ",".charCodeAt(0), S = "#".charCodeAt(0), E = /[ \n\t\r\f{}()'"\\;/[\]#]/g, q = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, P = /.[\\/("'\n]/, z = /[a-f0-9]/i, B = /[\r\f\n]/g;
          i.exports = function($, G) {
            G === void 0 && (G = {});
            var k = $.css.valueOf(), j = G.ignoreErrors, N, I, X, Z, Y, K, J, D, H, Q, C, O, x, F, R = k.length, T = -1, W = 1, U = 0, re = [], ne = [];
            function le(se) {
              throw $.error("Unclosed " + se, W, U - T);
            }
            function fe() {
              return ne.length === 0 && U >= R;
            }
            function te() {
              for (var se = 1, ce = false, he = false; se > 0; )
                I += 1, k.length <= I && le("interpolation"), N = k.charCodeAt(I), O = k.charCodeAt(I + 1), ce ? !he && N === ce ? (ce = false, he = false) : N === a ? he = !Q : he && (he = false) : N === s || N === f ? ce = N : N === d ? se -= 1 : N === S && O === v && (se += 1);
            }
            function ie() {
              if (ne.length)
                return ne.pop();
              if (!(U >= R)) {
                switch (N = k.charCodeAt(U), (N === c || N === g || N === t && k.charCodeAt(U + 1) !== c) && (T = U, W += 1), N) {
                  case c:
                  case h:
                  case u:
                  case t:
                  case g:
                    I = U;
                    do
                      I += 1, N = k.charCodeAt(I), N === c && (T = I, W += 1);
                    while (N === h || N === c || N === u || N === t || N === g);
                    x = ["space", k.slice(U, I)], U = I - 1;
                    break;
                  case r:
                    x = ["[", "[", W, U - T];
                    break;
                  case o:
                    x = ["]", "]", W, U - T];
                    break;
                  case v:
                    x = ["{", "{", W, U - T];
                    break;
                  case d:
                    x = ["}", "}", W, U - T];
                    break;
                  case b:
                    x = ["word", ",", W, U - T, W, U - T + 1];
                    break;
                  case m:
                    x = [":", ":", W, U - T];
                    break;
                  case _:
                    x = [";", ";", W, U - T];
                    break;
                  case n:
                    if (C = re.length ? re.pop()[1] : "", O = k.charCodeAt(U + 1), C === "url" && O !== s && O !== f) {
                      for (F = 1, Q = false, I = U + 1; I <= k.length - 1; ) {
                        if (O = k.charCodeAt(I), O === a)
                          Q = !Q;
                        else if (O === n)
                          F += 1;
                        else if (O === l && (F -= 1, F === 0))
                          break;
                        I += 1;
                      }
                      K = k.slice(U, I + 1), Z = K.split(`
`), Y = Z.length - 1, Y > 0 ? (D = W + Y, H = I - Z[Y].length) : (D = W, H = T), x = ["brackets", K, W, U - T, D, I - H], T = H, W = D, U = I;
                    } else
                      I = k.indexOf(")", U + 1), K = k.slice(U, I + 1), I === -1 || P.test(K) ? x = ["(", "(", W, U - T] : (x = ["brackets", K, W, U - T, W, I - T], U = I);
                    break;
                  case l:
                    x = [")", ")", W, U - T];
                    break;
                  case s:
                  case f:
                    for (X = N, I = U, Q = false; I < R && (I++, I === R && le("string"), N = k.charCodeAt(I), O = k.charCodeAt(I + 1), !(!Q && N === X)); )
                      N === a ? Q = !Q : Q ? Q = false : N === S && O === v && te();
                    K = k.slice(U, I + 1), Z = K.split(`
`), Y = Z.length - 1, Y > 0 ? (D = W + Y, H = I - Z[Y].length) : (D = W, H = T), x = ["string", k.slice(U, I + 1), W, U - T, D, I - H], T = H, W = D, U = I;
                    break;
                  case y:
                    E.lastIndex = U + 1, E.test(k), E.lastIndex === 0 ? I = k.length - 1 : I = E.lastIndex - 2, x = ["at-word", k.slice(U, I + 1), W, U - T, W, I - T], U = I;
                    break;
                  case a:
                    for (I = U, J = true; k.charCodeAt(I + 1) === a; )
                      I += 1, J = !J;
                    if (N = k.charCodeAt(I + 1), J && N !== p && N !== h && N !== c && N !== u && N !== t && N !== g && (I += 1, z.test(k.charAt(I)))) {
                      for (; z.test(k.charAt(I + 1)); )
                        I += 1;
                      k.charCodeAt(I + 1) === h && (I += 1);
                    }
                    x = ["word", k.slice(U, I + 1), W, U - T, W, I - T], U = I;
                    break;
                  default:
                    O = k.charCodeAt(U + 1), N === S && O === v ? (I = U, te(), K = k.slice(U, I + 1), Z = K.split(`
`), Y = Z.length - 1, Y > 0 ? (D = W + Y, H = I - Z[Y].length) : (D = W, H = T), x = ["word", K, W, U - T, D, I - H], T = H, W = D, U = I) : N === p && O === w ? (I = k.indexOf("*/", U + 2) + 1, I === 0 && (j ? I = k.length : le("comment")), K = k.slice(U, I + 1), Z = K.split(`
`), Y = Z.length - 1, Y > 0 ? (D = W + Y, H = I - Z[Y].length) : (D = W, H = T), x = ["comment", K, W, U - T, D, I - H], T = H, W = D, U = I) : N === p && O === p ? (B.lastIndex = U + 1, B.test(k), B.lastIndex === 0 ? I = k.length - 1 : I = B.lastIndex - 2, K = k.slice(U, I + 1), x = ["comment", K, W, U - T, W, I - T, "inline"], U = I) : (q.lastIndex = U + 1, q.test(k), q.lastIndex === 0 ? I = k.length - 1 : I = q.lastIndex - 2, x = ["word", k.slice(U, I + 1), W, U - T, W, I - T], re.push(x), U = I);
                    break;
                }
                return U++, x;
              }
            }
            function ae(se) {
              ne.push(se);
            }
            return { back: ae, nextToken: ie, endOfFile: fe };
          };
        } }), nh = M({ "node_modules/postcss-scss/lib/scss-parser.js"(e2, i) {
          "use strict";
          A();
          function s(g, u) {
            g.prototype = Object.create(u.prototype), g.prototype.constructor = g, g.__proto__ = u;
          }
          var f = kr(), a = Ft(), p = rh(), c = th(), h = function(g) {
            s(u, g);
            function u() {
              return g.apply(this, arguments) || this;
            }
            var t = u.prototype;
            return t.createTokenizer = function() {
              this.tokenizer = c(this.input);
            }, t.rule = function(o) {
              for (var n = false, l = 0, v = "", w = o, d = Array.isArray(w), _ = 0, w = d ? w : w[Symbol.iterator](); ; ) {
                var m;
                if (d) {
                  if (_ >= w.length)
                    break;
                  m = w[_++];
                } else {
                  if (_ = w.next(), _.done)
                    break;
                  m = _.value;
                }
                var y = m;
                if (n)
                  y[0] !== "comment" && y[0] !== "{" && (v += y[1]);
                else {
                  if (y[0] === "space" && y[1].indexOf(`
`) !== -1)
                    break;
                  y[0] === "(" ? l += 1 : y[0] === ")" ? l -= 1 : l === 0 && y[0] === ":" && (n = true);
                }
              }
              if (!n || v.trim() === "" || /^[a-zA-Z-:#]/.test(v))
                g.prototype.rule.call(this, o);
              else {
                o.pop();
                var b = new p();
                this.init(b);
                var S = o[o.length - 1];
                for (S[4] ? b.source.end = { line: S[4], column: S[5] } : b.source.end = { line: S[2], column: S[3] }; o[0][0] !== "word"; )
                  b.raws.before += o.shift()[1];
                for (b.source.start = { line: o[0][2], column: o[0][3] }, b.prop = ""; o.length; ) {
                  var E = o[0][0];
                  if (E === ":" || E === "space" || E === "comment")
                    break;
                  b.prop += o.shift()[1];
                }
                b.raws.between = "";
                for (var q; o.length; )
                  if (q = o.shift(), q[0] === ":") {
                    b.raws.between += q[1];
                    break;
                  } else
                    b.raws.between += q[1];
                (b.prop[0] === "_" || b.prop[0] === "*") && (b.raws.before += b.prop[0], b.prop = b.prop.slice(1)), b.raws.between += this.spacesAndCommentsFromStart(o), this.precheckMissedSemicolon(o);
                for (var P = o.length - 1; P > 0; P--) {
                  if (q = o[P], q[1] === "!important") {
                    b.important = true;
                    var z = this.stringFrom(o, P);
                    z = this.spacesFromEnd(o) + z, z !== " !important" && (b.raws.important = z);
                    break;
                  } else if (q[1] === "important") {
                    for (var B = o.slice(0), L = "", $ = P; $ > 0; $--) {
                      var G = B[$][0];
                      if (L.trim().indexOf("!") === 0 && G !== "space")
                        break;
                      L = B.pop()[1] + L;
                    }
                    L.trim().indexOf("!") === 0 && (b.important = true, b.raws.important = L, o = B);
                  }
                  if (q[0] !== "space" && q[0] !== "comment")
                    break;
                }
                this.raw(b, "value", o), b.value.indexOf(":") !== -1 && this.checkMissedSemicolon(o), this.current = b;
              }
            }, t.comment = function(o) {
              if (o[6] === "inline") {
                var n = new f();
                this.init(n, o[2], o[3]), n.raws.inline = true, n.source.end = { line: o[4], column: o[5] };
                var l = o[1].slice(2);
                if (/^\s*$/.test(l))
                  n.text = "", n.raws.left = l, n.raws.right = "";
                else {
                  var v = l.match(/^(\s*)([^]*[^\s])(\s*)$/), d = v[2].replace(/(\*\/|\/\*)/g, "*//*");
                  n.text = d, n.raws.left = v[1], n.raws.right = v[3], n.raws.text = v[2];
                }
              } else
                g.prototype.comment.call(this, o);
            }, t.raw = function(o, n, l) {
              if (g.prototype.raw.call(this, o, n, l), o.raws[n]) {
                var v = o.raws[n].raw;
                o.raws[n].raw = l.reduce(function(d, _) {
                  if (_[0] === "comment" && _[6] === "inline") {
                    var w = _[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
                    return d + "/*" + w + "*/";
                  } else
                    return d + _[1];
                }, ""), v !== o.raws[n].raw && (o.raws[n].scss = v);
              }
            }, u;
          }(a);
          i.exports = h;
        } }), ih = M({ "node_modules/postcss-scss/lib/scss-parse.js"(e2, i) {
          "use strict";
          A();
          var s = xr(), f = nh();
          i.exports = function(p, c) {
            var h = new s(p, c), g = new f(h);
            return g.parse(), g.root;
          };
        } }), sh = M({ "node_modules/postcss-scss/lib/scss-syntax.js"(e2, i) {
          "use strict";
          A();
          var s = eh(), f = ih();
          i.exports = { parse: f, stringify: s };
        } });
        A();
        var oh = kc(), vt = Ps(), ah = Ls(), { hasPragma: uh } = Pc(), { locStart: lh, locEnd: ch } = Ys(), { calculateLoc: fh, replaceQuotesInInlineComments: hh } = Ys(), ph = Dc(), dh = Bc(), mt = zc(), da = Fc(), vh = Uc(), mh = Gc(), gh = Wc(), yh = $c(), _h = (e2) => {
          for (; e2.parent; )
            e2 = e2.parent;
          return e2;
        };
        function wh(e2, i) {
          let { nodes: s } = e2, f = { open: null, close: null, groups: [], type: "paren_group" }, a = [f], p = f, c = { groups: [], type: "comma_group" }, h = [c];
          for (let g = 0; g < s.length; ++g) {
            let u = s[g];
            if (da(i.parser, u.value) && u.type === "number" && u.unit === ".." && vt(u.value) === "." && (u.value = u.value.slice(0, -1), u.unit = "..."), u.type === "func" && u.value === "selector" && (u.group.groups = [Re(_h(e2).text.slice(u.group.open.sourceIndex + 1, u.group.close.sourceIndex))]), u.type === "func" && u.value === "url") {
              let t = u.group && u.group.groups || [], r = [];
              for (let o = 0; o < t.length; o++) {
                let n = t[o];
                n.type === "comma_group" ? r = [...r, ...n.groups] : r.push(n);
              }
              if (ph(r) || !dh(r) && !mh(r[0])) {
                let o = gh({ groups: u.group.groups });
                u.group.groups = [o.trim()];
              }
            }
            if (u.type === "paren" && u.value === "(")
              f = { open: u, close: null, groups: [], type: "paren_group" }, a.push(f), c = { groups: [], type: "comma_group" }, h.push(c);
            else if (u.type === "paren" && u.value === ")") {
              if (c.groups.length > 0 && f.groups.push(c), f.close = u, h.length === 1)
                throw new Error("Unbalanced parenthesis");
              h.pop(), c = vt(h), c.groups.push(f), a.pop(), f = vt(a);
            } else
              u.type === "comma" ? (f.groups.push(c), c = { groups: [], type: "comma_group" }, h[h.length - 1] = c) : c.groups.push(u);
          }
          return c.groups.length > 0 && f.groups.push(c), p;
        }
        function dr(e2) {
          return e2.type === "paren_group" && !e2.open && !e2.close && e2.groups.length === 1 || e2.type === "comma_group" && e2.groups.length === 1 ? dr(e2.groups[0]) : e2.type === "paren_group" || e2.type === "comma_group" ? Object.assign(Object.assign({}, e2), {}, { groups: e2.groups.map(dr) }) : e2;
        }
        function Ze(e2, i, s) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let f in e2)
              Ze(e2[f], i, s), f === "type" && typeof e2[f] == "string" && !e2[f].startsWith(i) && (!s || !s.test(e2[f])) && (e2[f] = i + e2[f]);
          }
          return e2;
        }
        function va(e2) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let i in e2)
              va(e2[i]);
            !Array.isArray(e2) && e2.value && !e2.type && (e2.type = "unknown");
          }
          return e2;
        }
        function ma(e2, i) {
          if (e2 && typeof e2 == "object") {
            for (let s in e2)
              s !== "parent" && (ma(e2[s], i), s === "nodes" && (e2.group = dr(wh(e2, i)), delete e2[s]));
            delete e2.parent;
          }
          return e2;
        }
        function qe(e2, i) {
          let s = yf(), f = null;
          try {
            f = s(e2, { loose: true }).parse();
          } catch {
            return { type: "value-unknown", value: e2 };
          }
          f.text = e2;
          let a = ma(f, i);
          return Ze(a, "value-", /^selector-/);
        }
        function Re(e2) {
          if (/\/\/|\/\*/.test(e2))
            return { type: "selector-unknown", value: e2.trim() };
          let i = xf(), s = null;
          try {
            i((f) => {
              s = f;
            }).process(e2);
          } catch {
            return { type: "selector-unknown", value: e2 };
          }
          return Ze(s, "selector-");
        }
        function bh(e2) {
          let i = kf().default, s = null;
          try {
            s = i(e2);
          } catch {
            return { type: "selector-unknown", value: e2 };
          }
          return Ze(va(s), "media-");
        }
        var Sh = /(\s*)(!default).*$/, xh = /(\s*)(!global).*$/;
        function ga(e2, i) {
          if (e2 && typeof e2 == "object") {
            delete e2.parent;
            for (let p in e2)
              ga(e2[p], i);
            if (!e2.type)
              return e2;
            e2.raws || (e2.raws = {});
            let s = "";
            typeof e2.selector == "string" && (s = e2.raws.selector ? e2.raws.selector.scss ? e2.raws.selector.scss : e2.raws.selector.raw : e2.selector, e2.raws.between && e2.raws.between.trim().length > 0 && (s += e2.raws.between), e2.raws.selector = s);
            let f = "";
            typeof e2.value == "string" && (f = e2.raws.value ? e2.raws.value.scss ? e2.raws.value.scss : e2.raws.value.raw : e2.value, f = f.trim(), e2.raws.value = f);
            let a = "";
            if (typeof e2.params == "string" && (a = e2.raws.params ? e2.raws.params.scss ? e2.raws.params.scss : e2.raws.params.raw : e2.params, e2.raws.afterName && e2.raws.afterName.trim().length > 0 && (a = e2.raws.afterName + a), e2.raws.between && e2.raws.between.trim().length > 0 && (a = a + e2.raws.between), a = a.trim(), e2.raws.params = a), s.trim().length > 0)
              return s.startsWith("@") && s.endsWith(":") ? e2 : e2.mixin ? (e2.selector = qe(s, i), e2) : (vh(e2) && (e2.isSCSSNesterProperty = true), e2.selector = Re(s), e2);
            if (f.length > 0) {
              let p = f.match(Sh);
              p && (f = f.slice(0, p.index), e2.scssDefault = true, p[0].trim() !== "!default" && (e2.raws.scssDefault = p[0]));
              let c = f.match(xh);
              if (c && (f = f.slice(0, c.index), e2.scssGlobal = true, c[0].trim() !== "!global" && (e2.raws.scssGlobal = c[0])), f.startsWith("progid:"))
                return { type: "value-unknown", value: f };
              e2.value = qe(f, i);
            }
            if (mt(i) && e2.type === "css-decl" && f.startsWith("extend(") && (e2.extend || (e2.extend = e2.raws.between === ":"), e2.extend && !e2.selector && (delete e2.value, e2.selector = Re(f.slice(7, -1)))), e2.type === "css-atrule") {
              if (mt(i)) {
                if (e2.mixin) {
                  let p = e2.raws.identifier + e2.name + e2.raws.afterName + e2.raws.params;
                  return e2.selector = Re(p), delete e2.params, e2;
                }
                if (e2.function)
                  return e2;
              }
              if (i.parser === "css" && e2.name === "custom-selector") {
                let p = e2.params.match(/:--\S+\s+/)[0].trim();
                return e2.customSelector = p, e2.selector = Re(e2.params.slice(p.length).trim()), delete e2.params, e2;
              }
              if (mt(i)) {
                if (e2.name.includes(":") && !e2.params) {
                  e2.variable = true;
                  let p = e2.name.split(":");
                  e2.name = p[0], e2.value = qe(p.slice(1).join(":"), i);
                }
                if (!["page", "nest", "keyframes"].includes(e2.name) && e2.params && e2.params[0] === ":" && (e2.variable = true, e2.value = qe(e2.params.slice(1), i), e2.raws.afterName += ":"), e2.variable)
                  return delete e2.params, e2;
              }
            }
            if (e2.type === "css-atrule" && a.length > 0) {
              let { name: p } = e2, c = e2.name.toLowerCase();
              return p === "warn" || p === "error" ? (e2.params = { type: "media-unknown", value: a }, e2) : p === "extend" || p === "nest" ? (e2.selector = Re(a), delete e2.params, e2) : p === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? e2.params = qe(a, i) : (e2.selector = Re(a), delete e2.params), e2) : yh(c) ? (e2.import = true, delete e2.filename, e2.params = qe(a, i), e2) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(p) ? (a = a.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), a = a.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), e2.value = qe(a, i), delete e2.params, e2) : ["media", "custom-media"].includes(c) ? a.includes("#{") ? { type: "media-unknown", value: a } : (e2.params = bh(a), e2) : (e2.params = a, e2);
            }
          }
          return e2;
        }
        function ya(e2, i, s) {
          let f = ah(i), { frontMatter: a } = f;
          i = f.content;
          let p;
          try {
            p = e2(i);
          } catch (c) {
            let { name: h, reason: g, line: u, column: t } = c;
            throw typeof u != "number" ? c : oh("".concat(h, ": ").concat(g), { start: { line: u, column: t } });
          }
          return p = ga(Ze(p, "css-"), s), fh(p, i), a && (a.source = { startOffset: 0, endOffset: a.raw.length }, p.nodes.unshift(a)), p;
        }
        function Oh(e2, i) {
          let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = da(s.parser, e2) ? [kt, Ot] : [Ot, kt], p;
          for (let c of a)
            try {
              return c(e2, i, s);
            } catch (h) {
              p = p || h;
            }
          if (p)
            throw p;
        }
        function Ot(e2, i) {
          let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = Xf();
          return ya((a) => f.parse(hh(a)), e2, s);
        }
        function kt(e2, i) {
          let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: f } = sh();
          return ya(f, e2, s);
        }
        var gt = { astFormat: "postcss", hasPragma: uh, locStart: lh, locEnd: ch };
        _a.exports = { parsers: { css: Object.assign(Object.assign({}, gt), {}, { parse: Oh }), less: Object.assign(Object.assign({}, gt), {}, { parse: Ot }), scss: Object.assign(Object.assign({}, gt), {}, { parse: kt }) } };
      });
      "use strict";
      return kh();
    });
  }
});

// ../../node_modules/.pnpm/lru-cache@7.7.1/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/.pnpm/lru-cache@7.7.1/node_modules/lru-cache/index.js"(exports, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController !== "undefined";
    var AC = hasAbortController ? AbortController : Object.assign(class AbortController {
      constructor() {
        this.signal = new AC.AbortSignal();
      }
      abort() {
        this.signal.aborted = true;
      }
    }, { AbortSignal: class AbortSignal {
      constructor() {
        this.aborted = false;
      }
    } });
    var warned2 = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    };
    var shouldWarn = (code) => typeof process === "object" && process && !warned2.has(code);
    var warn = (code, what, instead, fn) => {
      warned2.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      process.emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        const UintArray = max ? getUintArray(max) : Array;
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          sizeCalculation,
          fetchMethod
        } = options;
        const {
          length,
          maxAge,
          stale
        } = options instanceof LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculating set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        if (this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned2.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            process.emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl) => {
          this.starts[index] = ttl !== 0 ? perf.now() : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(index) {
      }
      setItemTTL(index, ttl) {
      }
      isStale(index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => this.calculatedSize -= this.sizes[index];
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (sizeCalculation && !size) {
            size = sizeCalculation(v, k);
          }
          if (!isPosInt(size)) {
            throw new TypeError("size must be positive integer");
          }
          return size;
        };
        this.addItemSize = (index, v, k, size) => {
          this.sizes[index] = size;
          const maxSize = this.maxSize - this.sizes[index];
          while (this.calculatedSize > maxSize) {
            this.evict();
          }
          this.calculatedSize += this.sizes[index];
        };
        this.delete = (k) => {
          if (this.size !== 0) {
            const index = this.keyMap.get(k);
            if (index !== void 0) {
              this.calculatedSize -= this.sizes[index];
            }
          }
          return LRUCache.prototype.delete.call(this, k);
        };
      }
      removeItemSize(index) {
      }
      addItemSize(index, v, k, size) {
      }
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize on cache");
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          yield [this.keyList[i], this.valList[i]];
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          yield this.keyList[i];
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          yield this.keyList[i];
        }
      }
      *values() {
        for (const i of this.indexes()) {
          yield this.valList[i];
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          yield this.valList[i];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of this.indexes()) {
          if (fn(this.valList[i], this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          fn.call(thisp, this.valList[i], this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes()) {
          const key = this.keyList[i];
          const value = this.valList[i];
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, v, k, size);
          noUpdateTTL = false;
        } else {
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort();
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, v, k, size);
          }
          this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl);
        }
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max) {
          return this.evict();
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict();
          return val;
        }
      }
      evict() {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort();
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k) {
        return this.keyMap.has(k) && !this.isStale(this.keyMap.get(k));
      }
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          return this.valList[index];
        }
      }
      backgroundFetch(k, index, options) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AbortController();
        const fetchOpts = {
          signal: ac.signal,
          options
        };
        const p = Promise.resolve(this.fetchMethod(k, v, fetchOpts)).then((v2) => {
          if (!ac.signal.aborted) {
            this.set(k, v2, fetchOpts.options);
          }
          return v2;
        });
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        if (index === void 0) {
          this.set(k, p, fetchOpts.options);
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching");
      }
      async fetch(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        if (!this.fetchMethod) {
          return this.get(k, { allowStale, updateAgeOnGet });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          return this.backgroundFetch(k, index, options);
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v;
          }
          if (!this.isStale(index)) {
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return v;
          }
          const p = this.backgroundFetch(k, index, options);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          if (this.isStale(index)) {
            if (!fetching) {
              this.delete(k);
              return allowStale ? value : void 0;
            } else {
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (fetching) {
              return void 0;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort();
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort();
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
    };
    module2.exports = LRUCache;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(src_exports);
var import_path5 = require("path");
var import_vscode4 = require("vscode");

// ../../node_modules/.pnpm/@antfu+utils@0.5.0/node_modules/@antfu/utils/dist/index.mjs
function toArray(array) {
  array = array || [];
  if (Array.isArray(array))
    return array;
  return [array];
}
function notNullish(v) {
  return v != null;
}
var Node = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();
var VOID = Symbol("p-void");

// ../../node_modules/.pnpm/unconfig@0.3.2/node_modules/unconfig/dist/presets.mjs
function sourcePluginFactory(options) {
  return __spreadProps(__spreadValues({}, options), {
    transform: (source) => {
      const prefix = `
let __unconfig_data;
let __unconfig_stub = function (data) { __unconfig_data = data };
__unconfig_stub.default = (data) => { __unconfig_data = data };
`;
      const suffix = "export default __unconfig_data;";
      let code = source.replace(new RegExp(`import (.+?) from (['"])${options.targetModule}\\2`), "const $1 = __unconfig_stub;").replace("export default", "const __unconfig_default = ");
      if (code.includes("__unconfig_default"))
        code += '\nif (typeof __unconfig_default === "function") __unconfig_default();';
      return `${prefix}${code}${suffix}`;
    }
  });
}
function sourceObjectFields(options) {
  const fields = toArray(options.fields);
  return __spreadProps(__spreadValues({}, options), {
    async rewrite(obj) {
      const config = await (typeof obj === "function" ? obj() : obj);
      if (!config)
        return config;
      for (const field of fields) {
        if (field in config)
          return config[field];
      }
    }
  });
}

// ../../node_modules/.pnpm/@rollup+pluginutils@4.2.0/node_modules/@rollup/pluginutils/dist/es/index.js
var import_path = require("path");
var import_picomatch = __toESM(require_picomatch2(), 1);
function isArray(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePath = function normalizePath2(filename) {
  return filename.split(import_path.win32.sep).join(import_path.posix.sep);
};
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || (0, import_path.isAbsolute)(id) || id.startsWith("*")) {
    return id;
  }
  const basePath = normalizePath((0, import_path.resolve)(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return import_path.posix.join(basePath, id);
}
var createFilter = function createFilter2(include, exclude, options) {
  const resolutionBase = options && options.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern = getMatcherString(id, resolutionBase);
      const fn = (0, import_picomatch.default)(pattern, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = normalizePath(id);
    for (let i = 0; i < excludeMatchers.length; ++i) {
      const matcher = excludeMatchers[i];
      if (matcher.test(pathId))
        return false;
    }
    for (let i = 0; i < includeMatchers.length; ++i) {
      const matcher = includeMatchers[i];
      if (matcher.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
forbiddenIdentifiers.add("");

// ../config/src/index.ts
var import_path3 = require("path");
var import_fs2 = __toESM(require("fs"));

// ../../node_modules/.pnpm/unconfig@0.3.2/node_modules/unconfig/dist/index.mjs
var import_fs = __toESM(require("fs"), 1);
var import_path2 = require("path");
var import_jiti = __toESM(require_lib(), 1);

// ../../node_modules/.pnpm/defu@5.0.1/node_modules/defu/dist/defu.mjs
function isObject(val) {
  return val !== null && typeof val === "object";
}
function _defu(baseObj, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObj, {}, namespace, merger);
  }
  const obj = Object.assign({}, defaults);
  for (const key in baseObj) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const val = baseObj[key];
    if (val === null || val === void 0) {
      continue;
    }
    if (merger && merger(obj, key, val, namespace)) {
      continue;
    }
    if (Array.isArray(val) && Array.isArray(obj[key])) {
      obj[key] = obj[key].concat(val);
    } else if (isObject(val) && isObject(obj[key])) {
      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      obj[key] = val;
    }
  }
  return obj;
}
function extend(merger) {
  return (...args) => args.reduce((p, c) => _defu(p, c, "", merger), {});
}
var defu = extend();
defu.fn = extend((obj, key, currentValue, _namespace) => {
  if (typeof obj[key] !== "undefined" && typeof currentValue === "function") {
    obj[key] = currentValue(obj[key]);
    return true;
  }
});
defu.arrayFn = extend((obj, key, currentValue, _namespace) => {
  if (Array.isArray(obj[key]) && typeof currentValue === "function") {
    obj[key] = currentValue(obj[key]);
    return true;
  }
});
defu.extend = extend;

// ../../node_modules/.pnpm/unconfig@0.3.2/node_modules/unconfig/dist/index.mjs
var defaultExtensions = ["mts", "cts", "ts", "mjs", "cjs", "js", "json", ""];
function existsSync(fp) {
  try {
    import_fs.default.accessSync(fp, import_fs.constants.R_OK);
    return true;
  } catch {
    return false;
  }
}
async function findUp(paths, options = {}) {
  const {
    cwd = process.cwd(),
    stopAt = (0, import_path2.parse)(cwd).root,
    multiple = false,
    allowSymlinks = true
  } = options;
  let current = cwd;
  const files = [];
  const stat = allowSymlinks ? import_fs.promises.stat : import_fs.promises.lstat;
  while (current && current !== stopAt) {
    for (const path of paths) {
      const filepath = (0, import_path2.resolve)(current, path);
      if (existsSync(filepath) && (await stat(filepath)).isFile()) {
        files.push(filepath);
        if (!multiple)
          return files;
      }
    }
    const parent = (0, import_path2.dirname)(current);
    if (parent === current)
      break;
    current = parent;
  }
  return files;
}
function createConfigLoader(options) {
  const sources = toArray(options.sources || []);
  const {
    cwd = process.cwd(),
    merge,
    defaults
  } = options;
  const results = [];
  let matchedFiles;
  async function findConfigs() {
    if (matchedFiles == null)
      matchedFiles = [];
    matchedFiles.length = 0;
    for (const source of sources) {
      const { extensions = defaultExtensions } = source;
      const flatTargets = toArray((source == null ? void 0 : source.files) || []).flatMap((file) => !extensions.length ? [file] : extensions.map((i) => i ? `${file}.${i}` : file));
      const files = await findUp(flatTargets, { cwd, stopAt: options.stopAt, multiple: merge });
      matchedFiles.push([source, files]);
    }
    return matchedFiles.flatMap((i) => i[1]);
  }
  async function load(force = false) {
    if (matchedFiles == null || force)
      await findConfigs();
    for (const [source, files] of matchedFiles) {
      if (!files.length)
        continue;
      if (!merge) {
        const result = await loadConfigFile(files[0], source);
        if (result) {
          return {
            config: defu(result.config, defaults),
            sources: result.sources
          };
        }
      } else {
        results.push(...(await Promise.all(files.map((file) => loadConfigFile(file, source)))).filter(notNullish));
      }
    }
    if (!results.length) {
      return {
        config: defaults,
        sources: []
      };
    }
    return {
      config: defu(...results.map((i) => i.config), defaults),
      sources: results.map((i) => i.sources).flat()
    };
  }
  return {
    load,
    findConfigs
  };
}
async function loadConfigFile(filepath, source) {
  let config;
  let parser = source.parser || "auto";
  let bundleFilepath = filepath;
  let code;
  async function read() {
    if (code == null)
      code = await import_fs.promises.readFile(filepath, "utf-8");
    return code;
  }
  if (source.transform) {
    const transformed = await source.transform(await read(), filepath);
    if (transformed) {
      bundleFilepath = (0, import_path2.join)((0, import_path2.dirname)(filepath), `__unconfig_${(0, import_path2.basename)(filepath)}`);
      await import_fs.promises.writeFile(bundleFilepath, transformed, "utf-8");
      code = transformed;
    }
  }
  if (parser === "auto") {
    try {
      config = JSON.parse(await read());
      parser = "json";
    } catch {
      parser = "require";
    }
  }
  try {
    if (!config) {
      if (typeof parser === "function") {
        config = await parser(filepath);
      } else if (parser === "require") {
        config = await (0, import_jiti.default)(filepath, {
          interopDefault: true,
          cache: false,
          requireCache: false,
          v8cache: false,
          esmResolve: true
        })(bundleFilepath);
      } else if (parser === "json") {
        config = JSON.parse(await read());
      }
    }
    if (!config)
      return;
    const rewritten = source.rewrite ? await source.rewrite(config, filepath) : config;
    if (!rewritten)
      return void 0;
    return {
      config: rewritten,
      sources: [filepath]
    };
  } catch (e2) {
    if (source.skipOnError)
      return;
    throw e2;
  } finally {
    if (bundleFilepath !== filepath)
      await import_fs.promises.unlink(bundleFilepath);
  }
}

// ../config/src/index.ts
function createConfigLoader2(configOrPath = process.cwd(), extraConfigSources = []) {
  let inlineConfig = {};
  if (typeof configOrPath !== "string") {
    inlineConfig = configOrPath;
    if (inlineConfig.configFile === false) {
      return async () => ({
        config: inlineConfig,
        sources: []
      });
    } else {
      configOrPath = inlineConfig.configFile || process.cwd();
    }
  }
  const resolved = (0, import_path3.resolve)(configOrPath);
  let cwd = resolved;
  let isFile = false;
  if (import_fs2.default.existsSync(resolved) && import_fs2.default.statSync(resolved).isFile()) {
    isFile = true;
    cwd = (0, import_path3.dirname)(resolved);
  }
  const loader = createConfigLoader({
    sources: isFile ? [
      {
        files: resolved,
        extensions: []
      }
    ] : [
      {
        files: [
          "unocss.config",
          "uno.config"
        ]
      },
      ...extraConfigSources
    ],
    cwd,
    defaults: inlineConfig
  });
  return async () => {
    const result = await loader.load();
    result.config = result.config || inlineConfig;
    if (result.config.configDeps) {
      result.sources = [
        ...result.sources,
        ...result.config.configDeps.map((i) => (0, import_path3.resolve)(cwd, i))
      ];
    }
    return result;
  };
}

// ../core/src/utils/escape.ts
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function escapeSelector(str) {
  const length = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "\uFFFD";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\2c ";
      continue;
    }
    if (codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (index === 0 && length === 1 && codeUnit === 45) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
var e = escapeSelector;

// ../core/src/utils/object.ts
function normalizeCSSEntries(obj) {
  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);
}
function normalizeCSSValues(obj) {
  if (Array.isArray(obj)) {
    if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0])))
      return obj.map((i) => normalizeCSSEntries(i));
    else
      return [obj];
  } else {
    return [normalizeCSSEntries(obj)];
  }
}
function clearIdenticalEntries(entry) {
  return entry.filter(([k, v], idx) => {
    if (k.startsWith("$$"))
      return false;
    for (let i = idx - 1; i >= 0; i--) {
      if (entry[i][0] === k && entry[i][1] === v)
        return false;
    }
    return true;
  });
}
function entriesToCss(arr) {
  if (arr == null)
    return "";
  return clearIdenticalEntries(arr).map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join("");
}
function isObject2(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch) {
  const o = original;
  const p = patch;
  if (Array.isArray(o) && Array.isArray(p))
    return [...o, ...p];
  if (Array.isArray(o))
    return [...o];
  const output = __spreadValues({}, o);
  if (isObject2(o) && isObject2(p)) {
    Object.keys(p).forEach((key) => {
      if (isObject2(p[key])) {
        if (!(key in o))
          Object.assign(output, { [key]: p[key] });
        else
          output[key] = mergeDeep(o[key], p[key]);
      } else {
        Object.assign(output, { [key]: p[key] });
      }
    });
  }
  return output;
}
function clone(val) {
  let k, out, tmp;
  if (Array.isArray(val)) {
    out = Array(k = val.length);
    while (k--)
      out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = {};
    for (k in val) {
      if (k === "__proto__") {
        Object.defineProperty(out, k, {
          value: clone(val[k]),
          configurable: true,
          enumerable: true,
          writable: true
        });
      } else {
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
      }
    }
    return out;
  }
  return val;
}
function isStaticRule(rule) {
  return typeof rule[0] === "string";
}
function isStaticShortcut(sc) {
  return typeof sc[0] === "string";
}

// ../core/src/utils/basic.ts
function toArray2(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}

// ../core/src/utils/helpers.ts
var attributifyRE = /^\[(.+?)~?="(.*)"\]$/;
var validateFilterRE = /(?!\d|-{2}|-\d)[a-zA-Z0-9\u00A0-\uFFFF-_:%-?]/;
var CONTROL_SHORTCUT_NO_MERGE = "$$shortcut-no-merge";
function isAttributifySelector(selector) {
  return selector.match(attributifyRE);
}
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}
function notNull(value) {
  return value != null;
}

// ../core/src/utils/map.ts
var TwoKeyMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2)
      return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2))
      m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = /* @__PURE__ */ new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    var _a;
    return (_a = this._map.get(key1)) == null ? void 0 : _a.has(key2);
  }
  delete(key1, key2) {
    var _a;
    return ((_a = this._map.get(key1)) == null ? void 0 : _a.delete(key2)) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
};
var BetterMap = class extends Map {
  map(mapFn) {
    const result = [];
    this.forEach((v, k) => {
      result.push(mapFn(v, k));
    });
    return result;
  }
};

// ../core/src/utils/variantGroup.ts
var regexClassGroup = /([!\w+:_/-]+?)([:-])\(((?:[!\w\s:/\\,%#.$-]|\[.*?\])*?)\)/gm;
function expandVariantGroup(str) {
  regexClassGroup.lastIndex = 0;
  return str.replace(regexClassGroup, (_, pre, sep, body) => {
    return body.split(/\s/g).map((i) => i.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`)).join(" ");
  });
}

// ../core/src/utils/warn.ts
var warned = /* @__PURE__ */ new Set();
function warnOnce(msg) {
  if (warned.has(msg))
    return;
  console.warn("[unocss]", msg);
  warned.add(msg);
}

// ../core/src/extractors/split.ts
var splitCode = (code) => code.split(/[\s'"`;>=]+/g).filter(isValidSelector);
var extractorSplit = {
  name: "split",
  order: 0,
  extract({ code }) {
    return new Set(splitCode(code));
  }
};

// ../core/src/config.ts
function resolveShortcuts(shortcuts) {
  return toArray2(shortcuts).flatMap((s) => {
    if (Array.isArray(s))
      return [s];
    return Object.entries(s);
  });
}
var defaultLayers = {
  shortcuts: -1,
  default: 0
};
function resolveConfig(userConfig = {}, defaults = {}) {
  const config = Object.assign({}, defaults, userConfig);
  const rawPresets = (config.presets || []).flatMap(toArray2);
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const layers = Object.assign(defaultLayers, ...rawPresets.map((i) => i.layers), userConfig.layers);
  function mergePresets(key) {
    return uniq([
      ...sortedPresets.flatMap((p) => toArray2(p[key] || [])),
      ...toArray2(config[key] || [])
    ]);
  }
  const extractors = mergePresets("extractors");
  if (!extractors.length)
    extractors.push(extractorSplit);
  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));
  const rules = mergePresets("rules");
  const rulesStaticMap = {};
  const rulesSize = rules.length;
  rules.forEach((rule, i) => {
    if (isStaticRule(rule)) {
      rulesStaticMap[rule[0]] = [i, rule[1], rule[2]];
      delete rules[i];
    }
  });
  const theme = clone([
    ...sortedPresets.map((p) => p.theme || {}),
    config.theme || {}
  ].reduce((a, p) => mergeDeep(a, p), {}));
  mergePresets("extendTheme").forEach((extendTheme) => extendTheme(theme));
  const autocomplete = {
    templates: uniq(sortedPresets.map((p) => {
      var _a;
      return toArray2((_a = p.autocomplete) == null ? void 0 : _a.templates);
    }).flat()),
    extractors: sortedPresets.map((p) => {
      var _a;
      return toArray2((_a = p.autocomplete) == null ? void 0 : _a.extractors);
    }).flat().sort((a, b) => (a.order || 0) - (b.order || 0))
  };
  return __spreadProps(__spreadValues({
    mergeSelectors: true,
    warn: true,
    blocklist: [],
    safelist: [],
    sortLayers: (layers2) => layers2
  }, config), {
    presets: sortedPresets,
    envMode: config.envMode || "build",
    shortcutsLayer: config.shortcutsLayer || "shortcuts",
    layers,
    theme,
    rulesSize,
    rulesDynamic: rules,
    rulesStaticMap,
    preprocess: mergePresets("preprocess"),
    postprocess: mergePresets("postprocess"),
    preflights: mergePresets("preflights"),
    autocomplete,
    variants: mergePresets("variants").map(normalizeVariant),
    shortcuts: resolveShortcuts(mergePresets("shortcuts")),
    extractors
  });
}

// ../core/package.json
var version = "0.30.8";

// ../core/src/generator/index.ts
var UnoGenerator = class {
  constructor(userConfig = {}, defaults = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults;
    this.version = version;
    this._cache = /* @__PURE__ */ new Map();
    this.blocked = /* @__PURE__ */ new Set();
    this.parentOrders = /* @__PURE__ */ new Map();
    this.config = resolveConfig(userConfig, defaults);
  }
  setConfig(userConfig, defaults) {
    if (!userConfig)
      return;
    if (defaults)
      this.defaults = defaults;
    this.userConfig = userConfig;
    this.config = resolveConfig(userConfig, this.defaults);
    this.blocked.clear();
    this.parentOrders.clear();
    this._cache.clear();
  }
  async applyExtractors(code, id, set = /* @__PURE__ */ new Set()) {
    const context = {
      get original() {
        return code;
      },
      code,
      id
    };
    for (const extractor of this.config.extractors) {
      const result = await extractor.extract(context);
      result == null ? void 0 : result.forEach((t) => set.add(t));
    }
    return set;
  }
  makeContext(raw, applied) {
    const context = {
      rawSelector: raw,
      currentSelector: applied[1],
      theme: this.config.theme,
      generator: this,
      variantHandlers: applied[2],
      constructCSS: (...args) => this.constructCustomCSS(context, ...args),
      variantMatch: applied
    };
    return context;
  }
  async parseToken(raw, alias) {
    var _a;
    if (this.blocked.has(raw))
      return;
    const cacheKey = `${raw}${alias ? ` ${alias}` : ""}`;
    if (this._cache.has(cacheKey))
      return this._cache.get(cacheKey);
    let current = raw;
    for (const p of this.config.preprocess)
      current = p(raw);
    if (this.isBlocked(current)) {
      this.blocked.add(raw);
      this._cache.set(cacheKey, null);
      return;
    }
    const applied = this.matchVariants(raw, current);
    if (!applied || this.isBlocked(applied[1])) {
      this.blocked.add(raw);
      this._cache.set(cacheKey, null);
      return;
    }
    const context = this.makeContext(raw, [alias || applied[0], applied[1], applied[2], applied[3]]);
    const expanded = this.expandShortcut(context.currentSelector, context);
    if (expanded) {
      const utils = await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]);
      if (utils == null ? void 0 : utils.length) {
        this._cache.set(cacheKey, utils);
        return utils;
      }
    } else {
      const utils = (_a = await this.parseUtil(context.variantMatch, context)) == null ? void 0 : _a.map((i) => this.stringifyUtil(i)).filter(notNull);
      if (utils == null ? void 0 : utils.length) {
        this._cache.set(cacheKey, utils);
        return utils;
      }
    }
    this._cache.set(cacheKey, null);
  }
  async generate(input = "", {
    id,
    scope,
    preflights = true,
    safelist = true,
    minify = false
  } = {}) {
    const tokens = typeof input === "string" ? await this.applyExtractors(input, id) : input;
    if (safelist)
      this.config.safelist.forEach((s) => tokens.add(s));
    const nl = minify ? "" : "\n";
    const layerSet = /* @__PURE__ */ new Set(["default"]);
    const matched = /* @__PURE__ */ new Set();
    const sheet = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(tokens).map(async (raw) => {
      var _a;
      if (matched.has(raw))
        return;
      const payload = await this.parseToken(raw);
      if (payload == null)
        return;
      matched.add(raw);
      for (const item of payload) {
        const parent = item[3] || "";
        if (!sheet.has(parent))
          sheet.set(parent, []);
        sheet.get(parent).push(item);
        if ((_a = item[4]) == null ? void 0 : _a.layer)
          layerSet.add(item[4].layer);
      }
    }));
    if (preflights) {
      this.config.preflights.forEach((i) => {
        if (i.layer)
          layerSet.add(i.layer);
      });
    }
    const layerCache = {};
    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => {
      var _a, _b;
      return ((_a = this.config.layers[a]) != null ? _a : 0) - ((_b = this.config.layers[b]) != null ? _b : 0) || a.localeCompare(b);
    }));
    let preflightsMap = {};
    if (preflights) {
      const preflightContext = {
        generator: this,
        theme: this.config.theme
      };
      preflightsMap = Object.fromEntries(await Promise.all(layers.map(async (layer) => {
        const preflights2 = await Promise.all(this.config.preflights.filter((i) => (i.layer || "default") === layer).map(async (i) => await i.getCSS(preflightContext)));
        const css = preflights2.filter(Boolean).join(nl);
        return [layer, css];
      })));
    }
    const getLayer = (layer) => {
      if (layerCache[layer])
        return layerCache[layer];
      let css = Array.from(sheet).sort((a, b) => {
        var _a, _b, _c;
        return ((_a = this.parentOrders.get(a[0])) != null ? _a : 0) - ((_b = this.parentOrders.get(b[0])) != null ? _b : 0) || ((_c = a[0]) == null ? void 0 : _c.localeCompare(b[0] || "")) || 0;
      }).map(([parent, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => {
          var _a;
          return (((_a = i[4]) == null ? void 0 : _a.layer) || "default") === layer;
        }).sort((a, b) => {
          var _a, _b, _c;
          return a[0] - b[0] || (((_a = a[4]) == null ? void 0 : _a.sort) || 0) - (((_b = b[4]) == null ? void 0 : _b.sort) || 0) || ((_c = a[1]) == null ? void 0 : _c.localeCompare(b[1] || "")) || 0;
        }).map((a) => {
          var _a;
          return [a[1] ? applyScope(a[1], scope) : a[1], a[2], !!((_a = a[4]) == null ? void 0 : _a.noMerge)];
        }).map((a) => [a[0] == null ? a[0] : [a[0]], a[1], a[2]]);
        if (!sorted.length)
          return void 0;
        const rules = sorted.reverse().map(([selector, body, noMerge], idx) => {
          if (!noMerge && selector && this.config.mergeSelectors) {
            for (let i = idx + 1; i < size; i++) {
              const current = sorted[i];
              if (current && !current[2] && current[0] && current[1] === body) {
                current[0].push(...selector);
                return null;
              }
            }
          }
          return selector ? `${[...new Set(selector)].join(`,${nl}`)}{${body}}` : body;
        }).filter(Boolean).reverse().join(nl);
        return parent ? `${parent}{${nl}${rules}${nl}}` : rules;
      }).filter(Boolean).join(nl);
      if (preflights) {
        css = [preflightsMap[layer], css].filter(Boolean).join(nl);
      }
      return layerCache[layer] = !minify && css ? `/* layer: ${layer} */${nl}${css}` : css;
    };
    const getLayers = (includes = layers, excludes) => {
      return includes.filter((i) => !(excludes == null ? void 0 : excludes.includes(i))).map((i) => getLayer(i) || "").filter(Boolean).join(nl);
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      getLayers,
      getLayer,
      matched
    };
  }
  matchVariants(raw, current) {
    const variants = /* @__PURE__ */ new Set();
    const handlers = [];
    let processed = current || raw;
    let applied = false;
    const context = {
      rawSelector: raw,
      theme: this.config.theme,
      generator: this
    };
    while (true) {
      applied = false;
      for (const v of this.config.variants) {
        if (!v.multiPass && variants.has(v))
          continue;
        let handler = v.match(processed, context);
        if (!handler)
          continue;
        if (typeof handler === "string")
          handler = { matcher: handler };
        processed = handler.matcher;
        if (Array.isArray(handler.parent))
          this.parentOrders.set(handler.parent[0], handler.parent[1]);
        handlers.push(handler);
        variants.add(v);
        applied = true;
        break;
      }
      if (!applied)
        break;
      if (handlers.length > 500)
        throw new Error(`Too many variants applied to "${raw}"`);
    }
    return [raw, processed, handlers, variants];
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const handlers = [...variantHandlers].sort((a, b) => (a.order || 0) - (b.order || 0));
    const entries = handlers.reduce((p, v) => {
      var _a;
      return ((_a = v.body) == null ? void 0 : _a.call(v, p)) || p;
    }, parsed[2]);
    const obj = {
      selector: handlers.reduce((p, v) => {
        var _a;
        return ((_a = v.selector) == null ? void 0 : _a.call(v, p, entries)) || p;
      }, toEscapedSelector(raw)),
      entries,
      parent: handlers.reduce((p, v) => Array.isArray(v.parent) ? v.parent[0] : v.parent || p, void 0),
      layer: handlers.reduce((p, v) => v.layer || p, void 0),
      sort: handlers.reduce((p, v) => v.sort || p, void 0)
    };
    for (const p of this.config.postprocess)
      p(obj);
    return obj;
  }
  constructCustomCSS(context, body, overrideSelector) {
    body = normalizeCSSEntries(body);
    const { selector, entries, parent } = this.applyVariants([0, overrideSelector || context.rawSelector, body, void 0, context.variantHandlers]);
    const cssBody = `${selector}{${entriesToCss(entries)}}`;
    if (parent)
      return `${parent}{${cssBody}}`;
    return cssBody;
  }
  async parseUtil(input, context, internal = false) {
    var _a, _b;
    const [raw, processed, variantHandlers] = typeof input === "string" ? this.matchVariants(input) : input;
    const staticMatch = this.config.rulesStaticMap[processed];
    if (staticMatch) {
      if (staticMatch[1] && (internal || !((_a = staticMatch[2]) == null ? void 0 : _a.internal)))
        return [[staticMatch[0], raw, normalizeCSSEntries(staticMatch[1]), staticMatch[2], variantHandlers]];
    }
    context.variantHandlers = variantHandlers;
    const { rulesDynamic, rulesSize } = this.config;
    for (let i = rulesSize - 1; i >= 0; i--) {
      const rule = rulesDynamic[i];
      if (!rule)
        continue;
      if (((_b = rule[2]) == null ? void 0 : _b.internal) && !internal)
        continue;
      const [matcher, handler, meta] = rule;
      const match = processed.match(matcher);
      if (!match)
        continue;
      const result = await handler(match, context);
      if (!result)
        continue;
      if (typeof result === "string")
        return [[i, result, meta]];
      const entries = normalizeCSSValues(result).filter((i2) => i2.length);
      if (entries.length)
        return entries.map((e2) => [i, raw, e2, meta, variantHandlers]);
    }
  }
  stringifyUtil(parsed) {
    var _a;
    if (!parsed)
      return;
    if (isRawUtil(parsed))
      return [parsed[0], void 0, parsed[1], void 0, parsed[2]];
    const { selector, entries, parent, layer: variantLayer, sort: variantSort } = this.applyVariants(parsed);
    const body = entriesToCss(entries);
    if (!body)
      return;
    const _b = (_a = parsed[3]) != null ? _a : {}, { layer: metaLayer, sort: metaSort } = _b, meta = __objRest(_b, ["layer", "sort"]);
    const ruleMeta = __spreadProps(__spreadValues({}, meta), {
      layer: variantLayer != null ? variantLayer : metaLayer,
      sort: variantSort != null ? variantSort : metaSort
    });
    return [parsed[0], selector, body, parent, ruleMeta];
  }
  expandShortcut(processed, context, depth = 3) {
    if (depth === 0)
      return;
    let meta;
    let result;
    for (const s of this.config.shortcuts) {
      if (isStaticShortcut(s)) {
        if (s[0] === processed) {
          meta = meta || s[2];
          result = s[1];
          break;
        }
      } else {
        const match = processed.match(s[0]);
        if (match)
          result = s[1](match, context);
        if (result) {
          meta = meta || s[2];
          break;
        }
      }
    }
    if (typeof result === "string")
      result = expandVariantGroup(result).split(/\s+/g);
    if (!result)
      return;
    return [
      result.flatMap((r) => {
        var _a;
        return ((_a = this.expandShortcut(r, context, depth - 1)) == null ? void 0 : _a[0]) || [r];
      }).filter((r) => r !== ""),
      meta
    ];
  }
  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {
    var _a;
    const selectorMap = new TwoKeyMap();
    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {
      const result = await this.parseUtil(i, context, true);
      if (!result)
        warnOnce(`unmatched utility "${i}" in shortcut "${parent[1]}"`);
      return result || [];
    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    const rawStringfieldUtil = [];
    for (const item of parsed) {
      if (isRawUtil(item)) {
        rawStringfieldUtil.push([item[0], void 0, item[1], void 0, item[2]]);
        continue;
      }
      const { selector, entries, parent: parent2, sort } = this.applyVariants(item, [...item[4], ...parentVariants], raw);
      const mapItem = selectorMap.getFallback(selector, parent2, [[], item[0]]);
      mapItem[0].push([entries, !!((_a = item[3]) == null ? void 0 : _a.noMerge), sort != null ? sort : 0]);
    }
    return rawStringfieldUtil.concat(selectorMap.map(([e2, index], selector, mediaQuery) => {
      const stringify = (flatten, noMerge, entrySortPair) => {
        const maxSort = Math.max(...entrySortPair.map((e3) => e3[1]));
        const entriesList = entrySortPair.map((e3) => e3[0]);
        return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {
          const body = entriesToCss(entries);
          if (body)
            return [index, selector, body, mediaQuery, __spreadProps(__spreadValues({}, meta), { noMerge, sort: maxSort })];
          return void 0;
        });
      };
      const merges = [
        [e2.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true],
        [e2.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]
      ];
      return merges.map(([e3, noMerge]) => [
        ...stringify(false, noMerge, e3.filter(([entries]) => entries.some((entry) => entry[0] === CONTROL_SHORTCUT_NO_MERGE))),
        ...stringify(true, noMerge, e3.filter(([entries]) => entries.every((entry) => entry[0] !== CONTROL_SHORTCUT_NO_MERGE)))
      ]);
    }).flat(2).filter(Boolean));
  }
  isBlocked(raw) {
    return !raw || this.config.blocklist.some((e2) => typeof e2 === "string" ? e2 === raw : e2.test(raw));
  }
};
function createGenerator(config, defaults) {
  return new UnoGenerator(config, defaults);
}
var regexScopePlaceholder = / \$\$ /;
var hasScopePlaceholder = (css) => css.match(regexScopePlaceholder);
function applyScope(css, scope) {
  if (hasScopePlaceholder(css))
    return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : " ");
  else
    return scope ? `${scope} ${css}` : css;
}
var attributifyRe = /^\[(.+?)(~?=)"(.*)"\]$/;
function toEscapedSelector(raw) {
  if (attributifyRe.test(raw))
    return raw.replace(attributifyRe, (_, n, s, i) => `[${e(n)}${s}"${e(i)}"]`);
  return `.${e(raw)}`;
}

// ../plugins-common/constants.ts
var INCLUDE_COMMENT = "@unocss-include";
var INCLUDE_COMMENT_IDE = "@unocss-ide-include";
var CSS_PLACEHOLDER = "@unocss-placeholder";

// ../plugins-common/defaults.ts
var regexCssId = /\.(css|postcss|sass|scss|less|stylus|styl)$/;
var defaultExclude = [regexCssId];
var defaultInclude = [/\.vue$/, /\.vue\?vue/, /\.svelte$/, /\.[jt]sx$/, /\.mdx?$/, /\.astro$/, /\.elm$/];

// ../plugins-common/context.ts
function createContext(configOrPath, defaults = {}, extraConfigSources = []) {
  const loadConfig = createConfigLoader2(configOrPath, extraConfigSources);
  let rawConfig = {};
  const uno = createGenerator(rawConfig, defaults);
  let rollupFilter = createFilter(defaultInclude, defaultExclude);
  const invalidations = [];
  const modules = new BetterMap();
  const tokens = /* @__PURE__ */ new Set();
  const ready = reloadConfig();
  async function reloadConfig() {
    const result = await loadConfig();
    rawConfig = result.config;
    uno.setConfig(rawConfig);
    uno.config.envMode = "dev";
    rollupFilter = createFilter(rawConfig.include || defaultInclude, rawConfig.exclude || defaultExclude);
    tokens.clear();
    await Promise.all(modules.map((code, id) => uno.applyExtractors(code, id, tokens)));
    invalidate();
    return result;
  }
  function invalidate() {
    invalidations.forEach((cb) => cb());
  }
  async function extract(code, id) {
    if (id)
      modules.set(id, code);
    const len = tokens.size;
    await uno.applyExtractors(code, id, tokens);
    if (tokens.size > len)
      invalidate();
  }
  const filter = (code, id) => {
    return code.includes(INCLUDE_COMMENT) || code.includes(CSS_PLACEHOLDER) || rollupFilter(id);
  };
  async function getConfig() {
    await ready;
    return rawConfig;
  }
  return {
    ready,
    tokens,
    modules,
    invalidate,
    onInvalidate(fn) {
      invalidations.push(fn);
    },
    filter,
    reloadConfig,
    uno,
    extract,
    getConfig
  };
}

// package.json
var version2 = "0.30.8";

// src/log.ts
var import_vscode = require("vscode");
var log = import_vscode.window.createOutputChannel("UnoCSS");

// src/annonation.ts
var import_path4 = require("path");
var import_vscode2 = require("vscode");

// ../inspector/client/composables/pos.ts
function getMatchedPositions(code, matched) {
  const result = [];
  const attributify = [];
  const plain = /* @__PURE__ */ new Set();
  Array.from(matched).forEach((v) => {
    const match = isAttributifySelector(v);
    if (!match)
      plain.add(v);
    else if (!match[2])
      plain.add(match[1]);
    else
      attributify.push(match);
  });
  let start = 0;
  code.split(/[\s"';<>]/g).forEach((i) => {
    const end = start + i.length;
    if (plain.has(i))
      result.push([start, end, i]);
    start = end + 1;
  });
  attributify.forEach(([, name, value]) => {
    const regex = new RegExp(`${escapeRegExp(name)}=(['"])[^\\1]*?${escapeRegExp(value)}[^\\1]*?\\1`, "g");
    Array.from(code.matchAll(regex)).forEach((match) => {
      const start2 = match.index + match[0].indexOf(value);
      const end = start2 + value.length;
      result.push([start2, end, `[${name}="${value}"]`]);
    });
  });
  return result;
}

// src/utils.ts
var import_standalone = __toESM(require_standalone());
var import_parser_postcss = __toESM(require_parser_postcss());
function throttle(func, timeFrame) {
  let lastTime = 0;
  let timer;
  return function() {
    const now = Date.now();
    clearTimeout(timer);
    if (now - lastTime >= timeFrame) {
      lastTime = now;
      return func();
    } else {
      timer = setTimeout(func, timeFrame);
    }
  };
}
async function getPrettiedCSS(uno, util) {
  const result = await uno.generate(/* @__PURE__ */ new Set([util]), { preflights: false, safelist: false });
  const prettified = import_standalone.default.format(result.css, {
    parser: "css",
    plugins: [import_parser_postcss.default]
  });
  return __spreadProps(__spreadValues({}, result), {
    prettified
  });
}
async function getPrettiedMarkdown(uno, util) {
  return `\`\`\`css
${(await getPrettiedCSS(uno, util)).prettified}
\`\`\``;
}

// src/annonation.ts
async function registerAnnonations(cwd, context, status) {
  const { sources } = await context.ready;
  const { uno, filter } = context;
  import_vscode2.workspace.onDidSaveTextDocument(async (doc) => {
    if (sources.includes(doc.uri.fsPath)) {
      try {
        await context.reloadConfig();
        log.appendLine(`Config reloaded by ${(0, import_path4.relative)(cwd, doc.uri.fsPath)}`);
      } catch (e2) {
        log.appendLine("Error on loading config");
        log.appendLine(String(e2));
      }
    }
  });
  const UnderlineDecoration = import_vscode2.window.createTextEditorDecorationType({
    textDecoration: "none; border-bottom: 1px dashed currentColor",
    rangeBehavior: import_vscode2.DecorationRangeBehavior.ClosedClosed
  });
  async function updateAnnotation(editor = import_vscode2.window.activeTextEditor) {
    try {
      let reset = function() {
        editor == null ? void 0 : editor.setDecorations(UnderlineDecoration, []);
        status.hide();
      };
      const doc = editor == null ? void 0 : editor.document;
      if (!doc)
        return reset();
      const code = doc.getText();
      const id = doc.uri.fsPath;
      if (!code || !code.includes(INCLUDE_COMMENT_IDE) && !filter(code, id))
        return reset();
      const result = await uno.generate(code, { id, preflights: false, minify: true });
      const ranges = (await Promise.all(getMatchedPositions(code, Array.from(result.matched)).map(async (i) => {
        try {
          const md = await getPrettiedMarkdown(uno, i[2]);
          return {
            range: new import_vscode2.Range(doc.positionAt(i[0]), doc.positionAt(i[1])),
            get hoverMessage() {
              return new import_vscode2.MarkdownString(md);
            }
          };
        } catch (e2) {
          log.appendLine(`Failed to parse ${i[2]}`);
          log.appendLine(String(e2));
          return void 0;
        }
      }))).filter(Boolean);
      editor.setDecorations(UnderlineDecoration, ranges);
      status.text = `UnoCSS: ${result.matched.size}`;
      status.tooltip = new import_vscode2.MarkdownString(`${result.matched.size} utilities used in this file`);
      status.show();
    } catch (e2) {
      log.appendLine("Error on annotation");
      log.appendLine(String(e2));
    }
  }
  const throttledUpdateAnnotation = throttle(updateAnnotation, 200);
  import_vscode2.window.onDidChangeActiveTextEditor(updateAnnotation);
  import_vscode2.workspace.onDidChangeTextDocument((e2) => {
    var _a;
    if (e2.document === ((_a = import_vscode2.window.activeTextEditor) == null ? void 0 : _a.document))
      throttledUpdateAnnotation();
  });
  await updateAnnotation();
}

// ../autocomplete/src/create.ts
var import_lru_cache = __toESM(require_lru_cache());

// ../autocomplete/src/parse.ts
var shorthands = {
  num: `(${[0, 1, 2, 3, 4, 5, 6, 8, 10, 12, 24, 36].join("|")})`,
  percent: `(${Array.from({ length: 11 }, (_, i) => i * 10).join("|")})`,
  directions: "(x|y|t|b|l|r|s|e)"
};
var ignoredThemeKeys = ["DEFAULT"];
function handleRegexMatch(str, regex, onMatched, onNotMatched) {
  let lastIndex = 0;
  Array.from(str.matchAll(regex)).forEach((m) => {
    const index = m.index;
    if (lastIndex !== index)
      onNotMatched(str.slice(lastIndex, index), lastIndex, index);
    onMatched(m);
    lastIndex = index + m[0].length;
  });
  if (lastIndex !== str.length)
    onNotMatched(str.slice(lastIndex), lastIndex, str.length);
}
function parseAutocomplete(template, theme = {}) {
  const parts = [];
  template = template.replace(/<(\w+)>/g, (_, key) => {
    if (!shorthands[key])
      throw new Error(`Unknown template shorthand: ${key}`);
    return shorthands[key];
  });
  handleGroups(template);
  return {
    parts,
    suggest
  };
  function handleNonGroup(input) {
    handleRegexMatch(input, /\$([\w\.\|]+)/g, (m) => {
      parts.push({
        type: "theme",
        objects: m[1].split("|").map((i) => {
          return i.split(".").reduce((v, k) => {
            if (!k || !v[k])
              throw new Error(`Invalid theme key ${k}`);
            return v[k];
          }, theme);
        })
      });
    }, (str) => {
      parts.push({
        type: "static",
        value: str
      });
    });
  }
  function handleGroups(input) {
    handleRegexMatch(input, /\((.*?)\)/g, (m) => {
      parts.push({
        type: "group",
        values: m[1].split("|").sort((a, b) => b.length - a.length)
      });
    }, (str) => {
      handleNonGroup(str);
    });
  }
  function suggest(input) {
    var _a, _b;
    let rest = input;
    let matched = "";
    let combinations = [];
    const tempParts = [...parts];
    while (tempParts.length) {
      const part = tempParts.shift();
      if (part.type === "static") {
        if (combinations.length)
          combinations = combinations.map((i) => i + part.value);
        if (part.value.startsWith(rest) && part.value !== rest && !combinations.length) {
          combinations = [part.value];
          break;
        } else if (!rest.startsWith(part.value)) {
          break;
        }
        matched += part.value;
        rest = rest.slice(part.value.length);
      } else if (part.type === "group") {
        const fullMatched = part.values.find((i) => i && rest.startsWith(i));
        if (fullMatched != null) {
          matched += fullMatched;
          rest = rest.slice(fullMatched.length);
        } else {
          combinations = part.values.filter((i) => i.startsWith(rest));
          if (((_a = tempParts[0]) == null ? void 0 : _a.type) !== "static")
            break;
        }
      } else if (part.type === "theme") {
        const keys = part.objects.flatMap((i) => Object.keys(i)).filter((i) => i && !ignoredThemeKeys.includes(i) && i[0] !== "_");
        const fullMatched = keys.find((i) => i && rest.startsWith(i));
        if (fullMatched != null) {
          matched += fullMatched;
          rest = rest.slice(fullMatched.length);
          const subObjects = part.objects.map((i) => i[fullMatched]).filter((i) => !!i && typeof i === "object");
          if (subObjects.length) {
            tempParts.unshift({
              type: "static",
              value: "-"
            }, {
              type: "theme",
              objects: subObjects
            });
          }
        } else {
          combinations = keys.filter((i) => i.startsWith(rest));
          if (((_b = tempParts[0]) == null ? void 0 : _b.type) !== "static")
            break;
        }
      }
    }
    if (combinations.length === 0)
      combinations.push("");
    return combinations.map((i) => matched + i).filter((i) => i.length >= input.length);
  }
}

// ../autocomplete/src/utils.ts
function searchUsageBoundary(line, index) {
  let start = index;
  let end = index;
  const regex = /[^\s>"'`]/;
  while (start && regex.test(line.charAt(start - 1)))
    --start;
  while (end < line.length && regex.test(line.charAt(end)))
    ++end;
  return {
    content: line.slice(start, end),
    start,
    end
  };
}

// ../autocomplete/src/create.ts
function createAutocomplete(uno) {
  const templateCache = /* @__PURE__ */ new Map();
  const cache = new import_lru_cache.default({ max: 1e3 });
  let staticUtils = [];
  const templates = [];
  reset();
  return {
    suggest,
    suggestInFile,
    templates,
    cache,
    reset
  };
  function getParsed(template) {
    if (!templateCache.has(template))
      templateCache.set(template, parseAutocomplete(template, uno.config.theme));
    return templateCache.get(template).suggest;
  }
  async function suggest(input) {
    if (input.length < 2)
      return [];
    if (cache.has(input))
      return cache.get(input);
    const [, processed, , variants] = uno.matchVariants(input);
    const idx = processed ? input.search(processed) : input.length;
    if (idx === -1)
      return [];
    const variantPrefix = input.slice(0, idx);
    const variantSuffix = input.slice(idx + input.length);
    const result = processSuggestions(await Promise.all([
      suggestSelf(processed),
      suggestStatic(processed),
      ...suggestFromPreset(processed),
      ...suggestVariant(processed, variants)
    ]), variantPrefix, variantSuffix);
    cache.set(input, result);
    return result;
  }
  async function suggestInFile(content, cursor) {
    const byExtractor = await searchUsageByExtractor(content, cursor);
    if (byExtractor) {
      const suggestions2 = await suggest(byExtractor.extracted);
      const formatted = byExtractor.transformSuggestions ? byExtractor.transformSuggestions(suggestions2) : suggestions2;
      return {
        suggestions: suggestions2.map((v, i) => [v, formatted[i]]),
        resolveReplacement: byExtractor.resolveReplacement
      };
    }
    const regular = searchUsageBoundary(content, cursor);
    const suggestions = await suggest(regular.content);
    return {
      suggestions: suggestions.map((v) => [v, v]),
      resolveReplacement: (suggestion) => ({
        start: regular.start,
        end: regular.end,
        replacement: suggestion
      })
    };
  }
  async function searchUsageByExtractor(content, cursor) {
    if (!uno.config.autocomplete.extractors.length)
      return null;
    for (const extractor of uno.config.autocomplete.extractors) {
      const res = await extractor.extract({ content, cursor });
      if (res)
        return res;
    }
    return null;
  }
  async function suggestSelf(input) {
    const i = await uno.parseToken(input, "-");
    return i ? [input] : [];
  }
  async function suggestStatic(input) {
    return staticUtils.filter((i) => i.startsWith(input));
  }
  function suggestFromPreset(input) {
    return templates.map((fn) => typeof fn === "function" ? fn(input) : getParsed(fn)(input)) || [];
  }
  function suggestVariant(input, used) {
    return uno.config.variants.filter((v) => v.autocomplete && (v.multiPass || !used.has(v))).flatMap((v) => toArray2(v.autocomplete || [])).map((fn) => typeof fn === "function" ? fn(input) : getParsed(fn)(input));
  }
  function reset() {
    templateCache.clear();
    cache.clear();
    staticUtils = Object.keys(uno.config.rulesStaticMap);
    templates.length = 0;
    templates.push(...uno.config.autocomplete.templates || [], ...uno.config.rulesDynamic.flatMap((i) => {
      var _a;
      return toArray2(((_a = i == null ? void 0 : i[2]) == null ? void 0 : _a.autocomplete) || []);
    }));
  }
  function processSuggestions(suggestions, prefix = "", suffix = "") {
    return uniq(suggestions.flat()).filter((i) => !!(i && !i.match(/-$/))).sort((a, b) => {
      var _a, _b;
      const numA = +(((_a = a.match(/\d+$/)) == null ? void 0 : _a[0]) || NaN);
      const numB = +(((_b = b.match(/\d+$/)) == null ? void 0 : _b[0]) || NaN);
      if (!Number.isNaN(numA) && !Number.isNaN(numB))
        return numA - numB;
      return a.localeCompare(b);
    }).map((i) => prefix + i + suffix);
  }
}

// src/autocomplete.ts
var import_vscode3 = require("vscode");
var languageIds = [
  "erb",
  "haml",
  "hbs",
  "html",
  "javascript",
  "javascriptreact",
  "markdown",
  "ejs",
  "php",
  "svelte",
  "typescript",
  "typescriptreact",
  "vue-html",
  "vue"
];
var delimiters = ["-", ":"];
async function registerAutoComplete(context, ext) {
  const { uno, filter } = context;
  const autoComplete = createAutocomplete(uno);
  async function getMarkdown(util) {
    return new import_vscode3.MarkdownString(await getPrettiedMarkdown(uno, util));
  }
  const provider = {
    async provideCompletionItems(doc, position) {
      const code = doc.getText();
      const id = doc.uri.fsPath;
      if (!code || !filter(code, id))
        return null;
      try {
        const result = await autoComplete.suggestInFile(code, doc.offsetAt(position));
        log.appendLine(`[autocomplete] ${id} | ${result.suggestions.slice(0, 10).map((v) => `[${v[0]}, ${v[1]}]`).join(", ")}`);
        if (!result.suggestions.length)
          return;
        return new import_vscode3.CompletionList(result.suggestions.map(([value, label]) => {
          const resolved = result.resolveReplacement(value);
          const item = new import_vscode3.CompletionItem(label, import_vscode3.CompletionItemKind.EnumMember);
          item.insertText = resolved.replacement;
          item.range = new import_vscode3.Range(doc.positionAt(resolved.start), doc.positionAt(resolved.end));
          return item;
        }), true);
      } catch (e2) {
        log.appendLine(`[error] ${String(e2)}`);
        return null;
      }
    },
    async resolveCompletionItem(item) {
      return __spreadProps(__spreadValues({}, item), {
        documentation: await getMarkdown(item.label)
      });
    }
  };
  ext.subscriptions.push(import_vscode3.languages.registerCompletionItemProvider(languageIds, provider, ...delimiters));
}

// src/index.ts
async function activate(ext) {
  var _a;
  const projectPath = (_a = import_vscode4.workspace.workspaceFolders) == null ? void 0 : _a[0].uri.fsPath;
  if (!projectPath)
    return;
  const config = import_vscode4.workspace.getConfiguration("unocss");
  const root = config.get("root");
  const cwd = root ? (0, import_path5.resolve)(projectPath, root) : projectPath;
  log.appendLine(`UnoCSS for VS Code  v${version2} ${process.cwd()}`);
  const context = createContext(cwd, {}, [
    sourcePluginFactory({
      files: [
        "vite.config",
        "svelte.config",
        "astro.config"
      ],
      targetModule: "unocss/vite"
    }),
    sourceObjectFields({
      files: "nuxt.config",
      fields: "unocss"
    })
  ]);
  let sources = [];
  try {
    sources = (await context.ready).sources;
  } catch (e2) {
    log.appendLine(`[error] ${String(e2)}`);
    log.appendLine("[error] Failed to start extension, exiting");
    return;
  }
  if (!sources.length) {
    log.appendLine("[warn] No config files found, disabled");
    log.appendLine("[warn] Make sure you have `unocss.config.js` in your workspace root, or change `unocss.root` in your workspace settings");
    return;
  }
  log.appendLine(`Configuration loaded from
${sources.map((s) => ` - ${(0, import_path5.relative)(cwd, s)}`).join("\n")}`);
  const status = import_vscode4.window.createStatusBarItem(import_vscode4.StatusBarAlignment.Right, 200);
  status.text = "UnoCSS";
  registerAutoComplete(context, ext);
  registerAnnonations(cwd, context, status);
}
function deactivate() {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
/*! For license information please see babel.js.LICENSE.txt */
